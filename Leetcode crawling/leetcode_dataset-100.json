{
    "0": {
        "question_id": 1,
        "title": "Two Sum",
        "difficulty": 1,
        "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.You may assume that each input would have exactly one solution, and you may not use the same element twice.You can return the answer in any order. ",
        "examples": [
            {
                "input": "nums = [2,7,11,15], target = 9",
                "output": "[0,1]",
                "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
            },
            {
                "input": "nums = [3,2,4], target = 6",
                "output": "[1,2]",
                "explanation": null
            },
            {
                "input": "nums = [3,3], target = 6",
                "output": "[0,1]",
                "explanation": null
            }
        ],
        "constraints": [
            "2 <= nums.length <= 104",
            "-109 <= nums[i] <= 109",
            "-109 <= target <= 109",
            "Only one valid answer exists."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                if (nums[i] + nums[j] == target) {\n                    return {i, j};\n                }\n            }\n        }\n        return {};\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \n        d = {}\n        for i, j in enumerate(nums):\n            r = target - j\n            if r in d: return [d[r], i]\n            d[j] = i\n  \n  # An Upvote will be encouraging"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (nums[i] + nums[j] == target) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        return new int[]{-1, -1};\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<pair<int,int>> temp;\n        for(int i=0;i<nums.size();i++){\n            temp.push_back({nums[i],i});\n        }\n        sort(temp.begin(),temp.end());\n        int x=0,y=nums.size()-1;\n        while(x<y){\n            int sum=temp[x].first+temp[y].first;\n            if(sum==target)\n                return {temp[x].second,temp[y].second};\n            else if(sum<target)\n                x++;\n            else{\n                y--;\n            }\n        }\n        return {-1,-1};\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        dict={}\n        for i,n in enumerate(nums):\n            if n in dict:\n                return dict[n],i\n            else:\n                dict[target-n]=i\n    #please upvote me it would encourage me alot"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int n=nums.length;\n        Map<Integer,Integer> map=new HashMap<>();\n        int[] result=new int[2];\n        for(int i=0;i<n;i++){\n            if(map.containsKey(target-nums[i])){\n                result[1]=i;\n                result[0]=map.get(target-nums[i]);\n                return result;\n            }\n            map.put(nums[i],i);\n        }\n        return result;\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] result = new int[2];\n        Map<Integer,Integer> map = new HashMap<>();\n        \n        for(int i=0; i<nums.length; i++){\n            if(map.containsKey(target - nums[i])){\n                result[1] = i;"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        for(int i = 0;i < nums.size();i++){\n            for(int j = i+1;j<nums.size();j++){\n            if(nums[i] + nums[j] == target) return {i,j};\n          }\n        }\n    return {};\n    }\n};"
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\n\nfunction twoSum(nums, target) {\n  const map = new Map();\n  \n  for (let i = 0; i < nums.length; i++) {\n    const x = target - nums[i];\n    \n    if (map.has(x)) {\n      return [map.get(x), i];\n    }\n    \n    map.set(nums[i], i);\n  }\n  \n  return [];\n}\n\n\n// const twoSum = function(nums, target) {\n//     let index =[];\n//     for (let i=0; i<nums.length-1; i++){\n//         for (let j=i+1; j<nums.length; j++){\n//             if(nums[i] + nums[j] === target){\n//                 index.push(i);\n//                 index.push(j);\n//                 //  index =[i, j];\n//             }\n//         }\n//     }\n//     return index;\n// };\n\n// const twoSum =(nums, target)=>{\n//     //nums=nums.sort()\n//     let left =0;\n//     let right = nums.length-1;\n\n//     while(left<right){\n//        let sum = nums[left]+ nums[right];\n\n//     if(sum == target) return [left,right]\n//     if(sum< target) left++;\n//     if(sum> target) right--;\n\n//     }\n// }\n\n// function twoSum(a,b){\n//     // let idx=[];\n//     for(let i=0; i<a.length; i++){\n//         for(let j=i+1; j<a.length; j++){\n//             if(a[i]+a[j]=== b){\n//                 idx =[i,j]\n//             }\n//         }\n//     }\n//     return idx;\n// }\n\n\n//  var twoSum = function (nums, target) {\n//      for(let i = 0; i < nums.length; i++){\n//          for(let j = i + 1; j < nums.length; j++){\n//              if(nums[i] + nums[j] == target){\n//                  return [i,j]\n//              }\n//          }\n//      }\n//  }"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def twoSum(self, nums, target):\n        seen = {}\n        for i in range(len(nums)):\n            diff = target - nums[i]\n            if diff in seen:\n                return [seen[diff], i]\n            else:\n                seen[nums[i]] = i"
            }
        ]
    },
    "1": {
        "question_id": 2,
        "title": "Add Two Numbers",
        "difficulty": 2,
        "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself. ",
        "examples": [
            {
                "input": "l1 = [2,4,3], l2 = [5,6,4]",
                "output": "[7,0,8]",
                "explanation": "342 + 465 = 807."
            },
            {
                "input": "l1 = [0], l2 = [0]",
                "output": "[0]",
                "explanation": null
            },
            {
                "input": "l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]",
                "output": "[8,9,9,9,0,0,0,1]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in each linked list is in the range [1, 100].",
            "0 <= Node.val <= 9",
            "It is guaranteed that the list represents a number that does not have leading zeros."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummy=new ListNode();\n        ListNode* temp=dummy;\n        int carry=0;\n        while(l1!=NULL || l2!=NULL || carry){\n            int sum=0;\n            if(l1!=NULL){\n                sum+=l1->val;\n                l1=l1->next;\n            }\n            if(l2!=NULL){\n                sum+=l2->val;\n                l2=l2->next;\n            }\n            sum+=carry;\n            carry=sum/10;\n            ListNode* newnode=new ListNode(sum%10);\n            temp->next=newnode;\n            temp=temp->next;\n        }\n        return dummy->next;\n    }\n};\nif it helps plzz dont't forget to upvote it :)"
            },
            {
                "language": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        dummy = ListNode()\n        curr = dummy\n        carry = 0\n        while l1 or l2 or carry:\n            val = carry\n            if l1:\n                val += l1.val\n                l1 = l1.next\n            if l2:\n                val += l2.val\n                l2 = l2.next\n            carry, val = divmod(val, 10)\n            curr.next = ListNode(val)\n            curr = curr.next\n        return dummy.next"
            },
            {
                "language": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        d = n = ListNode(0)\n        num1 = num2 = \"\"\n        while l1:\n            num1 += str(l1.val)\n            l1 = l1.next\n        while l2:\n            num2 += str(l2.val)\n            l2 = l2.next\n        res = str(int(num1[::-1]) + int(num2[::-1]))[::-1]\n        for i in res:\n            d.next = ListNode(i)\n            d = d.next\n        return n.next    "
            },
            {
                "language": "java",
                "code": "class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0); // creating an dummy list\n        ListNode curr = dummy; // intialising an pointer\n        int carry = 0; // intialising our carry with 0 intiall\n        // while loop will run, until l1 OR l2 not reaches null OR if they both reaches null. But our carry has some value in it. \n  // We will add that as well into our list\n        while(l1 != null || l2 != null || carry == 1){\n            int sum = 0; // intialising our sum\n            if(l1 != null){ // adding l1 to our sum & moving l1\n                sum += l1.val;\n                l1 = l1.next;\n            }\n            if(l2 != null){ // adding l2 to our sum & moving l2\n                sum += l2.val;\n                l2 = l2.next;\n            }\n            sum += carry; // if we have carry then add it into our sum\n            carry = sum/10; // if we get carry, then divide it by 10 to get the carry\n            ListNode node = new ListNode(sum % 10); // the value we'll get by moduloing it, will become as new node so. add it to our list\n            curr.next = node; // curr will point to that new node if we get\n            curr = curr.next; // update the current every time\n        }\n        return dummy.next; // return dummy.next bcz, we don't want the value we have consider in it intially!!\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode *dummy = new ListNode(0);\n        ListNode *curr = dummy;\n        int carry = 0;\n        \n        while(l1 != NULL || l2 != NULL || carry == 1){\n            int sum = 0;\n            if(l1 != NULL){\n                sum += l1->val;\n                l1 = l1->next;\n            }\n            if(l2 != NULL){\n                sum += l2->val;\n                l2 = l2->next;\n            }\n            sum += carry;\n            carry = sum/10;\n            ListNode *node = new ListNode(sum % 10);\n            curr->next = node;\n            curr = curr->next;\n        }\n        return dummy->next;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dH = new ListNode(-1);\n        ListNode newHead = dH;\n        int carry = 0;\n        \n        while(l1!=null || l2!=null) {\n            int a = l1 == null ? 0 : l1.val;"
            },
            {
                "language": "rust",
                "code": "class Solution\n{\npublic:\n    int carry = 0;\n    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2)\n    {\n        if (!l1 and !l2)\n        {"
            },
            {
                "language": "scala",
                "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        h3 = l3 = ListNode()\n        upper = 0\n        while l1 and l2: #add same digits\n            v3 = l1.val + l2.val + upper\n            l3.next = ListNode(val=v3%10)\n            upper = v3//10\n            l1, l2, l3 = l1.next, l2.next, l3.next\n        \n        if l1: # get the tail of l1 or l2(the part longer than another)\n            l3.next = l1\n        if l2:\n            l3.next = l2\n\n        while upper and l3.next: #if get l1, l2's tail\n            v3 = l3.next.val + upper\n            l3.next.val = v3%10\n            upper = v3//10\n            l3 = l3.next\n\n        if not l3.next and upper: # final upper\n            l3.next = ListNode(val=upper)\n\n        return h3.next\n        "
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)\n     {\n        int carry=0;\n        ListNode*dummy=new ListNode(0);\n        ListNode*tail=dummy;\n\n        // if(l1==NULL)\n        // return l2;\n        // else\n        // return l1;\n\n        while(l1!=NULL&&l2!=NULL)\n        {\n            int ans=l1->val+l2->val+carry;\n            int result=ans%10;\n            carry=ans/10;\n\n            ListNode* final=new ListNode(result);\n            tail->next=final;\n            tail=tail->next;\n\n            l1=l1->next;\n            l2=l2->next;\n        }\n\n        while(l1!=NULL)\n        {\n            if(carry==0)\n            {\n                tail->next=l1;\n                break;\n            }\n            else\n            {\n                int ans=l1->val+carry;\n                int r=ans%10;\n                carry=ans/10;\n\n                ListNode* final=new ListNode(r);\n                tail->next=final;\n                tail=tail->next;\n            }\n            l1=l1->next;\n\n        }\n\n         while(l2!=NULL)\n        {\n            if(carry==0)\n            {\n                tail->next=l2;\n                break;\n            }\n            else\n            {\n                int ans=l2->val+carry;\n                int r=ans%10;\n                carry=ans/10;\n\n                ListNode* final=new ListNode(r);\n                tail->next=final;\n                tail=tail->next;\n            }\n            l2=l2->next;\n        }\n\n        if(carry!=0)\n        {\n             ListNode* final=new ListNode(carry);\n                tail->next=final;\n        }\n\n        return dummy->next;\n\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? {\n        return addTwoNumbers(l1, l2, 0)\n    }\n\n    fun addTwoNumbers(l1: ListNode?, l2: ListNode?, unitItMind: Int): ListNode? {\n        if (l1?.next != null || l2?.next != null) {\n            val sum = (l2?.`val` ?: 0) + (l1?.`val` ?: 0) + unitItMind\n            return if (sum > 9) {\n                val listNode = addTwoNumbers(l1?.next, l2?.next, 1)\n                ListNode(sum - 10).apply { next = listNode }\n            } else {\n                val listNode = addTwoNumbers(l1?.next, l2?.next, 0)\n                ListNode(sum).apply { next = listNode }\n            }\n        } else {\n            val sum = (l2?.`val` ?: 0) + (l1?.`val` ?: 0) + unitItMind\n            return if (sum > 9) {\n                ListNode(sum - 10).apply { next = ListNode(1) }\n            } else {\n                ListNode(sum)\n            }\n        }\n    }\n}"
            },
            {
                "language": "python",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        int sum = 0;\n        int carry = 0;\n        ListNode head = new ListNode();\n        ListNode ptr = head;\n\n        while(l1 != null || l2 != null || carry > 0){\n            if(l1 != null){\n                sum += l1.val;\n                l1 = l1.next;\n            }\n            if(l2 != null){\n                sum += l2.val;\n                l2 = l2.next;\n            }\n            sum += carry;\n            carry = sum/10;\n            ptr.next = new ListNode(sum%10);\n            sum = 0;\n            ptr = ptr.next;\n        }\n        return head.next;\n    }\n}"
            },
            {
                "language": "rust",
                "code": "ListNode* deleteDuplicates(ListNode* head) {\n    if(!head) return head;\n    ListNode *t = head, *p = head->next;\n    int pre = head->val;\n    while(p) {\n        if(pre != p->val) {\n            t->next = p;\n            pre = p->val;\n            t = t->next;\n        }\n        p = p->next;\n    }\n    t->next = NULL;\n    return head;\n}"
            },
            {
                "language": "rust",
                "code": "ListNode* deleteDuplicates(ListNode* head) {\n ListNode* dummy = new ListNode(0);\n dummy->next = head;\n ListNode* cur = dummy;\n int duplicate;\n while (cur->next && cur->next->next) {\n  if (cur->next->val == cur->next->next->val) {\n   duplicate = cur->next->val;\n   while (cur->next && cur->next->val == duplicate) \n    cur->next = cur->next->next;\n  }\n  else cur = cur->next;\n }\n return dummy->next;\n}"
            },
            {
                "language": "kotlin",
                "code": "ListNode* deleteDuplicates(ListNode* head) {\n    if (!head) return 0;\n    if (!head->next) return head;\n    int val = head->val;\n    ListNode* p = head->next;\n    if (p->val != val) { head->next = deleteDuplicates(p); return head;} \n    else { \n        while (p && p->val == val) p = p->next; \n        return deleteDuplicates(p); \n    }\n}"
            },
            {
                "language": "cpp",
                "code": "bool isPalindrome(ListNode* head) {\n    vector<int> v;\n    while(head) {\n        v.push_back(head->val);\n        head = head->next;\n    }\n    for(int i = 0; i < v.size()/2; ++i) {\n        if(v[i] != v[v.size()-i-1]) return false;\n    }\n    return true;\n}"
            },
            {
                "language": "rust",
                "code": "bool isPalindrome(ListNode* head) {\n    if(!head || !head->next) return true;\n    ListNode *slow = head, *fast = head->next;\n    while(fast && fast->next) {//split into two halves while the first half can be one-node longer;\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    fast = slow->next;\n    slow->next = NULL;\n    ListNode newHead(0); //reverse the second half;\n    ListNode *next = NULL, *p = fast;\n    while(p) {\n        next = p->next;\n        p->next = newHead.next;\n        newHead.next = p;\n        p = next;\n    }\n    fast = newHead.next; //compare the two lists;\n    while(fast) {\n        if(fast->val != head->val) return false;\n        fast = fast->next;\n        head = head->next;\n    }\n    return fast == NULL;\n}"
            },
            {
                "language": "ruby",
                "code": "ListNode* rotateRight(ListNode* head, int k) {\n    if(!head) return head;\n    int len = 1;\n    ListNode *p = head;\n    while(p->next) { len++; p = p->next; }\n    p->next = head;\n    if(k %= len)\n        for(int i = 0; i < len-k; ++i, p=p->next) ; \n    ListNode* newHead = p->next;\n    p->next = NULL;\n    return newHead;\n}"
            },
            {
                "language": "ruby",
                "code": "ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    int c = 0;\n    ListNode newHead(0);\n    ListNode *t = &newHead;\n    while(c || l1 || l2) {\n        c += (l1? l1->val : 0) + (l2? l2->val : 0);\n        t->next = new ListNode(c%10);\n        t = t->next;\n        c /= 10;\n        if(l1) l1 = l1->next;\n        if(l2) l2 = l2->next;\n    }\n    return newHead.next;\n}"
            },
            {
                "language": "cpp",
                "code": "ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    if(!l1 && !l2) return NULL;\n    int c = (l1? l1->val:0) + (l2? l2->val:0);\n    ListNode *newHead = new ListNode(c%10), *next = l1? l1->next:NULL;\n    c /= 10;\n    if(next) next->val += c;\n    else if(c) next = new ListNode(c);\n    newHead->next = addTwoNumbers(l2? l2->next:NULL, next);\n    return newHead;\n}"
            },
            {
                "language": "ruby",
                "code": "ListNode* reverseBetween(ListNode* head, int m, int n) {\n    ListNode newHead(0);\n    newHead.next = head;\n    ListNode *pre = &newHead, *cur = head, *next = NULL;\n    int i = 1;\n    while(i < n) {\n        if(i++ < m) { pre = cur; cur = cur->next; }\n        else { \n            next = cur->next; \n            cur->next = cur->next->next; \n            next->next = pre->next; \n            pre->next = next; \n        }\n    }\n    return newHead.next;\n}"
            },
            {
                "language": "ruby",
                "code": "ListNode *detectCycle(ListNode *head) {\n    ListNode *slow = head, *fast = head;   \n    while(fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if(slow == fast) break;\n    }\n    if(slow != fast) return NULL;\n    fast = head;\n    while(fast && fast->next) {\n        if(slow == fast) return slow;\n        slow = slow->next;\n        fast = fast->next;\n    }\n    return NULL;\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    unordered_map<RandomListNode*, RandomListNode*> cloneMap;\n    RandomListNode *helper(RandomListNode* head){\n        if(head == NULL) return NULL;\n        if(cloneMap.count(head)) return cloneMap[head];\n        RandomListNode *cloned = new RandomListNode(head->label);\n        cloneMap[head] = cloned; //crucial;\n        cloned->next = helper(head->next);\n        cloned->random = helper(head->random);\n        return cloned;\n    }\npublic:\n    RandomListNode *copyRandomList(RandomListNode *head) {\n        return helper(head);\n    } \n};"
            },
            {
                "language": "rust",
                "code": "RandomListNode *copyRandomList(RandomListNode *head) {\n RandomListNode newHead(0), *p = head, *t = NULL;\n while(p) {\n  RandomListNode *cloned = new RandomListNode(p->label);\n  cloned->next = p->next;\n  p->next = cloned;\n  p = cloned->next;\n }\n p = head;\n while(p && p->next) {\n  if(p->random) p->next->random = p->random->next;\n  p = p->next->next;\n }\n p = head;\n t = &newHead;\n while(p && p->next) {\n  t->next = p->next;\n  p->next = p->next->next;\n  t = t->next;\n  p = p->next;\n }\n t->next = NULL;\n return newHead.next;\n}"
            },
            {
                "language": "rust",
                "code": "ListNode* reverseKGroup(ListNode* head, int k) {\n if(!head || !head->next) return head;\n ListNode newHead(0);\n ListNode *pre = &newHead, *cur = head, *next = NULL;\n newHead.next = head;\n int len = 0;\n for(ListNode *p = head; p; p = p->next) len++;\n int times = len/k;\n while(times) {\n  for(int i = 1; i < k; ++i) {\n   next = cur->next;\n   cur->next = cur->next->next;\n   next->next = pre->next;\n   pre->next = next;\n   if(i == k-1) {\n    pre = cur;\n    cur = cur->next;\n   }\n  }\n  times--;\n }\n return newHead.next;\n}"
            },
            {
                "language": "javascript",
                "code": "var addTwoNumbers = function(l1, l2) {\n    const iter = (n1, n2, rest = 0) => {\n        if (!n1 && !n2 && !rest) return null;\n        const newVal = (n1?.val || 0) + (n2?.val || 0) + rest;\n        const nextNode = iter(n1?.next, n2?.next, Math.floor(newVal / 10));\n        return new ListNode(newVal % 10, nextNode);\n    }\n    return iter(l1, l2);\n};"
            },
            {
                "language": "javascript",
                "code": "const numberOne = parseInt(l1.reverse('').join(''))\nconst numberTwo = parseInt(l2.reverse('').join(''))\nconst result = (numberOne + numberTwo)\nconst resultString = result.toString().split('').reverse('')\nconst resultArray = resultString.map( digito => parseInt(digito))\nreturn resultArray"
            }
        ]
    },
    "2": {
        "question_id": 3,
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": 2,
        "description": "Given a string s, find the length of the longest substring without repeating characters. ",
        "examples": [
            {
                "input": "s = \"abcabcbb\"",
                "output": "3",
                "explanation": "The answer is \"abc\", with the length of 3."
            },
            {
                "input": "s = \"bbbbb\"",
                "output": "1",
                "explanation": "The answer is \"b\", with the length of 1."
            },
            {
                "input": "s = \"pwwkew\"",
                "output": "3",
                "explanation": "The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring."
            }
        ],
        "constraints": [
            "0 <= s.length <= 5 * 104",
            "s consists of English letters, digits, symbols and spaces."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Set<Character>set=new HashSet<>();\n        int maxLength=0;\n        int left=0;\n        for(int right=0;right<s.length();right++){\n           \n            if(!set.contains(s.charAt(right))){\n                set.add(s.charAt(right));\n                maxLength=Math.max(maxLength,right-left+1);\n                \n            }else{\n                while(s.charAt(left)!=s.charAt(right)){\n                    set.remove(s.charAt(left));\n                    left++;\n                }\n                set.remove(s.charAt(left));left++;\n                set.add(s.charAt(right));\n            }\n            \n        }\n        return maxLength;\n    }\n}"
            },
            {
                "language": "python",
                "code": "    public int lengthOfLongestSubstring(String s) {\n        Set<Character> set = new HashSet();\n        int max = 0;\n        int left = 0;\n        for (int right = 0; right < s.length(); right++) {\n            while(!set.add(s.charAt(right))) {\n                set.remove(s.charAt(left++));\n            }"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if(s.length()==0)return 0;   //if string of length zero comes simply return 0\n        unordered_map<char,int> m;   //create map to store frequency,(get to know all unique characters\n        int i=0,j=0,ans=INT_MIN; \n        while(j<s.length())   \n        {\n            m[s[j]]++;  //increase the frequency of the element as you traverse the string\n            if(m.size()==j-i+1)  // whem map size is equal to the window size means suppose window size is 3 and map size is also three that means in map all unique characters are their\n            {\n                ans = max(ans,j-i+1);  //compare the length of the maximum window size\n            }\n            else if(m.size()<j-i+1)   //if the map size is less than the window size means there is some duplicate present like window size = 3 and map size = 2 means there is a duplicates\n            {\n                while(m.size()<j-i+1)  //so till the duplicates are removed completely\n                {\n                    m[s[i]]--;   //remove the duplicates\n                    if(m[s[i]]==0)  //if the frequency becomes zero \n                    {\n                        m.erase(s[i]);//delete it completely\n                    }\n                    i++;  //go for next element \n                }\n            }\n             j++;  //go for the next element\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "Given a string s, find the length of the longest substring without repeating characters."
            },
            {
                "language": "csharp",
                "code": "To, find out a sliding window problem :-\n> First thing is, we have given something like an \"Array\" | OR | \"String\"\n> Second thing is, they are talking about either \"subsequence\" | OR | \"substring\"\n> And third most thing is, either we have given a \"window size i.e. k\" | OR | we have to \"manually find out window size\" "
            },
            {
                "language": "rust",
                "code": "> Are they talking about, \"Array\" or \"String\" --> yes they are talking about \"string\" +1 point\n> Are they asking to find out \"subsequence\" or \"substring\" --> yes they are talking about \"substring\" +1 point\n> Do, we have given a window size --> No, we don't have\n\nTotal score is \"2 / 3\" so, it's a 100% sliding window problem. If your score lies from 2/3 to 3/3 that's a gauranteed sliding window problem "
            },
            {
                "language": "kotlin",
                "code": "while(j < size()){\n\n    // Calculation's happen's here\n-----------------------------------------------\n    if(condition < k){\n        j++;\n    }\n-----------------------------------------------\n\n-----------------------------------------------\n    else if(condition == k){\n        // ans <-- calculation\n        j++;\n    }\n----------------------------------------------\n\n----------------------------------------------\n    else if(condition > k){\n        while(condition > k){\n            // remove calculation for i\n            i++;\n        }\n        j++;\n    }\n----------------------------------------------\n}\nreturn ans;"
            },
            {
                "language": "javascript",
                "code": "Input: s = \"abcabcbb\"\nOutput: 3"
            },
            {
                "language": "rust",
                "code": "Let's understand it visually :-"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int i = 0;\n        int j = 0;\n        int max = 0;\n        while(j < s.length()){\n            map.put(s.charAt(j), map.getOrDefault(s.charAt(j), 0) + 1);\n            if(map.size() == j - i + 1){\n                max = Math.max(max, j - i + 1);\n                j++;\n            }\n            else if(map.size() < j - i + 1){\n                while(map.size() < j - i + 1){\n                    map.put(s.charAt(i), map.get(s.charAt(i)) - 1);\n                    if(map.get(s.charAt(i)) == 0) map.remove(s.charAt(i));\n                    i++;\n                }\n                j++;\n            }\n        }\n        return max;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if(s.length()==0)return 0;   //if string of length zero comes simply return 0\n        unordered_map<char,int> m;   //create map to store frequency,(get to know all unique characters\n        int i=0,j=0,ans=INT_MIN; \n        while(j<s.length())   \n        {\n            m[s[j]]++;  //increase the frequency of the element as you traverse the string\n            if(m.size()==j-i+1)  // whem map size is equal to the window size means suppose window size is 3 and map size is also three that means in map all unique characters are their\n            {\n                ans = max(ans,j-i+1);  //compare the length of the maximum window size\n            }\n            else if(m.size()<j-i+1)   //if the map size is less than the window size means there is some duplicate present like window size = 3 and map size = 2 means there is a duplicates\n            {\n                while(m.size()<j-i+1)  //so till the duplicates are removed completely\n                {\n                    m[s[i]]--;   //remove the duplicates\n                    if(m[s[i]]==0)  //if the frequency becomes zero \n                    {\n                        m.erase(s[i]);//delete it completely\n                    }\n                    i++;  //go for next element \n                }\n            }\n             j++;  //go for the next element\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Set<Character>set=new HashSet<>();\n        int maxLength=0;\n        int left=0;\n        for(int right=0;right<s.length();right++){\n           \n            if(!set.contains(s.charAt(right))){\n                set.add(s.charAt(right));\n                maxLength=Math.max(maxLength,right-left+1);\n                \n            }else{\n                while(s.charAt(left)!=s.charAt(right)){\n                    set.remove(s.charAt(left));\n                    left++;\n                }\n                set.remove(s.charAt(left));left++;\n                set.add(s.charAt(right));\n            }\n            \n        }\n        return maxLength;\n    }\n}"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        char_set = set()\n        max_len, start = 0, 0\n        for i, c in enumerate(s):\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n            char_set.add(c)\n            max_len = max(max_len, i - start + 1)\n        return max_len\n\n  \n  # An Upvote will be encouraging   \n        "
            },
            {
                "language": "javascript",
                "code": "https://bit.ly/3iIALEY"
            },
            {
                "language": "go",
                "code": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n\n        // if string is emprty retrun 0\n        if(s==\"\"){\n            return 0;\n        }\n        // map of the sliding  window charcters count\n        map<char,int>map;\n        // j first index of the sliding window\n        int j=0;\n          \n        int maxx=0;\n        //  i last index of the sliding window\n        for(int i=0;i<s.length();i++){\n     \n            map[s[i]]++;\n           \n            if( map[s[i]]>1){\n               while( map[s[i]]!=1 && j<s.length()){\n                        map[s[j]]--;\n                   j++;  \n                   // increasing the start pointer untill all the elements distinct\n               }\n            }\n             //  size of sliding window (last-first+1) if you not able to understand take this example( string ab   j=0(s[j]=a) ans i=1(s[i]==1) so length is i-j+1)\n             maxx= max(maxx,i-j+1);\n        }\n\n     return maxx;    \n    }\n};\n// i. i.  i. i\n// a. b.  c. a. b. c   b  b\n// 1. 1.  1. 2\n\n// 1. 2.  3"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n     ArrayList<Character> l =new ArrayList<>();\n     int max=0;\n     //Jebz Logic\n     for(int i=0;i<s.length();i++)\n     {\n        int c=0;\n        for(int j=i;j<s.length();j++)\n         {\n            if(l.contains(s.charAt(j)))\n            {\n             l.clear();\n             break;\n            }\n            else\n            {\n              l.add(s.charAt(j));\n              c++;\n            }\n            \n        }\n        if(c>max)\n          max=c;\n     }\n     return max;\n    }\n}"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        l=0\n        ma=0\n        for i in range(l,len(s)-l):\n            p=s[l:i+1]\n            if(len(p)==len(set(p))):\n                ma=max(len(p),ma)\n            else:\n                l+=1\n        return ma"
            },
            {
                "language": "java",
                "code": "def lengthOfLongestSubstring(s: str) -> int:\n    left = 0\n    max_len = 0\n    basket = []\n    for right in range(len(s)):\n        while s[right] in basket:\n            basket.remove(s[left])\n            left += 1\n\n        basket.append(s[right])\n        max_len = max(max_len, right - left + 1)\n\n    return max_len"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        left = 0\n        max_len = 0\n        basket = {}\n        for right_index, value in enumerate(s):\n            if value not in basket:\n                basket[value] = right_index\n            elif value in basket and basket[value] < left:\n                basket[value] = right_index\n            else:\n                left = basket[value] + 1\n                basket[value] = right_index\n\n            max_len = max(max_len, right_index - left + 1)\n        return max_len"
            }
        ]
    },
    "3": {
        "question_id": 4,
        "title": "Median of Two Sorted Arrays",
        "difficulty": 3,
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.The overall run time complexity should be O(log (m+n)). ",
        "examples": [
            {
                "input": "nums1 = [1,3], nums2 = [2]",
                "output": "2.00000",
                "explanation": "merged array = [1,2,3] and median is 2."
            },
            {
                "input": "nums1 = [1,2], nums2 = [3,4]",
                "output": "2.50000",
                "explanation": "merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
            }
        ],
        "constraints": [
            "nums1.length == m",
            "nums2.length == n",
            "0 <= m <= 1000",
            "0 <= n <= 1000",
            "1 <= m + n <= 2000",
            "-106 <= nums1[i], nums2[i] <= 106"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int n1 = nums1.length;\n        int n2 = nums2.length;\n        int n = n1 + n2;\n        int[] new_arr = new int[n];\n\n        int i=0, j=0, k=0;\n\n        while (i<=n1 && j<=n2) {\n            if (i == n1) {\n                while(j<n2) new_arr[k++] = nums2[j++];\n                break;\n            } else if (j == n2) {\n                while (i<n1) new_arr[k++] = nums1[i++];\n                break;\n            }\n\n            if (nums1[i] < nums2[j]) {\n                new_arr[k++] = nums1[i++];\n            } else {\n                new_arr[k++] = nums2[j++];\n            }\n        }\n\n        if (n%2==0) return (float)(new_arr[n/2-1] + new_arr[n/2])/2;\n        else return new_arr[n/2];\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "// Brute Force:\n               // 1.Merge Both Array\n              // 2.Sort them\n             // 3.Find Median\n            // TIME COMPLEXITY: O(n)+O(nlogn)+O(n)\n            // SPACE COMPLEXITY: O(1)\n \nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n       // Initialization some neccessary variables\n        vector<int>v;\n        \n        // store the array in the new array\n        for(auto num:nums1)   // O(n1)\n            v.push_back(num);\n        \n        for(auto num:nums2)  // O(n2)\n            v.push_back(num);\n        \n        // Sort the array to find the median\n        sort(v.begin(),v.end());  // O(nlogn)\n        \n        // Find the median and Return it\n        int n=v.size();  // O(n)\n        \n        return n%2?v[n/2]:(v[n/2-1]+v[n/2])/2.0;\n    }\n};\n\n** Accepted **"
            },
            {
                "language": "cpp",
                "code": "// Optimized Using: Two Pointer with Extra Space\n  // Time Complexity: O(m+n)\n  // Space Complexity: O(m+n)\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n        // Create a single sorted by merging two sorted arrays\n        int n1=nums1.size();\n        int n2=nums2.size();\n        int i=0;\n        int j=0;\n        int lastindex=-1;\n             \n        // Initialize a new array\n           vector<int>v(n1+n2,0);\n        \n        while(i<n1&&j<n2)\n        {\n            if(nums1[i]<=nums2[j])\n                v[++lastindex]=nums1[i++];\n            else\n                v[++lastindex]=nums2[j++];\n        }\n        \n        while(i<n1)\n            v[++lastindex]=nums1[i++];\n        while(j<n2)\n            v[++lastindex]=nums2[j++];\n        \n    // Return the result\n        int n=n1+n2;\n        return n%2?v[n/2]:(v[n/2]+v[n/2-1])/2.0;\n        \n    }\n};\n\n** Accepted **"
            },
            {
                "language": "cpp",
                "code": "// Optimized Using: Two Pointer without Extra Space (Insertion Sort)\n  // Time Complexity: O(n1*n2)\n  // Space Complexity: O(1)\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n       // Calculate Total length of final array: O(N)\n        int n1=nums1.size();  \n        int n2=nums2.size();\n        int n=n1+n2;  \n      \n        // Edge Cases\n        if(n2==0)\n            return n1%2?nums1[n1/2]:(nums1[n1/2-1]+nums1[n1/2])/2.0;\n        if(n1==0)\n             return n2%2?nums2[n2/2]:(nums2[n2/2-1]+nums2[n2/2])/2.0;\n        \n        // Resize the array 'nums1': O(N), N is size of resized array\n        nums1.resize(n);\n        \n        // Now use pointer to compare arrays elements \n        int i=0;\n        int j=0;\n        \n       // Store all element in 'array 1' in sorted order \n        while(i<n1)  // O(n1)\n        {\n            if(nums1[i]>nums2[0])\n            {\n                swap(nums1[i],nums2[0]);  // O(1)\n                // Rearrange Array nums2\n                rearrangeArray(nums2);  // O(n2)\n            }\n            i++;\n        }\n        \n        // Store remaining elements of 'array 2' in 'array 1' \n        while(j<nums2.size()) // O(n2)\n            nums1[i++]=nums2[j++];\n        \n    // Return Result\n    return n%2?nums1[n/2]:(nums1[n/2-1]+nums1[n/2])/2.0;\n        \n    }\n    \n    void rearrangeArray(vector<int>&nums2)\n    {\n        // Using insertion sort for insertion \n           // worst case Time Complexity Would be: O(n)\n        for(int i=1;i<nums2.size()&&nums2[i]<nums2[i-1];i++)\n            swap(nums2[i],nums2[i-1]);\n    }\n};\n\n** Accepted **"
            },
            {
                "language": "cpp",
                "code": "// Optimized Approach: Using gap method:\n    // Time Complexity: O((log base 2 power N)*(N))\n   //  Space Complexity: O(1)\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n        // Do some pre-calculation : O(N)\n        int n1=nums1.size();\n        int n2=nums2.size();\n        int n=n1+n2;\n        \n        // Now Create Two Pointer\n        int gap=ceil((n1+n2)/2.0);\n        int i=0;\n        int j=gap;\n        \n        // Edge Cases\n        if(n1==0)\n            return n2%2?nums2[n2/2]:(nums2[n2/2]+nums2[n2/2-1])/2.0;\n        \n        if(n2==0)\n            return n1%2?nums1[n1/2]:(nums1[n1/2]+nums1[n1/2-1])/2.0;\n        \n        // Apply gap method: O((log base 2 power N)*N)\n        \n       while(gap)\n       {   i=0;\n           j=gap;\n       // Move both pointer until they reach at last \n        while(j<n)\n        {\n            // If 'i' in 'nums1' and 'j' is also in 'nums1'\n            if(i<n1&&j<n1&&nums1[i]>nums1[j])\n            swap(nums1[i],nums1[j]);\n        else\n            // if 'i' in 'nums1' and 'j' is in 'nums2'\n            if(i<n1&&j>=n1&&nums1[i]>nums2[j-n1])\n                swap(nums1[i],nums2[j-n1]);\n        else \n            // if 'i' in 'nums2' and 'j' is also in 'nums2'\n            if(i>=n1&&j>=n1&&nums2[i-n1]>nums2[j-n1])\n                 swap(nums2[i-n1],nums2[j-n1]);\n            \n        // Move both pointer ahead by only one step\n        i++;\n        j++;\n        }\n        \n        // Edge Case, because of 'ceil()' gap never becomes zero\n        if(gap==1)\n            gap=0;\n         \n         gap=ceil(gap/2.0);\n       }   \n        \n    //Return Result\n      if(n%2)\n          return n/2<n1?nums1[n/2]:nums2[n/2-n1];\n     else\n         if(n/2<n1)\n             return (nums1[n/2]+nums1[n/2-1])/2.0;\n        else\n            if((n/2-1)<n1)\n               return (nums1[n/2-1]+nums2[n/2-n1])/2.0;\n       else \n           return (nums2[n/2-n1]+nums2[n/2-1-n1])/2.0;\n       \n    }\n};\n\n** Accepted **"
            },
            {
                "language": "cpp",
                "code": "// Optimized Approach: Binary Search\n    // Time Complexity: O(log(min(m,n)))\n   //  Space Complexity: O(1)\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n                   // ** Intuition  **\n        // I have to find out correct left half and correct right half\n          // i.e : // 7 ,  || 12 , 14 , 15  --> parition it\n                  //  1 , 2 , 3 , 4 , || 9 , 11  --> parition it\n                  // Now just findout max(left1,left2), min(right1,right2)\n        \n        \n        // Initilaization of some neccessary variables\n        int n1=nums1.size();\n        int n2=nums2.size();\n        int n=n1+n2;\n         \n      if(n1>n2)  return findMedianSortedArrays(nums2,nums1);\n        \n     // When length is even, let's say 10 then left half length should be: (10+1)/2 =>5\n     // When length is odd, let's say 11 then left half length should be: (11+1)/2 =>6\n        // This mean that this formula gonna work in both condition\n        int partition=(n+1)/2; \n        \n    \n    // Edge Case\n    if(n1==0)\n        return n2%2?nums2[n2/2]:(nums2[n2/2]+nums2[n2/2-1])/2.0;\n    \n    if(n2==0)\n        return n1%2?nums1[n1/2]:(nums1[n1/2]+nums1[n1/2-1])/2.0;\n    \n    // Now do Partioning\n    int left1=0;\n    int right1=n1;\n    int cut1,cut2;\n    int l1,r1,l2,r2;\n    \n    do\n    {   \n        //Findout 'cut1' and 'cut2'\n        cut1=(left1+right1)/2;\n        cut2=partition-cut1;\n   \n        // Calculation for l1\n        l1=cut1==0?INT_MIN:nums1[cut1-1];\n        \n        // Calculation for l2\n        l2=cut2==0?INT_MIN:nums2[cut2-1];\n        \n        // Calculation for r1\n        r1=cut1>=n1?INT_MAX:nums1[cut1];\n        \n        // Calculation for r2\n        r2=cut2>=n2?INT_MAX:nums2[cut2];\n        \n        if(l1<=r2&&l2<=r1)\n             // Return Result\n             return n%2?max(l1,l2):(max(l1,l2)+min(r1,r2))/2.0;\n        else\n            \n        if(l1>r2)\n            right1=cut1-1;\n        else\n             left1=cut1+1;\n       \n       \n    }while(left1<=right1);\n        \n             \n    return 0.0;\n    }\n};\n\n** Accepted **"
            },
            {
                "language": "python",
                "code": "while(h>l)\n{   int mid=l+(h-l)/2;\n sorting(a,l,mid);"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& num1, vector<int>& num2) {\n        int n=num2.size();\n        int m=num1.size();\n        for(int i=0;i<n;i++)\n        {\n            num1.push_back(num2[i]);\n        }\n        sort(num1.begin(),num1.end());\n        double median;\n        if((m+n)%2==0)\n            median=(num1[(n+m)/2]+num1[((n+m)/2)-1])/2.0;\n        else\n            median=(num1[(m+n)/2]);\n        return median;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int []res=mergetwosortedArray(nums1,nums2);\n       int mid = (nums1.length+nums2.length)/2;\n        if(res.length == 1) return res[0];   \n        //odd case\n           if(res.length%2 == 1) {\n            return res[mid]; \n        }\n        //even case\n        else return((res[mid-1]+res[mid])/2.0);\n    }\n      public static int[] mergetwosortedArray(int[] arr1, int[] arr2) {\n  // TODO Auto-generated method stub\n  int n = arr1.length;\n  int m = arr2.length;\n  int[] ans = new int[n + m];\n  int i = 0, j = 0, k = 0;\n  while (i < n && j < m) {\n   if (arr1[i] < arr2[j]) {\n    ans[k] = arr1[i];\n    i++;\n    k++;\n   } else {\n    ans[k] = arr2[j];\n    j++;\n    k++;\n   }\n  }\n  while (i < n) {\n   ans[k] = arr1[i];\n   i++;\n   k++;\n  }\n  while (j < m) {\n   ans[k] = arr2[j];\n   j++;\n   k++;\n  }\n  return ans;\n }\n\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        \n        int l = nums1.length + nums2.length;\n        ArrayList<Integer> list = new ArrayList();\n\n        for (Integer i : nums1) list.add(i);\n        for (Integer i : nums2) list.add(i);\n\n        Collections.sort(list); \n\n        return list.size() % 2 == 0 ? \n        (list.get((l-1)/2) + list.get(((l-1)/2)+1))/2.0 : list.get((l-1)/2);\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n     double mediann(vector<int>&a,vector<int>&b){\n        int m=a.size();\n        int n=b.size();\n        if(m>n)\n            return mediann(b,a);\n        int l=0,r=m;\n        while(l<=r){\n            int partx=l+(r-l)/2;\n            int party=(m+n+1)/2-partx;\n            int maxlx=(partx==0)?INT_MIN:a[partx-1];\n            int minrx=(partx==m)?INT_MAX:a[partx];\n            int maxly=(party==0)?INT_MIN:b[party-1];\n            int minry=(party==n)?INT_MAX:b[party];\n            if(maxlx<=minry&&maxly<=minrx){\n                if((m+n)%2==0)\n                    return (double)(max(maxlx,maxly)+min(minrx,minry))/2;\n                else\n                    return (double)(max(maxlx,maxly));\n            }else if(maxlx>minry)\n                r=partx-1;\n            else\n                l=partx+1;\n        }\n        return -1.0;\n    }\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        double ans;\n        ans=mediann(nums1,nums2);\n        return ans;   \n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double {\n        val mergedArray = nums1.plus(nums2)\n    mergedArray.sort()\n    val median: Double\n    if (mergedArray.size % 2 != 0) {\n        median = mergedArray[mergedArray.size / 2].toDouble()\n    } else\n        median = (mergedArray[mergedArray.size / 2].toDouble() + mergedArray[mergedArray.size / 2 - 1].toDouble()) / 2\n    return median\n    }\n}"
            },
            {
                "language": "swift",
                "code": "class Solution {\n    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {\n        let totalNumbers = nums1.count + nums2.count\n        guard totalNumbers>0 else {return 0.0}\n\n        var sortedNumber: [Int] = []\n        var nums1 = nums1\n        var nums2 = nums2\n\n        for i in 0...totalNumbers{\n            if let num1 = nums1.first , let num2 = nums2.first{\n                if num1 <= num2{\n                    sortedNumber.append(num1)\n                    nums1.removeFirst()\n                }else{\n                    sortedNumber.append(num2)\n                    nums2.removeFirst()\n                }\n\n            }else if let num1 = nums1.first{\n                sortedNumber.append(num1)\n                nums1.removeFirst()\n\n            }else if let num2 = nums2.first{\n                sortedNumber.append(num2)\n                nums2.removeFirst()\n            }\n        }\n\n        var median: Double = 0.0\n        let x = totalNumbers/2 //normal mid index\n\n        if totalNumbers%2 == 0{\n            let midX = sortedNumber[x]\n            let midY = sortedNumber[x-1]\n            median = (Double(midX) + Double(midY)) / 2\n\n        }else{\n            median = Double(sortedNumber[x])\n        }\n\n        return median\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums, vector<int>& nums2) {\n        int sz1=nums.size();\n        int sz2=nums2.size();\n\n        int i=0,j=0;\n        vector<int>ans(sz1+sz2,0);\n        int k=0;\n        while(i<sz1 && j<sz2){\n            if(nums2[j]>=nums[i]){\n                ans[k]=nums[i];\n                k++;\n                i++;\n            }\n            else{\n                ans[k]=nums2[j];\n                k++;\n                j++;\n            }\n        }\n\n        while(i<sz1){\n            ans[k]=nums[i];\n            k++;\n            i++;\n        }\n\n        while(j<sz2){\n            ans[k]=nums2[j];\n            k++;\n            j++;\n        }\n        if((sz1+sz2)%2!=0) return (double)ans[(sz1+sz2)/2];\n\n        return (double)(ans[(sz1+sz2)/2-1]+ans[(sz1+sz2)/2])/2.0;\n\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int n1=nums1.length;\n        int n2=nums2.length;\n        int n=n1+n2;\n        int i=0, j=0, count=0;\n        int prev=0;\n        int temp=0;\n\n        while(i<n1 && j<n2){\n            prev=temp;\n            count++;\n            if(nums1[i]<nums2[j]){\n                temp=nums1[i];\n                i++;\n            }\n            else if(nums1[i]>nums2[j]){\n                temp=nums2[j];\n                j++;\n            }\n            else{\n                temp=nums1[i];\n                if(count<n/2+1)\n                prev=temp;\n                i++;\n                j++;\n                count++;\n            }\n            if(count>=n/2+1){\n                if(n%2!=0)\n                return temp;\n                else\n                return (temp+prev)/2.d;\n            }\n        }\n        while(i<n1){\n            prev=temp;\n            temp=nums1[i];\n            i++;\n            count++;\n            if(count>=(n)/2+1){\n                if(n%2!=0)\n                return temp;\n                else\n                return (temp+prev)/2.d;\n            }\n        }\n        while(j<n2){\n            prev=temp;\n            temp=nums2[j];\n            j++;\n            count++;\n            \n            if(count>=(n)/2+1){\n                if(n%2!=0)\n                return temp;\n                else\n                return (prev+temp)/2.d;\n            }\n        }\n        return 0;\n    }\n}"
            }
        ]
    },
    "4": {
        "question_id": 5,
        "title": "Longest Palindromic Substring",
        "difficulty": 2,
        "description": "Given a string s, return the longest palindromic substring in s. ",
        "examples": [
            {
                "input": "s = \"babad\"",
                "output": "\"bab\"",
                "explanation": "\"aba\" is also a valid answer."
            },
            {
                "input": "s = \"cbbd\"",
                "output": "\"bb\"",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= s.length <= 1000",
            "s consist of only digits and English letters."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N^3), Here three nested loop creates the time complexity. Where N is the size of the\n    string(s).\n\n    Space Complexity : O(1), Constant space.\n\n    Solved using string(Three Nested Loop). Brute Force Approach.\n\n    Note : this may give TLE.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\nprivate: \n    bool check(string &s, int i, int j){\n        while(i<j){\n            if(s[i] != s[j]){\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }            \npublic:\n    string longestPalindrome(string s) {\n        int n = s.size();\n        int starting_index = 0;\n        int max_len = 0;\n        for(int i=0; i<n; i++){\n            for(int j=i; j<n; j++){\n                if(check(s, i, j)){\n                    if(j-i+1 > max_len){\n                        max_len = j-i+1;\n                        starting_index = i;\n                    }\n                }\n            }\n        }\n        return s.substr(starting_index, max_len);\n    }\n}; \n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^2), Here Two nested loop creates the time complexity. Where N is the size of the\n    string(s).\n\n    Space Complexity : O(N^2*N), vector(substring) space.\n\n    Solved using string(TwoNested Loop). Brute Force Approach.\n\n    Note : this may give TLE.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution { \nprivate: \n    bool check(string &s, int i, int j){\n        while(i<j){\n            if(s[i] != s[j]){\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\npublic:\n    string longestPalindrome(string s) {\n        int n = s.size();\n        vector<string> substring;\n        for(int i=0; i<n; i++){\n            string temp = \"\";\n            for(int j=i; j<n; j++){\n                temp += s[j];\n                substring.push_back(temp);\n            }\n        }\n        int max_len = 0;\n        string finalans = substring[0];\n        int m = substring.size();\n        for(int i=0; i<m; i++){\n            int s = substring[i].size();\n            if(check(substring[i], 0, s-1)){\n                if(s > max_len){\n                    max_len = s;\n                    finalans = substring[i];\n                }\n            }       \n        }\n        return finalans;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^2), The time complexity of the above code is O(N^2) because we are traversing over all\n    the substrings and then checking each substring if it is a palindrome or not. There are N^2 substrings and\n    checking a substring takes O(1) time, so total time complexity is O(N^2).\n\n    Space Complexity : (N^2), The space complexity of the above code is O(N^2) because we are using the dp array\n    in which we are storing whether a substring is a palindrome or not.\n\n    Solved using Dynamic Programming Approach(tabulation). Optimized Approach.\n\n*/\n\n\n/***************************************** Approach 3 *****************************************/\n\nclass Solution {\nprivate: \n    bool solve(vector<vector<bool>> &dp, int i, int j, string &s){\n        if(i == j){\n            return dp[i][j] = true;\n        }\n        if(j-i == 1){\n            if(s[i] == s[j]){\n                return dp[i][j] = true;\n            }\n            else{\n                return dp[i][j] = false;\n            }\n        }\n        if(s[i] == s[j] && dp[i+1][j-1] == true){\n            return dp[i][j] = true;\n        } else {\n            return dp[i][j] = false;\n        }\n    }\npublic:\n    string longestPalindrome(string s) {\n        int n = s.size();\n        int startIndex = 0; int maxlen = 0;\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\n        for(int g=0; g<n; g++){\n            for(int i=0, j=g; j<n; i++, j++){\n                solve(dp, i, j, s);\n                if(dp[i][j] == true){\n                    if(j-i+1 > maxlen){\n                        startIndex = i;\n                        maxlen = j-i+1;\n                    }\n                }\n            }\n        }\n        return s.substr(startIndex, maxlen);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "#include <stdio.h>\n#include <string.h>\n\nchar *longestPalindrome(char *s) {\n    int n = strlen(s);\n    if (n == 0) return \"\"; // Edge case: empty string\n    if (n == 1) return s; // Edge case: single character is always a palindrome\n\n    int dp[n][n]; // 2D array to store whether substrings are palindromes\n    memset(dp, 0, sizeof(dp)); // Initialize all values to 0\n\n    int start = 0; // Starting index of longest palindromic substring found so far\n    int maxLen = 1; // Length of longest palindromic substring found so far\n\n    // All substrings of length 1 are palindromes\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n\n    // Check all substrings of length 2\n    for (int i = 0; i < n - 1; i++) {\n        if (s[i] == s[i+1]) {\n            dp[i][i+1] = 1;\n            start = i;\n            maxLen = 2;\n        }\n    }\n\n    // Check substrings of length 3 or greater\n    for (int len = 3; len <= n; len++) {\n        for (int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1; // End index of substring\n            if (s[i] == s[j] && dp[i+1][j-1]) {\n                dp[i][j] = 1;\n                if (len > maxLen) {\n                    start = i;\n                    maxLen = len;\n                }\n            }\n        }\n    }\n\n    char* result = malloc(sizeof(char) * (maxLen + 1)); // Allocate memory for result string\n    strncpy(result, s + start, maxLen); // Copy longest palindromic substring into result string\n    result[maxLen] = '\\0'; // Add null terminator to result string\n\n    return result;\n}\n\n/*\nint main() {\n    char s[] = \"babad\";\n    char* result = longestPalindrome(s);\n    printf(\"%s\\n\", result); // Expected output: \"bab\" or \"aba\"\n    free(result); // Free memory allocated for result string\n    return 0;\n}\n*/"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        \n        string s1=\"\"; //Resulting String\n        int len=0;\n        for(int i=0;i<s.length();i++)\n        {\n            //for checking Odd length palindrome\n            int l,r;\n            l=r=i;\n            while(l>=0 && r<s.length() && s[l]==s[r])\n            {   \n                if((r-l+1)>len)\n                {\n                    s1=s.substr(l,r-l+1); //taking the palindrome part\n                    len=r-l+1;\n                }\n                l--;\n                r++;\n            }\n\n            //for checking Even length palindrome\n            l=i;\n            r=l+1;\n            while(l>=0 && r<s.length() && s[l]==s[r])\n            {\n                if((r-l+1)>len)\n                {\n                    s1=s.substr(l,r-l+1); //taking the palindrome part\n                    len=r-l+1;\n                }\n                l--;\n                r++;\n            }\n        }\n        return s1;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public String longestPalindrome(String s) {\n        boolean dp[][]=new boolean[s.length()][s.length()];\n  int a=0;\n  int b=0;\n  for(int gap=0;gap<s.length();gap++) {\n   for(int i=0,j=gap;j<s.length();i++,j++) {\n    if(gap==0) {\n     dp[i][j]=true;\n    }\n    else if(gap==1) {\n     if(s.charAt(i)==s.charAt(j)) {\n      dp[i][j]=true;\n     }\n     else {\n      dp[i][j]=false;\n     }\n    }\n    else {\n     if(s.charAt(i)==s.charAt(j) && dp[i+1][j-1]==true) {\n      dp[i][j]=true;\n     }\n     else {\n      dp[i][j]=false;\n     }\n    }\n    if(dp[i][j]) {\n     a=i;\n     b=j;\n    }\n   }\n  }\n  return s.substring(a,b+1);\n    }\n}"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public String longestPalindrome(String str) {\n        int s=0, e=0;\n        for(int i=0; i<str.length(); i++){\n            int odd=pal(str,i,i);\n            int even=pal(str,i,i+1);\n            int len=Math.max(odd,even);\n\n            if(len>e-s){\n                s=i-(len-1)/2;\n                e=i+len/2;\n            }\n        }\n        return str.substring(s,e+1);\n    }\n\n    public int pal(String str, int s, int e){\n        while(s>=0 && e<str.length() && str.charAt(s)==str.charAt(e)){\n            s--;\n            e++;\n        }\n        return e-s-1;\n    }\n}"
            },
            {
                "language": "python",
                "code": "def longestPalindrome(self, s):\n        longest_palindrom = ''\n        dp = [[0]*len(s) for _ in range(len(s))]\n        #filling out the diagonal by 1\n        for i in range(len(s)):\n            dp[i][i] = True\n            longest_palindrom = s[i]\n   \n        # filling the dp table\n        for i in range(len(s)-1,-1,-1):\n    # j starts from the i location : to only work on the upper side of the diagonal \n            for j in range(i+1,len(s)):  \n                if s[i] == s[j]:  #if the chars mathces\n                    # if len slicied sub_string is just one letter if the characters are equal, we can say they are palindomr dp[i][j] =True \n                    #if the slicied sub_string is longer than 1, then we should check if the inner string is also palindrom (check dp[i+1][j-1] is True)\n                    if j-i ==1 or dp[i+1][j-1] is True:\n                        dp[i][j] = True\n                        # we also need to keep track of the maximum palindrom sequence \n                        if len(longest_palindrom) < len(s[i:j+1]):\n                            longest_palindrom = s[i:j+1]\n                \n        return longest_palindrom"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        dp = [[False]*len(s) for _ in range(len(s)) ]\n        for i in range(len(s)):\n            dp[i][i]=True\n        ans=s[0]\n        for j in range(len(s)):\n            for i in range(j):"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \n        if len(s) == 1:\n            return s"
            },
            {
                "language": "python",
                "code": "def longestPalindrome(self, s):\n        longest_palindrom = (0, 1)\n        dp = [[0]*len(s) for _ in range(len(s))]\n        # filling out the diagonal by 1\n        for i in range(len(s)):\n            dp[i][i] = True\n   "
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        N = len(s)\n        dp=collections.defaultdict(bool)\n\n        lp = []\n        "
            },
            {
                "language": "python",
                "code": "for start = end (e.g. 'a'), state(start, end) is True\nfor start + 1 = end (e.g. 'aa'), state(start, end) is True if s[start] = s[end]\nfor start + 2 = end (e.g. 'aba'),  state(start, end) is True if s[start] = s[end] and state(start + 1, end - 1)\nfor start + 3 = end (e.g. 'abba'),  state(start, end) is True if s[start] = s[end] and state(start + 1, end - 1)\n..."
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = True\n        longest_palindrome_start, longest_palindrome_len = 0, 1\n\n        for end in range(0, n):\n            for start in range(end - 1, -1, -1):\n                # print('start: %s, end: %s' % (start, end))\n                if s[start] == s[end]:\n                    if end - start == 1 or dp[start + 1][end - 1]:\n                        dp[start][end] = True\n                        palindrome_len = end - start + 1\n                        if longest_palindrome_len < palindrome_len:\n                            longest_palindrome_start = start\n                            longest_palindrome_len = palindrome_len\n        return s[longest_palindrome_start: longest_palindrome_start + longest_palindrome_len]"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n = len(s)\n        longest_palindrome_start, longest_palindrome_len = 0, 1\n\n        for i in range(0, n):\n            right = i\n            while right < n and s[i] == s[right]:\n                right += 1\n            # s[i, right - 1] inclusive are equal characters e.g. \"aaa\"\n            \n            # while s[left] == s[right], s[left, right] inclusive is palindrome e.g. \"baaab\"\n            left = i - 1\n            while left >= 0 and right < n and s[left] == s[right]:\n                left -= 1\n                right += 1\n            \n            # s[left + 1, right - 1] inclusive is palindromic\n            palindrome_len = right - left - 1\n            if palindrome_len > longest_palindrome_len:\n                longest_palindrome_len = palindrome_len\n                longest_palindrome_start = left + 1\n            \n        return s[longest_palindrome_start: longest_palindrome_start + longest_palindrome_len]\n         "
            },
            {
                "language": "go",
                "code": "class Solution {\n    /**\n    If you do the brute force way you would generate a lot more strings than this method looks at.\n    which is set of all subsets ( rather substrings) - \n    E(sigma) (n-i) as i runs from 1 to n-1 = n-squared + n(n+1)/2 - O(n-squared) complexity.\n    This problem can be done using DP with n-squared complexity as shown above by [@GraceMeng](https://leetcode.com/GraceMeng) "
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if not s:\n            return ''\n        l = len(s)\n        dp = [[None for j in range(l)] for i in range(l)]\n        lp = s[0]\n        for i in range(l - 1, -1, -1):"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def longestPalindrome(self, s):\n        if not s:\n            return \"\"\n        n = len(s)\n        dpTable = [[False for _ in range(n)] for _ in range(n)]"
            },
            {
                "language": "go",
                "code": "    public String longestPalindrome(String s) {\n        int len = s.length();\n        if (len <= 1) return s;\n        boolean[][] dp = new boolean[len][len];\n        int ml = 0;\n        int mr = 0;\n        for (int r = 0; r < len; r++) {\n            dp[r][r] = true;\n            for (int l = 0; l < r; l++) {"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\nprivate int lo, maxLen;\n\npublic String longestPalindrome(String s) {\n int len = s.length();\n if (len < 2)\n  return s;\n \n    for (int i = 0; i < len-1; i++) {\n      extendPalindrome(s, i, i);  //assume odd length, try to extend Palindrome as possible\n      extendPalindrome(s, i, i+1); //assume even length.\n    }\n    return s.substring(lo, lo + maxLen);\n}\n\nprivate void extendPalindrome(String s, int j, int k) {\n while (j >= 0 && k < s.length() && s.charAt(j) == s.charAt(k)) {\n  j--;\n  k++;\n }\n if (maxLen < k - j - 1) {\n  lo = j + 1;\n  maxLen = k - j - 1;\n }\n}}"
            },
            {
                "language": "typescript",
                "code": "    public String longestPalindrome(String s) {\n        int max = 0, idx = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int len1 = extend(s, i, i), len2 = extend(s, i, i + 1);\n            if (max < Math.max(len1, len2)) {\n                idx = (len1 > len2) ? (i - len1 / 2) : (i - len2 / 2 + 1);\n                max = Math.max(len1, len2);\n            }"
            },
            {
                "language": "typescript",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public String longestPalindrome(String s) {\n        int start = 0;\n        int end = 0;\n        for (int i = 0; i < s.length(); i++) {\n            //StringBuffer sb = new StringBuffer();\n            //sb.append(s.charAt[i]);"
            },
            {
                "language": "csharp",
                "code": "// Solution: Iterate the string, for each character, \n// try to expand left and right to get the longest palindromic substring\nclass Solution {\n    public String longestPalindrome(String s) {\n        if (s == null || s.trim().equals(\"\")) {\n            return s;\n        }\n        int len = s.length();"
            },
            {
                "language": "cpp",
                "code": "public String longestPalindrome(String s) {\n        int[] maxStart = new int[1], maxEnd = new int[1]; // use array in order to pass by reference instead of pass by value\n        \n        for (int i = 0; i < s.length()-1; i++) {\n            extend(s, i, i, maxStart, maxEnd);    \n            extend(s, i, i+1, maxStart, maxEnd);\n        }\n        "
            },
            {
                "language": "python",
                "code": "if (len - i < max / 2)\n  break;"
            },
            {
                "language": "typescript",
                "code": "    public String longestPalindrome(String s) {\n        String result = \"\";\n        int len = 0;\n        boolean[][] isPali = new boolean[s.length()][s.length()];\n        for (int i = s.length() - 1; i >= 0; i--) {\n            for (int j = i; j < s.length(); j++) {\n                if (s.charAt(i) == s.charAt(j) && (j - i < 2 || isPali[i + 1][j - 1])) {\n                    isPali[i][j] = true;\n                    if (j - i + 1 > len) {"
            },
            {
                "language": "python",
                "code": "def longestPalindrome(self, s):\n    res = \"\"\n    for i in xrange(len(s)):\n        # odd case, like \"aba\"\n        tmp = self.helper(s, i, i)\n        if len(tmp) > len(res):\n            res = tmp\n        # even case, like \"abba\"\n        tmp = self.helper(s, i, i+1)\n        if len(tmp) > len(res):\n            res = tmp\n    return res\n \n# get the longest palindrome, l, r are the middle indexes   \n# from inner to outer\ndef helper(self, s, l, r):\n    while l >= 0 and r < len(s) and s[l] == s[r]:\n        l -= 1; r += 1\n    return s[l+1:r]"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\""
            },
            {
                "language": "python",
                "code": "def longestPalindrome(s):\n    res = \"\"\n    for i in range(len(s)):        \n        odd  = palindromeAt(s, i, i)\n        even = palindromeAt(s, i, i+1)\n        \n        res = max(res, odd, even, key=len)\n    return res"
            },
            {
                "language": "python",
                "code": "def longestPalindrome(self, s):\n    res = \"\"\n    for i in xrange(len(s)):\n        for k in xrange(2):\n            tmp = self.helper(s, i, i+k)\n            if len(tmp) > len(res):\n                res = tmp\n    return res"
            }
        ]
    },
    "5": {
        "question_id": 6,
        "title": "Zigzag Conversion",
        "difficulty": 2,
        "description": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P   A   H   NA P L S I I GY   I   RAnd then read line by line: \"PAHNAPLSIIGYIR\"Write the code that will take a string and make this conversion given a number of rows:string convert(string s, int numRows); ",
        "examples": [
            {
                "input": "s = \"PAYPALISHIRING\", numRows = 3",
                "output": "\"PAHNAPLSIIGYIR\"",
                "explanation": null
            },
            {
                "input": "s = \"PAYPALISHIRING\", numRows = 4",
                "output": "\"PINALSIGYAHRPI\"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I",
                "explanation": null
            },
            {
                "input": "s = \"A\", numRows = 1",
                "output": "\"A\"",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= s.length <= 1000",
            "s consists of English letters (lower-case and upper-case), ',' and '.'.",
            "1 <= numRows <= 1000"
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n\n    string convert(string s, int numRows) {\n    \n    if(numRows <= 1) return s;\n\n    vector<string>v(numRows, \"\"); \n\n    int j = 0, dir = -1;\n\n    for(int i = 0; i < s.length(); i++)\n    {\n\n        if(j == numRows - 1 || j == 0) dir *= (-1); \n   \n        v[j] += s[i];\n\n        if(dir == 1) j++;\n\n        else j--;\n    }\n\n    string res;\n\n    for(auto &it : v) res += it; \n\n    return res;\n\n    }\n};"
            },
            {
                "language": "php",
                "code": "class Solution {\npublic:\n    string convert(string s, int numRows) {\n        if (numRows <= 1) {\n            return s;\n        }\n        std::vector<std::string> list(numRows, \"\");\n        int currentLine = 0;"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\nmap<int,vector<int>> mapps;\n    string convert(string s, int numRows) {\n        string ssols=\"\";\n        int po=0;\n        mapps[1].push_back(s[po]);\n        po++;\n    while(po<s.size()){\n    for(int p=2;po<s.size()&&p+1<=numRows;p++){\n    mapps[p].push_back(s[po]);\n    po++;\n    }\n    for(int p=numRows;p>=1&&po<s.size();p--){\n    mapps[p].push_back(s[po]);\n    po++;\n    }\n    }\n    for(int p=1;p<=numRows;p++){\n        for(int po=0;po<mapps[p].size();po++){\n        ssols+=mapps[p][po];}\n    }\n    return ssols;}\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n\n/*Solution:\n\n    1) Implemntation Problem.\n    2) i] Move from top to bottom in a column .\n       ii] Then move diagonally from down to up.\n       For eg.\n         string=abcdefghijklmnop , numRows=4\n         \n         a     g     m\n         b   f h   l n\n         c e   i k   o\n         d     j     p\n\n\n\n*/\n    string convert(string s, int numRows) {\n        int n=s.size();\n        vector<string>ans(numRows,\"\");\n\n        int i=0;\n        while(i<n) //Iterate in a string\n        {\n            for(int j=0;j<numRows&&i<n;j++) //Move from top to bottom in a column and store ans \n\n            {\n                ans[j].push_back(s[i]); \n                i++;\n            }\n            int k=numRows-2;\n             for(;k>0&&i<n;k--)  //Then move diagonally from down to up and store ans\n            {\n                ans[k].push_back(s[i]);\n                i++;\n            }\n        }\n\n\n    string e;\n    for(int i=0;i<numRows;i++)\n    {\n        e+=ans[i];\n        //cout<<ans[i]<<\" \";\n    }\n\n    return e;\n\n\n        \n    }\n};"
            },
            {
                "language": "go",
                "code": "class Solution {\n    public String convert(String s, int numRows) {\n    char[] charArr = s.toCharArray();\n    int len = charArr.length;\n    StringBuffer[] sb = new StringBuffer[numRows]; \n    for(int i=0;i<numRows;i++){\n        sb[i]=new StringBuffer();\n    }\n    int i=0;\n    while(i<len){\n        for(int index=0;index<numRows && i<len;index++){\n            sb[index].append(charArr[i++]);\n            \n        }\n        for(int index=numRows-2;index>=1 &&i<len;index--){\n            sb[index].append(charArr[i++]);\n        }\n    }    \n     for(int j=1;j<sb.length;j++){\n         sb[0].append(sb[j]);\n     }   \n      return sb[0].toString(); \n    }\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string convert(string s, int row) {\n        if(row==1)return s;\n\n        string ans;\n        int p=0,n=s.length();\n\n        // row=0\n        while(p<n){\n            ans.push_back(s[p]);\n            p += (row-1)*2;\n        }\n\n        //middle rows\n        for(int i=1 ; i<row-1 ; i++){\n            p = i;\n            bool down=true;\n            while(p<n){\n                ans.push_back(s[p]);\n                if(down){\n                    p += (row-1-i)*2;\n                }\n                else{\n                    p += i*2;\n                }\n                down = !down;\n            }\n        }\n\n        // last row\n        p=row-1;\n        while(p<n){\n            ans.push_back(s[p]);\n            p += (row-1)*2;\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string convert(string s, int numRows) {\n        if(numRows==1) return s;\n        bool down=true;\n        string arr[numRows];\n        int row=0;\n        for(int i=0; i<s.size(); i++) {\n            arr[row].push_back(s[i]);\n            if(row==numRows-1) down=false;\n            else if (row==0) down=true;\n            if(down) row++;\n            else row--;\n        }\n        string res=\"\";\n        for(int i=0; i<numRows; i++) {\n            res += arr[i];\n        }\n        return res;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public String convert(String s, int numRows) {\n        if(numRows==1) return s;\n\n        int k=0; //iterator for string\n        int i=0; //iterator for row\n        int j=0; //iterator for column\n\n        //pattern will be stored in 2D array -> arr[]\n        char[][] arr = new char[numRows][s.length()];\n        for(int x=0; x<numRows; x++){\n            Arrays.fill(arr[x],'0'); //fill arr[] with '0'\n        }\n\n        while(k != s.length()){\n            //loop for vertical line chars of the pattern\n            while(i<numRows && k!=s.length()){ \n                arr[i][j] = s.charAt(k);\n                k++;\n                i++;\n            }\n            i--;\n            //loop for diagonal chars in pattern\n            while(i>0 && k!=s.length()){ \n                i--;\n                j++;\n                arr[i][j] = s.charAt(k);\n                k++;\n            }\n            i++;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for(int x=0; x<arr.length; x++){\n            for(int y=0; y<arr[x].length; y++){\n                //if arr[x][y] is filled with char, add it to sb\n                if(arr[x][y]!='0'){\n                    sb.append(arr[x][y]);\n                }\n            }\n        }\n\n        return sb.toString(); //return sb as a string\n\n    }\n}"
            },
            {
                "language": "typescript",
                "code": "object Solution {\n  import collection.immutable.SortedSet\n  def convert(s: String, numRows: Int): String =\n    if(numRows==1) s else\n      (0 until numRows).flatMap{r =>(r until s.length by ((numRows-1)*2)).flatMap{i =>\n          SortedSet(i, i + (numRows-1-r)*2%((numRows-1)*2) )\n      }}.filter(_ < s.length).map(s).mkString\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string convert(string s, int numRows) {\n        if(numRows == 1) return s;\n        string ans= \"\";\n        for(int i=0;i<numRows;i++){\n            int nextindex = (numRows-1)*2;\n            for(int j=i;j<s.size();j += nextindex){\n                ans += s[j];\n                int temp = j+nextindex-2*i;\n                if( i != 0 && i!= numRows-1 && temp < s.size()){\n                    ans += s[temp]; \n                }\n            }\n        }\n        return ans;\n    }\n\n};"
            },
            {
                "language": "",
                "code": ""
            },
            {
                "language": "ruby",
                "code": "# simulate and add each character to the corresponding row\n# go down -> reach bottom -> go up -> reach top -> go down ...\nclass Solution:\n    def convert(self, s: str, n: int) -> str:\n        # edge case\n        if n == 1: return s\n        rows = ['' for _ in range(n)]\n        # j is the index to track which rows a character should be added to\n        # d is the direction: -1 means go up, 1 means go down\n        j, d = 0, 1\n        for i in range(len(s)):\n            # add the current character to corresponding row\n            rows[j] += s[i]\n            # if it reaches to the last row, we need to go up\n            if j == n - 1: d = -1\n            # if it reaches to the first row, we need to go down\n            elif j == 0: d = 1\n            # move j pointer\n            j += d;\n        # rows would look like below in the first example\n        # ['PAHN', 'APLSIIG', 'YIR']\n        # we use join to build the final answer\n        return ''.join(rows)"
            },
            {
                "language": "csharp",
                "code": "// simulate and add each character to the corresponding row\n// go down -> reach bottom -> go up -> reach top -> go down ...\nclass Solution {\npublic:\n    string convert(string s, int n) {\n        // edge case\n        if (n == 1) return s;\n        vector<string> rows(n);\n        // j is the index to track which rows a character should be added to\n        // d is the direction: -1 means go up, 1 means go down\n        int j = 0, d = 1;\n        for (int i = 0; i < s.size(); i++) {\n            // add the current character to corresponding row\n            rows[j] += s[i];\n            // if it reaches to the last row, we need to go up\n            if(j == n - 1) d = -1;\n            // if it reaches to the first row, we need to go down\n            else if(j == 0) d = 1;\n            // move j pointer\n            j += d;\n        }\n        // rows would look like below in the first example\n        // ['PAHN', 'APLSIIG', 'YIR']\n        // we use `accumulate` to build the final answer (in C++ 20, it takes O(n) only)\n        return accumulate(rows.begin(), rows.end(), string{});\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string convert(string s, int numRows) {\n        if(numRows == 1)\n            return s;\n        vector<string> rows(numRows);\n        int j = 0, d = 1;\n        for (int i = 0; i < s.size(); i++) {"
            }
        ]
    },
    "6": {
        "question_id": 7,
        "title": "Reverse Integer",
        "difficulty": 2,
        "description": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.Assume the environment does not allow you to store 64-bit integers (signed or unsigned). ",
        "examples": [
            {
                "input": "x = 123",
                "output": "321",
                "explanation": null
            },
            {
                "input": "x = -123",
                "output": "-321",
                "explanation": null
            },
            {
                "input": "x = 120",
                "output": "21",
                "explanation": null
            }
        ],
        "constraints": [
            "-231 <= x <= 231 - 1"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int reverse(int x) {\n       int ans=0;\n        while(x!=0)\n        {\n            if (ans > INT_MAX/10 || (ans == INT_MAX / 10 && x > 7)) return 0;\n            if (ans < INT_MIN/10 || (ans == INT_MIN / 10 && x < -8)) return 0;   \n            ans=ans*10+x%10;\n            x=x/10;\n        }\n        return ans; \n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int reverse(int x) {\n        long finalNum = 0;\n        while(x!=0){\n            int lastDig = x%10;\n            finalNum += lastDig;\n            finalNum = finalNum*10;\n            x= x/10;\n        }\n        finalNum = finalNum/10;\n        if(finalNum > Integer.MAX_VALUE || finalNum<Integer.MIN_VALUE){\n            return 0;\n        }\n        if(x<0){\n            return (int)(-1*finalNum);\n        }\n        return (int)finalNum;\n    }\n}"
            },
            {
                "language": "dart",
                "code": "    if (x < 0) {\n        x = -x;\n        negative = true;\n    }\n    while(x!=0){  \n        int a=x%10; \n        // Check if the next operation is going to cause an overflow"
            },
            {
                "language": "erlang",
                "code": "- Space complexity:  O(1) "
            },
            {
                "language": "java",
                "code": "class Solution {                      \npublic:\n    int reverse(int x) {\n        long r=0;      // decleare r \n        while(x){\n         r=r*10+x%10; // find remainder and add its to r\n         x=x/10;     // Update the value of x\n        }\n        if(r>INT_MAX || r<INT_MIN) return 0; // check 32 bit range if r is outside the range then return 0  \n        return int(r);  // if r in the 32 bit range return r\n    }\n}; "
            },
            {
                "language": "kotlin",
                "code": "//System.out.println(\"Original Number: \" + x);\n\n// run loop until num becomes 0"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int reverse(int n) {\n        int res=0;\n        while(n!=0){\n            int ld=n%10;\n            int curRes=(res*10)+ld;\n            if((curRes-ld)/10!=res) return 0;\n            res=curRes;\n            n/=10;\n        }\n        return res;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int reverse(int x) {\n        long ans = 0;\n        while(x != 0){\n            int r = x % 10;\n            ans += r;\n            ans *= 10;\n            x /= 10;\n        }\n        ans /= 10;\n        if(ans > Integer.MAX_VALUE || ans < Integer.MIN_VALUE){\n            return 0;\n        }\n        return (int)ans;\n    }\n}"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public int reverse(int x) {\n     int y=0;\n       if(x==1534236469){\n            return 0;\n       }\n       if(x==2147483647){\n            return 0;\n       }\n        if(x==-2147483648){\n            return 0;\n       }   if(x==1563847412){\n            return 0;\n       }\n        if(x==-1563847412){\n            return 0;\n       }\n     if(x>0) \n        {\n            while(x>0)\n        {\n            \n            int temp = x%10;\n            y=y*10+temp;\n            x=x/10;\n        }\n        return y ;\n        }\n     if(x<0) \n        {\n           \n            while(x<0)\n        {\n            int temp = x%10;\n            y=y*(10)-temp;\n            x=x/10;\n        }\n      \n        return -y ;\n        }\n        \n        return y; \n    }\n}"
            },
            {
                "language": "swift",
                "code": "class Solution {\n    func reverse(_ x: Int) -> Int {\n        var (r, x) = (0, x)\n        while x != 0 {\n            r = (r * 10) + (x % 10)\n            x /= 10\n        }\n        return r < Int32.min || r > Int32.max ? 0 : r\n    }\n}"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int reverse(int x) {\n        boolean negativeNumber = false;\n        int result = 0;\n        if (x < 0) {\n            x = x * (-1);\n            if (x < 0) {\n                return 0;\n            }\n            negativeNumber = true;\n        }\n        while (x >= 0) {\n            if (result > 214748364){\n                return 0;\n            }\n            if (x >= 10) {\n                int x1 = x % 10;\n                x = x / 10;\n                result = (result * 10) + x1;\n            } else {\n                result = (result * 10) + x;\n                x = -1;\n            }\n        }\n        if (negativeNumber) {\n            result = result * (-1);\n        }\n        return result;\n        \n    }\n}"
            },
            {
                "language": "javascript",
                "code": "original number: 543\nreverse number: 0\n\n//Get the last digit of the original number\noriginal % 10 = 543 % 10 = 3\n//Put this digit as the last one in the reverse number\nreverse * 10 + digit = 0 * 10 + 3 = 0 + 3 = 3\nreverse: 3\n//Remove this digit from the original number\noriginal / 10 = 543 / 10 = 54.3\n~~54.3 = 54\noriginal: 54\n\n//Repeat\noriginal % 10 = 54 % 10 = 4\nreverse * 10 + digit = 3 * 10 + 4 = 30 + 4 = 34\nreverse: 34\noriginal / 10 = 54 / 10 = 5.4\n~~5.4 = 5\noriginal: 5\n\n//Repeat\noriginal % 10 = 5 % 10 = 5\nreverse * 10 + digit = 34 * 10 + 5 = 340 + 5 = 345\nreverse: 345\noriginal / 10 = 5 / 10 = 0.5\n~~0.5 = 0\noriginal: 0\n\ninput: 543\noutput: 345"
            }
        ]
    },
    "7": {
        "question_id": 8,
        "title": "String to Integer (atoi)",
        "difficulty": 2,
        "description": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).The algorithm for myAtoi(string s) is as follows:Read in and ignore any leading whitespace.Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.Return the integer as the final result.Note:Only the space character ' ' is considered a whitespace character.Do not ignore any characters other than the leading whitespace or the rest of the string after the digits. ",
        "examples": [
            {
                "input": "s = \"42\"",
                "output": "42",
                "explanation": "The underlined characters are what is read in, the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range [-231, 231 - 1], the final result is 42."
            },
            {
                "input": "s = \"   -42\"",
                "output": "-42\nExplanation:\nStep 1: \"   -42\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -42\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -42\" (\"42\" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range [-231, 231 - 1], the final result is -42.",
                "explanation": null
            },
            {
                "input": "s = \"4193 with words\"",
                "output": "4193\nExplanation:\nStep 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range [-231, 231 - 1], the final result is 4193.",
                "explanation": null
            }
        ],
        "constraints": [
            "0 <= s.length <= 200",
            "s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'."
        ],
        "solutions": [
            {
                "language": "kotlin",
                "code": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        su,num,flag = 1,0,0\n        s = s.strip()\n        if len(s) == 0: return 0\n        if s[0] == \"-\":\n            su = -1\n        for i in s:\n            if i.isdigit():\n                num = num*10 + int(i)\n                flag = 1\n            elif (i == \"+\" or i == \"-\") and (flag == 0):\n                flag = 1\n                pass\n            else: break\n        num = num*su\n        if (-2**31<=num<=(2**31)-1): return num\n        if num<0: return -2**31\n        else: return 2**31-1"
            },
            {
                "language": "dart",
                "code": "/*\n\n    Time Complexity : O(logN), Since we are going through the entire number digit by digit, the time complexity\n    should be O(log10N). The reason behind log10 is because we are dealing with integers which are base 10.\n\n    Space Complexity : O(1), We are not using any data structure for interim operations, therefore, the space\n    complexity is O(1).\n\n    Solved using String.\n\n*/\n\nclass Solution {\npublic:\n    int myAtoi(string s) {\n        int len = s.size();\n        double num = 0;\n        int i=0;\n        while(s[i] == ' '){\n            i++;\n        }\n        bool positive = s[i] == '+';\n        bool negative = s[i] == '-';\n        positive == true ? i++ : i;\n        negative == true ? i++ : i;\n        while(i < len && s[i] >= '0' && s[i] <= '9'){\n            num = num*10 + (s[i]-'0');\n            i++;\n        }\n        num = negative ? -num : num;\n        cout<<num<<endl;\n        num = (num > INT_MAX) ? INT_MAX : num;\n        num = (num < INT_MIN) ? INT_MIN : num;\n        cout<<num<<endl;\n        return int(num);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int myAtoi(string s) {\n       string str=\"\";\n       int minus = 1;\n       int flag = 0;\n       int i = 0;\n       while((s[i] == ' '))i++; //removing all spaces\n       if(s[i] == '-' || s[i] == '+'){\n          if(s[i] == '-')minus = -1;\n           i++;\n       }//seeing weather the number is pos or neg\n    \n       for(;i<s.length();i++){\n          if(s[i] >= 48 && (s[i] <= 57)){\n            str = str + s[i];\n          }\n          else break;\n       }\n       if(str.length() == 0)return 0;\n       int res = 0;\n       for(int i=0;i<str.length();i++){\n           long long res_temp = res;\n           if(res_temp*10+int(str[i] - 48) > INT_MAX){\n               if(minus == -1)return 2147483648*minus;//for neg elements it is 2^31\n               else return 2147483647;//for positive elements it is 2^31-1\n           }\n           res  = res*10 + int(str[i] - 48);\n       }//converting to string\n       return res*minus;\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    fun myAtoi(s: String): Int {\n        var finalNumber = \"\"\n        var isNegative = false\n\n        run breaking@{\n            s.forEach {\n                if (it.isDigit())\n                    finalNumber += it\n                else if (finalNumber.isEmpty() && (it == '-' || it == '+')) {\n                    finalNumber += it\n                    isNegative = it == '-'\n                } else if (!it.isDigit() && (finalNumber.isNotEmpty() || !it.isWhitespace()))\n                    return@breaking\n            }\n        }\n\n        if (!finalNumber.contains(\"[0-9]\".toRegex()))\n            return 0\n\n        return try {    \n            finalNumber.toInt()\n        } catch (e: Exception) {\n            if (isNegative) {\n                -2147483648\n            } else {\n                2147483647\n            }\n        }\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int myAtoi(String s) {\n        int sign=1; int result=0; int i=0; int n=s.length();\n        while(i<n && s.charAt(i)==' ')\n            i++;\n        \n        if(i<n && s.charAt(i)=='+'){\n            sign=1;\n            i++;\n        }\n        else if(i<n && s.charAt(i)=='-'){\n            sign=-1;\n            i++;\n        }\n        while(i<n && 0<=(int)s.charAt(i)-'0' && (int)s.charAt(i)-'0'<=9 ){   \n            if(result>Integer.MAX_VALUE/10 || (result==Integer.MAX_VALUE/10 && (int)(s.charAt(i)-'0')>Integer.MAX_VALUE%10))\n            return result=(sign==1?Integer.MAX_VALUE:Integer.MIN_VALUE);\n            result*=10;\n            result+=((int)s.charAt(i)-'0');\n            i++;\n        }\n        return result*sign;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int myAtoi(string s) {\n        long number = 0;\n        bool isNegative = false;\n        bool signReceived = false;\n        bool numberReceived = false;\n\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] == ' ' && !numberReceived && !signReceived) continue;\n            else if(s[i] == '-'){\n                if(signReceived && numberReceived)\n                    break;\n                else if(signReceived)\n                    return 0;\n                isNegative = true;\n                signReceived = true;\n            }\n            else if(s[i] == '+'){\n                if(signReceived && numberReceived)\n                    break;\n                else if(signReceived)\n                    return 0;\n                signReceived = true;\n            }\n            else if(s[i] >= '0' && s[i] <= '9'){\n                numberReceived = true;\n                signReceived = true;\n                number += s[i] - 48; //48 is ascii for 0\n                if(number > pow(2,31) && isNegative){ \n                    number = pow(2,31);\n                    break;\n                }\n                else if(number > pow(2,31) - 1 && !isNegative){ \n                    number = pow(2,31) - 1;\n                    break;\n                }\n                if(i < s.size()-1 && s[i+1] >= '0' && s[i+1] <= '9')number *= 10;\n            }\n            else break;\n        }\n        \n        return isNegative ? -number : number;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int myAtoi(string s) {\n        long number = 0;\n        bool isNegative = false;\n        bool signReceived = false;\n        bool numberReceived = false;\n\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] == ' ' && !numberReceived && !signReceived) continue;\n            else if(s[i] == '-'){\n                if(signReceived && numberReceived)\n                    break;\n                else if(signReceived)\n                    return 0;\n                isNegative = true;\n                signReceived = true;\n            }\n            else if(s[i] == '+'){\n                if(signReceived && numberReceived)\n                    break;\n                else if(signReceived)\n                    return 0;\n                signReceived = true;\n            }\n            else if(s[i] >= '0' && s[i] <= '9'){\n                numberReceived = true;\n                signReceived = true;\n                number += s[i] - 48; //48 is ascii for 0\n                if(number > pow(2,31) && isNegative){ \n                    number = pow(2,31);\n                    break;\n                }\n                else if(number > pow(2,31) - 1 && !isNegative){ \n                    number = pow(2,31) - 1;\n                    break;\n                }\n                if(i < s.size()-1 && s[i+1] >= '0' && s[i+1] <= '9')number *= 10;\n            }\n            else break;\n        }\n        \n        return isNegative ? -number : number;\n    }\n};"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def myAtoi(self, str: str) -> int:\n        str = str.strip()\n        if not str:\n            return 0\n        sign = -1 if str[0] == '-' else 1\n        str = str[1:] if str[0] in ['-', '+'] else str\n        res = 0\n        for char in str:\n            if not char.isdigit():\n                break\n            res = res * 10 + int(char)\n            if res * sign >= 2**31 - 1:\n                return 2**31 - 1\n            if res * sign <= -2**31:\n                return -2**31\n        return res * sign"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int myAtoi(string s) {\n        //triming front spaces\n        int i=0;\n        while(s[i]==' ')i++;\n        \n        //check if sigh present in string\n        int sign=1;\n        if(s[i]=='+' || s[i]=='-'){\n            if(s[i]=='-') sign= -1;\n            i++;\n        }\n        \n        //initialize ans =0\n        int ans=0;\n        \n        for(;i<s.size();i++){\n            if(!isdigit(s[i])) return ans;\n            int dig= (s[i]-'0')*sign;\n            \n   //very risky part (to handle overflows)\n            if(sign== 1 && (ans> INT_MAX/10  || (ans==INT_MAX/10 && dig>(INT_MAX%10)))) return INT_MAX;\n            if(sign== -1 && (ans< INT_MIN/10 || (ans==INT_MIN/10 && dig<(INT_MIN%10)))) return INT_MIN;\n            \n            ans= (1LL*ans*10)+ dig;\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "if(result > (Integer.MAX_VALUE / 10) || (result == (Integer.MAX_VALUE / 10) && digit > 7))\n                return isNegative ? Integer.MIN_VALUE : Integer.MAX_VALUE;"
            },
            {
                "language": "kotlin",
                "code": "if(result > (Integer.MAX_VALUE - digit) / 10)\n                return isNegative ? Integer.MIN_VALUE : Integer.MAX_VALUE;"
            },
            {
                "language": "kotlin",
                "code": "if(result > (INT_MAX / 10) || (result == (INT_MAX / 10) && digit > 7))\n                return isNegative ? INT_MIN : INT_MAX;"
            },
            {
                "language": "kotlin",
                "code": "if(result > (INT_MAX - digit) / 10)\n                return isNegative ? INT_MIN : INT_MAX;"
            }
        ]
    },
    "8": {
        "question_id": 9,
        "title": "Palindrome Number",
        "difficulty": 1,
        "description": "Given an integer x, return true if x is a palindrome, and false otherwise. ",
        "examples": [
            {
                "input": "x = 121",
                "output": "true",
                "explanation": "121 reads as 121 from left to right and from right to left."
            },
            {
                "input": "x = -121",
                "output": "false",
                "explanation": "From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome."
            },
            {
                "input": "x = 10",
                "output": "false",
                "explanation": "Reads 01 from right to left. Therefore it is not a palindrome."
            }
        ],
        "constraints": [
            "-231\u00a0<= x <= 231\u00a0- 1"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution {\n    public boolean isPalindrome(int x) {\n        String s = String.valueOf(x); // Convert to String\n        int n = s.length(); // Store the String length to int n\n\n        for (int i=0; i<n/2; i++) {\n            // We check whether the elements at the same distance from\n            // beginning and from ending are same, if not we return false\n            if (s.charAt(i) != s.charAt(n-i-1)) return false;\n        }\n\n        // if no flaws are found we return true\n        return true;\n    }\n}"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean isPalindrome(int x) {\n      if(x<0){\n            return false;\n      }    \n       int rem=0;\n       int sum=0;\n       int temp=x;\n       while(x>0){\n         rem=x%10;\n         sum=(sum*10)+rem;\n         x=x/10;\n        }\n      if(temp==sum){\n      return true;\n      }\n      return false;\n    }\n}\n    "
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0:\n            return False\n        rev = 0\n        orig = x\n        while x != 0:\n            rev = rev * 10 + x % 10\n            x //= 10\n        return rev == orig"
            },
            {
                "language": "javascript",
                "code": "   check only Half of the digits of given Number\n   to prevent from OVERFLOW"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean isPalindrome(int x) {\n        if(x<0 || x!=0 && x%10 ==0 ) return false;\n        int check=0;\n        while(x>check){\n            check = check*10 + x%10;\n            x/=10;\n        }\n        return (x==check || x==check/10);\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "bool isPalindrome(int x){\n    if(x<0 || x!=0 && x%10 ==0 ) return false;\n    int check=0;\n    while(x>check){\n        check = check*10 + x%10;\n        x/=10;\n    }\n    return (x==check || x==check/10);\n}"
            },
            {
                "language": "javascript",
                "code": " **   Use similar Math in PYTHON / C++   **"
            },
            {
                "language": "cpp",
                "code": "bool isPalindrome(int x){\n   long rem=0,sum=0,num=x;\n   while(x>0)\n   {rem=x%10; //1%10\n    sum=sum*10+rem; //10*1\n    x/=10; //10/1\n    }\n    if(sum==num)\n    return true;\n    else\n    return false;\n}"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean isPalindrome(int x) {\n      String s = String.valueOf(x);  \n\n        int i = 0;                   \n        int j = s.length() - 1; \n       \n          while(i <= j)      \n        {\n            if(s.charAt(i) != s.charAt(j))  \n                return false;\n            i++;                                \n            j--;                                \n        }  \n        \n        return true;\n        \n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public boolean isPalindrome(int x) {\n        if(x==-1)\n        {\n            return false;\n        }\n    \n       int ans=  palin(x);\n       if(x==ans)\n       {\n           return true;\n       }\n       return false;\n        \n    }\n    public static int palin(int x)\n    {\n        int digit=(int )Math.log10(x)+1;\n        \n        \n        int ans=helper(x,digit);\n        return ans;\n\n    }\n    public static int helper(int n,int digit)\n    {\n        if(n%10==n)\n        {\n            return n;\n        }\n        return (n%10)*(int)Math.pow(10,digit-1)+helper(n/10,digit-1);\n    }\n}"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        y=str(x)\n        lst=list(y)\n        m=len(lst)\n        if(x<0):\n            return False\n        elif(x==0):\n            return True\n        else:\n            flag=1\n            for x in range((m+1)//2):\n                if(lst[x]!=lst[m-1-x]):\n                    return False\n                    flag=0\n            if(flag>0):\n                return True\n                \n                \n                \n            \n        "
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {number} x\n * @return {boolean}\n */\nvar isPalindrome = function (x) {\n  //TIME-COMPLEXITY: O(n);\n  //MEMORY: O(1);\n  const str = x.toString();\n  let leftIndex = 0;\n  let rightIndex = str.length - 1;\n\n  while (leftIndex < rightIndex) {\n    if (str.charAt(leftIndex) !== str.charAt(rightIndex)) {\n      return false;\n    }\n    leftIndex++;\n    rightIndex--;\n  }\n\n  return true;\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        stack<int> st;\n        if(x<0)\n            return false;\n        int y=x;\n        while(x)\n        {\n            st.push(x%10);\n            x/=10;\n        }\n        while(y)\n        {\n            if(st.top()!=(y%10))\n               return false;\n             st.pop();\n               y/=10;\n        }\n        return true;\n    }\n};"
            }
        ]
    },
    "9": {
        "question_id": 10,
        "title": "Regular Expression Matching",
        "difficulty": 3,
        "description": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:'.' Matches any single character.\u200b\u200b\u200b\u200b'*' Matches zero or more of the preceding element.The matching should cover the entire input string (not partial). ",
        "examples": [
            {
                "input": "s = \"aa\", p = \"a\"",
                "output": "false",
                "explanation": "\"a\" does not match the entire string \"aa\"."
            },
            {
                "input": "s = \"aa\", p = \"a*\"",
                "output": "true",
                "explanation": "'*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\"."
            },
            {
                "input": "s = \"ab\", p = \".*\"",
                "output": "true",
                "explanation": "\".*\" means \"zero or more (*) of any character (.)\"."
            }
        ],
        "constraints": [
            "1 <= s.length\u00a0<= 20",
            "1 <= p.length\u00a0<= 20",
            "s contains only lowercase English letters.",
            "p contains only lowercase English letters, '.', and\u00a0'*'.",
            "It is guaranteed for each appearance of the character '*', there will be a previous valid character to match."
        ],
        "solutions": [
            {
                "language": "kotlin",
                "code": "class Solution {\npublic boolean isMatch(String s, String p) {\n    return helper(0,0,s,p,new Boolean[s.length()][p.length()]);\n}\npublic boolean helper(int index1,int index2, String s, String p, Boolean[][] dp) {\n    if(index1>=s.length()|| index2>= p.length()) {\n        if(index1>=s.length()&& index2>= p.length())\n            return true;\n        else  if(index2+1<p.length() && p.charAt(index2+1)=='*')  {\n         return helper(index1, index2+2, s, p, dp);\n        }\n        \n            return false;\n        \n    }\n    if(dp[index1][index2] != null)\n        return dp[index1][index2];\n    \n    if(index2+1<p.length() && p.charAt(index2+1)=='*')\n    {\n     if(p.charAt(index2) == '.')\n        {\n            return  dp[index1][index2] = helper(index1+1,index2,s,p,dp) || helper(index1,index2+2,s,p,dp);\n        }\n     else {\n      if(s.charAt(index1) == p.charAt(index2))    {\n               return dp[index1][index2] =helper(index1+1,index2,s,p,dp) || helper(index1,index2+2,s,p,dp); \n            }\n      else {\n       return dp[index1][index2]=helper(index1,index2+2,s,p,dp);\n      }\n       \n     }\n    }\n    else {\n      if(s.charAt(index1) == p.charAt(index2))  {\n            return dp[index1][index2] =helper(index1+1,index2+1,s,p,dp); \n         }\n         else if(p.charAt(index2) == '.')  {\n             return  dp[index1][index2] = helper(index1+1,index2+1,s,p,dp);\n         }\n    }\n    \n    return false;\n}\n}"
            },
            {
                "language": "python",
                "code": "1, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-1][j-1];\n2, If p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1];\n3, If p.charAt(j) == '*': \n   here are two sub conditions:\n               1   if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty\n               2   if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.':\n                              dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a \n                           or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a\n                           or dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty"
            },
            {
                "language": "typescript",
                "code": "public boolean isMatch(String s, String p) {\n\n    if (s == null || p == null) {\n        return false;\n    }\n    boolean[][] dp = new boolean[s.length()+1][p.length()+1];\n    dp[0][0] = true;\n    for (int i = 0; i < p.length(); i++) {\n        if (p.charAt(i) == '*' && dp[0][i-1]) {\n            dp[0][i+1] = true;\n        }\n    }\n    for (int i = 0 ; i < s.length(); i++) {\n        for (int j = 0; j < p.length(); j++) {\n            if (p.charAt(j) == '.') {\n                dp[i+1][j+1] = dp[i][j];\n            }\n            if (p.charAt(j) == s.charAt(i)) {\n                dp[i+1][j+1] = dp[i][j];\n            }\n            if (p.charAt(j) == '*') {\n                if (p.charAt(j-1) != s.charAt(i) && p.charAt(j-1) != '.') {\n                    dp[i+1][j+1] = dp[i+1][j-1];\n                } else {\n                    dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]);\n                }\n            }\n        }\n    }\n    return dp[s.length()][p.length()];\n}"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean isMatch(String s, String p) {\n        // corner case\n        if(s == null || p == null) return false;"
            },
            {
                "language": "typescript",
                "code": "public class Solution {\n    public boolean isMatch(String s, String p) {\n        if(s == null || p == null) {\n            return false;\n        }\n        boolean[][] state = new boolean[s.length() + 1][p.length() + 1];\n        state[0][0] = true;\n        // no need to initialize state[i][0] as false"
            },
            {
                "language": "java",
                "code": "  public boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    char[] sc = s.toCharArray(), pc = p.toCharArray();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n    for(int i = 2; i <= n; i++){\n      if(pc[i - 1] == '*'){"
            },
            {
                "language": "ruby",
                "code": "2 if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.':i->j\nit should be \"2 if p.charAt(j-1) == s.charAt(i) or p.charAt(j-1) == '.'"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int n = s.length(), m = p.length();\n        bool dp[n+1][m+1];\n        memset(dp, false, sizeof(dp));\n        dp[0][0] = true;\n        \n        for(int i=0; i<=n; i++){\n            for(int j=1; j<=m; j++){\n                if(p[j-1] == '*'){\n                    dp[i][j] = dp[i][j-2] || (i > 0 && (s[i-1] == p[j-2] || p[j-2] == '.') && dp[i-1][j]);\n                }\n                else{\n                    dp[i][j] = i > 0 && dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.');\n                }\n            }\n        }\n        \n        return dp[n][m];\n    }\n};"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        memo = {}\n    \n        def dp(i: int, j: int) -> bool:\n            if (i, j) in memo:\n                return memo[(i, j)]\n        \n            if j == len(p):\n                return i == len(s)\n        \n            first_match = i < len(s) and (p[j] == s[i] or p[j] == '.')\n        \n            if j + 1 < len(p) and p[j+1] == '*':\n                ans = dp(i, j+2) or (first_match and dp(i+1, j))\n            else:\n                ans = first_match and dp(i+1, j+1)\n        \n            memo[(i, j)] = ans\n            return ans\n    \n        return dp(0, 0)"
            },
            {
                "language": "javascript",
                "code": "s='aab', p='c*a*b'\n\n      c * a * b \n    0 1 2 3 4 5\n  0 y\na 1\na 2\nb 3"
            },
            {
                "language": "javascript",
                "code": "s='aab', p='c*a*b'\n\n      c * a * b \n    0 1 2 3 4 5\n  0 y\na 1 n\na 2 n\nb 3 n"
            },
            {
                "language": "lisp",
                "code": "        for (int j=2; j<=p.length(); j++) {\n            dp[0][j] = p.charAt(j-1) == '*' && dp[0][j-2]; \n        }"
            },
            {
                "language": "javascript",
                "code": "s='aab', p='c*a*b'\n\n      c * a * b \n    0 1 2 3 4 5\n  0 y n y n y n\na 1 n\na 2 n\nb 3 n"
            },
            {
                "language": "javascript",
                "code": "s='aab', p='c*a*b'\n\n      c * a * b \n    0 1 2 3 4 5\n  0 y n y n y n\na 1 n n n y y n\na 2 n n n n y n\nb 3 n n n n n y"
            },
            {
                "language": "typescript",
                "code": "public boolean isMatch(String s, String p) {\n        if (p == null || p.length() == 0) return (s == null || s.length() == 0);\n        \n        boolean dp[][] = new boolean[s.length()+1][p.length()+1];\n        dp[0][0] = true;\n        for (int j=2; j<=p.length(); j++) {\n            dp[0][j] = p.charAt(j-1) == '*' && dp[0][j-2]; \n        }\n        \n        for (int j=1; j<=p.length(); j++) {\n            for (int i=1; i<=s.length(); i++) {\n                if (p.charAt(j-1) == s.charAt(i-1) || p.charAt(j-1) == '.') \n     dp[i][j] = dp[i-1][j-1];\n                else if(p.charAt(j-1) == '*')\n                    dp[i][j] = dp[i][j-2] || ((s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == '.') && dp[i-1][j]); \n            }\n        }\n        return dp[s.length()][p.length()];\n    }"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic boolean isMatch(String s, String p) {\n    return helper(0,0,s,p,new Boolean[s.length()][p.length()]);\n}\npublic boolean helper(int index1,int index2, String s, String p, Boolean[][] dp) {\n    if(index1>=s.length()|| index2>= p.length()) {\n        if(index1>=s.length()&& index2>= p.length())\n            return true;\n        else  if(index2+1<p.length() && p.charAt(index2+1)=='*')  {\n         return helper(index1, index2+2, s, p, dp);\n        }\n        \n            return false;\n        \n    }\n    if(dp[index1][index2] != null)\n        return dp[index1][index2];\n    \n    if(index2+1<p.length() && p.charAt(index2+1)=='*')\n    {\n     if(p.charAt(index2) == '.')\n        {\n            return  dp[index1][index2] = helper(index1+1,index2,s,p,dp) || helper(index1,index2+2,s,p,dp);\n        }\n     else {\n      if(s.charAt(index1) == p.charAt(index2))    {\n               return dp[index1][index2] =helper(index1+1,index2,s,p,dp) || helper(index1,index2+2,s,p,dp); \n            }\n      else {\n       return dp[index1][index2]=helper(index1,index2+2,s,p,dp);\n      }\n       \n     }\n    }\n    else {\n      if(s.charAt(index1) == p.charAt(index2))  {\n            return dp[index1][index2] =helper(index1+1,index2+1,s,p,dp); \n         }\n         else if(p.charAt(index2) == '.')  {\n             return  dp[index1][index2] = helper(index1+1,index2+1,s,p,dp);\n         }\n    }\n    \n    return false;\n}\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int m = s.size(), n = p.size();\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\n        dp[0][0] = true;\n        for (int i = 0; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p[j - 1] == '*') {\n                    dp[i][j] = dp[i][j - 2] || (i && dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n                } else {\n                    dp[i][j] = i && dp[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == '.');\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '.' or p[j - 1] == s[i - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2]\n                    if p[j - 2] == '.' or p[j - 2] == s[i - 1]:\n                        dp[i][j] |= dp[i - 1][j]\n        return dp[m][n]"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int m = s.size(), n = p.size();\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\n        dp[0][0] = true;\n        for (int i = 0; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p[j - 1] == '*') {\n                    dp[i][j] = dp[i][j - 2] || (i && dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n                }\n                 else if(i>0 && (s[i - 1] == p[j - 1] || p[j - 1] == '.')) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                }\n            }\n        }\n        return dp[m][n];   \n    }\n};"
            }
        ]
    },
    "10": {
        "question_id": 11,
        "title": "Container With Most Water",
        "difficulty": 2,
        "description": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store.Notice that you may not slant the container. ",
        "examples": [
            {
                "input": "height = [1,8,6,2,5,4,8,3,7]",
                "output": "49",
                "explanation": "The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49."
            },
            {
                "input": "height = [1,1]",
                "output": "1",
                "explanation": null
            }
        ],
        "constraints": [
            "n == height.length",
            "2 <= n <= 105",
            "0 <= height[i] <= 104"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxArea(vector<int>& height) {\n       int ans = 0, n = height.size();\n       int i = 0, j = n-1;\n       while(i<j){\n           if(height[i]>height[j]){\n               ans = max(ans, (j-i)*height[j]);\n               j--;\n           }\n           else{\n               ans = max(ans, (j-i)*height[i]);\n               i++;\n           }\n       }\n       return ans;\n    }\n};\n\nDo Upvote if it helps."
            },
            {
                "language": "php",
                "code": "You are given an integer array height of length n\n\nReturn the maximum amount of water a container can store."
            },
            {
                "language": "",
                "code": "8    |                                     |\n7    |                                     |             |\n6    |     |                             |             |\n5    |     |             |             |             |\n4    |     |             |     |     |             |\n3    |     |             |     |     |     |     |\n2    |     |     |     |     |     |     |     |\n1    |     |     |     |     |     |     |     |     |\n       0        1       2       3       4       5       6       7       8\n             ^                                       ^"
            },
            {
                "language": "python",
                "code": "> max area which is intially 0\n> Then, we going to have 2 pointers. One in left start at 0th index & one right start from last index."
            },
            {
                "language": "swift",
                "code": "8    |                                     |\n7    |                                     |             |                             width = 8 - 0 = 8\n6    |     |                             |             |                             height = min(1, 7)\n5    |     |             |             |             |                             Area = 8 * 1 = 8\n4    |     |             |     |     |             |\n3    |     |             |     |     |     |     |                             max = 0 -> max = 8\n2    |     |     |     |     |     |     |     |\n1    |     |     |     |     |     |     |     |     |\n       0        1       2       3       4       5       6       7       8\n    ^                                                                ^\n   left                                                            right"
            },
            {
                "language": "swift",
                "code": "8    |                                     |\n7    |                                     |             |                             width = 8 - 1 = 7\n6    |     |                             |             |                             height = min(8, 7)\n5    |     |             |             |             |                             Area = 7 * 7 = 49\n4    |     |             |     |     |             |\n3    |     |             |     |     |     |     |                             max = 8 -> max = 49\n2    |     |     |     |     |     |     |     |\n1    |     |     |     |     |     |     |     |     |\n       0        1       2       3       4       5       6       7       8\n             ^                                                       ^\n            left                                                   right"
            },
            {
                "language": "python",
                "code": "8    |                                     |\n7    |                                     |             |                             width = 7 - 1 = 6\n6    |     |                             |             |                             height = min(8, 3)\n5    |     |             |             |             |                             Area = 6 * 3 = 18\n4    |     |             |     |     |             |\n3    |     |             |     |     |     |     |                             max = 49\n2    |     |     |     |     |     |     |     |\n1    |     |     |     |     |     |     |     |     |\n       0        1       2       3       4       5       6       7       8\n             ^                                               ^\n            left                                           right"
            },
            {
                "language": "python",
                "code": "8    |                                     |\n7    |                                     |             |                             width = 6 - 1 = 5\n6    |     |                             |             |                             height = min(8, 8)\n5    |     |             |             |             |                             Area = 8 * 5 = 40\n4    |     |             |     |     |             |\n3    |     |             |     |     |     |     |                             max = 49\n2    |     |     |     |     |     |     |     |\n1    |     |     |     |     |     |     |     |     |\n       0        1       2       3       4       5       6       7       8\n             ^                                       ^\n            left                                   right"
            },
            {
                "language": "python",
                "code": "8    |                                     |\n7    |                                     |             |                             width = 5 - 2 = 3\n6    |     |                             |             |                             height = min(4, 6)\n5    |     |             |             |             |                             Area = 4 * 3 = 12\n4    |     |             |     |     |             |\n3    |     |             |     |     |     |     |                             max = 49\n2    |     |     |     |     |     |     |     |\n1    |     |     |     |     |     |     |     |     |\n       0        1       2       3       4       5       6       7       8\n                     ^                       ^\n                    left                   right"
            },
            {
                "language": "python",
                "code": "8    |                                     |\n7    |                                     |             |                             width = 4 - 2 = 2\n6    |     |                             |             |                             height = min(5, 6)\n5    |     |             |             |             |                             Area = 5 * 2 = 10\n4    |     |             |     |     |             |\n3    |     |             |     |     |     |     |                             max = 49\n2    |     |     |     |     |     |     |     |\n1    |     |     |     |     |     |     |     |     |\n       0        1       2       3       4       5       6       7       8\n                     ^               ^\n                    left           right"
            },
            {
                "language": "python",
                "code": "8    |                                     |\n7    |                                     |             |                             width = 3 - 2 = 1\n6    |     |                             |             |                             height = min(2, 6)\n5    |     |             |             |             |                             Area = 2 * 1 = 2\n4    |     |             |     |     |             |\n3    |     |             |     |     |     |     |                             max = 49\n2    |     |     |     |     |     |     |     |\n1    |     |     |     |     |     |     |     |     |\n       0        1       2       3       4       5       6       7       8\n                     ^       ^\n                    left   right"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int maxArea(int[] height) {\n        int left = 0;\n        int right = height.length - 1;\n        int max = 0;\n        while(left < right){\n            int w = right - left;\n            int h = Math.min(height[left], height[right]);\n            int area = h * w;\n            max = Math.max(max, area);\n            if(height[left] < height[right]) left++;\n            else if(height[left] > height[right]) right--;\n            else {\n                left++;\n                right--;\n            }\n        }\n        return max;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int left = 0;\n        int right = height.size() - 1;\n        int maxi = 0;\n        while(left < right){\n            int w = right - left;\n            int h = min(height[left], height[right]);\n            int area = h * w;\n            maxi = max(maxi, area);\n            if(height[left] < height[right]) left++;\n            else if(height[left] > height[right]) right--;\n            else {\n                left++;\n                right--;\n            }\n        }\n        return maxi;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxArea(vector<int> &height) {\n        int i = 0, j = height.size() - 1, area = 0;\n        while (i < j) {\n            area = max(area, min(height[i], height[j]) * (j - i));\n            height[i] < height[j] ? i++ : j--;\n        }"
            },
            {
                "language": "python",
                "code": "    int i=0;\n    int j=height.size()-1;\n    int ans=0;\n    while(i<j){\n        if(height[i]<=height[j]){"
            },
            {
                "language": "javascript",
                "code": "var maxArea = function (height) {\n    var leftIndex = 0;\n    var rightIndex = height.length - 1;\n    var maxStoredWater = 0;\n\n    while (leftIndex < rightIndex) {\n        const leftHeight = height[leftIndex];\n        const rightHeight = height[rightIndex];\n        const width = rightIndex - leftIndex;\n        const smallerHeight = leftHeight < rightHeight ? leftHeight : rightHeight;\n        const storedWater = width * smallerHeight;\n\n        maxStoredWater = storedWater > maxStoredWater ? storedWater : maxStoredWater;\n        smallerHeight == leftHeight ? leftIndex++ : rightIndex--;\n    }\n\n    return maxStoredWater;\n};"
            },
            {
                "language": "ruby",
                "code": "  Code in JAVA and C :-"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int maxArea(int[] arr) {\n        final int N = arr.length;\n        int max = 0 , test, i=0, j=N-1;\n        while(j>i){\n            test = arr[i] < arr[j] ? arr[i] : arr[j];\n            test = (j - i) * test;\n            if(max < test) max = test;\n            if(arr[i] < arr[j]) i++ ;\n            else j--;\n        }\n        return max;\n    }\n}"
            },
            {
                "language": "python",
                "code": "int maxArea(int* arr, int N){\n    int max = 0,test,i=0,j=N-1;\n    while(j>i){\n        test = arr[i];\n        if(test>arr[j]) test = arr[j];\n        test = (j - i) * test;\n        if(max < test) max = test;\n        if(arr[i] < arr[j]) i++ ;\n        else j--;\n    }\n    return max;\n}"
            },
            {
                "language": "cpp",
                "code": "public int maxArea(int[] height) {      \n       final int N = height.length;\n       int max = 0 , area, i=0, j=N-1, min_height;\n       while(j > i)  {\n           // find the smaller side of the bucket"
            },
            {
                "language": "swift",
                "code": "class Solution {\n    func maxArea(_ height: [Int]) -> Int {\n        var (l, r) = (0, height.count-1)\n        var (lm, rm) = (height[l], height[r])\n        var res = min(lm, rm)*max(r-l, 1)\n\n        while l < r {\n            if lm < rm{\n                l += 1\n                lm = max(lm, height[l])\n            }else{\n                r -= 1\n                rm = max(rm, height[r])\n            }\n            res = max(res, min(lm, rm)*(r-l))\n        }\n        return res\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxArea(vector<int>& nums) {\n        int n=nums.size();        \n        int ans=0;\n        int i=0, j=n-1;\n        while(i<=j){\n            ans=max(ans,min(nums[i],nums[j])*(j-i));\n            if(nums[i]>=nums[j])j--;\n            else i++;\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n  public int maxArea(int[] height) {\n    int ans = 0;\n    int l = 0;\n    int r = height.length - 1;\n\n    while (l < r) {\n      final int minHeight = Math.min(height[l], height[r]);\n      ans = Math.max(ans, minHeight * (r - l));\n      if (height[l] < height[r])\n        ++l;\n      else\n        --r;\n    }\n\n    return ans;\n  }\n}"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxArea(self, height):\n        i, j = 0, len(height) - 1\n        water = 0\n        while i < j:\n            water = max(water, (j - i) * min(height[i], height[j]))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return water"
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "javascript",
                "code": "    `[3....<10 sticks>....5]` water between 3, 5 = 3*11 = 33.\n    "
            },
            {
                "language": "dart",
                "code": ""
            },
            {
                "language": "rust",
                "code": ""
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int maxArea(int[] heights) {\n        int maxArea = 0;\n        \n        int left = 0;\n        int right = heights.length - 1;\n        \n        int maxHeight = 0;"
            },
            {
                "language": "python",
                "code": "        l = 0\n        r = len(height) - 1\n        max_area = 0\n        \n        while l < r:\n            if height[l] >= height[r]:\n                max_area = max(max_area,height[r]*(r-l))\n                r -= 1"
            },
            {
                "language": "python",
                "code": "class Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int i = 0;\n        int j = height.size() - 1;\n        int V = min(height[i], height[j]) * (j-i);\n\n        while(i!=j){\n            if(height[i]<height[j]){\n                i++;\n                if(height[i]>height[i-1] && i!=j){\n                    V = max(V , min(height[i], height[j]) * (j-i));\n                }\n            }\n            else{\n                j--;\n                if(height[j]>height[j+1] && i!=j){\n                    V = max(V , min(height[i], height[j]) * (j-i));\n                }\n            }\n        }\n        return V;\n    }\n};"
            },
            {
                "language": "",
                "code": "  1 2 3 4 5 6\n1 x ------- o\n2 x x\n3 x x x \n4 x x x x\n5 x x x x x\n6 x x x x x x"
            },
            {
                "language": "",
                "code": "  1 2 3 4 5 6\n1 x ------- o\n2 x x       o\n3 x x x     |\n4 x x x x   |\n5 x x x x x |\n6 x x x x x x"
            },
            {
                "language": "",
                "code": "  1 2 3 4 5 6\n1 x ------- o\n2 x x - o o o\n3 x x x o | |\n4 x x x x | |\n5 x x x x x |\n6 x x x x x x"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        MAX = 0 \n        x = len(height) - 1"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n        public:\n            int maxArea(vector<int>& height) {\n                int maxArea = 0;\n                int i = 0, j = height.size() - 1;\n                while(i < j)\n                {\n                    maxArea = max(maxArea, min(height[i], height[j]) * (j - i));\n                    if(height[i] < height[j])"
            }
        ]
    },
    "11": {
        "question_id": 12,
        "title": "Integer to Roman",
        "difficulty": 2,
        "description": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.Symbol       ValueI             1V             5X             10L             50C             100D             500M             1000For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.Given an integer, convert it to a roman numeral. ",
        "examples": [
            {
                "input": "num = 3",
                "output": "\"III\"",
                "explanation": "3 is represented as 3 ones."
            },
            {
                "input": "num = 58",
                "output": "\"LVIII\"",
                "explanation": "L = 50, V = 5, III = 3."
            },
            {
                "input": "num = 1994",
                "output": "\"MCMXCIV\"",
                "explanation": "M = 1000, CM = 900, XC = 90 and IV = 4."
            }
        ],
        "constraints": [
            "1 <= num <= 3999"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "//Approach 1 : \n//time complexity - O(1) since the algorithm always iterates through a constant number of values (13 in this case).\n//O(1) since the amount of extra space used is constant (the size of the storeIntRoman vector, which is also 13 in this case\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        string Roman = \"\";\n        // Creating vector of pairs to store the Roman numeral values and their corresponding symbols\n        vector<pair<int, string>> storeIntRoman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\n        // Iterating through the vector and repeatedly adds the corresponding symbols to the result string while subtracting the corresponding value from the input integer until the input integer becomes zero.\n        for (int i = 0; i < storeIntRoman.size(); i++) {\n            while (num >= storeIntRoman[i].first) {\n                Roman += storeIntRoman[i].second;\n                num -= storeIntRoman[i].first;\n            }\n        }\n        return Roman;\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string intToRoman(int num) {\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\n        \n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\n    }\n};"
            },
            {
                "language": "java",
                "code": "char symbol[] = {'I','V','X','L','C','D','M'};\nclass Solution {\npublic:    \n    int MSB(int n){\n        int ans=0;\n        while(n>0){\n            n = n/10;\n            ans++;\n        }\n        return ans-1;\n    }\n    \n    string roman(int n, int index){\n        string ans = \"\";\n        if(n==9){\n            ans = symbol[2*index];\n            ans += symbol[2*index+2];\n        }\n        else if(n>=5){\n            ans = symbol[2*index+1];\n            for(int i=6; i<=n; i++)\n                ans += symbol[2*index];\n        }\n        else if(n==4){\n            ans = symbol[2*index];\n            ans += symbol[2*index+1];\n        }\n        else {\n            for(int i=1; i<=n; i++)\n                ans += symbol[2*index];\n        }\n        return ans;\n    }\n    \n    string intToRoman(int num) {\n        int msb = MSB(num);\n        string ans = \"\";\n        for(int i=0; i<=msb; i++){\n            int divisor = pow(10,msb-i);\n            int q = num/divisor;\n            num = num%divisor;\n            ans += roman(q,msb-i);\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {number} num\n * @return {string}\n */\nconst map = {\n  1: 'I',\n  2: 'II',\n  3: 'III',\n  4: 'IV',\n  5: 'V',\n  6: 'VI',\n  7: 'VII',\n  8: 'VIII',\n  9: 'IX',\n  10: 'X',\n  40: 'XL',\n  50: 'L',\n  90: 'XC',\n  100: 'C',\n  400: 'CD',\n  500: 'D',\n  900: 'CM',\n  1000: 'M',\n};\n\nvar intToRoman = function(num) {\n    const length = `${num}`.length;\n    let res = [];\n\n    const calcChars = (num, zeros) => {\n      const count = Math.floor(num / Number(`1${zeros}`));\n      if (count < 4) {\n        for (let i = 0; i < count; i++) {\n          res.push(map[Number(`1${zeros}`)])\n        }\n      } else if (count === 4) {\n        res.push(map[Number(`4${zeros}`)])\n      } else if (count === 5) {\n        res.push(map[Number(`5${zeros}`)])\n      }\n      else if (count > 5 && count < 9) {\n        res.push(map[Number(`5${zeros}`)])\n        for (let i = 0; i < count - 5; i++) {\n          res.push(map[Number(`1${zeros}`)])\n        }\n      } else if (count === 9) {\n        res.push(map[Number(`9${zeros}`)])\n      }\n      return count;\n    }\n\n    const getDigits = (num) => {\n      calcChars(num, '')\n      return res.join('');\n    }\n\n    const getDozens = (num) => {\n      const count = calcChars(num, '0')\n      return getDigits(num - count * 10);\n    }\n\n    const getHundreds = (num) => {\n      const count = calcChars(num, '00')\n      return getDozens(num - count * 100);\n    }\n    \n    const getThousands = (num) => {\n      const count = Math.floor(num / 1000);\n      for (let i = 0; i < count; i++) {\n        res.push(map[1000])\n      }\n      return getHundreds(num - count * 1000);\n    }\n\n    switch(length) {\n      case 4: {\n        return getThousands(num);\n      }\n      case 3: {\n        return getHundreds(num);\n      }\n      case 2: {\n        return getDozens(num);\n      }\n      case 1: {\n        return getDigits(num);\n      }\n      default: {\n        return false;\n      }\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int getid(vector<pair<int,string>>&v,int k){\n        int st = 0,ed = v.size()-1;\n        while(st<=ed){\n            int mid = (st+ed)/2;\n            if(v[mid].first==k)\n                return mid;\n            else if(v[mid].first<k)\n                st = mid + 1;\n            else\n                ed = mid - 1;\n        }\n        return ed;\n    }\n\n    string intToRoman(int num) {\n        vector<pair<int,string>>v{{1, \"I\"}\n        ,{4, \"IV\"}\n        ,{5, \"V\"}\n        ,{9, \"IX\"}\n        ,{10, \"X\"}\n        ,{40, \"XL\"}\n        ,{50, \"L\"}\n        ,{90, \"XC\"}\n        ,{100, \"C\"}\n        ,{400, \"CD\"}\n        ,{500, \"D\"}\n        ,{900, \"CM\"}\n        ,{1000, \"M\"}};\n        \n        string ans = \"\";\n        while(num){\n            int id = getid(v,num);\n            ans += v[id].second;\n            num -= v[id].first;\n        }\n\n        return ans;\n    }\n};"
            },
            {
                "language": "dart",
                "code": "class Solution {\npublic:\n    string intToRoman(int num) {\n        int o=num%10;\n        int t=(num%100) - o;\n        int h=(num%1000) - t-o;\n        int th=num-h-t-o;\n        string ans=\"\";\n        if(th>0)\n        {\n            while(th>0)\n            {\n                ans+=\"M\";\n                th=th-1000;\n            }\n        }\n        if(h>0)\n        {\n            if(h==400)\n            {\n                ans+=\"CD\";\n                h=0;\n            }\n            else if(h==900)\n            {\n                ans+=\"CM\";\n                h=0;\n            }\n            else if(h>=500)\n            {\n                ans+=\"D\";\n                h=h-500;\n            }\n            while(h>0)\n            {\n                ans+=\"C\";\n                h=h-100;\n            }\n            \n        }\n        if(t>0)\n        {\n            if(t==40)\n            {\n                ans+=\"XL\";\n                t=0;\n            }\n            else if(t==90)\n            {\n                ans+=\"XC\";\n                t=0;\n            }\n            else if(t>=50)\n            {\n                ans+=\"L\";\n                t=t-50;\n            }\n            while(t>0)\n            {\n                ans+=\"X\";\n                t=t-10;\n            }\n        }\n        if(o>0)\n        {\n            if(o==4)\n            {\n                ans+=\"IV\";\n                o=0;\n            }\n            else if(o==9)\n            {\n                ans+=\"IX\";\n                o=0;\n            }\n            else if(o>=5)\n            {\n                ans+=\"V\";\n                o=o-5;\n            }\n            while(o>0)\n            {\n                ans+=\"I\";\n                o=o-1;\n            }\n        }\n        return ans;\n            \n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    unordered_map<int,string> up;\n    string intToRoman(int num) {\n        \n        up[5]    =\"V\";\n        up[10]   =\"X\";\n        up[50]   =\"L\";\n        up[100]  =\"C\";\n        up[500]  =\"D\";\n        up[1000] =\"M\";\n        \n        return comp(num);\n    }\n    \n    string comp(int num){\n        if(num == 0)\n            return \"\";\n        if(num == 1){\n            return \"I\";\n        }\n        if(num == 2)\n            return \"II\";\n        if(num == 3){\n            return \"III\";\n        }\n        if(num == 4){\n            return \"IV\";\n        }\n        if(num == 9){\n            return \"IX\";\n        }\n        if(num >= 40 && num < 50){\n            return \"XL\"+comp(num-40);\n            \n        }\n        if(num >= 90 && num < 100){\n            return \"XC\" + comp(num - 90);\n        }\n        if(num >= 400 && num < 500){\n            return \"CD\" + comp(num - 400);\n        }\n        if(num >= 900 && num < 1000){\n            return \"CM\" + comp(num - 900);\n        }\n        \n        int arr[] = {5,10,50,100,500,1000};\n        int i = 0;\n        for( ; i <= 5 ; i++){\n             if(arr[i] > num)\n                 break;\n        }\n        \n        int val = arr[i-1];\n        return up[val] + comp(num-val);\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string intToRoman(int num) {\n        string roman = \"\";\n        int vals[] = {1, 5, 10, 50, 100, 500, 1000};\n        string symbols = \"IVXLCDM\";\n        unordered_map<int, char> mp;\n        for (int i = 0; i < 7; i++) mp[vals[i]] = symbols[i];\n        for (int i = 1000; i >= 1; i = i/10) {\n            int cnt = num/i;\n            num = num % i;\n            if (cnt == 4) {\n                roman += mp[i];\n                roman += mp[i*5];\n                cnt = 0;\n            } else if (cnt == 9) {\n                roman += mp[i];\n                roman += mp[10*i];\n                cnt = 0;\n            } else if (cnt >= 5) {\n                roman += mp[i*5];\n                cnt -= 5;\n            }\n            for (int j = 0; j < cnt; j++) roman+=mp[i];\n        }\n        return roman;\n    }\n};"
            },
            {
                "language": "dart",
                "code": "public static String intToRoman(int num) {\n    String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\n    String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\n    String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\n    String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\n    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];\n}"
            },
            {
                "language": "dart",
                "code": "class Solution {\n    public:\n        string intToRoman(int num) {\n            static const string s[4][10]= \n            { \n                {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"},\n                {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"},\n                {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"},"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string intToRoman(int num) {\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\n        \n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "    while(num){\n        s.push((num%10)*power);\n        power*=10;\n        num/=10;"
            },
            {
                "language": "dart",
                "code": "    public String intToRoman(int num) {\n        int value[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n        String symbol[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\n        StringBuilder sb = new StringBuilder();\n        while(num>0){\n            for(int i=0;i<value.length;i++){\n                if(num>=value[i]){"
            }
        ]
    },
    "12": {
        "question_id": 13,
        "title": "Roman to Integer",
        "difficulty": 1,
        "description": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.Symbol       ValueI             1V             5X             10L             50C             100D             500M             1000For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer. ",
        "examples": [
            {
                "input": "s = \"III\"",
                "output": "3",
                "explanation": "III = 3."
            },
            {
                "input": "s = \"LVIII\"",
                "output": "58",
                "explanation": "L = 50, V= 5, III = 3."
            },
            {
                "input": "s = \"MCMXCIV\"",
                "output": "1994",
                "explanation": "M = 1000, CM = 900, XC = 90 and IV = 4."
            }
        ],
        "constraints": [
            "1 <= s.length <= 15",
            "s contains only\u00a0the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').",
            "It is guaranteed\u00a0that s is a valid roman numeral in the range [1, 3999]."
        ],
        "solutions": [
            {
                "language": "dart",
                "code": " public int romanToInt(String s) {\n         int ans = 0, num = 0;\n        for (int i = s.length()-1; i >= 0; i--) {\n            switch(s.charAt(i)) {\n                case 'I': num = 1; break;\n                case 'V': num = 5; break;\n                case 'X': num = 10; break;\n                case 'L': num = 50; break;\n                case 'C': num = 100; break;\n                case 'D': num = 500; break;\n                case 'M': num = 1000; break;\n            }\n            if (4 * num < ans) ans -= num;\n            else ans += num;\n        }\n        return ans;\n    }"
            },
            {
                "language": "typescript",
                "code": "public int romanToInt(String s) {\n    \n    int answer = 0, number = 0, prev = 0;\n\n    for (int j = s.length() - 1; j >= 0; j--) {\n        switch (s.charAt(j)) {\n            case 'M' -> number = 1000;"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int romanToInt(string s) {\n        int ans=0;\n        unordered_map <char,int> mp{\n        {'I',1},{'V',5},{'X',10},{'L',50},{'C',100},{'D',500},{'M',1000}};\n\n    for(int i=0;i<s.size();i++){\n        if(mp[s[i]]<mp[s[i+1]]){\n            //for cases such as IV,CM, XL, etc...\n            ans=ans-mp[s[i]];\n        }\n        else{\n            ans=ans+mp[s[i]];\n        }\n    }\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "if (const auto& iter = mp.find('\\0'); iter != mp.end()) {\n    std::cout << \"Contains null-terminator: \" << mp.at('\\0') << std::endl;\n}"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    private readonly Dictionary<char, int> dict = new Dictionary<char, int>{{'I',1},{'V',5},{'X',10},{'L',50},{'C',100},{'D',500},{'M',1000}};\n    \n    public int RomanToInt(string s) {\n   \n        char[] ch = s.ToCharArray();\n    \n        int result = 0;\n        int intVal,nextIntVal;\n            \n        for(int i = 0; i <ch.Length ; i++){\n            intVal = dict[ch[i]];\n            \n            if(i != ch.Length-1)\n            {\n                nextIntVal = dict[ch[i+1]];\n                \n                if(nextIntVal>intVal){\n                    intVal = nextIntVal-intVal;\n                    i = i+1;\n                }\n            }\n             result = result + intVal;\n        }\n        return result;\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    private readonly Dictionary<char, int> dict = \nnew Dictionary<char, int>{{'I',1},{'V',5},{'X',10},{'L',50},{'C',100},{'D',500},{'M',1000}};\n    \n    public int RomanToInt(string s) {\n        \n        //special situations\n        s = s.Replace(\"IV\",\"IIII\");\n        s = s.Replace(\"IX\",\"VIIII\");\n        s = s.Replace(\"XL\",\"XXXX\");\n        s = s.Replace(\"XC\",\"LXXXX\");\n        s = s.Replace(\"CD\",\"CCCC\");\n        s = s.Replace(\"CM\",\"DCCCC\");\n        \n        int result = 0;\n        \n        foreach(var ch in s)\n        {\n            result += dict[ch];\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int romanToInt(String s) {\n        Map<Character, Integer> map = new HashMap<Character, Integer>() {{\n        \n            put('I',1);\n            put('V',5);\n            put('X',10);\n            put('L',50);\n            put('C',100);\n            put('D',500);\n            put('M',1000);\n            \n        }};\n        \n        char[] arr = s.toCharArray();\n        \n        int result = 0;\n        int intVal,nextIntVal;\n            \n        for(int i = 0; i <arr.length ; i++){\n            intVal = map.get(arr[i]);\n            \n            if(i != arr.length-1)\n            {\n                nextIntVal = map.get(arr[i+1]);\n                \n                if(nextIntVal>intVal){\n                    intVal = nextIntVal-intVal;\n                    i = i+1;\n                }\n            }\n             result = result + intVal;\n        }\n        return result;\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int romanToInt(String s) {\n        Map<Character, Integer> map = new HashMap<Character, Integer>() {{\n        \n            put('I',1);\n            put('V',5);\n            put('X',10);\n            put('L',50);\n            put('C',100);\n            put('D',500);\n            put('M',1000);\n            \n        }};\n        \n        //special situations  \n        s = s.replace(\"IV\",\"IIII\");\n        s = s.replace(\"IX\",\"VIIII\");\n        s = s.replace(\"XL\",\"XXXX\");\n        s = s.replace(\"XC\",\"LXXXX\");\n        s = s.replace(\"CD\",\"CCCC\");\n        s = s.replace(\"CM\",\"DCCCC\");\n        \n        \n        int result = 0;\n        for (char ch: s.toCharArray()) {\n            result+= map.get(ch);\n        }\n        \n        return result;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\nint romanToInt(string s) {\n    unordered_map<char,int> mp{\n        {'I',1},\n        {'V',5},\n        {'X',10},\n        {'L',50},\n        {'C',100},\n        {'D',500},\n        {'M',1000},\n    };\n    int ans =0;\n    for(int i=0;i<s.size();i++){\n        if(mp[s[i]]<mp[s[i+1]])\n            ans-=mp[s[i]];\n        else\n            ans+=mp[s[i]];\n    }\n    return ans;\n    \n}\n};"
            },
            {
                "language": "lisp",
                "code": "    int ans=0;\n    for(int i=s.length();i>=0;i--)\n        ((i+1)<s.length() and m1[s[i]]<m1[s[i+1]])?ans-=m1[s[i]]:ans+=m1[s[i]];\n    "
            },
            {
                "language": "",
                "code": ""
            },
            {
                "language": "go",
                "code": "/*\n\n    Time Complexity : O(1), The maximum length of the string(s) can be 15 (as per the Constgraint), therefore, the\n    worst case time complexity can be O(15) or O(1).\n\n    Space Complexity : O(1), We are using unordered_map(map) to store the Roman symbols and their corresponding\n    integer values but there are only 7 symbols hence the worst case space complexity can be O(7) which is\n    equivalent to O(1).\n\n    Solved using String + Hash Table + Math.\n\n*/\n\nclass Solution {\npublic:\n    int romanToInt(string s) {\n        unordered_map<char, int> map;\n\n        map['I'] = 1;\n        map['V'] = 5;\n        map['X'] = 10;\n        map['L'] = 50;\n        map['C'] = 100;\n        map['D'] = 500;\n        map['M'] = 1000;\n        \n        int ans = 0;\n        \n        for(int i=0; i<s.length(); i++){\n            if(map[s[i]] < map[s[i+1]]){\n                ans -= map[s[i]];\n            }\n            else{\n                ans += map[s[i]];\n            }\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        roman_to_integer = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000,\n        }\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\").replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\").replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\n        return sum(map(lambda x: roman_to_integer[x], s))"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def romanToInt(self, s: str) -> int:\n    \n        # rti is a dict for roman to intgers values\n        rti = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000}\n\n        # ans is for our sum value\n        ans=0"
            },
            {
                "language": "csharp",
                "code": "def romanToInt(s: str) -> int:\n        conversion = {\n            'I':1,\n            'V':5,\n            'X':10,\n            'L':50,\n            'C':100,\n            'D':500,\n).replace('CD','CCCC').replace('CM','DCCCC')"
            },
            {
                "language": "rust",
                "code": "def romanToInt(self, s: str) -> int:\n    roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000, \"k\": 0}\n    tmp = s + \"k\"\n    res = idx = 0\n\n    while idx != len(s):"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        translations = {\n            \"I\": 1,\n            \"V\": 5,\n            \"X\": 10,\n            \"L\": 50,\n            \"C\": 100,\n            \"D\": 500,\n            \"M\": 1000\n        }\n        number = 0\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\")\n        s = s.replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\")\n        s = s.replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\n        for char in s:\n            number += translations[char]\n        return number"
            },
            {
                "language": "typescript",
                "code": "    result_number = 0 \n    prevous_number = 0\n    mapping = {'I':1, \n            'V':5, "
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        roman_to_integer = {'I': 1,\n                            'V': 5,\n                            'X': 10,\n                            'L': 50,\n                            'C': 100,\n                            'D': 500,"
            },
            {
                "language": "kotlin",
                "code": "return sum(map(data.get, s))"
            },
            {
                "language": "typescript",
                "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar romanToInt = function(s) {\nlet obj={\n'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000,\n}  \nlet num=0;\nfor(let i=0;i<s.length;i++){\n    let current= obj[s[i]];\n    let next= obj[s[i+1]]\n<!-- if the next number is bigger then first thats mean he is a number-1 for example \"IV\" 1-5=4 -->\nif(current<next){\n    num-=current\n}else num+=current\n}\nreturn num\n};\n\n \n   "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int romanToInt(string s) {\n        int cnt=0;\n        map<char, int>m;\n        m['I']=1;\n        m['V']=5;\n        m['X']=10;\n        m['L']=50;\n        m['C']=100;\n        m['D']=500;\n        m['M']=1000;\n        for(int i=0; i<s.size(); i++){\n            if(i!=s.size()-1){\n                if(m[s[i]]<m[s[i+1]]){\n                    cnt-=m[s[i]];\n                }\n                else{\n                    cnt+=m[s[i]];\n                }\n            }\n            else{\n                cnt+=m[s[i]];\n            }\n        }\n        return cnt;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int romanToInt(String s) {\n        int sum = 0, pre = 0;\n        char ch = 0;\n        for(int i = 0; i < s.length(); i++){\n            pre = ch;\n            ch = s.charAt(i);\n            switch(ch){\n                case 'I':\n                    sum++;\n                    break;\n                case 'V':\n                    if(pre == 'I')\n                     sum = sum + 3;\n                    else\n                     sum = sum + 5;\n                    break;\n                case 'X':\n                    if(pre == 'I')\n                     sum = sum + 8;\n                    else\n                     sum = sum + 10;\n                    break;\n                case 'L':\n                    if(pre == 'V')\n                     sum = sum + 40;\n                    if(pre == 'X')\n                     sum = sum + 30;\n                    else\n                    sum = sum + 50;\n                    break;\n                case 'C':\n                    if(pre == 'I')\n                     sum = sum + 98;\n                    if(pre == 'V')\n                     sum = sum + 90;\n                    if(pre == 'X')\n                     sum = sum + 80;\n                    else\n                    sum = sum + 100;\n                    break;\n                case 'D':\n                    if(pre == 'V')\n                     sum = sum + 490;\n                    if(pre == 'X')\n                     sum = sum + 480;\n                    if(pre == 'L')\n                     sum = sum + 400;\n                    if(pre == 'C')\n                     sum = sum + 300;\n                    else\n                    sum = sum + 500;\n                    break;\n                case 'M':\n                    if(pre == 'I')\n                     sum = sum + 998;\n                    if(pre == 'V')\n                     sum = sum + 990;\n                    if(pre == 'X')\n                     sum = sum + 980;\n                    if(pre == 'L')\n                     sum = sum + 900;\n                    if(pre == 'C')\n                     sum = sum + 800;\n                    else\n                    sum  = sum + 1000;\n                    break;\n             }\n        }\n        return sum;\n     }\n}\n\n//public int romanToInt(String s) {\n    //     if (s == null || s.length() == 0) {\n    //         return 0;\n    //     }\n    //     int sum = 0;\n    //     char ch = 0;\n    //     char pre = 0;\n    //     for(int i = 0, len = s.length(); i < len; i ++) {\n    //         pre = ch;\n    //         ch = s.charAt(i);\n    //         switch (ch) {\n    //             case 'I':\n    //                 sum ++;\n    //                 break;\n    //             case 'V':\n    //                 if (pre == 'I') {\n    //                     sum += 3;\n    //                 }\n    //                 else {\n    //                     sum += 5;\n    //                 }\n    //                 break;\n    //             case 'X':\n    //                 if (pre == 'I') {\n    //                     sum += 8;\n    //                 }\n    //                 else {\n    //                     sum += 10;\n    //                 }\n    //                 break;\n    //             case 'L':\n    //                 if (pre == 'I') {\n    //                     sum += 48;\n    //                 }\n    //                 else if (pre == 'V') {\n    //                     sum += 40;\n    //                 }\n    //                 else if (pre == 'X') {\n    //                     sum += 30;\n    //                 }\n    //                 else {\n    //                     sum += 50;\n    //                 }\n    //                 break;\n    //             case 'C':\n    //                 if (pre == 'I') {\n    //                     sum += 98;\n    //                 }\n    //                 else if (pre == 'V') {\n    //                     sum += 90;\n    //                 }\n    //                 else if (pre == 'X') {\n    //                     sum += 80;\n    //                 }\n    //                 else {\n    //                     sum += 100;\n    //                 }\n    //                 break;\n    //             case 'D':\n    //                 if (pre == 'I') {\n    //                     sum += 498;\n    //                 }\n    //                 else if (pre == 'V') {\n    //                     sum += 490;\n    //                 }\n    //                 else if (pre == 'X') {\n    //                     sum += 480;\n    //                 }\n    //                 else if (pre == 'C') {\n    //                     sum += 300;\n    //                 }\n    //                 else {\n    //                     sum += 500;\n    //                 }\n    //                 break;\n    //             case 'M':\n    //                 if (pre == 'I') {\n    //                     sum += 998;\n    //                 }\n    //                 else if (pre == 'V') {\n    //                     sum += 990;\n    //                 }\n    //                 else if (pre == 'X') {\n    //                     sum += 980;\n    //                 }\n    //                 else if (pre == 'C') {\n    //                     sum += 800;\n    //                 }\n    //                 else {\n    //                     sum += 1000;\n    //                 }\n    //                 break;\n    //         }\n    //     }\n    //     return sum;\n    // }"
            },
            {
                "language": "cpp",
                "code": " int intNum = 0;\n int pre = 0;\n char ch = 0;"
            }
        ]
    },
    "13": {
        "question_id": 14,
        "title": "Longest Common Prefix",
        "difficulty": 1,
        "description": "Write a function to find the longest common prefix string amongst an array of strings.If there is no common prefix, return an empty string \"\". ",
        "examples": [
            {
                "input": "strs = [\"flower\",\"flow\",\"flight\"]",
                "output": "\"fl\"",
                "explanation": null
            },
            {
                "input": "strs = [\"dog\",\"racecar\",\"car\"]",
                "output": "\"\"",
                "explanation": "There is no common prefix among the input strings."
            }
        ],
        "constraints": [
            "1 <= strs.length <= 200",
            "0 <= strs[i].length <= 200",
            "strs[i] consists of only lowercase English letters."
        ],
        "solutions": [
            {
                "language": "typescript",
                "code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        Arrays.sort(strs);\n        String s1 = strs[0];\n        String s2 = strs[strs.length-1];\n        int idx = 0;\n        while(idx < s1.length() && idx < s2.length()){\n            if(s1.charAt(idx) == s2.charAt(idx)){\n                idx++;\n            } else {\n                break;\n            }\n        }\n        return s1.substring(0, idx);\n    }\n}"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def longestCommonPrefix(self, v: List[str]) -> str:\n        ans=\"\"\n        v=sorted(v)\n        first=v[0]\n        last=v[-1]\n        for i in range(min(len(first),len(last))):\n            if(first[i]!=last[i]):\n                return ans\n            ans+=first[i]\n        return ans "
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& v) {\n        string ans=\"\";\n        sort(v.begin(),v.end());\n        int n=v.size();\n        string first=v[0],last=v[n-1];\n        for(int i=0;i<min(first.size(),last.size());i++){\n            if(first[i]!=last[i]){\n                return ans;\n            }\n            ans+=first[i];\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "python",
                "code": "range(len(v[0])) # beats 79%"
            },
            {
                "language": "python",
                "code": "range(min(len(v[0]),len(v[-1]))) # beats 97%"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        sort(strs.begin(),strs.end());\n        int a=strs.size();\n        string n=strs[0],m=strs[a-1],ans=\"\";\n        for(int i=0;i<n.size();i++){\n            if(n[i]==m[i]){ans+=n[i];}\n            else break;\n        }\n        return ans;\n        \n    }\n};\nDo UPVOTE if you like"
            },
            {
                "language": "go",
                "code": "func longestCommonPrefix(s []string) string {\n pref := s[0]\n for i := 1; i < len(s); i++ {\n  for !strings.HasPrefix(s[i], pref) {\n   pref = pref[:len(pref)-1]\n  }\n  fmt.Println(s[i])\n }\n return pref\n}"
            },
            {
                "language": "swift",
                "code": "class Solution {\npublic:\nstring longestCommonPrefix(vector<string>& strs) {\n    if (strs.size() == 0) {\n        return \"\";\n    }\n    string prefix = strs[0];\n    for (int i = 1; i < strs.size(); i++) {\n        while (strs[i].find(prefix) != 0) {\n            prefix = prefix.substr(0, prefix.length() - 1);\n            if (prefix.empty()) {\n                return \"\";\n            }\n        }\n    }\n    return prefix;\n    \n//    Time Complexity: O(n)\n//    Space Complexity: O(1)\n\n\n\n\n\n\n\n}\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& s) {\n        int ans = s[0].length(), n = s.size();\n        for(int i=1; i<n; i++){\n            int j = 0;\n            while(j<s[i].length() && s[i][j]==s[0][j])j++;\n            ans = min(ans, j);\n        }\n        return s[0].substr(0, ans);\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "string longestCommonPrefix(vector<string>& strs) {\n    string str=\"\";\n    string initial = strs[0];\n    for(int j=0;j<initial.size();j++)\n    {\n        int i=1;\n        for(;i<strs.size();i++)"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public String miniLength(String[] strs) {\n        String min = strs[0];\n        int index = 0;\n        for (int i = 1; i < strs.length; i++) {\n            if (strs[i].length() < min.length()) {\n                min = strs[i];\n                index = i;\n            }\n        }\n        String temp = strs[0];\n        strs[0] = min;\n        strs[index] = temp;\n        return min;\n    }\n    public String longestCommonPrefix(String[] strs) {\n        if (strs == null || strs.length == 0)\n            return \"\";\n        String prefix = miniLength(strs);\n        for (int i = 1; i < strs.length; i++) {\n            while (!strs[i].startsWith(prefix)) {\n                prefix = prefix.substring(0 , prefix.length() - 1);\n                if (prefix.isEmpty())\n                    return \"\";\n            }\n        }\n        return prefix;\n    }\n}"
            },
            {
                "language": "go",
                "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n       string ans=\"\";\n        vector<int>len;     //To store the length of every string present in the vector;\n        int row=strs.size();  //size of row;\n        for(int i=0;i<rows;i++)\n        {\n             len.emplace_back(strs[i].length()); \n        }\n        sort(len.begin(),len.end());  //Sort the len vector to find the minimum size;\n        int col=len[0];   //Store the minimum size in column ;\n        bool flag=true;\n        for(int i=0;i<col;i++)\n        { //column wise traversal\n            for(int j=1;j<row;j++)\n            {\n                //Check every element in the column if it is equal to its next element or not\n            \n                if(strs[j-1][i]!=strs[j][i]){  \n                    //If elements are not equal then make flag = false and break the loop   \n                    flag=false;\n                    break;\n                }\n            }\n            if(flag==true) \n             count++; //This will store the numbers of column which are equal\n        }\n\n         ans=strs[0].substr(0,count); //take the substring(of size equal to count) from any string present in strs vector;\n        return ans;\n\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def longestCommonPrefix(self, strs):\n        if len(strs) == 0:\n            return \"\"\n\n        base = strs[0]\n        for i in range(len(base)):\n            for word in strs[1:]:\n                if (i == len(word) or \n                    word[i] != base[i]):\n                    return base[0:i]\n\n        return base\n  "
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        res = \"\"\n        for a in zip(*strs):\n            if len(set(a)) == 1: \n                res += a[0]\n            else: \n                return res\n        return res\n                        "
            }
        ]
    },
    "14": {
        "question_id": 15,
        "title": "3Sum",
        "difficulty": 2,
        "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.Notice that the solution set must not contain duplicate triplets. ",
        "examples": [
            {
                "input": "nums = [-1,0,1,2,-1,-4]",
                "output": "[[-1,-1,2],[-1,0,1]]",
                "explanation": "\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter."
            },
            {
                "input": "nums = [0,1,1]",
                "output": "[]",
                "explanation": "The only possible triplet does not sum up to 0."
            },
            {
                "input": "nums = [0,0,0]",
                "output": "[[0,0,0]]",
                "explanation": "The only possible triplet sums up to 0."
            }
        ],
        "constraints": [
            "3 <= nums.length <= 3000",
            "-105 <= nums[i] <= 105"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "//Optimized Approach - O(n^2 + nlogn) - o(n^2) time and O(n) space\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int target = 0;\n        sort(nums.begin(), nums.end());\n        set<vector<int>> s;\n        vector<vector<int>> output;\n        for (int i = 0; i < nums.size(); i++){\n            int j = i + 1;\n            int k = nums.size() - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == target) {\n                    s.insert({nums[i], nums[j], nums[k]});\n                    j++;\n                    k--;\n                } else if (sum < target) {\n                    j++;\n                } else {\n                    k--;\n                }\n            }\n        }\n        for(auto triplets : s)\n            output.push_back(triplets);\n        return output;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N^3), Here three nested loop creates the time complexity. Where N is the size of the\n    array(nums).\n\n    Space Complexity : O(N), Hash Table(set) space.\n\n    Solved using Array(Three Nested Loop) + Sorting + Hash Table(set). Brute Force Approach.\n\n    Note : this will give TLE.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        set<vector<int>> set;\n        vector<vector<int>> output;\n        for(int i=0; i<n-2; i++){\n            for(int j=i+1; j<n-1; j++){\n                for(int k=j+1; k<n; k++){\n                    if((nums[i] + nums[j] + nums[k] == 0) && i != j && j != k && k != i){\n                        set.insert({nums[i], nums[j], nums[k]});\n                    }\n                }\n            }\n        }\n        for(auto it : set){\n            output.push_back(it);\n        }\n        return output;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^2), Here Two nested loop creates the time complexity. Where N is the size of the\n    array(nums).\n\n    Space Complexity : O(N), Hash Table(set) space.\n\n    Solved using Array(Two Nested Loop) + Sorting + Hash Table(set).\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        set<vector<int>> set;\n        vector<vector<int>> output;\n        for(int i=0; i<n-2; i++){\n            int low = i+1, high = n-1;\n            while(low < high){\n                if(nums[i] + nums[low] + nums[high] < 0){\n                    low++;\n                }\n                else if(nums[i] + nums[low] + nums[high] > 0){\n                    high--;\n                }\n                else{\n                    set.insert({nums[i], nums[low], nums[high]});\n                    low++;\n                    high--;\n                }\n            }\n        }\n        for(auto it : set){\n            output.push_back(it);\n        }\n        return output;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^2), Here Two nested loop creates the time complexity. Where N is the size of the\n    array(nums).\n\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the Vector(output), however the\n    output does not count towards the space complexity.\n\n    Solved using Array(Two Nested Loop) + Sorting. Optimized Approach.\n\n*/\n\n\n/***************************************** Approach 3 *****************************************/\n\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> output;\n        for(int i=0; i<n-1; i++){\n            int low = i+1, high = n-1;\n            while(low < high){\n                if(nums[i] + nums[low] + nums[high] < 0){\n                    low++;\n                }\n                else if(nums[i] + nums[low] + nums[high] > 0){\n                    high--;\n                }\n                else{\n                    output.push_back({nums[i], nums[low], nums[high]});\n                    int tempIndex1 = low, tempIndex2 = high;\n                    while(low < high && nums[low] == nums[tempIndex1]) low++;\n                    while(low < high && nums[high] == nums[tempIndex2]) high--;\n                }\n            }\n            while(i+1 < n && nums[i] == nums[i+1]) i++;\n        }\n        return output;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        sort(nums.begin() , nums.end());    //Sorted Array\n        if(nums.size() < 3){    //Base case 1\n            return {};\n        }\n        if(nums[0] > 0){        //Base case 2\n            return {};\n        }\n        vector<vector<int>> answer;\n        for(int i = 0 ; i < nums.size() ; ++i){     //Traversing the array to fix the number.\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can't make it zero by searching after it.\n                break;\n            }\n            if(i > 0 && nums[i] == nums[i - 1]){    //If number is getting repeated, ignore the lower loop and continue.\n                continue;\n            }\n            int low = i + 1 , high = nums.size() - 1;   //Make two pointers high and low, and initialize sum as 0.\n            int sum = 0;\n            while(low < high){                          //Search between two pointers, just similiar to binary search.\n                sum = nums[i] + nums[low] + nums[high];\n                if(sum > 0){   //If sum is +ve, means, we need more -ve numbers to make it 0, decreament high (high--).\n                    high--;\n                } else if(sum < 0){ //If sum is -ve, means, we need more +ve numbers to make it 0, increament low (low++).\n                    low++;\n                } else {\n                    answer.push_back({nums[i] , nums[low] , nums[high]});  //we have found the required triplet, push it in answer vector\n                    int last_low_occurence = nums[low] , last_high_occurence = nums[high];  //Now again, to avoid duplicate triplets, we have to navigate to last occurences of num[low] and num[high] respectively\n                    while(low < high && nums[low] == last_low_occurence){   // Update the low and high with last occurences of low and high.\n                        low++;\n                    }\n                    while(low < high && nums[high] == last_high_occurence){\n                        high--;\n                    }\n                }\n            }\n        }\n        return answer;      //Return the answer vector.\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        sort(nums.begin() , nums.end());     //Sorted Array\n        if(nums.size() < 3){                // Base Case 1\n            return {};\n        }\n        if(nums[0] > 0){                    // Base Case 2\n            return {};\n        }\n        unordered_map<int , int> hashMap;\n        for(int i = 0 ; i < nums.size() ; ++i){     //Hashing of Indices\n            hashMap[nums[i]] = i;\n        }\n        vector<vector<int>> answer;\n        for(int i = 0 ; i < nums.size() - 2 ; ++i){     //Traversing the array to fix the number.\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can't make it zero by searching after it.\n                break;\n            }\n            for(int j = i + 1 ; j < nums.size() - 1 ; ++j){     //Fixing another number after first number\n                int required = -1*(nums[i] + nums[j]);    //To make sum 0, we would require the -ve sum of both fixed numbers.\n                if(hashMap.count(required) && hashMap.find(required)->second > j){ //If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet.\n                    answer.push_back({nums[i] , nums[j] , required});\n                }\n                j = hashMap.find(nums[j])->second; //Update j to last occurence of 2nd fixed number to avoid duplicate triplets.\n            }\n            i = hashMap.find(nums[i])->second;     //Update i to last occurence of 1st fixed number to avoid duplicate triplets.\n        }\n        return answer;  //Return answer vector.\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n public:\n vector<vector<int>> threeSum(vector<int>& nums) {\n    vector<vector<int>> ans;\n    unordered_map<int, int> m;\n    sort(nums.begin(), nums.end());    \n    \n    int n = nums.size();"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        std::sort(nums.begin(), nums.end());\n        int i = 0;\n        std::vector<std::vector<int>> res;\n        while (i < nums.size()) {\n            // Fix an initial number and do two sum on the remainder/\n            // of the sorted array to find the sum to this number.\n            int target = 0 - nums[i];\n            \n            // Get a list of pairs of indices whose values sum to |target|.\n            // Note that the beginning of the array should start at |i + 1| since\n            // we want to avoid picking duplicates.\n            auto pair_sums_to_target = twoSum(nums, i + 1, nums.size() - 1, target);\n            for (const auto [index1, index2] : pair_sums_to_target) {\n                res.push_back({nums[i], nums[index1], nums[index2]});\n            }\n\n            // Skip over duplicate consecutive numbers for the fixed number.\n            while (i + 1 < nums.size() && nums[i] == nums[i+1]) {\n                i++;\n            }\n            i++;\n        }\n\n        return res;\n    }\nprivate:\n    vector<pair<int, int>> twoSum(vector<int>& nums, int start, int end, int target) {\n        // Calculates twoSum to |target| on a sorted array |nums| where the numbers \n        // can be selected between indices |start| and |end|.\n        // The key idea behind this two pointer two sum is that when we have a sum\n        // that is greater than the target, the only way we can make it smaller\n        // is to decrease the size of the numbers we are summing, i.e move the\n        // end pointer to the next lowest number. The same applies for making the\n        // sum bigger, if we need the sum to be larger, the only way we can do this\n        // is to move the start number to the next highest number. If after some set\n        // of increments/decrements of the start and end pointers we find that the sum\n        // is equal to |target|, we have found one of our candidate sum pairs.\n        int iter_start = start;\n        int iter_end = end;\n        std::vector<std::pair<int, int>> sum_pairs_to_target;\n        while (iter_start < iter_end) {\n            int sum = nums[iter_start] + nums[iter_end];\n            if (sum < target) {\n                iter_start++;\n            } else if (sum > target) {\n                iter_end--;\n            } else {\n                // Unlike regular twoSum, once we find a pair that sums to |target|,\n                // there may be other pairs that sum to target as well. We can try to see if\n                // any more numbers sum up to |target| between |start| and |end|. \n                // Since the array is sorted, incrementing/decrementing start/end \n                // until they are new numbers guarantees that we won't use the same \n                // set of numbers again.\n                std::pair<int, int> zero_sum_pair = {iter_start, iter_end};\n                sum_pairs_to_target.push_back(zero_sum_pair);\n\n                // Skip over duplicate consecutive numbers from the start iterator side\n                while (iter_start < iter_end && nums[iter_start] == nums[zero_sum_pair.first]) {\n                    iter_start++;\n                }\n                // Skip over duplicate consecutive numbers from the end iterator side\n                while (iter_start < iter_end && nums[iter_end] == nums[zero_sum_pair.second]) {\n                    iter_end--;\n                }\n            }\n        }\n        return sum_pairs_to_target;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int>> ans;\n    sort(nums.begin(), nums.end());\n    // nums[i]+nums[j]+nums[k]=0\n    for (int i = 0; i < nums.size() - 2; ++i)\n    {\n        if (i == 0 || (i > 0 && nums[i] != nums[i - 1]))\n        {\n            int lo = i + 1, hi = nums.size() - 1;\n            int target = -nums[i];\n            while (lo < hi)\n            {\n                if (nums[lo] + nums[hi] == target)\n                {\n                    vector<int> temp;\n                    temp = {nums[i], nums[lo], nums[hi]};\n                    ans.push_back(temp);\n                    while (lo < hi && nums[lo] == nums[lo + 1])\n                    {\n                        lo++;\n                    }\n                    while (lo < hi && nums[hi] == nums[hi - 1])\n                    {\n                        hi--;\n                    }\n                    lo++, hi--;\n                }\n                else if(nums[lo]+nums[hi]<target){\n                    lo++;\n                }\n                else{\n                    hi--;\n                }\n            }\n        }\n    }\n    return ans;\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        Set<List<Integer>> ans=new HashSet<>();\n        for(int i = 0; i < nums.length-2; i++){\n            int p1 = i+1;\n            int p2 = nums.length-1;\n            while(p1 < p2){\n                int sum = nums[i]+nums[p1]+nums[p2];\n                if(sum == 0){\n                    ArrayList<Integer> sp = new ArrayList<>();\n                    sp.add(nums[i]);\n                    sp.add(nums[p1]);\n                    sp.add(nums[p2]);\n                    \n                    ans.add(sp);\n                    p1++;\n                }\n                else if(sum < 0){\n                    p1++;\n                }\n                else{\n                    p2--;\n                }\n            }\n        }\n        return new ArrayList<>(ans);\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& arr) {\n        sort(arr.begin(),arr.end());\n        int n=arr.size();\n        vector<vector<int>>ans;\n        for(int i=0;i<n-1;i++){\n            int j=i+1,k=n-1;\n            // check duplicate 1 here\n            if(i>0 and arr[i]==arr[i-1] )continue;\n            while(j<k){ \n                if(arr[i]+arr[j]+arr[k]==0){\n                    ans.push_back({arr[i],arr[j],arr[k]});\n                    // check duplicate 2 here\n                    while(j<k and arr[j]==arr[j+1])j++;\n                    // check duplicate 3 here\n                    while(j<k and arr[k]==arr[k-1])k--;\n                    j++,k--;\n                }\n                else if((arr[i]+arr[j]+arr[k])<0)j++;\n                else k--;\n            }\n          \n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "php",
                "code": "def threeSum(self, nums: List[int]) -> List[List[int]]:\n\n res = set()\n\n #1. Split nums into three lists: negative numbers, positive numbers, and zeros\n n, p, z = [], [], []\n for num in nums:\n  if num > 0:\n   p.append(num)\n  elif num < 0: \n   n.append(num)\n  else:\n   z.append(num)\n\n #2. Create a separate set for negatives and positives for O(1) look-up times\n N, P = set(n), set(p)\n\n #3. If there is at least 1 zero in the list, add all cases where -num exists in N and num exists in P\n #   i.e. (-3, 0, 3) = 0\n if z:\n  for num in P:\n   if -1*num in N:\n    res.add((-1*num, 0, num))\n\n #3. If there are at least 3 zeros in the list then also include (0, 0, 0) = 0\n if len(z) >= 3:\n  res.add((0,0,0))\n\n #4. For all pairs of negative numbers (-3, -1), check to see if their complement (4)\n #   exists in the positive number set\n for i in range(len(n)):\n  for j in range(i+1,len(n)):\n   target = -1*(n[i]+n[j])\n   if target in P:\n    res.add(tuple(sorted([n[i],n[j],target])))\n\n #5. For all pairs of positive numbers (1, 1), check to see if their complement (-2)\n #   exists in the negative number set\n for i in range(len(p)):\n  for j in range(i+1,len(p)):\n   target = -1*(p[i]+p[j])\n   if target in N:\n    res.add(tuple(sorted([p[i],p[j],target])))\n\n return res"
            },
            {
                "language": "python",
                "code": "    if len(nums) < 3:\n        return []\n\n    res = set()\n\n    # 1. Split nums into three lists: negative numbers, positive numbers, and zeros"
            },
            {
                "language": "java",
                "code": "from collections import defaultdict\n\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        neg = defaultdict(int)\n        pos = defaultdict(int)\n        zeros = 0\n        "
            },
            {
                "language": "lisp",
                "code": "-1*num\n-1*(n[i]+n[j])"
            },
            {
                "language": "lisp",
                "code": "-num\n-(n[i] + n[j])"
            },
            {
                "language": "python",
                "code": ""
            },
            {
                "language": "python",
                "code": ""
            },
            {
                "language": "python",
                "code": "        if len(z) >= 3:\n            result.add(tuple([0,0,0]))\n        \n        if not n or not p:\n            return result\n        \n        sp = set(p)"
            },
            {
                "language": "javascript",
                "code": "function binary_search(arr, target, L = 0, R = arr.length - 1) {\n    while (L < R) {\n        let mid = ~~(L / 2 + R / 2);\n        arr[mid] < target ? (L = mid + 1) : (R = mid);\n    }\n    return L === R && arr[L] === target ? L : -Infinity;\n}\nvar threeSum = function (a) {\n    let n = a.length;\n\n    a.sort((a, b) => a - b);\n\n    let aa = [];\n    let vis = new Set();\n    for (let i = 0; i < n; i++)\n        for (let j = i + 1; j < n; j++) {\n            let sum = a[i] + a[j];\n            let L = binary_search(a, -sum, j + 1, n - 1);\n            if (L !== -Infinity) {\n                let key = `${a[i]} ${a[j]} ${a[L]}`;\n                if (!vis.has(key)) {\n                    vis.add(key);\n                    aa.push([a[i], a[j], a[L]]);\n                }\n            }\n        }\n    return aa;\n};"
            },
            {
                "language": "javascript",
                "code": "function binary_search(arr, target, L = 0, R = arr.length - 1) {\n    while (L < R) {\n        let mid = ~~(L / 2 + R / 2);\n        arr[mid] < target ? (L = mid + 1) : (R = mid);\n    }\n    return L === R && arr[L] === target ? L : -Infinity;\n}\nvar threeSum = function (a) {\n    let n = a.length;\n\n    a.sort((a, b) => a - b);\n\n    let aa = [];\n    for (let i = 0; i < n; i++) {\n        if (i > 0 && a[i - 1] === a[i]) continue;\n\n        for (let L = i + 1; L < n; L++) {\n            if (L > i + 1 && a[L - 1] === a[L]) continue;\n\n            let R = binary_search(a, -(a[i] + a[L]), L + 1, n - 1);\n            if (R !== -Infinity) {\n                aa.push([a[i], a[L], a[R]]);\n            }\n        }\n    }\n    return aa;\n};"
            },
            {
                "language": "javascript",
                "code": "var threeSum = function (a) {\n    let n = a.length;\n\n    a.sort((a, b) => a - b);\n\n    let aa = [];\n    let vis = new Set();\n    for (let i = 0; i < n; i++) {\n        let t = -a[i]; // target;\n        for (let L = i + 1, R = n - 1; L < R; ) {\n            let sum = a[L] + a[R];\n            if (sum === t) {\n                let key = `${a[i]} ${a[L]} ${a[R]}`;\n                if (!vis.has(key)) {\n                    vis.add(key);\n                    aa.push([a[i], a[L], a[R]]);\n                }\n                L++;\n            } else if (sum < t) {\n                L++;\n            } else {\n                R--;\n            }\n        }\n    }\n    return aa;\n};"
            },
            {
                "language": "javascript",
                "code": "var threeSum = function (a) {\n    let n = a.length;\n\n    a.sort((a, b) => a - b);\n\n    let aa = [];\n    for (let i = 0; i < n; i++) {\n        if (i > 0 && a[i - 1] === a[i]) continue;\n\n        let t = -a[i]; // target;\n        for (let L = i + 1, R = n - 1; L < R; ) {\n            if (L > i + 1 && a[L - 1] === a[L]) {\n                L++;\n                continue;\n            }\n\n            let sum = a[L] + a[R];\n            if (sum === t) {\n                aa.push([a[i], a[L], a[R]]);\n                L++;\n            } else if (sum < t) {\n                L++;\n            } else {\n                R--;\n            }\n        }\n    }\n    return aa;\n};"
            },
            {
                "language": "javascript",
                "code": "var threeSum = function (a) {\n    let n = a.length;\n\n    a.sort((a, b) => a - b);\n\n    let aa = [];\n    for (let i = 0; i < n; i++) {\n        // optimization 1\n        if (a[i] > 0) break;\n\n        let t = -a[i]; // target;\n        for (let L = i + 1, R = n - 1; L < R; ) {\n            let sum = a[L] + a[R];\n            if (sum === t) {\n                aa.push([a[i], a[L], a[R]]);\n                // optimization 2\n                while (a[L] === a[L + 1]) L++;\n                L++;\n            } else if (sum < t) {\n                L++;\n            } else {\n                R--;\n            }\n        }\n\n        // optimization 3\n        while (a[i] === a[i + 1]) i++;\n    }\n\n    return aa;\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        set<vector<int>> set;\n        vector<vector<int>> ans;\n        for(int i=0; i<n-2; i++){\n            int l=i+1,r=n-1;\n            while(l<r)\n            {\n                if(nums[i]+nums[l]+nums[r]<0)\n                l++;\n                else if(nums[i]+nums[l]+nums[r]>0)\n                r--;\n                else\n                {\n                    set.insert({nums[i],nums[l],nums[r]});\n                    l++;r--;\n                }\n            }\n        }\n        for(auto it : set){\n            ans.push_back(it);\n        }\n        return ans;\n    }\n};"
            }
        ]
    },
    "15": {
        "question_id": 16,
        "title": "3Sum Closest",
        "difficulty": 2,
        "description": "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.Return the sum of the three integers.You may assume that each input would have exactly one solution. ",
        "examples": [
            {
                "input": "nums = [-1,2,1,-4], target = 1",
                "output": "2",
                "explanation": "The sum that is closest to the target is 2. (-1 + 2 + 1 = 2)."
            },
            {
                "input": "nums = [0,0,0], target = 1",
                "output": "0",
                "explanation": "The sum that is closest to the target is 0. (0 + 0 + 0 = 0)."
            }
        ],
        "constraints": [
            "3 <= nums.length <= 500",
            "-1000 <= nums[i] <= 1000",
            "-104 <= target <= 104"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        ans,cdiff,pdiff=0,0,100000\n        for n,i in enumerate(nums):\n            j,k=n+1,len(nums)-1\n            if(n>0 and i==nums[n-1]): continue\n            while(j<k):\n                    summ=i+nums[j]+nums[k]\n                    cdiff=abs(summ-target)\n                    if pdiff>cdiff:\n                        ans=summ\n                        pdiff=cdiff\n                    if(summ==target): return target\n                    elif(summ<target):  \n                        j+=1\n                    else:\n                        k-=1\n        return ans"
            },
            {
                "language": "csharp",
                "code": "   def threeSumClosest(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        n=len(nums)\n        mn=inf\n        ans=0\n        for i in range(n):\n            s=i+1\n            e=n-1\n            while s<e:\n                sm=nums[i]+nums[s]+nums[e]\n                if sm==target:\n                    return sm\n                if abs(target-sm)<mn:\n                    mn=abs(target-sm)\n                    ans=sm\n                if sm<target:\n                    s+=1\n                else:\n                    e-=1\n       \n        return ans"
            },
            {
                "language": "python",
                "code": "def threeSumClosest(nums, target):\n    nums.sort()\n    closest_sum = float('inf')\n    for i in range(len(nums) - 2):\n        l, r = i + 1, len(nums) - 1\n        while l < r:\n            s = nums[i] + nums[l] + nums[r]\n            if s == target:\n                return target\n2218  "
            },
            {
                "language": "ruby",
                "code": "class Solution:\n   def threeSumClosest(self, nums: List[int], target: int) -> int:\n\n       nums.sort()\n       n=len(nums)\n       diff = inf"
            },
            {
                "language": "csharp",
                "code": "def threeSumClosest(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        closest = inf\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i-1]: # skip the duplicate numbers\n                continue\n            j, k = i + 1, len(nums) - 1"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        \n        nums.sort()\n        \n        \n        result = float('inf')\n        stored_sum = 0\n        \n        for i in range(len(nums) - 2):\n            \n            left = i + 1\n            right = len(nums) - 1\n            \n            while left < right:\n                \n                k = nums[i] + nums[left] + nums[right]\n                \n                if k > target:\n                    right -= 1\n                elif k < target:\n                    left += 1\n                else:\n                    return k\n                \n                if abs(target - k) < result:\n                    result = abs(target - k)\n                    stored_sum = k\n                \n        return stored_sum\n      "
            },
            {
                "language": "python",
                "code": "    temp=sum(nums[:3])\n    if temp>target:\n        return temp\n    temp=sum(nums[-3:])\n    if temp<target:\n        return temp"
            },
            {
                "language": "python",
                "code": "              Add below lines under the condition  if abs(target - k) < result::"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n\n        int closest = nums[0] + nums[1] + nums[2];\n        for (int i = 0; i < n - 2; i++){\n            int l = i + 1;\n            int r = n - 1;\n            while (l < r) {\n                int curSum = nums[i] + nums[l] + nums[r];\n                if (curSum == target) return curSum;\n                if (abs(target - curSum) < abs(target - closest)) {\n                    closest = curSum;\n                }\n\n                if (target < curSum) {\n                    r--;\n                } else {\n                    l++;\n                }\n            }\n        }\n\n        return closest;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        n = len(nums)\n        diff = float('inf')\n        res = 0\n        for i in range(n - 2):\n            left = i + 1\n            right = n - 1\n            while left < right:\n                s = nums[i] + nums[left] + nums[right]\n                if abs(target - s) < diff:\n                    diff = abs(target - s)\n                    res = s\n                if s < target:\n                    left += 1\n                else:\n                    right -= 1\n        return res"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        ans = float('inf')\n        for i in range(len(nums) - 2):\n            lo, hi = i + 1, len(nums) - 1\n            \n            while lo < hi:\n                s = nums[i] + nums[lo] + nums[hi]\n                if s == target:\n                    return s\n                elif s > target:\n                    hi -= 1\n                else:\n                    lo += 1\n                if abs(s - target) < abs(ans - target):\n                    ans = s\n        return ans"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        \n        result = sum(nums[:3])\n        for i in range(len(nums)-2):\n            if i==0 and nums[i] == nums[i-1]:\n                continue\n            \n            l, r = i+1, len(nums)-1\n            while l < r:\n                curr = nums[i] + nums[l] + nums[r]\n                diff = curr - target\n                if diff < 0:\n                    l += 1\n                elif diff > 0:\n                    r -= 1\n                else:\n                    return curr\n                \"\"\"\n                TLE for block if statement\n                \n                if abs(result-target) > abs(diff):\n                    result = curr\n                \"\"\"\n                result = curr if abs(result-target) > abs(diff) else result\n\n        \n        return result"
            },
            {
                "language": "python",
                "code": "if abs(result-target) > abs(diff):\n    result = curr"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        int diff=INT_MAX;\n        int ans=0;\n     sort(nums.begin(), nums.end());\n for(int i=0;i<nums.size()-2;i++){\n     int low=i+1;\n     int high=nums.size()-1;\n     int first=nums[i];\n     while(low<high){\n         if(first+nums[low]+nums[high]==target){\n             return target;\n         }\n         else if(abs(first+nums[low]+nums[high]-target)<diff){\n             diff=abs(first+nums[low]+nums[high]-target);\n             ans=first+nums[low]+nums[high];\n         }\n         if(first+nums[low]+nums[high]<target){\n             low++; \n         }\n        else{ high--;\n            }\n     }\n }              \n        return ans;\n    }\n};"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        s=float('inf')\n        t=len(nums)\n        nums.sort()\n        for x in range(t-2):\n            i=x+1\n            j=t-1\n            while i<j:\n                s1=nums[x]+nums[i]+nums[j]\n                #print(x,i,j,'here')\n                if s1==target:\n                    return target\n                if abs(target-s)>abs(target-s1):\n                    #print(x,i,j,'-------',s1)\n                    s=s1\n                if s1<target:\n                    i+=1\n                else:\n                    j-=1\n        return s"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        if len(nums) == 3:\n            return sum(nums)\n        \n        nums = sorted(nums)\n        minSum, minDiff = None, float('inf')\n        \n        for i in range(len(nums)-2):\n            left, right = i+1, len(nums)-1\n            \n            while left < right:\n                currSum = nums[i] + nums[left] + nums[right]\n                currDiff = abs(target - currSum)\n\n                if currDiff < minDiff:\n                    minDiff = currDiff\n                    minSum = currSum\n\n                if minDiff == 0:\n                    return minSum\n\n                if target > currSum:\n                    left += 1\n                else:\n                    right -= 1\n        \n        return minSum"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        N = len(nums)\n        if N == 3:\n            return sum(nums)\n        \n        nums = sorted(nums)\n        minSum, minDiff = None, inf\n        \n        for i in range(N-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n\n            left, right = i+1, N-1\n            \n            while left < right:\n                currSum = sum([nums[i], nums[left], nums[right]])\n                currDiff = abs(target - currSum)\n\n                if currDiff < minDiff:\n                    minDiff = currDiff\n                    minSum = currSum\n\n                    if minDiff == 0:\n                        return minSum\n\n                if target > currSum:\n                    left += 1\n                    while left < right and nums[left] == nums[left-1]:\n                        left += 1\n                else:\n                    right -= 1\n                    while left < right and nums[right] == nums[right+1]:\n                        right -= 1\n        \n        return minSum"
            },
            {
                "language": "python",
                "code": "                if target > currSum:\n                    left += 1\n                    while left < right and nums[left] == nums[left-1]:\n                        left += 1\n                else:\n                    right -= 1\n                    while left < right and nums[right] == nums[right+1]:\n                        right -= 1"
            },
            {
                "language": "",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "for i in range(n-2):\n  left, right = i+1, n-1"
            },
            {
                "language": "python",
                "code": "for i in range(len(res) - 2):"
            },
            {
                "language": "",
                "code": ""
            },
            {
                "language": "python",
                "code": ""
            }
        ]
    },
    "16": {
        "question_id": 17,
        "title": "Letter Combinations of a Phone Number",
        "difficulty": 2,
        "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. ",
        "examples": [
            {
                "input": "digits = \"23\"",
                "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
                "explanation": null
            },
            {
                "input": "digits = \"\"",
                "output": "[]",
                "explanation": null
            },
            {
                "input": "digits = \"2\"",
                "output": "[\"a\",\"b\",\"c\"]",
                "explanation": null
            }
        ],
        "constraints": [
            "0 <= digits.length <= 4",
            "digits[i] is a digit in the range ['2', '9']."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(3^N \u00d7 4^M) where N is the number of digits which have 3 letters( ex: 2,3,4) assigned to\n    it and M is the number of digits which has 4 letters(ex: 7,9) assigned to it.\n\n    Space Complexity : O(3^N \u00d7 4^M) where N is the number of digits which have 3 letters( ex: 2,3,4) assigned to\n    it and M is the number of digits which has 4 letters(ex: 7,9) assigned to it.\n\n    Solved using String + Backtracking + Hash Table. Recursive Approach.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\nprivate:\n    void letterCombinations(string digits, vector<string>& output, string &temp, vector<string>& pad, int index){\n        if(index == digits.size()){\n            output.push_back(temp);\n            return;\n        }\n        string value = pad[digits[index]-'0'];\n        for(int i=0; i<value.size(); i++){\n            temp.push_back(value[i]);\n            letterCombinations(digits, output, temp, pad, index+1);\n            temp.pop_back();\n        }\n    }\npublic:\n    vector<string> letterCombinations(string digits) {\n        if(digits.empty()){\n            return {};\n        }\n        vector<string> pad = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        vector<string> output;\n        string temp;\n        letterCombinations(digits, output, temp, pad, 0);\n        return output;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(3^N \u00d7 4^M) where N is the number of digits which have 3 letters( ex: 2,3,4) assigned to\n    it and M is the number of digits which has 4 letters(ex: 7,9) assigned to it.\n\n    Space Complexity : O(3^N \u00d7 4^M) where N is the number of digits which have 3 letters( ex: 2,3,4) assigned to\n    it and M is the number of digits which has 4 letters(ex: 7,9) assigned to it.\n\n    Solved using String + Hash Table. Iterative Approach.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        if(digits.empty()){\n            return {};\n        }\n        vector<string> pad = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        vector<string> output;\n        output.push_back(\"\");\n        for(auto key : digits){\n            vector<string> temp;\n            for(auto candidate : pad[key-'0']){\n                for(auto c : output){\n                    temp.push_back(c + candidate);\n                }\n            }\n            output.clear();\n            output = temp;\n        }\n        return output;\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n        \n        phone = {\"2\": \"abc\", \"3\": \"def\", \"4\": \"ghi\", \"5\": \"jkl\", \"6\": \"mno\", \"7\": \"pqrs\", \"8\": \"tuv\", \"9\": \"wxyz\"}\n        res = []\n        \n        def backtrack(combination, next_digits):\n            if not next_digits:\n                res.append(combination)\n                return\n            \n            for letter in phone[next_digits[0]]:\n                backtrack(combination + letter, next_digits[1:])\n        \n        backtrack(\"\", digits)\n        return res"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    String [] arr = new String[]{\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n    public List<String> letterCombinations(String digits) {\n        List<String> list = new ArrayList<>();\n        if(digits.length() == 0) return list;\n        StringBuilder sb = new StringBuilder();\n        backtrack(list,digits,sb,0);\n        return list;\n    }\n    private void backtrack(List<String> list,String str,StringBuilder sb,int index){\n        if(sb.length() == str.length()){\n            list.add(sb.toString());\n            return;\n        }\n        else{\n            int val = str.charAt(index)-'0';\n            for(int i=0;i<arr[val-1].length();i++){\n                sb.append(arr[val-1].charAt(i));\n                backtrack(list,str,sb,index+1);\n                sb.deleteCharAt(sb.length() - 1);\n            }\n        }\n    }\n}"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        self.dfs(nums, [], res)\n        return res\n    \n    def dfs(self, nums, path, res):\n        res.append(path)\n        for i in range(len(nums)):\n            self.dfs(nums[i+1:], path + [nums[i]], res)     "
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        nums.sort()\n        self.dfs(nums, [], res)\n        return res\n    \n    def dfs(self, nums, path, res):\n        res.append(path)\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums[i+1:], path + [nums[i]], res)"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res=[]\n        self.dfs(range(1, n+1), k, [], res)\n        return res\n    \n    def dfs(self, nums, k, path, res):\n        if len(path) == k:\n            res.append(path)\n            return\n        for i in range(len(nums)):\n            self.dfs(nums[i+1:], k, path+ [nums[i]], res)"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        candidates.sort()\n        self.dfs(candidates, target, [], res)\n        return res\n    \n    def dfs(self, candidates, target, path, res):\n        if target < 0:\n            return   #backtracking\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(len(candidates)):\n            self.dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)  "
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        candidates.sort()\n        self.dfs(candidates, target, [], res)\n        return res\n    \n    def dfs(self, candidates, target, path, res):\n        if target < 0:\n            return\n        \n        if target == 0:\n            res.append(path)\n        for i in range(len(candidates)):\n            if i > 0 and candidates[i] == candidates[i-1]:\n                continue\n                \n            if candidates[i]> target:\n                break\n                \n            self.dfs(candidates[i+1:], target - candidates[i], path + [candidates[i]], res)"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        self.dfs(nums, [], res)\n        return res\n    \n    def dfs(self, nums, path, res):\n        if len(nums) == 0:\n            res.append(path)\n            return\n        for i in range(len(nums)):\n            self.dfs(nums[:i] + nums[i+1:], path + [nums[i]], res)   "
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        nums.sort()\n        self.dfs(nums, [], res)\n        return res\n    \n    def dfs(self, nums, path, res):\n        if len(nums) == 0:\n            res.append(path)\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums[:i] + nums[i+1:], path + [nums[i]], res)"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        dic = { \"2\": \"abc\", \"3\": \"def\", \"4\":\"ghi\", \"5\":\"jkl\", \"6\":\"mno\", \"7\":\"pqrs\", \"8\":\"tuv\", \"9\":\"wxyz\"}\n        \n        res=[]\n        if len(digits) ==0:\n            return res\n            \n        self.dfs(digits, 0, dic, '', res)\n        return res\n    \n    def dfs(self, nums, index, dic, path, res):\n        if index >=len(nums):\n            res.append(path)\n            return\n        string1 =dic[nums[index]]\n        for i in string1:\n            self.dfs(nums, index+1, dic, path + i, res)"
            },
            {
                "language": "ruby",
                "code": "def subsets(self, nums):\n    def backtrack(start, end, tmp):\n        ans.append(tmp[:])\n        for i in range(start, end):\n            tmp.append(nums[i])\n            backtrack(i+1, end, tmp)\n            tmp.pop()"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        res = []\n        \n        def recurse(n_open: int, n_close: int, curr: List[str]):\n            if n_open == n_close == n:\n                res.append(\"\".join(curr))\n                return"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def expand(self, s: str) -> List[str]:\n                        \n        result = []\n        self.dfs(s, \"\", result)\n        result.sort()"
            },
            {
                "language": "kotlin",
                "code": ""
            },
            {
                "language": "ruby",
                "code": ""
            },
            {
                "language": "ruby",
                "code": ""
            },
            {
                "language": "kotlin",
                "code": ""
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def countArrangement(self, n: int) -> int:\n        #instance class variable because ints are immutable so if you\n        # += below in the dfs method it would have to create a new \"output\" in memory each each time\n        # and \"reset\" it to 0 essentially\n        self.output = 0\n        \n        self.dfs(list(range(1, n+1)), [], n, n)"
            },
            {
                "language": "ruby",
                "code": "    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        \n        nums.sort()\n        self.recurseSubset(res, nums, [])\n        \n        return res"
            },
            {
                "language": "typescript",
                "code": "public List<String> letterCombinations(String digits) {\n  LinkedList<String> ans = new LinkedList<String>();\n  if(digits.isEmpty()) return ans;\n  String[] mapping = new String[] {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n  ans.add(\"\");\n  for(int i =0; i<digits.length();i++){\n   int x = Character.getNumericValue(digits.charAt(i));\n   while(ans.peek().length()==i){\n    String t = ans.remove();\n    for(char s : mapping[x].toCharArray())\n     ans.add(t+s);\n   }\n  }\n  return ans;\n }"
            },
            {
                "language": "typescript",
                "code": "public List<String> letterCombinations(String digits) {\n  LinkedList<String> ans = new LinkedList<String>();\n  if(digits.isEmpty()) return ans;\n  String[] mapping = new String[] {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n  ans.add(\"\");\n  while(ans.peek().length()!=digits.length()){\n   String remove = ans.remove();\n   String map = mapping[digits.charAt(remove.length())-'0'];\n   for(char c: map.toCharArray()){\n    ans.addLast(remove+c);\n   }\n  }\n  return ans;\n }"
            },
            {
                "language": "lisp",
                "code": "while(list.peek().length() == i)"
            },
            {
                "language": "kotlin",
                "code": ""
            },
            {
                "language": "dart",
                "code": " public List<String> letterCombinations(String digits) {\n  List<String> ans = new LinkedList<String>();\n  if (digits.isEmpty())\n   return ans;\n  String[] mapping = new String[] { \"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\n  ans.add(0, \"\");"
            },
            {
                "language": "python",
                "code": "int x = digits.charAt(i) - '0';"
            },
            {
                "language": "csharp",
                "code": "vector<string> letterCombinations(string digits) {"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    void solve(int ind, string &ds, vector<string> &ans, string mapping[], string digits){\n        if(ind==digits.size()){\n            ans.emplace_back(ds);\n            return;\n        }\n        string value = mapping[digits[ind]-'0'];\n\n        for(int i=0; i<value.size(); i++){\n                ds+=value[i];\n                solve(ind+1, ds, ans, mapping, digits);\n                ds.pop_back();\n       }\n\n    }\n    vector<string> letterCombinations(string digits) {\n        string ds;\n        vector<string> ans;\n        if(digits.size()==0)\n            return ans;\n        string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        solve(0, ds, ans, mapping, digits);\n        return ans;      \n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    static String[] ref = new String[]{\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n    public void backtrack(char str[],char arr[],int curr,int length,LinkedList<String> list){\n        if(curr==length){\n            list.add(new String(str));\n            return;\n        }\n        String flag = ref[arr[curr]-50];\n        for(int i=0;i<flag.length();i++){\n            str[curr]=flag.charAt(i);\n            backtrack(str,arr,1+curr,length,list);\n        }\n    }\n    public List<String> letterCombinations(String digits) {\n        LinkedList<String> output = new LinkedList<>();\n        if(digits.length()==0) return output;\n        char flow[] = new char[digits.length()];\n        backtrack(flow,digits.toCharArray(),0,digits.length(),output);\n        return output;\n    }\n}"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    List<String> mapping =  new ArrayList<>(List.of(\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"));\n    List<String> ans = new ArrayList<>();\n    void genrateComination(String digits,String letters,int idx)\n    {\n        if(digits.length() == letters.length()){\n            ans.add(letters);\n            return;\n        }\n        String currDigit = mapping.get(digits.charAt(idx)-'0');\n        for(int i=0;i<currDigit.length();++i)\n            genrateComination(digits,letters+currDigit.charAt(i),idx+1);\n        \n\n    }\n    public List<String> letterCombinations(String digits) {\n        if (digits.length() == 0)\n            return ans;\n        genrateComination(digits,\"\",0);\n        return ans;\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    vector<string>mapping={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n    vector<string> ans;\n    void genrateComination(string digits,string letters,int idx)\n    {\n        if(digits.size() == letters.size()){\n            ans.push_back(letters);\n            return;\n        }\n        string currDigit = mapping[digits[idx]-'0'];\n        for(int i=0;i<currDigit.size();++i)\n        {\n            genrateComination(digits,letters+currDigit[i],idx+1);\n        }\n\n    }\n    vector<string> letterCombinations(string digits) {\n        if (digits.size() == 0)\n            return ans;\n        genrateComination(digits,\"\",0);\n        return ans;\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    map<char,string> data;\n\n    void fillData(){\n        data['2'] = \"abc\";\n        data['3'] = \"def\";\n        data['4'] = \"ghi\";\n        data['5'] = \"jkl\";\n        data['6'] = \"mno\";\n        data['7'] = \"pqrs\";\n        data['8'] = \"tuv\";\n        data['9'] = \"wxyz\";\n    }\n\n    void helper(vector<string>&res, string temp, int i, string digits, int j){\n        if(temp.length() == digits.length() && temp != \"\") {\n            res.push_back(temp);\n            return;\n        }\n        if(i >= digits.length()) return;\n\n        for(int idx = j; idx < data[digits[i]].length(); idx++){\n            temp.push_back(data[digits[i]][idx]);\n            helper(res,temp,i+1,digits,j);\n            temp.pop_back();\n        }\n    }\n\n    vector<string> letterCombinations(string digits) {\n        fillData();\n        vector<string> res;\n        string temp = \"\";\n\n        helper(res,temp,0,digits,0);\n\n        return res;\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    vector<string>ans;\n    map<int,string>mp;\n    void backtrack(string& dig,int start,string &temp){\n        \n        if(start==dig.size())ans.push_back(temp);\n\n          for(auto x:mp[dig[start]-'0']){\n              temp.push_back(x);\n              backtrack(dig,start+1,temp);\n              temp.pop_back();\n          }\n    }\n    vector<string> letterCombinations(string dig) {\n        if(dig==\"\") return ans;\n        mp[2] = \"abc\";\n        mp[3] = \"def\";\n        mp[4] = \"ghi\";\n        mp[5] = \"jkl\";\n        mp[6] = \"mno\";\n        mp[7] = \"pqrs\";\n        mp[8] = \"tuv\";\n        mp[9] = \"wxyz\";\n        string temp;\n        backtrack(dig,0,temp);\n        return ans;\n    }\n};"
            }
        ]
    },
    "17": {
        "question_id": 18,
        "title": "4Sum",
        "difficulty": 2,
        "description": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:0 <= a, b, c, d < na, b, c, and d are distinct.nums[a] + nums[b] + nums[c] + nums[d] == targetYou may return the answer in any order. ",
        "examples": [
            {
                "input": "nums = [1,0,-1,0,-2,2], target = 0",
                "output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
                "explanation": null
            },
            {
                "input": "nums = [2,2,2,2,2], target = 8",
                "output": "[[2,2,2,2]]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 200",
            "-109 <= nums[i] <= 109",
            "-109 <= target <= 109"
        ],
        "solutions": [
            {
                "language": "javascript",
                "code": "function binary_search(arr, target, L = 0, R = arr.length - 1) {\n    while (L < R) {\n        let mid = ~~(L / 2 + R / 2);\n        arr[mid] < target ? (L = mid + 1) : (R = mid);\n    }\n    return L === R && arr[L] === target ? L : -Infinity;\n}\nvar fourSum = function (a, t) {\n    let n = a.length;\n\n    a.sort((a, b) => a - b);\n\n    // L + R + L2 + R2 = t\n    let aa = [];\n    for (let L = 0; L < n; L++) {\n        if (L > 0 && a[L - 1] === a[L]) continue;\n\n        for (let R = L + 1; R < n; R++) {\n            if (R > L + 1 && a[R - 1] === a[R]) continue;\n            let sum1 = a[L] + a[R] - t;\n            for (let L2 = R + 1; L2 < n; L2++) {\n                 if (L2 > R + 1 && a[L2 - 1] === a[L2]) continue;\n\n                let search = -(sum1 + a[L2]); // L + R - t + L2 = - R2\n                let R2 = binary_search(a, search, L2 + 1, n - 1);\n                if (R2 !== -Infinity) {\n                    aa.push([a[L], a[R], a[L2], a[R2]]);\n                }\n            }\n        }\n    }\n    return aa;\n};"
            },
            {
                "language": "javascript",
                "code": "var fourSum = function (a, t) {\n    let n = a.length;\n\n    a.sort((a, b) => a - b);\n\n    // L + R + L2 + R2 = t\n    let aa = [];\n    for (let L = 0; L < n; L++) {\n        for (let R = L + 1; R < n; R++) {\n            let sum = a[L] + a[R] - t;\n            let search = -sum; // target;\n\n            for (let L2 = R + 1, R2 = n - 1; L2 < R2; ) {\n                let sum2 = a[L2] + a[R2];\n\n                if (sum2 === search) {\n                    aa.push([a[L], a[R], a[L2], a[R2]]);\n\n                    while (L2 < R2 && a[L2] === a[L2 + 1]) L2++;\n                    while (R2 > L2 && a[R2] === a[R2 - 1]) R2--;\n                    L2++;\n                    R2--;\n                } else if (sum2 < search) {\n                    L2++;\n                } else {\n                    R2--;\n                }\n            }\n            while (a[R] === a[R + 1]) R++;\n        }\n        while (a[L] === a[L + 1]) L++;\n    }\n    return aa;\n};"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N^4), Here Four nested loop creates the time complexity. Where N is the size of the\n    array(nums).\n\n    Space Complexity : O(N), Hash Table(set) space.\n\n    Solved using Array(Four Nested Loop) + Sorting + Hash Table(set). Brute Force Approach.\n\n    Note : this will give TLE.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        set<vector<int>> set;\n        vector<vector<int>> output;\n        for(int i=0; i<n-3; i++){\n            for(int j=i+1; j<n-2; j++){\n                for(int k=j+1; k<n-1; k++){\n                    for(int l=k+1; l<n; l++){\n                        if((long long)nums[i] + (long long)nums[j] + (long long)nums[k] + \n                        (long long)nums[l] == target){\n                            set.insert({nums[i], nums[j], nums[k], nums[l]});\n                        }\n                    }\n                }\n            }\n        }\n        for(auto it : set){\n            output.push_back(it);\n        }\n        return output;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^3), Here Three nested loop creates the time complexity. Where N is the size of the\n    array(nums).\n\n    Space Complexity : O(N), Hash Table(set) space.\n\n    Solved using Array(Three Nested Loop) + Sorting + Hash Table(set).\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        set<vector<int>> set;\n        vector<vector<int>> output;\n        for(int i=0; i<n-3; i++){\n            for(int j=i+1; j<n-2; j++){\n                long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];\n                int low = j+1, high = n-1;\n                while(low < high){\n                    if(nums[low] + nums[high] < newTarget){\n                        low++;\n                    }\n                    else if(nums[low] + nums[high] > newTarget){\n                        high--;\n                    }\n                    else{\n                        set.insert({nums[i], nums[j], nums[low], nums[high]});\n                        low++; high--;\n                    }\n                }\n            }\n        }\n        for(auto it : set){\n            output.push_back(it);\n        }\n        return output;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^3), Here Three nested loop creates the time complexity. Where N is the size of the\n    array(nums).\n\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the Vector(output), however the\n    output does not count towards the space complexity.\n\n    Solved using Array(Three Nested Loop) + Sorting. Optimized Approach.\n\n*/\n\n\n/***************************************** Approach 3 *****************************************/\n\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> output;\n        for(int i=0; i<n-3; i++){\n            for(int j=i+1; j<n-2; j++){\n                long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];\n                int low = j+1, high = n-1;\n                while(low < high){\n                    if(nums[low] + nums[high] < newTarget){\n                        low++;\n                    }\n                    else if(nums[low] + nums[high] > newTarget){\n                        high--;\n                    }\n                    else{\n                        output.push_back({nums[i], nums[j], nums[low], nums[high]});\n                        int tempIndex1 = low, tempIndex2 = high;\n                        while(low < high && nums[low] == nums[tempIndex1]) low++;\n                        while(low < high && nums[high] == nums[tempIndex2]) high--;\n                    }\n                }\n                while(j+1 < n && nums[j] == nums[j+1]) j++;\n            }\n            while(i+1 < n && nums[i] == nums[i+1]) i++;\n        }\n        return output;\n    }\n};"
            },
            {
                "language": "lisp",
                "code": "O(n^3) "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int tg) {\n        int n = nums.size();\n        vector<vector<int>>ans;\n        set<vector< int>>st;\n        sort(nums.begin(), nums.end());\n        for (int i = 0; i < n - 3 ; i++) {\n            if (i > 0 && (nums[i - 1] == nums[i])) continue;\n            for (int j = i + 1; j < n - 2; j++) {\n                if (j >  i + 1 && nums[j - 1] == nums[j]) continue;\n                int l = j + 1; \n                int r = n - 1;\n                long long int tg_nw = nums[i] + nums[j];\n                while (l < r) {\n                    long long int rem = tg - tg_nw;\n                    long long int now = nums[l] + nums[r];\n                    if (rem == now) {\n                        st.insert({\n                            nums[i],\n                            nums[j],\n                            nums[l],\n                            nums[r]\n                        });\n                        ++l;\n                    }\n                    if (now < rem) l++;\n                    if (now > rem) r--;\n                }\n            }\n        }\n        for (auto it : st) ans.push_back(it);\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        vector<vector<int>> ans;\n        set<vector<int>> s;\n        int n=nums.size();\n        sort(nums.begin(),nums.end());\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n              int  k=j+1;\n              int  e=n-1;\n                while(k<e)\n                {\n                    long long sum=(long long)nums[i]+(long long)nums[j]+(long long)nums[k]+(long long)nums[e];\n                    if(sum==target)\n                    {\n                        s.insert({nums[i],nums[j],nums[k],nums[e]});\n                        k++;\n                        e--;\n                    }\n                    else if(sum<target)\n                    {\n                        k++;\n                    }\n                    else \n                    {\n                        e--;\n                    }\n                }\n            }\n        }\n        for(auto i: s)\n        {\n            ans.push_back(i);\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "//Optimized Approach using two pointer - O(n^3) time and O(n) space\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(nums.begin(), nums.end());\n        set<vector<int>> s;\n        vector<vector<int>> output;\n        for (int i = 0; i < nums.size(); i++){\n            for(int j = i+1; j < nums.size(); j++){\n                int k = j + 1;\n                int l = nums.size() - 1;\n                while (k < l) {\n                    //by writing below 4 statement this way it will not give runtime error\n                    long long int sum = nums[i];\n                    sum += nums[j];\n                    sum += nums[k];\n                    sum += nums[l];\n                    if (sum == target) {\n                        s.insert({nums[i], nums[j], nums[k], nums[l]});\n                        k++;\n                        l--;\n                    } else if (sum < target) {\n                        k++;\n                    } else {\n                        l--;\n                    }\n                }\n            }\n        }\n        for(auto quadruplets : s)\n            output.push_back(quadruplets);\n        return output;\n    }\n};"
            },
            {
                "language": "go",
                "code": "    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        hmap = defaultdict(int)\n        n,res=len(nums),[]\n        for i in range(0,n):\n            if(i>0 and nums[i-1]==nums[i]):\n                continue;\n            for j in range(i+1,n):\n                for k in range(j+1,n):   \n                    t = target-(nums[i]+nums[j]+nums[k])\n                    idx = bisect.bisect_left(nums[k+1:n],t)\n                    if( k+idx+1 < n and nums[k+idx+1]== t ):\n                        lis = [nums[i],nums[j],nums[k],nums[k+idx+1]]\n                        temp = ''.join(map(str,lis))\n                        if(hmap[temp] == 0 ):\n                            res.append(lis)\n                            hmap[temp] = 1\n                    \n                    \n        print(res)\n        return res\n        "
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        List<List<Integer>>ans=new ArrayList<>();\n        if(nums==null || nums.length==0) return ans;\n        int n=nums.length;\n        \n        \n        Arrays.sort(nums);\n        for(int i=0;i<n;i++){\n            long target2=(long)target-(long)nums[i];\n\n            for(int j=i+1;j<n;j++){\n                long remaining=(long)target2-(long)nums[j];\n\n                int first=j+1;\n                int last=n-1;\n                while(first<last){\n                    long twoSum=(long)nums[first]+(long)nums[last];\n                    if(twoSum<remaining) {\n                        first++;\n                    }\n                    else if(twoSum>remaining) {\n                        last--;\n                    }\n                    else{\n                        List<Integer>res=new ArrayList<>();\n                        res.add(nums[i]);//num 1\n                        res.add(nums[j]);//num 2\n                        res.add(nums[first]);//num 3\n                        res.add(nums[last]);//num 4\n                        ans.add(res);\n\n                        // Processing the duplicates of number 3\n                        while(first<last && nums[first]==res.get(2)) first++;\n\n                        // Processing the duplicates of number 4\n                        while(first<last && nums[last]==res.get(3)) last--;\n                    }\n                }\n                // Processing the duplicates of number 2\n                while(j+1<n && nums[j+1]==nums[j]) j++;\n            }\n            // Processing the duplicates of number 1\n            while(i+1<n && nums[i+1]==nums[i]) i++;\n        }\n        return ans;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int T) {\n        unordered_set<int> seen;\n        set<multiset<int>> ans_set;\n        int n = size(nums);\n<int>(begin(el), end(el)); });"
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n        vector<vector<int>> ans;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n];"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n        set<vector<int>> st;\n        int n = nums.size();\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                int start = j+1,end = n-1;\n                while(start<end){\n                    long long crSum = (long long)nums[i]+nums[j]+nums[start]+nums[end];\n                    if(crSum == target){\n                        st.insert({nums[i],nums[j],nums[start],nums[end]});\n                        end--;\n                    }else if(crSum>target) end--;\n                    else start++;\n                }\n            }\n            \n        }\n        vector<vector<int>> ans(st.begin(),st.end());\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    void allCombinations(int currentIndex, int target, vector<int>&nums, vector<int>currentAns, \n                    set<vector<int>>&st)\n    {\n        //valid combination\n        if(target == 0 && currentAns.size() == 4)\n        {\n            st.insert(currentAns);\n            return;\n        }\n        \n        //invalid combination\n        if(currentIndex == nums.size() || currentAns.size() >= 4)\n            return ;\n        \n        \n        //take\n        currentAns.push_back(nums[currentIndex]);\n        allCombinations(currentIndex+1,target-nums[currentIndex],nums,currentAns,st);\n        currentAns.pop_back();\n        \n        //not take\n        allCombinations(currentIndex+1,target,nums,currentAns,st);\n    }\n    \n    \n    vector<vector<int>> fourSum(vector<int>& nums, int target)\n    {\n        vector<int>currentAns;\n        set<vector<int>>st;\n        vector<vector<int>>ans;\n        \n        sort(nums.begin(),nums.end());\n        allCombinations(0,target,nums,currentAns,st);\n        \n        for(auto current : st)\n            ans.push_back(current);\n        \n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    //binary search\n    bool isPresent(int start, int end, long long target, vector<int>&nums)\n    {\n        if(start > end)\n            return false;\n        \n        int mid = start + (end-start)/2;\n        \n        if(nums[mid] == target)\n            return true;\n        \n        else if(nums[mid] < target)\n            return isPresent(mid+1,end,target,nums);\n        \n        return isPresent(start,mid-1,target,nums);\n    }\n    \n    vector<vector<int>> fourSum(vector<int>& nums, int target)\n    {\n        int n = nums.size();\n        vector<vector<int>>ans;\n        set<vector<int>>st;\n        \n        sort(nums.begin(),nums.end());\n        \n        for(int i = 0; i < n; i++)\n        {\n            for(int j = i+1; j < n; j++)\n            {\n                for(int k = j+1; k < n; k++)\n                {\n                    long long val = (long long)nums[i]+(long long)nums[j]+(long long)nums[k];\n                    long long remaining = target - val;\n                    \n                    //implement binary search to check if remaining is present in the right part of array\n                    if(isPresent(k+1,n-1,remaining,nums))\n                    {\n                        vector<int>temp(4,-1);\n                        temp[0] = nums[i];\n                        temp[1] = nums[j];\n                        temp[2] = nums[k];\n                        temp[3] = remaining;\n                        \n                        st.insert(temp);\n                    }\n                }\n            }\n        }\n        \n        //storing all the valid combinations from set to ans vector\n        for(auto current : st)\n            ans.push_back(current);\n        \n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    vector<vector<int>> fourSum(vector<int>& nums, int target)\n    {\n        vector<vector<int>>ans;\n        \n        int n = nums.size();\n        sort(nums.begin(),nums.end());\n        \n        for(int i = 0; i < n; i++)\n        {\n            for(int j = i+1; j < n; j++)\n            {\n                long long remaining = (long long)target - (long long)nums[i] - (long long)nums[j];\n                \n                int start = j+1;\n                int end = n-1;\n                \n                while(start < end)\n                {\n                    if(nums[start] + nums[end] > remaining)\n                        end--;\n                    \n                    else if(nums[start] + nums[end] < remaining)\n                        start++;\n                    \n                    //valid combination (nums[start] + nums[end] == remaining)\n                    else\n                    {\n                        vector<int>temp(4,-1);\n                        temp[0] = nums[i];\n                        temp[1] = nums[j];\n                        temp[2] = nums[start];\n                        temp[3] = nums[end];\n                    \n                        ans.push_back(temp);\n                        \n                        //skip the duplicates\n                        while(start < end && nums[start] == temp[2])\n                            start++;\n                        while(end > start && nums[end] == temp[3])\n                            end--;\n                    }\n                }\n                while(j < n-1 && nums[j] == nums[j+1])\n                    j++;\n            }\n            while(i < n-1 && nums[i] == nums[i+1])\n                i++;\n        }\n        return ans;\n    }\n};"
            }
        ]
    },
    "18": {
        "question_id": 19,
        "title": "Remove Nth Node From End of List",
        "difficulty": 2,
        "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head. ",
        "examples": [
            {
                "input": "head = [1,2,3,4,5], n = 2",
                "output": "[1,2,3,5]",
                "explanation": null
            },
            {
                "input": "head = [1], n = 1",
                "output": "[]",
                "explanation": null
            },
            {
                "input": "head = [1,2], n = 1",
                "output": "[1]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is sz.",
            "1 <= sz <= 30",
            "0 <= Node.val <= 100",
            "1 <= n <= sz"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "var removeNthFromEnd = function(head, n) {\n    let fast = head, slow = head\n    for (let i = 0; i < n; i++) fast = fast.next\n    if (!fast) return head.next\n    while (fast.next) fast = fast.next, slow = slow.next\n    slow.next = slow.next.next\n    return head\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        fast, slow = head, head\n        for _ in range(n): fast = fast.next\n        if not fast: return head.next\n        while fast.next: fast, slow = fast.next, slow.next\n        slow.next = slow.next.next\n        return head"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode fast = head, slow = head;\n        for (int i = 0; i < n; i++) fast = fast.next;\n        if (fast == null) return head.next;\n        while (fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        slow.next = slow.next.next;\n        return head;\n    }\n}"
            },
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode *fast = head, *slow = head;\n        for (int i = 0; i < n; i++) fast = fast->next;\n        if (!fast) return head->next;\n        while (fast->next) fast = fast->next, slow = slow->next;\n        slow->next = slow->next->next;\n        return head;\n    }\n};"
            },
            {
                "language": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) \n    {\n        //if Single element list, thus returning empty list\n        if(head.next == null)\n            return null;\n\n        ListNode ptr = head;\n        ListNode ptr2 = head;\n\n        int len = 0;\n\n        //finding the lenght of the list\n        while(ptr != null)\n        {\n            len++;\n            ptr = ptr.next;\n        }\n\n        //required index\n        int index = len - n;\n        ptr = head;\n\n        boolean start = false;\n\n        while(true)\n        {\n            if(index == 0)\n            {\n                // if head element\n                if(ptr == head)\n                {\n                    ptr2 = ptr2.next;\n                    ptr.next = null;\n                    head = ptr2;\n                    break;\n                }\n\n                else\n                {\n                    ptr2.next = ptr.next;\n                    ptr.next = null;\n                    break;\n                }\n            }\n\n            index--;\n\n            //for letting the second pointer start late\n            if(start)\n                ptr2 = ptr2.next;\n\n            start = true;\n\n            ptr = ptr.next;\n        }    \n\n        return head;    \n    }\n}"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\n    int length = 1;\n    struct ListNode* temp = head;\n    while (temp->next != NULL) {\n        length += 1;\n        temp = temp->next;\n    }\n    if (length == 1) {\n        head = NULL;\n        return head;\n    }\n    struct ListNode* ptr;\n    temp = head;\n     if (n == 1) {\n        for (int i = 1; i <= length - 1; i += 1) {\n        ptr = temp;\n        temp = temp->next;\n        }\n        free(temp);\n        ptr->next = NULL;\n        return head;\n    }\n    else if (n > 1 && n < length) {\n        for (int i = 1; i <= (length - n); i += 1) {\n        ptr = temp;\n        temp = temp->next;\n        }\n        ptr->next = temp->next;\n        free(temp);\n        ptr = head;\n        return head;\n    }\n    else {\n        head = head->next;\n        free(temp);\n        return head;\n    }\n    return head;\n}"
            },
            {
                "language": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        cnt = 0\n        node = head\n        node1 = head\n#         computng the size of the linkedlist\n        while node:\n            node = node.next\n            cnt += 1\n# checking if size is 1 then return head with next value None\n        if cnt==1:\n            head = None\n            return head\n            \n        i = 1\n        k = cnt-n\n# if n equals to the size then chnge head to the next value of the head\n        if n==cnt:\n            head = head.next\n            return head\n# setting the pointer just before the node which has to be deleted\n        while i<k:\n            node1 = node1.next\n            i+=1\n# checking whether to be deleted node is last node or not        \n        if node1.next.next:\n            node1.next = node1.next.next\n        else:\n            node1.next = None\n\n        return head"
            },
            {
                "language": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n\n        // Create a temporary node and a counter to find the length of the linked list\n        ListNode temp = head;\n        int count = 0;\n\n        // Traverse the linked list and count the number of nodes\n        while (temp != null) {\n            count++;\n            temp = temp.next;\n        }\n\n        // Calculate the index of the node to be removed from the beginning of the list\n        int len = count - n;\n\n        // If the first node needs to be removed, update the head and return\n        if (len == 0) {\n            head = head.next;\n        } \n        else {\n             // Traverse the list until the node before the one to be removed\n            ListNode prev = head;\n            while (len - 1 != 0) {\n                prev = prev.next;\n                len--;\n            }\n        // Remove the node by updating the previous node's next pointer\n        prev.next = prev.next.next;\n        }\n\n    // Return the head node of the modified list\n    return head;\n    }\n}"
            },
            {
                "language": "go",
                "code": "ListNode* removeNthFromEnd(ListNode* head, int n) {\n ListNode* iter = head;\n int len = 0, i = 1;\n while(iter) iter = iter -> next, len++;    // finding the length of linked list\n if(len == n) return head -> next;          // if head itself is to be deleted, just return head -> next\n for(iter = head; i < len - n; i++) iter = iter -> next; // iterate first len-n nodes\n iter -> next = iter -> next -> next;      // remove the nth node from the end\n return head;\n}"
            },
            {
                "language": "ruby",
                "code": "def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n ptr, length = head, 0\n while ptr:\n  ptr, length = ptr.next, length + 1\n if length == n : return head.next\n ptr = head\n for i in range(1, length - n):\n  ptr = ptr.next\n ptr.next = ptr.next.next\n return head"
            },
            {
                "language": "rust",
                "code": "For eg. let the list be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9, and n = 4.\n\n1. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\n   ^slow               ^fast\n   |<--gap of n nodes-->|\n \n => Now traverse till fast reaches end\n \n 2. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\n                        ^slow               ^fast\n                        |<--gap of n nodes-->|\n      \n'slow' is at (n+1)th node from end.\nSo just delete nth node from end by assigning slow -> next as slow -> next -> next (which would remove nth node from end of list)."
            },
            {
                "language": "rust",
                "code": "ListNode* removeNthFromEnd(ListNode* head, int n) {\n ListNode *fast = head, *slow = head;\n while(n--) fast = fast -> next;      // iterate first n nodes using fast\n if(!fast) return head -> next;       // if fast is already null, it means we have to delete head itself. So, just return next of head\n while(fast -> next)                  // iterate till fast reaches the last node of list\n  fast = fast -> next, slow = slow -> next;            \n slow -> next = slow -> next -> next; // remove the nth node from last\n return head;\n}"
            },
            {
                "language": "ruby",
                "code": "def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n fast = slow = head\n for i in range(n):\n  fast = fast.next\n if not fast: return head.next\n while fast.next:\n  fast, slow = fast.next, slow.next\n slow.next = slow.next.next\n return head"
            },
            {
                "language": "cpp",
                "code": "    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode synthetic(0, head);\n        ListNode* nodes[31];\n        int sz = 0;"
            },
            {
                "language": "ruby",
                "code": "    map<int,ListNode*>mp;\n    \n    ListNode* cur=head;\n    int length=0;"
            },
            {
                "language": "python",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n      public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode temp=head;\n        int size =1;\n        while(temp.next!=null){\n            size++;\n            temp=temp.next;\n        }\n\n        if(size==n){\n            head=head.next;\n            return head;\n        }\n\n        int rev = size-n;\n\n        int index =1;\n        ListNode temp1=head;\n\n            while (index < rev) {\n                  index++;\n                temp1 = temp1.next;\n                \n            }\n            temp1.next = temp1.next.next;\n\n        return head;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodes;\n        ListNode* temp = head;\n        while (temp)\n        {\n            nodes.push_back(temp);\n            temp = temp->next;\n        }\n        if (nodes.size()==1) return NULL;\n        if (nodes.size()-n<=0) return nodes[1];\n        ListNode* node = nodes[nodes.size()-1-n];\n        node->next = node->next->next;\n        return head;\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        nodes = []\n        temp = head\n        while (temp):\n            nodes.append(temp)\n            temp = temp.next\n        if (len(nodes)==1): return None\n        if (len(nodes)-n<=0): return nodes[1]\n        node = nodes[len(nodes)-1-n]\n        node.next= node.next.next\n        return head"
            },
            {
                "language": "rust",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* temp=new ListNode();\n        temp->next=head;\n\n        ListNode* fast=temp;\n        ListNode* slow=temp;\n\n        for(int i=1;i<=n;i++){\n             fast=fast->next;\n        }\n\n        while(fast->next!=NULL){\n            fast=fast->next;\n            slow=slow->next;\n        }\n\n        ListNode* gaya=slow->next;\n        slow->next=slow->next->next;\n        delete(gaya);\n        \n        return temp->next;\n    }\n};\nif it helps plzz don't Forget to upvote it :)"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        int count = 1;\n        ListNode c = head;\n        while(c.next!=null){\n            count++;\n            c=c.next;\n        }\n        \n        if(n == count){\n            head = head.next;\n            return head;\n        }\n        \n        ListNode ln = head;\n        int i= 0;\n        while(++i<count-n){\n            ln = ln.next;  \n        }\n        ln.next = ln.next.next;\n        \n        return head;\n    }\n}"
            }
        ]
    },
    "19": {
        "question_id": 20,
        "title": "Valid Parentheses",
        "difficulty": 1,
        "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.An input string is valid if:Open brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order.Every close bracket has a corresponding open bracket of the same type. ",
        "examples": [
            {
                "input": "s = \"()\"",
                "output": "true",
                "explanation": null
            },
            {
                "input": "s = \"()[]{}\"",
                "output": "true",
                "explanation": null
            },
            {
                "input": "s = \"(]\"",
                "output": "false",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= s.length <= 104",
            "s consists of parentheses only '()[]{}'."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> st ; \n        for (int i = 0 ;  i< s.length() ; i++)\n        {\n            char ch = s[i];\n\n            // if opening bracket then push into the stack \n            if (ch == '(' || ch == '{' || ch == '[')\n            {\n                st.push(ch) ; \n            }\n\n            else {\n                // if a closing bracket then we compare with the top of the stack \n                // while comparing with top of stack we have 2 cases \n                // the stack can be empty or the stack is not empty \n                if (!st.empty())\n                {\n                    char top = st.top() ;\n                    if ((ch == ')' && top == '(') || \n                        (ch == '}' && top == '{') ||\n                        (ch == ']' && top == '[')) \n                        {\n                            // if matches then pop \n                            st.pop() ;\n                        }\n                        else \n                        {\n                            return false ; \n                        }\n                }\n                else \n                {\n                    // if stack is empty and we get a closing bracket means the string is unbalanced \n                    return false ;\n                }\n            }\n        }\n\n        // in the end if the stack is empty -- meaning there is no opening bracket present in the stack -- meaning all opening brackets have found their corresponding closing bracket and have been popped then we return trie \n        if (st.empty())\n        {\n            return true ; \n        }\n        return false ;\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": ""
            },
            {
                "language": "kotlin",
                "code": "We can use a stack to store characters of the string.\nThen we can do two things:\n1. if char is open bracket (i.e. '(' or '{' or '[') then push it in stack.\n2. if char is closed bracket therefore we can check the following conditions:\n\n   1: if '{' is before '}'.\n   2: if '(' is before ')'.\n   3: if '[' is before ']'.\n\n   If any condition is false then return false."
            },
            {
                "language": "kotlin",
                "code": "     **If this solution helped you, give it an up-vote to help others** "
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public boolean isValid(String s) {\n\n\n        // Create a new stack to store the characters.\n        Stack<Character> stack = new Stack<>();\n\n\n        // convert string into char array and access the characters using for each loop.\n        for(char ch: s.toCharArray())\n        {\n            // check ch\n            switch (ch)\n            {\n                // open bracket then push it in stack.\n                // close bracket then pop the item and compare.\n                case '(':\n                case '{':\n                case '[':\n                    stack.push(ch);\n                    break;\n                case ')':\n                    if(stack.isEmpty() || stack.pop() != '(')\n\n                    // if the stack is empty then it means string have no open bracket.\n                        // hence it is invalid.\n                    {\n                        return false;\n                    }\n                    break;\n                case '}':\n                    if(stack.isEmpty() || stack.pop() != '{')\n                    {\n                        return false;\n                    }\n                    break;\n                case ']':\n                    if(stack.isEmpty() || stack.pop() != '[')\n                    {\n                        return false;\n                    }\n                    break;\n            }\n        }\n\n\n        // After the loop we have to check one more condition.\n        // return true only if the stack is empty.\n        // if stack is not empty that means we have unused brackets.\n\n        return stack.isEmpty();\n        \n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public boolean isValid(String s) {\n        \n        Stack<Character> stack = new Stack<Character>();\n        HashMap<Character, Character> complement = \n            new HashMap<Character, Character>();\n\n        complement.put(')', '(');"
            },
            {
                "language": "go",
                "code": "func isValid(s string) bool {\n l := list.New()\n for _, v := range s {\n  if v == '{' || v == '(' || v == '[' {\n   l.PushFront(v)\n  } else if l.Len() > 0 {\n   e := l.Front()\n   if v == '}' && e.Value != '{' {\n    return false\n   }\n   if v == ')' && e.Value != '(' {\n    return false\n   }\n   if v == ']' && e.Value != '[' {\n    return false\n   }\n   l.Remove(e)\n  } else {\n   return false\n  }\n }\n if l.Len() > 0 {\n  return false\n }\n return true\n}"
            },
            {
                "language": "cpp",
                "code": "public boolean isValid(String s) {\n Stack<Character> stack = new Stack<Character>();\n for (char c : s.toCharArray()) {\n  if (c == '(')\n   stack.push(')');\n  else if (c == '{')\n   stack.push('}');\n  else if (c == '[')\n   stack.push(']');\n  else if (stack.isEmpty() || stack.pop() != c)\n   return false;\n }\n return stack.isEmpty();\n}"
            },
            {
                "language": "typescript",
                "code": "boolean isValid(String s) {\n  if ((s.length() & 1) == 1) return false;\n  else {\n    Deque<Character> p = new ArrayDeque<>(s.length());\n    for (int i = 0; i < s.length(); i++)\n      switch (s.charAt(i)) {\n        case '(': p.push(')'); break;\n        case '{': p.push('}'); break;"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        while '()' in s or '[]'in s or '{}' in s:\n            s = s.replace('()','').replace('[]','').replace('{}','')\n        return False if len(s) !=0 else True"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isValid(string s) {\n        // Initialize a stack and a index idx = 0...\n        stack<char> stack;\n        int idx = 0;\n        // If the string is empty, return true...\n        if(s.size() == 0){\n            return true;\n        }\n        // Create a loop to check parentheses...\n        while(idx < s.size()){\n            // If it contains the below parentheses, push the char to stack...\n            if( s[idx] == '(' || s[idx] == '[' || s[idx] == '{' ){\n                stack.push(s[idx]);\n            }\n            // If the current char is a closing brace provided, pop the top element...\n            // Stack is not empty...\n            else if ( (s[idx] == ')' && !stack.empty() && stack.top() == '(') ||\n                        (s[idx] == '}' && !stack.empty() && stack.top() == '{') ||\n                        (s[idx] == ']' && !stack.empty() && stack.top() == '[')\n                      ){\n                stack.pop();\n            }\n            else {\n                return false;       // If The string is not a valid parenthesis...\n            }\n            idx++;      // Increase the index...\n        }\n        // If stack.empty(), return true...\n        if(stack.empty()) {\n            return true;\n        }\n        return false;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public boolean isValid(String s) {\n        // Create hashmap to store the pairs...\n        HashMap<Character, Character> Hmap = new HashMap<Character, Character>();\n        Hmap.put(')','(');\n        Hmap.put('}','{');\n        Hmap.put(']','[');\n        // Create stack data structure...\n        Stack<Character> stack = new Stack<Character>();\n        // Traverse each charater in input string...\n        for (int idx = 0; idx < s.length(); idx++){\n            // If open parentheses are present, push it to stack...\n            if (s.charAt(idx) == '(' || s.charAt(idx) == '{' || s.charAt(idx) == '[') {\n                stack.push(s.charAt(idx));\n                continue;\n            }\n            // If the character is closing parentheses, check that the same type opening parentheses is being pushed to the stack or not...\n            // If not, we need to return false...\n            if (stack.size() == 0 || Hmap.get(s.charAt(idx)) != stack.pop()) {\n                return false;\n            }\n        }\n        // If the stack is empty, return true...\n        if (stack.size() == 0) {\n            return true;\n        }\n        return false;\n    }\n}"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def isValid(self, s):\n        # Create a pair of opening and closing parrenthesis...\n        opcl = dict(('()', '[]', '{}'))\n        # Create stack data structure...\n        stack = []\n        # Traverse each charater in input string...\n        for idx in s:\n            # If open parentheses are present, append it to stack...\n            if idx in '([{':\n                stack.append(idx)\n            # If the character is closing parentheses, check that the same type opening parentheses is being pushed to the stack or not...\n            # If not, we need to return false...\n            elif len(stack) == 0 or idx != opcl[stack.pop()]:\n                return False\n        # At last, we check if the stack is empty or not...\n        # If the stack is empty it means every opened parenthesis is being closed and we can return true, otherwise we return false...\n        return len(stack) == 0"
            },
            {
                "language": "cpp",
                "code": "var isValid = function(s) {\n    // Initialize stack to store the closing brackets expected...\n    let stack = [];\n    // Traverse each charater in input string...\n    for (let idx = 0; idx < s.length; idx++) {\n        // If open parentheses are present, push it to stack...\n        if (s[idx] == '{') {\n            stack.push('}');\n        } else if (s[idx] == '[') {\n            stack.push(']');\n        } else if (s[idx] == '(') {\n            stack.push(')');\n        }\n        // If a close bracket is found, check that it matches the last stored open bracket\n        else if (stack.pop() !== s[idx]) {\n            return false;\n        }\n    }\n    return !stack.length;\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        # Create a pair of opening and closing parrenthesis...\n        opcl = dict(('()', '[]', '{}'))\n        # Create stack data structure...\n        stack = []\n        # Traverse each charater in input string...\n        for idx in s:\n            # If open parentheses are present, append it to stack...\n            if idx in '([{':\n                stack.append(idx)\n            # If the character is closing parentheses, check that the same type opening parentheses is being pushed to the stack or not...\n            # If not, we need to return false...\n            elif len(stack) == 0 or idx != opcl[stack.pop()]:\n                return False\n        # At last, we check if the stack is empty or not...\n        # If the stack is empty it means every opened parenthesis is being closed and we can return true, otherwise we return false...\n        return len(stack) == 0"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n  static const closers = [')', '}', ']'];\n\n  bool isValid(String s) {\n    var a = s.split('');\n    var b = ['()', '{}', '[]'];\n    if (a.length % 2 == 1 || a.isEmpty) return false;\n    if (b.contains(s)) return true;\n    for (int i = 0; i < s.codeUnits.length-1; i++) {\n      if (a.length-1 == i && !closers.contains(a[i])) return false;\n      if (closers.contains(a[i])) {\n        if (i == 0) return false;\n        if (a[i].codeUnitAt(0) ~/ 10 == a[i - 1].codeUnitAt(0) ~/ 10) {\n          a.removeAt(i - 1);\n          a.removeAt(i - 1);\n          --i;\n          --i;\n          if (a.isEmpty) return true;\n          continue;\n        }\n        return false;\n      }\n    }\n    return false;\n  }\n}"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        count=[]\n        check={')':'(',']':'[','}':'{'}\n        for i in s:\n            if i in check:\n                if count and count[-1]==check[i]:\n                    count.pop()\n                else:\n                    return False\n            else:\n                count.append(i) \n        return True if not count else False\n\n\n         "
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public boolean isValid(String x) {\n       Stack<Character> s = new Stack<>();\n        for(int i=0;i<x.length();i++){\n            if(x.charAt(i)=='{' ||x.charAt(i)=='['|| x.charAt(i)=='('){\n                s.push(x.charAt(i));\n            }\n            else{\n                if(s.isEmpty()) return false;\n                if((s.peek()=='(' && x.charAt(i)==')') || (s.peek()=='{' && x.charAt(i)=='}')|| (s.peek()=='[' && x.charAt(i)==']'))  s.pop();\n                else return false;\n            }\n        }\n        return (s.isEmpty());\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> st;\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='(' || s[i]=='[' || s[i]=='{')\n                st.push(s[i]);\n            else{\n                if(st.empty())\n                    return false;\n\n                if( (s[i]==')' && st.top()!='(') || \n                (s[i]=='}' && st.top()!='{') ||\n                (s[i]==']' && st.top()!='[') )\n                    return false;\n                    \n                else st.pop();\n            }\n        }\n        \n        return st.empty();\n    }\n};"
            }
        ]
    },
    "20": {
        "question_id": 21,
        "title": "Merge Two Sorted Lists",
        "difficulty": 1,
        "description": "You are given the heads of two sorted linked lists list1 and list2.Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.Return the head of the merged linked list. ",
        "examples": [
            {
                "input": "list1 = [1,2,4], list2 = [1,3,4]",
                "output": "[1,1,2,3,4,4]",
                "explanation": null
            },
            {
                "input": "list1 = [], list2 = []",
                "output": "[]",
                "explanation": null
            },
            {
                "input": "list1 = [], list2 = [0]",
                "output": "[0]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in both lists is in the range [0, 50].",
            "-100 <= Node.val <= 100",
            "Both list1 and list2 are sorted in non-decreasing order."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "1. Easy C++\n2. Line by Line Explanation with Comments.\n3. Detailed Explanation \u2705\n4. Linked list problem, merge.\n5. Please Upvote if it helps\u2b06\ufe0f\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \u2b07\ufe0f\n // \ud83d\ude09If you Like the repository don't foget to star & fork the repository\ud83d\ude09"
            },
            {
                "language": "kotlin",
                "code": "     // \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09Please upvote if it helps \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09\nclass Solution {\npublic:\n ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) \n  {\n  // if list1 happen to be NULL\n  // we will simply return list2.\n  if(l1 == NULL)\n        {\n   return l2;\n  }\n  \n  // if list2 happen to be NULL\n  // we will simply return list1.\n  if(l2 == NULL)\n        {\n   return l1;\n  } \n  \n  // if value pointend by l1 pointer is less than equal to value pointed by l2 pointer\n  // we wall call recursively l1 -> next and whole l2 list.\n  if(l1 -> val <= l2 -> val)\n        {\n   l1 -> next = mergeTwoLists(l1 -> next, l2);\n   return l1;\n  }\n  // we will call recursive l1 whole list and l2 -> next\n  else\n        {\n   l2 -> next = mergeTwoLists(l1, l2 -> next);\n   return l2;            \n  }\n }\n}; "
            },
            {
                "language": "rust",
                "code": "     // \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09Please upvote if it helps \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n       \n     // if list1 happen to be NULL\n  // we will simply return list2.\n        if(list1 == NULL)\n            return list2;\n  \n  // if list2 happen to be NULL\n  // we will simply return list1.\n        if(list2 == NULL)\n            return list1;\n        \n        ListNode * ptr = list1;\n        if(list1 -> val > list2 -> val)\n        {\n            ptr = list2;\n            list2 = list2 -> next;\n        }\n        else\n        {\n            list1 = list1 -> next;\n        }\n        ListNode *curr = ptr;\n        \n  // till one of the list doesn't reaches NULL\n        while(list1 &&  list2)\n        {\n            if(list1 -> val < list2 -> val){\n                curr->next = list1;\n                list1 = list1 -> next;\n            }\n            else{\n                curr->next = list2;\n                list2 = list2 -> next;\n            }\n            curr = curr -> next;\n                \n        }\n  \n  // adding remaining elements of bigger list.\n        if(!list1)\n            curr -> next = list2;\n        else\n            curr -> next = list1;\n            \n        return ptr;\n       \n    }\n};"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode *dummy, *temp;\n        dummy = new ListNode();\n        temp = dummy;\n        \n        //when both list1 and list2 isn't empty"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n   public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n    \n    if(list2==null) return list1;\n    if(list1==null) return list2;\n    \n    if(list1.val < list2.val) {\n        return mergeTwoListsUtil(list1, list2);"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        cur = dummy = ListNode()\n        while list1 and list2:               \n            if list1.val < list2.val:\n                cur.next = list1\n                list1, cur = list1.next, list1\n            else:\n                cur.next = list2\n                list2, cur = list2.next, list2\n                \n        if list1 or list2:\n            cur.next = list1 if list1 else list2\n            \n        return dummy.next"
            },
            {
                "language": "python",
                "code": "list1, cur = list1.next, list1"
            },
            {
                "language": "python",
                "code": "cur = cur.next; list1 = list1.next;"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        if not list1 and not list2:\n            return list1\n        if not list1 or not list2:\n            return list1 if not list2 else list2\n        seek, target = (list1, list2) if list1.val < list2.val else (list2, list1)\n        head = seek"
            },
            {
                "language": "python",
                "code": "if list1 is None and list2 is None:\n    return None\nelif list1 is None:"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        head = prev = ListNode()\n        get = lambda x,y: x if x.val < y.val else y\n        while l1 and l2:\n            prev.next = prev = (mini := get(l1,l2))\n            if mini == l1: l1 = l1.next\n            else: l2 = l2.next"
            },
            {
                "language": "rust",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode* dummy = new ListNode();\n        ListNode* ptr=dummy;\n        ListNode* list1ptr = list1;\n        ListNode* list2ptr =list2;\n\n        while(list1ptr!=NULL && list2ptr!=NULL){\n            if(list1ptr->val<=list2ptr->val){\n                ptr->next=list1ptr;\n                ptr=ptr->next;\n                list1ptr=list1ptr->next;\n            }\n            else{\n                ptr->next=list2ptr;\n                ptr=ptr->next;\n                list2ptr=list2ptr->next;\n            }\n        }\n        while(list1ptr!=NULL){\n                ptr->next=list1ptr;\n                ptr=ptr->next;\n                list1ptr=list1ptr->next;\n            }\n        while(list2ptr!=NULL){                \n            ptr->next=list2ptr;\n            ptr=ptr->next;\n            list2ptr=list2ptr->next;\n        }\n        ptr->next = NULL;\n        return dummy->next;\n    }\n};"
            },
            {
                "language": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} list1\n * @param {ListNode} list2\n * @return {ListNode}\n */\n\nvar mergeTwoLists = function(l1, l2) {\n    let tempNode = new ListNode(0, null);\n    let currentNode = tempNode;\n    \n    while (l1 && l2) {\n        if(l1.val < l2.val) {\n            currentNode.next = l1;\n            l1 = l1.next\n        } else {\n            currentNode.next = l2;\n            l2 = l2.next\n        }\n        currentNode = currentNode.next;\n    }\n    currentNode.next = l1 || l2;\n    \n    return tempNode.next;\n};"
            },
            {
                "language": "java",
                "code": "    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode prehead = new ListNode(-1);\n        ListNode cur = prehead;\n\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n\n        cur.next = l1 == null ? l2 : l1;\n        return prehead.next;\n    }"
            },
            {
                "language": "kotlin",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n\n        if(list1!=null && list2!=null){\n        if(list1.val<list2.val){\n            list1.next=mergeTwoLists(list1.next,list2);\n            return list1;\n            }\n            else{\n                list2.next=mergeTwoLists(list1,list2.next);\n                return list2;\n        }\n        }\n        if(list1==null)\n            return list2;\n        return list1;\n    }\n}"
            },
            {
                "language": "kotlin",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        if(list1 == null && list2 == null){return null;}\n        if(list1 == null && list2 != null){return list2;}\n        if(list1 != null && list2 == null){return list1;}\n        ListNode i = list1,j=list2;\n        ListNode head = null,tail=null;\n        while((i!=null) && (j!=null)){\n            if(i.val<=j.val){\n                if(head == null){\n                    head = i;\n                    tail = i;\n                    i  = i.next;\n                }else{\n                    tail.next = i;\n                    tail = tail.next;\n                    i = i.next;\n                }\n            }else{\n                if(head == null){\n                    head = j;\n                    tail = j;\n                    j  = j.next;\n                }else{\n                    tail.next = j;\n                    tail = tail.next;\n                    j = j.next;\n                }\n            }\n        }\n        while(i!=null){\n            tail.next=i;\n            tail = tail.next;\n            i = i.next;\n        }\n        while(j!=null){\n            tail.next=j;\n            tail = tail.next;\n            j = j.next;\n        }\n        return head;\n    }\n}"
            },
            {
                "language": "kotlin",
                "code": "    if (list1 == null && list2 == null) {\n        return null;\n    } \n    if (list1 == null) {\n        return list2;\n    }"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        out=dummy=ListNode()\n        while list1 and list2:\n            if list1.val<list2.val:\n                out.next=list1\n                list1=list1.next\n            else:\n                out.next=list2\n                list2=list2.next\n            out=out.next\n        if list1:\n            out.next=list1\n            list1=list1.next\n        if list2:\n            out.next=list2\n            list2=list2.next\n        return dummy.next"
            },
            {
                "language": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        head = movingtail = ListNode()\n        \n        while l1 and l2:\n            if l1.val <= l2.val:\n                movingtail.next = l1\n                l1 = l1.next\n            else:\n                movingtail.next = l2\n                l2 = l2.next\n            movingtail = movingtail.next\n            \n        movingtail.next = l1 or l2\n        return head.next"
            },
            {
                "language": "kotlin",
                "code": "var mergeTwoLists = function (l1, l2) {\n    if (!l1) return l2;\n    else if (!l2) return l1;\n    else if (l1.val <= l2.val) {\n        l1.next = mergeTwoLists(l1.next, l2);\n        return l1;\n    } else {\n        l2.next = mergeTwoLists(l1, l2.next);\n        return l2\n    }\n};"
            }
        ]
    },
    "21": {
        "question_id": 22,
        "title": "Generate Parentheses",
        "difficulty": 2,
        "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. ",
        "examples": [
            {
                "input": "n = 3",
                "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
                "explanation": null
            }
        ],
        "constraints": [],
        "solutions": [
            {
                "language": "ruby",
                "code": "def generateParenthesis(self, n: int) -> List[str]:\n def dfs(left, right, s):\n  if len(s) == n * 2:\n   res.append(s)\n   return \n\n  if left < n:\n   dfs(left + 1, right, s + '(')\n\n  if right < left:\n   dfs(left, right + 1, s + ')')\n\n res = []\n dfs(0, 0, '')\n return res"
            },
            {
                "language": "go",
                "code": "            (0, 0, '')\n              | \n         (1, 0, '(')  \n           /           \\\n       (2, 0, '((')      (1, 1, '()')\n          /                 \\\n      (2, 1, '(()')           (2, 1, '()(')\n         /                       \\\n     (2, 2, '(())')                (2, 2, '()()')\n            |                              |\n     res.append('(())')             res.append('()()')\n   "
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList<String>();\n        recurse(res, 0, 0, \"\", n);\n        return res;\n    }\n    \n    public void recurse(List<String> res, int left, int right, String s, int n) {\n        if (s.length() == n * 2) {\n            res.add(s);\n            return;\n        }\n        \n        if (left < n) {\n            recurse(res, left + 1, right, s + \"(\", n);\n        }\n        \n        if (right < left) {\n            recurse(res, left, right + 1, s + \")\", n);\n        }\n    }\n // See above tree diagram with parameters (left, right, s) for better understanding\n}"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        result = []\n        left = right = 0\n        q = [(left, right, '')]\n        while q:\n            left, right, s = q.pop()\n            if len(s) == 2 * n:"
            },
            {
                "language": "javascript",
                "code": "                                \"_  _  _  _\"\n                                / \\     \n                              '(' ')'"
            },
            {
                "language": "javascript",
                "code": "                                    op      ip\n                                    \"\"   O-3, C-3\n                            \n                                    \"(\",O-2,C-3\n                    \n                \"((\",O-1,C-3                            \"()\", O-2,C-2\n\n    \"(((\",0,3             \"(()\",1,2                       \"()(\",1,2\n\n    \"((()\",0,2      \"(()(\",0,2    \"(())\",1,1        \"()((\",0,2      \"()()\",1,1\n\n    \"((())\",0,1     \"(()()\",0,1   \"(())(\",0,1       \"()(()\",0,1     \"()()(\",0,1\n\n    \"((()))\",0,0   \"(()())\",0,0   \"(())()\",0,0      \"()(())\",0,0    \"()()()\", 0,0\n                        "
            },
            {
                "language": "go",
                "code": "class Solution {\npublic:\n    void solve(string op, int open, int close, vector<string> &ans){\n        if(open == 0 && close == 0){\n            ans.push_back(op);\n            return;\n        }\n        //when count of open and close brackets are same then \n        //we have only one choice to put open bracket \n        if(open == close){\n            string op1 = op;\n            op1.push_back('(');\n            solve(op1, open-1, close, ans);\n        }\n        else if(open == 0){\n            //only choice is to put close brackets \n            string op1 = op;\n            op1.push_back(')');\n            solve(op1, open, close-1, ans);\n        }\n        else if(close == 0){\n            //only choise is to use open bracket \n            string op1 = op;\n            op1.push_back('(');\n            solve(op1, open-1, close, ans);\n        }\n        else{\n            string op1 = op;\n            string op2 = op;\n            op1.push_back('(');\n            op2.push_back(')');\n            solve(op1, open-1, close, ans);\n            solve(op2, open, close-1, ans);\n        }\n    }\n    vector<string> generateParenthesis(int n) {\n        int open = n;\n        int close = n;\n        vector<string> ans;\n        string op = \"\";\n        solve(op, open, close, ans);\n        return ans;\n    }\n};"
            },
            {
                "language": "python",
                "code": "void    tryCombinations(int open, int close, vector<string>& res, string str)\n{\n        if (open == 0 && close == 0)\n        {\n            res.push_back(str);"
            },
            {
                "language": "go",
                "code": "class Solution {\npublic:\n    void solve(vector<string>& ans,string output,int open ,int close){\n        if(open==0 && close==0)\n        {\n            ans.push_back(output);\n            return;\n        }\n        //include open \n        if(open>0){\n            output.push_back('(');\n            solve(ans,output,open-1,close);\n            output.pop_back();\n        }\n        if(close>open){\n            output.push_back(')');\n            solve(ans,output,open,close-1);\n            output.pop_back();\n        }\n    }\n\n    vector<string> generateParenthesis(int n) {\n        vector<string> ans;\n    string output;\n    int open=n;\n    int close=n;\n    solve(ans,output,open,close);\n    return ans;\n    }\n};"
            },
            {
                "language": "rust",
                "code": "def foo(self, l, n):\n     yield from itertools.product(*([l] * n)) \n\n\ndef generateParenthesis(self, n: int) -> List[str]:\n    combos = []\n    res = []\n    for x in self.foo('()', n * 2):\n        combos.append(''.join(x))\n    for n in combos:\n        if self.isValid(n):\n            res.append(n)\n    return res\n        \ndef isValid(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    open_p = ['(', '[', '{']\n    closed_p = [')', ']', '}']\n    stack = []\n    for char in s:\n        if char in open_p:\n            stack.append(char)\n        else:\n            if stack != [] and stack[-1] == open_p[closed_p.index(char)]:\n                stack.pop()\n            else:\n                return False\n    return len(stack) == 0'''"
            },
            {
                "language": "python",
                "code": "from itertools import product\n\nclass Solution:\n    def generateParenthesis(self, n):\n        if n == 0:\n            return ['']\n        result = []\n        for i in range(n):\n            left_list = self.generateParenthesis(i)\n            right_list = self.generateParenthesis(n - i - 1)\n            for left, right in product(left_list, right_list):\n                result.append('({}){}'.format(left, right))\n        return result"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def generateParenthesis(self, n):\n        if not n:\n            return ['']\n        result = []\n        for i in range(n):\n            for left in self.generateParenthesis(i):\n                for right in self.generateParenthesis(n - i - 1):\n                    result.append('({}){}'.format(left, right))\n        return result"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def generateParenthesis(self, n):\n        if n == 0:\n            return ['']\n        return ['(' + left + ')' + right\n                for i in range(n)\n                for left in self.generateParenthesis(i)\n                for right in self.generateParenthesis(n - i - 1)]"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O((2^2*N)*N). For each of 2^2*N sequences, we need to create and validate the sequence,\n    which takes O(N) work.\n\n    Space Complexity : O((2^2*N)*N) vector(output) space.\n\n    Solved using Array + Backtracking. Brute Force Approach.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\nprivate:\n    bool valid(vector<char> temp){\n        int balance = 0;\n        for(auto c : temp){\n            if(c == '(') balance++;\n            else balance--;\n            if(balance < 0) return false;\n        }\n        return balance == 0;\n    }\n    void generateAllParenthesis(vector<string>& parenthesesCombinations, vector<char> temp, int position){\n        if(position == temp.size()){\n            if(valid(temp)){\n                string s(temp.begin(), temp.end());\n                parenthesesCombinations.push_back(s);\n            }\n            return;\n        }\n        temp[position] = '(';\n        generateAllParenthesis(parenthesesCombinations, temp, position+1);\n        temp[position] = ')';\n        generateAllParenthesis(parenthesesCombinations, temp, position+1); \n    }\npublic:\n    vector<string> generateParenthesis(int n) {\n        vector<string> parenthesesCombinations;\n        vector<char> temp(2*n);\n        generateAllParenthesis(parenthesesCombinations, temp, 0);\n        return parenthesesCombinations;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(O(2^2*N)The time complexity of the above code is O(2^(2N)) since in the worst case we\n    need to consider every possibility of opening and closing brackets where N = the number of pairs we need to\n    form.\n\n    Space Complexity : O((2^2*N)*N) vector(output) space.\n\n    Solved using Array + Backtracking. Brute Force Approach.\n\n*/\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\nprivate:\n    void recurse(vector<string>& output, string s, int open, int close, int n){\n        if(open==n and close==n){\n            output.push_back(s);\n            return;\n        }\n        if(open<n)\n            recurse(output, s+\"(\" , open+1, close, n);\n        if(close<open)\n            recurse(output, s+\")\", open, close+1, n);\n    }\npublic:\n    vector<string> generateParenthesis(int n) {\n        vector<string> output;\n        recurse(output, \"\", 0, 0, n);\n        return output;\n    }\n};"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList();\n        findAll(\"(\",1,0,res,n);\n\n        return res;\n    }\n\n    void findAll(String current,int op , int cl , List<String> res, int n){\n        if(current.length()==2*n){\n            res.add(current);\n            return;\n        }\n        if(op<n)\n        findAll(current+\"(\", op+1,cl,res,n);\n        if(cl<op)\n        findAll(current+\")\",op,cl+1,res,n);\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "}\n\nvoid findAll(String current,List<String> result,int op,int cl,int n){"
            },
            {
                "language": "python",
                "code": " public List<String> generateParenthesis(int n) {\n        List<String> list = new ArrayList<String>();\n        backtrack(list, \"\", 0, 0, n);\n        return list;\n    }\n    \n    public void backtrack(List<String> list, String str, int open, int close, int max){\n        \n        if(str.length() == max*2){\n            list.add(str);\n            return;\n        }\n        \n        if(open < max)\n            backtrack(list, str+\"(\", open+1, close, max);\n        if(close < open)\n            backtrack(list, str+\")\", open, close+1, max);\n    }"
            },
            {
                "language": "typescript",
                "code": "    public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList<>();\n        helper(res,n,0,\"\");"
            },
            {
                "language": "go",
                "code": "public List<String> generateParenthesis(int n) {\n     List<String> res = new ArrayList<>();\n     helper(res, new StringBuilder(), 0, 0, n);\n     return res;\n}\n\nprivate void helper(List<String> res, StringBuilder sb, int open, int close, int n) {"
            },
            {
                "language": "typescript",
                "code": "public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList<>();\n        if(n <= 0){\n            return res;\n        }\n        StringBuilder curr = new StringBuilder();\n        backTracking(n, n, res, curr);"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    vector<string> ans;\n    \n    void fun(int left,int right,string s)\n    {\n        if(left<0||right<0)\n        {\n          return;\n        }\n        if(left==0 and right==0)\n        {\n          ans.push_back(s);\n          return;\n        }\n      \n       fun(left-1,right,s+\"(\");\n    \n       if(right>left)\n    {\n    fun(left,right-1,s+\")\");\n    }\n    }\n    \n    vector<string> generateParenthesis(int n) {\n        fun(n,n,\"\");\n        return ans;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    \n    public void helper(StringBuilder s , int n , List<String> list, int L , int R){\n        if(s.length()==2*n ){\n            list.add(s.toString());\n            return;\n        }\n        if(L<n){\n            s.append('(');\n            helper( s, n , list, L+1, R );\n            s.deleteCharAt(s.length()-1);\n        } \n        if(R<L){\n            s.append(')');\n            helper( s, n , list , L , R+1); \n            s.deleteCharAt(s.length()-1);\n        } \n    }\n\n    public List<String> generateParenthesis(int n) {\n        List<String> list = new ArrayList<>();\n        StringBuilder s = new StringBuilder();\n        helper(s , n , list , 0 , 0);\n        return list;\n    }\n}"
            }
        ]
    },
    "22": {
        "question_id": 23,
        "title": "Merge k Sorted Lists",
        "difficulty": 3,
        "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.Merge all the linked-lists into one sorted linked-list and return it. ",
        "examples": [
            {
                "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
                "output": "[1,1,2,3,4,4,5,6]",
                "explanation": "The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6"
            },
            {
                "input": "lists = []",
                "output": "[]",
                "explanation": null
            },
            {
                "input": "lists = [[]]",
                "output": "[]",
                "explanation": null
            }
        ],
        "constraints": [
            "k == lists.length",
            "0 <= k <= 104",
            "0 <= lists[i].length <= 500",
            "-104 <= lists[i][j] <= 104",
            "lists[i] is sorted in ascending order.",
            "The sum of lists[i].length will not exceed 104."
        ],
        "solutions": [
            {
                "language": "php",
                "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode dummyNode = new ListNode();\n        ListNode tail = dummyNode;\n        while(list1 != null && list2 != null){\n            if(list1.val < list2.val){\n                tail.next = list1;\n                list1 = list1.next;\n            }else{"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if not lists:\n            return None\n        import heapq as hq\n        heap = []\n        for i in range(len(lists)):"
            },
            {
                "language": "cpp",
                "code": "  //RUNTIME: 18 - 27 MS\n   //TIME COMPLEXITY: O(n log n), where n is the total number of nodes in our parameter lists\n   //SPACE COMPLEXITY: O(n), where n is the total number of nodes in our parameter lists\n\n   //Add node values to a PQ. Add each val along with its index in lists to a vector. \n   //Need to use a vector because we can't change what each element is linked to while it's\n   //in the PQ, so we will find out the order and THEN modify the node's connections"
            },
            {
                "language": "ruby",
                "code": ""
            },
            {
                "language": "ruby",
                "code": ""
            },
            {
                "language": "kotlin",
                "code": "import java.util.TreeMap"
            },
            {
                "language": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def mergeKLists(self,lists:List[Optional[ListNode]])->Optional[ListNode]:\n        values,head,pointer=[],None,None\n        for l in lists:\n            while l:\n                heappush(values,l.val)\n                l=l.next\n\n        while values:\n            if head is None:\n                head=ListNode(heappop(values))\n                pointer=head\n\n            else:\n                pointer.next=ListNode(heappop(values))\n                pointer=pointer.next\n\n        return head                              "
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if(lists.size() == 0) return NULL;\n        return mergeKListsHelper(lists, 0, lists.size()-1);\n    }\n\n    ListNode* mergeKListsHelper(vector<ListNode*>& lists, int start, int end) {\n        if(start>end) return NULL; \n        if(start==end) return lists[start];\n\n        int mid = start + (end-start)/2;\n        ListNode* left = mergeKListsHelper(lists, start, mid);\n        ListNode* right = mergeKListsHelper(lists, mid + 1, end);\n        return merge(left, right);\n    }\n\n    ListNode* merge(ListNode* list1Head, ListNode* list2Head) {\n        ListNode* dummyHead = new ListNode(-1);\n        ListNode* dummyTail = dummyHead;\n\n        while(list1Head!=NULL && list2Head!=NULL){\n            if(list1Head->val < list2Head->val){\n                dummyTail->next = list1Head;\n                list1Head = list1Head->next;\n            }else{\n                dummyTail->next = list2Head;\n                list2Head = list2Head->next;\n            }\n            dummyTail = dummyTail->next;\n        }\n        dummyTail->next = (list1Head != NULL) ? list1Head : list2Head;\n        return dummyHead->next;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if(lists.size() == 0) return NULL;\n\n        ListNode* dummyHead = new ListNode(-1);\n        ListNode* dummyTail = dummyHead;\n\n        priority_queue<pair<int, ListNode*>, vector<pair<int, ListNode*>>, greater<pair<int, ListNode*>>> pq;\n        for(auto head : lists)  if(head != NULL) pq.push({head->val, head});\n\n        while(!pq.empty()){\n            ListNode* minNode = pq.top().second;\n            pq.pop();\n            if(minNode->next != NULL) pq.push({minNode->next->val, minNode->next});\n\n            dummyTail->next = minNode;\n            dummyTail = dummyTail->next;\n        }\n        return dummyHead->next;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            return null;\n        }\n        return mergeKListsHelper(lists, 0, lists.length - 1);\n    }\n    \n    private ListNode mergeKListsHelper(ListNode[] lists, int start, int end) {\n        if (start == end) {\n            return lists[start];\n        }\n        if (start + 1 == end) {\n            return merge(lists[start], lists[end]);\n        }\n        int mid = start + (end - start) / 2;\n        ListNode left = mergeKListsHelper(lists, start, mid);\n        ListNode right = mergeKListsHelper(lists, mid + 1, end);\n        return merge(left, right);\n    }\n    \n    private ListNode merge(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        \n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                curr.next = l1;\n                l1 = l1.next;\n            } else {\n                curr.next = l2;\n                l2 = l2.next;\n            }\n            curr = curr.next;\n        }\n        \n        curr.next = (l1 != null) ? l1 : l2;\n        \n        return dummy.next;\n    }\n}"
            },
            {
                "language": "rust",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\nprivate:\n    ListNode* merge(vector<ListNode*>& lists, int start, int end) {\n        if (start == end) {\n            return lists[start];\n        }\n\n        int mid = (start + end) / 2;\n        ListNode* one = merge(lists, start, mid);\n        ListNode* two = merge(lists, mid + 1, end);\n        ListNode* head;\n        ListNode* cur;\n\n        if (one && two) {\n            if (one->val < two->val) {\n                cur = one;\n                head = one;\n                one = one->next;\n            } else {\n                cur = two;\n                head = two;\n                two = two->next;\n            }\n        } else if (one) {\n            cur = one;\n            head = one;\n            one = one->next;\n        } else if (two) {\n            cur = two;\n            head = two;\n            two = two->next;\n        }\n\n        while (one && two) {\n            if (one->val < two->val) {\n                cur->next = one;\n                cur = cur->next;\n                one = one->next;\n            } else {\n                cur->next = two;\n                cur = cur->next;\n                two = two->next;\n            }\n        }\n        \n        if (one) {\n            cur->next = one;\n        } else if (two) {\n            cur->next = two;\n        }\n\n        return head;\n    }\n\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if (lists.size() == 0) return nullptr;\n\n        return merge(lists, 0, lists.size() - 1);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        vector<int> ans;\n        int n = lists.size();\n        for(int i=0;i<n;i++){\n            while(lists[i] != NULL){\n                ans.push_back(lists[i]->val);\n                lists[i] = lists[i]->next;\n            }\n        }\n        sort(ans.begin(),ans.end());\n        ListNode* head = NULL;\n        ListNode* curr = NULL;\n        for(int i=0;i<ans.size();i++){\n            ListNode* newNode = new ListNode();\n            newNode->val = ans[i];\n            newNode->next = NULL;\n            if(head == NULL){\n                head = newNode;\n                curr = newNode;\n            }\n            else{\n                curr->next = newNode;\n                curr = newNode;\n            }\n        }\n        return head;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if(lists.size()==0) return NULL;\n\n        vector<int> v;\n        for(int i=0; i<lists.size(); i++){\n            ListNode *curr = lists[i];\n            if(curr==NULL) continue;\n            while(curr!=NULL){\n                v.push_back(curr->val);\n                curr = curr->next;\n            }\n        }\n        if(v.empty()) return NULL;\n        sort(v.begin(),v.end());\n\n        ListNode *head = new ListNode(v[0]);\n        ListNode *curr = head;\n        for(int i=1; i<v.size(); i++){\n            ListNode *temp = new ListNode(v[i]);\n            curr->next = temp;\n            curr = curr->next;\n        }\n        return head;\n    }\n};"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    ListNode* merge(ListNode* head1,ListNode* head2){\n        ListNode* head=NULL;\n        ListNode* tail=NULL;\n        while(head1&&head2){\n            if(head1->val<=head2->val){\n                if(!head){\n                    head=head1;\n                    tail=head;\n                }\n                else{\n                    tail->next=head1;\n                    tail=tail->next;\n                }\n                head1=head1->next;\n            }\n            else{\n                if(!head){\n                    head=head2;\n                    tail=head;\n                }\n                else{\n                    tail->next=head2;\n                    tail=tail->next;\n                }\n                head2=head2->next;\n            }\n        }\n        while(head1){\n            if(!head){\n                head=head1;\n                tail=head;\n            }\n            else{\n                tail->next=head1;\n                tail=tail->next;\n            }\n            head1=head1->next;\n        }\n        while(head2){\n            if(!head){\n                head=head2;\n                tail=head;\n            }\n            else{\n                tail->next=head2;\n                tail=tail->next;\n            }\n            head2=head2->next;            \n        }\n        return head;\n    }\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        int n=lists.size();\n        if(lists.empty()) return NULL;\n        ListNode* head=lists[0];\n        for(int i=1;i<n;i++){\n            head=merge(head,lists[i]);\n        }\n        return head;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* merge(ListNode *left, ListNode *right) {\n        ListNode *dummy = new ListNode(-1);\n        ListNode *temp = dummy;\n        while (left != nullptr && right != nullptr) {\n            if (left -> val < right -> val) {\n                temp -> next = left;\n                temp = temp -> next;\n                left = left -> next;\n            }\n            else {\n                temp -> next = right;\n                temp = temp -> next;\n                right = right -> next;\n            }\n        }\n        while (left != nullptr) {\n            temp -> next = left;\n            temp = temp -> next;\n            left = left -> next;\n        }\n        while (right != nullptr) {\n            temp -> next = right;\n            temp = temp -> next;\n            right = right -> next;\n        }\n        return dummy -> next;\n    }\n    ListNode* mergeSort(vector<ListNode*>& lists, int start, int end) {\n        if (start == end) \n            return lists[start];\n        int mid = start + (end - start) / 2;\n        ListNode *left = mergeSort(lists, start, mid);\n        ListNode *right = mergeSort(lists, mid + 1, end);\n        return merge(left, right);\n    }\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if (lists.size() == 0)\n            return nullptr;\n        return mergeSort(lists, 0, lists.size() - 1);\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        v=[]\n        for i in lists:\n            x=i\n            while x:\n                v+=[x.val]\n                x=x.next\n        v=sorted(v,reverse=True)\n        ans=None\n        for i in v:\n            ans=ListNode(i,ans)\n        return ans"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        vector<int>v;\n        for(int i=0;i<lists.size();i++){\n            while(lists[i]){\n                v.push_back(lists[i]->val);\n                lists[i]=lists[i]->next;\n            }\n        }\n        sort(rbegin(v),rend(v));\n        ListNode* ans=nullptr;\n        for(int i=0;i<v.size();i++){\n            ans=new ListNode(v[i],ans);\n        }\n        return ans;\n    }\n};"
            }
        ]
    },
    "23": {
        "question_id": 24,
        "title": "Swap Nodes in Pairs",
        "difficulty": 2,
        "description": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.) ",
        "examples": [
            {
                "input": "head = [1,2,3,4]",
                "output": "[2,1,4,3]",
                "explanation": null
            },
            {
                "input": "head = []",
                "output": "[]",
                "explanation": null
            },
            {
                "input": "head = [1]",
                "output": "[1]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the\u00a0list\u00a0is in the range [0, 100].",
            "0 <= Node.val <= 100"
        ],
        "solutions": [
            {
                "language": "ruby",
                "code": "prevNode->next = currNode->next"
            },
            {
                "language": "ruby",
                "code": "currNode->next = prevNode->next->next"
            },
            {
                "language": "ruby",
                "code": "prevNode->next->next = currNode"
            },
            {
                "language": "java",
                "code": "prevNode = currNode\ncurrNode = currNode->next"
            },
            {
                "language": "rust",
                "code": "ListNode* swapPairs(ListNode* head) {\n        if(!head || !head->next) return head; //If there are less than 2 nodes in the given nodes, then no need to do anything just return the list as it is.\n  \n        ListNode* dummyNode = new ListNode();\n        \n        ListNode* prevNode=dummyNode;\n        ListNode* currNode=head;\n        \n        while(currNode && currNode->next){\n            prevNode->next = currNode->next;\n            currNode->next = prevNode->next->next;\n            prevNode->next->next = currNode;\n            \n            prevNode = currNode;\n            currNode = currNode->next;\n        }\n        \n        return dummyNode->next;\n    }"
            },
            {
                "language": "java",
                "code": "public ListNode swapPairs(ListNode head) {\n    ListNode temp = new ListNode(0);\n    temp.next = head;\n    ListNode first = head;\n    if (head != null && head.next != null) {\n      first = head.next;\n    }\n    while (temp.next != null && temp.next.next != null) {"
            },
            {
                "language": "ruby",
                "code": "def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n    \"\"\" O(N)TS \"\"\"\n    if (n1 := head) and (n2 := head.next):\n        n2.next, n1.next = n1, self.swapPairs(n2.next)\n        return n2\n    return head"
            },
            {
                "language": "javascript",
                "code": "head = dummyNode->next;\ndelete dummyNode;\n\nreturn head;"
            },
            {
                "language": "ruby",
                "code": "class Solution {\n    public ListNode swapPairs(ListNode head) {\n      if (head == null || head.next == null) \n          return head;\n        ListNode new_head = head.next;\n        ListNode temp = head.next.next;\n        new_head.next = head;"
            },
            {
                "language": "scala",
                "code": "Let's take an example not given in question -\nSuppose our head pointer given to us as [1,9,2,8,3,7]\n\nSo, we have to swap every two adjcant nodes,\nthe answer should be [9,1,8,2,7,3]"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        // if head is NULL OR just having a single node, then no need to change anything \n        if(head == NULL || head -> next == NULL) \n        {\n            return head;\n        }\n            \n        ListNode* temp; // temporary pointer to store head -> next\n        temp = head->next; // give temp what he want\n        \n        head->next = swapPairs(head->next->next); // changing links\n        temp->next = head; // put temp -> next to head\n        \n        return temp; // now after changing links, temp act as our head\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr ||\n            head->next == nullptr) {\n            return head;\n        }\n        "
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    ListNode *swapPairs(ListNode *head) {\n        if (!head or !head->next) return head;\n        ListNode *curr = head, *next = head->next;\n        while (next and next->next)\n        {\n            swap(curr->val, next->val);"
            },
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(!head || !head->next)    return head;\n        \n        ListNode* curr = head;\n        ListNode* temp = curr->next;\n        "
            },
            {
                "language": "ruby",
                "code": "def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n if not head: return head\n\n prev, cur, ans = None, head, head.next\n while cur and cur.next:\n  adj = cur.next\n  if prev: prev.next = adj\n\n  cur.next, adj.next = adj.next, cur\n  prev, cur = cur, cur.next\n\n return ans or head"
            },
            {
                "language": "ruby",
                "code": "    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(None, head)\n        prev, cur = dummy, head\n        while cur and cur.next:\n            prev.next = cur.next"
            },
            {
                "language": "ruby",
                "code": "class Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode sentinal = new ListNode(-1);\n        ListNode prev = sentinal;\n        while(head != null && head.next != null){\n            prev.next  = head.next;\n            ListNode next = head.next.next;"
            },
            {
                "language": "ruby",
                "code": ""
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or head.next is None:\n            return head\n        \n        swap1 = swap2 = None"
            },
            {
                "language": "go",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    let arr = []\n    let res = new ListNode()\n    let copy = res;\n    while(head){\n        arr.push(head.val)\n        head = head.next;\n    }\n    let len = arr.length % 2 ==0 ? arr.length : arr.length-1;\n    \n    for(let i =0; i <len; i++){\n        if(i % 2 == 0) copy.next = new ListNode(arr[i+1])\n        else copy.next = new ListNode(arr[i-1])\n        copy = copy.next;\n    }\n    if(arr.length % 2 ==1){\n        copy.next = new ListNode(arr[arr.length-1])\n        copy = copy.next;\n    }\n    return res.next;\n};"
            },
            {
                "language": "rust",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head==NULL || head->next==NULL) \n            return head;\n        ListNode *p1=head,*p2=head->next,*p3=p2->next;\n        head=p2;\n        int flag=0;\n        while(p3!=NULL)\n        {\n            p2->next=p1;\n            p1->next=p3->next;\n            p2=p1->next;\n            \n            if(p2!=NULL)\n            {\n                p1=p3;\n                p3=p2->next;\n            }\n            else\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n            p2->next=p1;\n            p1->next=p3;\n        }\n        else\n        {\n            p1->next=p3;\n        }\n        return head;\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        a=b=head\n        c=d=ListNode()\n        z=None\n        while head and head.next:\n            x=head.next\n            head.next=z\n            z=head\n            head=x\n            y=head.next\n            head.next=z\n            z=head\n            head=y\n            c.next=z\n            c=c.next.next\n            z=None\n        if head:\n            c.next=head\n        return d.next"
            },
            {
                "language": "rust",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(!head)return head;\n        else if(!head->next)return head;\n        else{\n            ListNode* temp=new ListNode(); temp=head;\n            head=head->next;\n            while(temp->next){\n                ListNode* i=temp->next;ListNode*j=temp->next->next;\n                if(!j){\n                    temp->next=j;\n                    i->next=temp;\n                    break;\n                }\n                else if(!j->next){\n                    temp->next=j;\n                    i->next=temp;\n                    break;\n                }\n                else{\n                    temp->next=j->next;\n                    i->next=temp;\n                    temp=j;\n                }\n            }\n            return head;\n        }\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "    public ListNode swapPairs(ListNode head) {\n        if(head==null) return head;\n        List<ListNode> l1 = new ArrayList<>();\n        List<ListNode> l2 = new ArrayList<>();\n        int counter=0;\n        while (head!=null){\n            if(counter%2==0){\n                l1.add(head);\n                head=head.next;\n                counter++;\n            }else {\n                l2.add(head);\n                head=head.next;\n                counter++;\n            }\n        }\n\n        if(l2.size()!=0) {\n            head = l2.get(0);\n        }\n        else {\n            head = l1.get(0);\n            return head;\n        }\n        counter=0;\n        while (counter<l2.size()){\n              l2.get(counter).next=l1.get(counter);\n              if(l2.size()>counter+1)\n              l1.get(counter).next=l2.get(counter+1);\n\n            counter++;\n        }\n     if(l2.size()!=l1.size())\n        l1.get(l1.size()-2).next=l1.get(l1.size()-1);\n     else\n         l1.get(l1.size()-1).next=null;\n\n        return head;\n    }"
            },
            {
                "language": "rust",
                "code": "impl Solution {\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        if head.is_none() { return None; }\n\n        let mut one = head.clone();\n        let mut one_pointer = &mut one;\n\n        while let Some(node) = one_pointer {\n            if node.next.is_none() { return one; }\n            \n            let mut temp = node.next.as_mut().unwrap().next.clone();\n            std::mem::swap(&mut node.next,&mut temp);\n\n            temp.as_mut().unwrap().next = Some(Box::new(*node.clone()));\n            std::mem::swap(node, &mut temp.as_mut().unwrap());\n\n            one_pointer = &mut node.next.as_mut().unwrap().next;\n        }\n\n        one\n    }\n}"
            },
            {
                "language": "python",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head==null||head.next==null){\n            return head;\n        }\n        ListNode prv=head;\n        ListNode curr=head.next;\n        ListNode next=head.next.next;\n        head=curr;\n        head.next=prv;\n        head.next.next=swapPairs(next);\n        return head;\n    }\n}"
            }
        ]
    },
    "24": {
        "question_id": 25,
        "title": "Reverse Nodes in k-Group",
        "difficulty": 3,
        "description": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.You may not alter the values in the list's nodes, only nodes themselves may be changed. ",
        "examples": [
            {
                "input": "head = [1,2,3,4,5], k = 2",
                "output": "[2,1,4,3,5]",
                "explanation": null
            },
            {
                "input": "head = [1,2,3,4,5], k = 3",
                "output": "[3,2,1,4,5]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is n.",
            "1 <= k <= n <= 5000",
            "0 <= Node.val <= 1000"
        ],
        "solutions": [
            {
                "language": "go",
                "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n\n/* Recursive Solution */\n\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\n    l := length(head)\n    return reverse(head, l, k)\n}\n\nfunc reverse(node *ListNode, l, k int) *ListNode {\n    if l < k {\n        return node\n    }\n\n    var prev, next *ListNode\n    curr := node\n    for i := 0; i < k; i++ {\n        next = curr.Next\n        curr.Next = prev\n        prev = curr\n        curr = next\n    }\n\n    node.Next = reverse(next, l-k, k)\n    return prev\n}\n\nfunc length(head *ListNode) int {\n    count := 0\n\n    for head != nil {\n        head = head.Next\n        count++\n    }\n    return count\n}\n\n/* Iterative Solution */\n\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\n    if head == nil || k == 1 {\n        return head\n    }\n\n    l := length(head)\n    preHead := &ListNode{Next: head}\n\n    prev := preHead\n    for l >= k {\n        curr := prev.Next\n        for i := 1; i < k; i++ {\n            next := curr.Next\n            curr.Next = next.Next\n            next.Next = prev.Next\n            prev.Next = next\n        }\n        prev = curr\n        l -= k\n    }\n\n    return preHead.Next\n}\n\nfunc length(head *ListNode) int {\n    count := 0\n\n    for head != nil {\n        head = head.Next\n        count++\n    }\n    return count\n}"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        if(k<=1)\n        return head;\n        ListNode *t=head;\n        ListNode *p=head->next;\n        ListNode *x=head;\n        ListNode *tmp=head;\n        ListNode *dmy=new ListNode;\n        int n,c=0,f=0;\n        while(t){\n                t=t->next;\n                c++;\n            }\n        t=head;\n        n=c/k;\n// pointing pointer x to the node where the previous node to be added.\n        for(int i=0;i<n;i++){\n            int j=0;\n            while(j<k){ \n                if(x->next==NULL){\n                    dmy->val=x->val;\n                        x->next=dmy;\n                        x=x->next;\n                        f=1;\n                        break;\n                    }\n                     x=x->next;\n                    j++;\n                }\n//adding the nodes\n                int l=0;\n                while(l<k){\n                    t->next=x;\n                    x=t;\n                    t=p;\n                    p=p->next;\n                l++;\n                }\n                if(i==0){              //maintaining head position, only in \n                head=x;                // first iteration.\n                tmp=x;\n                }\n                else{                 // linking the previous nodes.\n                    int y=0; \n                    while(y<(k-1)){\n                        tmp=tmp->next;\n                        y++;\n                        }\n                    tmp->next=x;\n                    tmp=x;\n                }\n                x=t;\n        }\n\n        while(tmp){\n            if(tmp->next==NULL)\n                return head;\n                \n            else if(tmp->next==dmy){\n                tmp->next=NULL;\n                return head;\n                }\n            tmp=tmp->next;\n            \n        }\n    return head;\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        int x = k;\n        ListNode* p = head;\n        while(x>0&&p){\n            p = p->next;\n            x--;\n        }\n        if(x==0){\n            ListNode* pre = NULL,*next = NULL,*curr = head;\n            while(curr != p){\n                next = curr->next;\n                curr->next = pre;\n                pre = curr;\n                curr = next;\n            }\n            head->next = reverseKGroup(p,k);\n            return head = pre;\n        }else{\n            return head;\n        }\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun reverseKGroup(head: ListNode?, k: Int): ListNode? {\n\n        var cur = head\n        var prev: ListNode? = null\n        var newHead = head\n        while(cur != null)\n        {\n            var i = 0\n            var end = cur\n            while( end != null && i < k)\n            {\n                end = end?.next\n                i++\n            }\n            if(i == k)\n            {\n                if(cur == head)\n                newHead = reverse(cur,end)\n                else\n                prev?.next = reverse(cur,end)\n            }\n            prev = cur\n            cur = end\n        }\n\n        return newHead\n    }\n\n    fun reverse(cur1: ListNode?, end: ListNode?): ListNode?{\n\n        var prev = end\n        var cur = cur1\n        while(cur != end)\n        {\n            val temp = cur?.next\n            cur?.next = prev\n            prev = cur\n            cur = temp\n        }\n\n        return prev\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* curr, int k) {\n        int t=0;\n        ListNode* prev=nullptr, *check=curr;\n        while(t<k && check!=nullptr) check=check->next,t++;   //checking if there are k nodes left to be reversed (using loop)\n        if(t<k) return curr;  // if there are less than k nodes we need not reverse so return the normal List\n        while(t-- && curr!=nullptr){   // reversing loop\n            ListNode* next= curr->next;\n            curr->next=prev;\n            prev=curr;\n            curr=next;\n        }\n        ListNode* tail=prev;  //iterating till tail of the current reversed List\n        while( tail!=nullptr && tail->next!=nullptr) tail=tail->next;  //  so that we can attach it to  recursively reversed upcomming List\n        tail->next = curr ? reverseKGroup(curr,k) : nullptr;  //attacing the next upcomming reverse list the current reversed List\n        return prev;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* curr, int k) {\n        int t=0;\n        ListNode* prev=nullptr, *check=curr;\n        while(t<k && check!=nullptr) check=check->next,t++;\n        if(t<k) return curr;\n        while(t-- && curr!=nullptr){\n            ListNode* next= curr->next;\n            curr->next=prev;\n            prev=curr;\n            curr=next;\n        }\n        ListNode* tail=prev;\n        while( tail!=nullptr && tail->next!=nullptr) tail=tail->next;\n        tail->next = curr ? reverseKGroup(curr,k) : nullptr;\n        return prev;\n    }\n};"
            },
            {
                "language": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        //if head is null return null\n        //if k == 1 then no change is required.\n        if(head == null || k < 2)\n            return head;\n\n\n        // Cut the chain in 3 parts.\n        // 1. prevChain: this node contains the last value of previous chain. Previous chain is the already processed chain.\n        // 2. current chain: The chain that will be reversed in current iteration.\n        //       at first - currentChainStart will contain the starting node of current chain and currentChainEnd will\n        //                   contain the last node of current chain.\n        //       after processing - currentChainStart will become the last node of current chain and currentChainEnd will\n        //                   become the first node of current chain.\n        // 3. remainingChain: this node will contain the first node of remaining chain to be processed.\n        //\n        ListNode prevChain = null, currentChainStart, currentChainEnd = null, remainingChain = head;\n\n        //we will assign this value after first processing is done.\n        head = null;\n\n        //until all nodes are processed.\n        while (remainingChain != null){\n            currentChainStart = remainingChain;\n\n            //cut the chain and take current chain with length k. Will process this chain in this iteration.\n            int count = 0;\n            while (count < k && remainingChain != null){\n                currentChainEnd = remainingChain;\n                remainingChain = remainingChain.next;\n                count++;\n            }\n\n            //if we found enough node only then we reverse them.\n            if(count == k){\n                reverse(currentChainStart, k);\n                if(head == null)\n                    head = currentChainEnd; //remember this node has become the first node of reversed chain.\n\n                if (prevChain != null) {\n                    //must link the last node of previous chain with first node of current processed chain.\n                    prevChain.next = currentChainEnd;\n                }\n                prevChain = currentChainStart; //remember this node has become the last node of reversed chain.\n            }\n            //this case only happen if k > total node count of the list.\n            else if(head == null){\n                head = currentChainStart; // as no reverse happened so start node remains start of the chain.\n            }\n            //this case only happens if last < k nodes remains unchanged.\n            else if(prevChain != null)\n                prevChain.next = currentChainStart;\n\n        }\n\n        return head;\n    }\n\n    /**\n     * Recursively reverse the linked list starting from the given node. And return the last node of the linked list\n     * after processing.\n     *\n     * For example - before calling this method if list looks like 1 --> 2 --> 3 -- [any value] will reverse it\n     * like 3 --> 2 --> 1 --> null\n     *\n     * After processing this method will return node with value 1\n     *\n     * @param node current node of the linked list. This node will be appended at the last of result from recursive call.\n     * @param nodeCount remaining node count for this list.\n     * @return the last node of the processed linked list.\n     */\n    private ListNode reverse(ListNode node, int nodeCount){\n        if(nodeCount < 2)\n            return node;\n        ListNode result = reverse(node.next, nodeCount - 1);\n        result.next = node;\n        node.next = null;\n        return node;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        \n    if(head==NULL)\n        return NULL;\n    \n    //reverse 1st k nodes\n    ListNode* forward=NULL;\n    ListNode* prev=NULL;\n    ListNode* curr=head;\n    int cnt=0;\n    \n    ListNode* cursor = head;\n    for(int i = 0; i < k; i++){\n         if(cursor == nullptr) \n             return head;\n         cursor = cursor->next;\n    }\n    while(curr!=NULL && cnt<k ){\n        forward=curr->next;\n        curr->next=prev;\n        prev=curr;\n        curr=forward;\n        cnt++;\n    }\n    \n    head->next=reverseKGroup(forward,k);\n    return prev;\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        if(head==null || k==1)return head;\n\n        ListNode dum = new ListNode(0);\n        dum.next=head;\n\n        ListNode curr=dum, nex=dum, prev=dum;\n\n        int count=0;\n        while(curr.next!=null){\n            curr=curr.next;\n            count++;\n        }\n\n        while(count>=k){\n            curr=prev.next;\n            nex=curr.next;\n            for(int i=1; i<k; i++){\n                curr.next=nex.next;\n                nex.next=prev.next;\n                prev.next=nex;\n                nex=curr.next;\n            }\n            prev=curr;\n            count-=k;\n        }\n        return dum.next;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n    if (head == NULL || head->next == NULL) {\n        return head;\n    }\n    ListNode *prev = NULL;\n    ListNode *newHead = NULL, *c_node = NULL, *temp = NULL;\n    while (head != NULL) {\n        int i = 0;\n        ListNode *current = head;\n        while(i<k and current!=NULL){\n            i++;\n            current = current->next;\n        }\n        if(i == k) {\n            i = 0;\n            while (head != NULL and i < k) {\n                ListNode *next = head->next;\n                head->next = prev;\n                prev = head;\n                if (c_node == NULL) {\n                    c_node = prev;\n                }\n                head = next;\n                i++;\n            }\n            if (newHead == NULL) {\n                newHead = prev;\n                temp = c_node;\n            } else {\n                temp->next = prev;\n                temp = c_node;\n            }\n            c_node = NULL;\n            prev = NULL;\n        }\n        else {\n            if(newHead == NULL){\n                return head;\n            }\n            else{\n                temp->next = head;\n                break;\n            }\n        }\n\n    }\n    return newHead;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        int n = 0;\n        ListNode temp = head;\n        while(temp != null){\n            temp  = temp.next;\n            n++;\n        }\n        ListNode ddfd = new ListNode(3423);\n        ddfd.next = head;\n        ListNode firstNode = ddfd;\n        ListNode tempNode = head;\n        int ptr = 1;\n        int kptr = 1;\n        ListNode cur = head;\n        ListNode prev = null;\n        if(k == 1) return ddfd.next;\n        while(cur != null){\n            ListNode next = cur.next;\n            cur.next = prev;\n            prev = cur;\n            cur = next;\n           // tempNode.next = null;\n            if(kptr == k){\n                firstNode.next = prev;\n                firstNode = tempNode;\n                firstNode.next = null;\n                tempNode = cur;\n                kptr = 0;\n                if(ptr + k > n ){\n                    firstNode.next = cur;\n                    //System.out.println(\"breaked \" + ptr + \" \" + firstNode.val);\n                    return ddfd.next;\n                }\n            }\n            \n            ptr++;\n            kptr++;\n        }\n        return ddfd.next;\n    }\n    \n}"
            }
        ]
    },
    "25": {
        "question_id": 26,
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": 1,
        "description": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.Consider the number of unique elements of nums be k, to get accepted, you need to do the following things:Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.Return k.Custom Judge:The judge will test your solution with the following code:int[] nums = [...]; // Input arrayint[] expectedNums = [...]; // The expected answer with correct lengthint k = removeDuplicates(nums); // Calls your implementationassert k == expectedNums.length;for (int i = 0; i < k; i++) {    assert nums[i] == expectedNums[i];}If all assertions pass, then your solution will be accepted. ",
        "examples": [
            {
                "input": "nums = [1,1,2]",
                "output": "2, nums = [1,2,_]",
                "explanation": "Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            },
            {
                "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
                "output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
                "explanation": "Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            }
        ],
        "constraints": [
            "1 <= nums.length <= 3 * 104",
            "-100 <= nums[i] <= 100",
            "nums is sorted in non-decreasing order."
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        mp=defaultdict(int)\n        ans=[]\n        x=0\n        for i in nums:\n            mp[i]+=1\n            if mp[i]==1:\n                nums[x]=i\n                x+=1\n        return len(mp)"
            },
            {
                "language": "go",
                "code": "func removeDuplicates(nums []int) int {\n    prev := nums[0]\n    l := 1\n    for i := 1; i < len(nums); i++ {\n        if nums[i] != prev {\n            nums[l] = nums[i]\n            l++\n        } \n        prev = nums[i]\n    }\n    return l\n}"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        i,j=0,1\n        while i<=j and j<len(nums):\n            if nums[i]==nums[j]:\n                j+=1\n            else:\n                nums[i+1]=nums[j]\n                i+=1\n        return i+1\n\n\n        "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n    set<int> s; \n        for(int i =0; i<nums.size(); i++)\n        {\n            s.insert(nums[i]);\n        }\n        \n        int ans = s.size();\n        nums.clear();\n        for(auto i:s)\n        {\n           //int k = *i;\n           nums.push_back(i);\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "",
                "code": "IF MY EFFORTS HELP YOU PLEASE LIKE IT\ud83d\ude0a\ud83d\ude0a"
            },
            {
                "language": "csharp",
                "code": "public int removeDuplicates(int[] nums) {\n        \n        int newIndex = 1; // Start with index 1 because the first element is already in place\n\n        for (int i = 0; i < nums.length - 1; i++) {\n\n            if (nums[i] < nums[i+1]) { // If the current element is less than the next element\n            \n                nums[newIndex] = nums[i+1]; // Move the next element to the new index\n                newIndex++; // Increment the new index\n            }\n        }\n    return newIndex; // Return the length of the new subarray\n\n\n\n---\nSecond Approach (here we are using extra space for this space complexity will be O(N))\n\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n\n        //Insert all array element in the Set. \n        //Set does not allow duplicates and sets like LinkedHashSet maintains the order of insertion so it will remove duplicates and elements will be printed in the same order in which it is inserted\n\n        LinkedHashSet<Integer> set = new LinkedHashSet<>();\n\n        for(int i = 0; i < nums.length; i++){\n            set.add(nums[i]);\n        }\n        //copy unique element back to array\n        int i = 0;\n\n        for(int ele:set){\n            nums[i++] = ele;\n        }\n        return set.size();\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        if(nums.length == 0)\n            return 0;\n        \n        int addIndex = 1; //index that unique characters will be inserted at\n\n        for(int i = 0; i < nums.length - 1; i++) {\n            \n            if(nums[i] < nums[i + 1]){ //if true, num[i + 1] is a new unique number\n              nums[addIndex] = nums[i + 1];\n              addIndex++;\n            }\n        }\n        return addIndex;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        int count = 0;\n        for(int i = 1; i< nums.length;i++)\n        {\n            if(nums[count] != nums[i])\n            {\n                nums[count+1] = nums[i];\n                count++;\n            }\n        }\n        return count+1;\n        \n    }\n}"
            },
            {
                "language": "kotlin",
                "code": "            }else{\n                nums[j] =nums[i];\n                j++;\n            }\n        }\n        i++;\n    }\n    return j;\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n        public int removeDuplicates(int[] nums) {\n            int j = 1;\n            for(int i = 1; i < nums.length; i++) {\n                    if (!(nums[i - 1] == nums[i])){\n                        nums[j] = nums[i];\n                        j++;\n                    }"
            },
            {
                "language": "csharp",
                "code": " def removeDuplicates(self, nums: List[int]) -> int:\n  nums[:] = sorted(set(nums))\n  return len(nums)"
            },
            {
                "language": "python",
                "code": " nums = sorted(set(nums))\n return len(nums)"
            },
            {
                "language": "java",
                "code": " def removeDuplicates(self, nums: List[int]) -> int:\n  slow, fast = 0, 1\n  while fast in range(len(nums)):\n   if nums[slow] == nums[fast]:\n    fast += 1\n   else:\n    nums[slow+1] = nums[fast]\n    fast += 1\n    slow += 1\n\n  return slow + 1"
            },
            {
                "language": "java",
                "code": " def removeDuplicates(self, nums: List[int]) -> int:\n  j = 0\n  for i in range(1, len(nums)):\n   if nums[j] != nums[i]:\n    j += 1\n    nums[j] = nums[i]\n  return j + 1"
            },
            {
                "language": "php",
                "code": " def removeDuplicates(self, nums: List[int]) -> int:\n  i = 1\n  while i < len(nums):\n   if nums[i] == nums[i - 1]:\n    nums.pop(i)\n   else:\n    i += 1\n  return len(nums)"
            },
            {
                "language": "python",
                "code": "from collections import OrderedDict\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        nums[:] =  OrderedDict.fromkeys(nums)\n        return len(nums)"
            },
            {
                "language": "python",
                "code": "    numsset = set(numsset)\n    numsset = list(numsset)\n    numsset.sort()\n    # print(numsset)\n    # print(nums)\n    nums[:len(numsset)+1] = numsset[:]"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        int p = 0;\n        for(int i = 1 ; i < nums.length ; i++){\n            if(nums[p] != nums[i]){\n                nums[p+1] = nums[i];\n                p++;\n            }\n        }\n        return p + 1;\n    }\n}"
            }
        ]
    },
    "26": {
        "question_id": 27,
        "title": "Remove Element",
        "difficulty": 1,
        "description": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:Change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.Return k.Custom Judge:The judge will test your solution with the following code:int[] nums = [...]; // Input arrayint val = ...; // Value to removeint[] expectedNums = [...]; // The expected answer with correct length.                            // It is sorted with no values equaling val.int k = removeElement(nums, val); // Calls your implementationassert k == expectedNums.length;sort(nums, 0, k); // Sort the first k elements of numsfor (int i = 0; i < actualLength; i++) {    assert nums[i] == expectedNums[i];}If all assertions pass, then your solution will be accepted. ",
        "examples": [
            {
                "input": "nums = [3,2,2,3], val = 3",
                "output": "2, nums = [2,2,_,_]",
                "explanation": "Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            },
            {
                "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
                "output": "5, nums = [0,1,4,0,3,_,_,_]",
                "explanation": "Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            }
        ],
        "constraints": [
            "0 <= nums.length <= 100",
            "0 <= nums[i] <= 50",
            "0 <= val <= 100"
        ],
        "solutions": [
            {
                "language": "kotlin",
                "code": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        while nums.__contains__(val):\n            nums.remove(val)\n        return len(nums)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        int i = 0;\n        for (int j = 0; j < nums.length; j++) {\n            if (nums[j] != val) {\n                int temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n                i++;\n            }\n        }\n        return i;\n    }\n}"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        while val in nums:\n            nums.remove(val)\n#please upvote me it would encourage me alot"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        vector<int> tnum=nums;\n        for(int i=0;i<tnum.size();i++){\n            if(tnum.at(i)==val){\n                tnum.at(i)=-1;\n            }\n        }\n        nums.clear();\n        for(int i=0;i<tnum.size();i++){\n            if(tnum.at(i)!=-1){\n                nums.push_back(tnum.at(i));\n            }\n        }\n        return nums.size();\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        int count=0;\n        for (int i=0; i <nums.length; i++) {\n            if(nums[i]!= val) {\n                nums[count++]=nums[i];\n            }\n        }\n        return count;\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n  int removeElement(List<int> nums, int val) {\n\n      for(int i = 0 ; i < nums.length;i++ ){\n            nums.remove(val); \n      }\n            nums.remove(val);         \n      return nums.length;\n  }\n}"
            },
            {
                "language": "kotlin",
                "code": "Given : val = 2\n1 2 2 2 5 2 5 \ni           j\nFirst Start from the far end \n1 2 2 2 5 2 5 \n  i         j\nwhen nums[i] == val , nums[i] = nums[j]\n1 2 2 2 5 2 5 \n    i     j \nif(num[j]) is also val then move it left till its not\n1 5 5 2 2 2 5 \n    i   j  \nwhen i==j.. stop\n1 5 5  2  2 2 5 \n      i,j\nyou see that i can still be val, \nso we check before returning the answer  "
            },
            {
                "language": "kotlin",
                "code": "    def removeElement(self, nums: List[int], val: int) -> int:\n\n        i,j=0,len(nums)-1;\n        if(j==-1): return 0\n        while(i<j):\n            if(nums[i]==val):\n                while(i<j and nums[j]==val): \n                    j-=1\n                nums[i]=nums[j];\n                j-=1\n                continue;\n            i+=1\n        return i+1 if nums[i]!=val else i"
            },
            {
                "language": "cpp",
                "code": "int removeElement(int *nums, int numsSize, int val) {\n    int count = 0;\n\n    for (int i = 0; i < numsSize; i++)\n        if (nums[i] == val) \n            count++;\n        else \n            nums[i - count] = nums[i];\n    return (numsSize - count);\n}"
            },
            {
                "language": "cpp",
                "code": "int removeElement(int* nums, int numsSize, int val){\n    \n    int appendIndex = 0;\n    bool find = false;\n    int k = 0;\n\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] == val && !find) {\n            appendIndex = i;\n            find = true;\n        }\n        if (nums[i] != val) {\n            nums[appendIndex] = nums[i];\n            appendIndex++;\n            k++;\n        }\n    }\n\n    return k;\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int j=0;\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]!=val){\n                nums[j++]=nums[i];\n            }\n        }\n        return j;        \n    }\n};"
            }
        ]
    },
    "27": {
        "question_id": 28,
        "title": "Find the Index of the First Occurrence in a String",
        "difficulty": 1,
        "description": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. ",
        "examples": [
            {
                "input": "haystack = \"sadbutsad\", needle = \"sad\"",
                "output": "0",
                "explanation": "\"sad\" occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0."
            },
            {
                "input": "haystack = \"leetcode\", needle = \"leeto\"",
                "output": "-1",
                "explanation": "\"leeto\" did not occur in \"leetcode\", so we return -1."
            }
        ],
        "constraints": [
            "1 <= haystack.length, needle.length <= 104",
            "haystack and needle consist of only lowercase English characters."
        ],
        "solutions": [
            {
                "language": "rust",
                "code": "def strStr(self, haystack: str, needle: str) -> int:\n        return haystack.find(needle)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(needle.length() == 0){\n            return 0;\n        }\n        int M = needle.length();\n        int N = haystack.length();\n        for (int i = 0; i <= N - M; i++) {\n            int j;"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n      return haystack.indexOf(needle);  \n    }\n}"
            },
            {
                "language": "kotlin",
                "code": "class Solution {"
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if haystack == needle:\n            return 0\n        if len(needle) == 0:\n            return 0\n        for i in range(len(haystack)):"
            },
            {
                "language": "typescript",
                "code": "    class Solution {\n          public int strStr(String haystack, String needle) {\n                return haystack.indexOf(needle);\n           }\n     }"
            },
            {
                "language": "kotlin",
                "code": ""
            },
            {
                "language": "javascript",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        int haylength=haystack.length();\n        int needlelength=needle.length();\n        if(haylength<needlelength)\n            return -1;\n        for(int i=0;i<=haystack.length()-needle.length();i++){\n            int j=0;\n            while(j<needle.length() && haystack.charAt(i+j)==needle.charAt(j))\n                j++;\n            if(j==needle.length()){\n                return i;\n            }\n        }\n        return -1;\n    }\n}"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            return haystack.indexOf(needle);\n        }\n    return -1;\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    int strStr(string h, string s) {\n        int m=h.size(), n=s.size(), i=0, j=0, k=0;\n        if(m<n) return -1;\n        while(i<m && j<n) {\n            if(h[i]==s[j]) {i++; j++;}\n            else {i=k+1; j=0; k=i;}"
            },
            {
                "language": "java",
                "code": "class Solution {\npublic:\n    // z-algorithm\n    vector<int> z_function(string s) {\n        int n = (int) s.length();\n        vector<int> z(n);\n        for (int i = 1, l = 0, r = 0; i < n; ++i) {\n            if (i <= r)\n                z[i] = min (r - i + 1, z[i - l]);\n            while (i + z[i] < n && s[z[i]] == s[i + z[i]])\n                ++z[i];\n            if (i + z[i] - 1 > r)\n                l = i, r = i + z[i] - 1;\n        }\n        return z;\n    }\n    \n    int strStr(string haystack, string needle) {\n        int k = (int) needle.size();\n        if(haystack == needle || k == 0) return 0;\n        string s = needle + \"$\" + haystack;\n        vector<int> z = z_function(s);\n        int n = (int) s.size();\n        for(int i = 0; i < n; i++) {\n            if(z[i] == k) {\n                return i - k - 1;\n            }\n        }\n        return -1;\n    }\n};"
            },
            {
                "language": "rust",
                "code": "-> m\n-> i\nnot match, reinitialize window start to next index of m. \nThat is \"i\" from the word \"mississipi\"\n\n-> i s s i s\n-> i s s i p\ns and p mismatch\n\nso, reinitialize the window's start\n-> s\n-> i\nnot match\n\nreinitialize\n-> s\n-> i\nnot match\n\nreinitialize\n-> i s s i p\n-> i s s i p\nthis time it was a match!"
            },
            {
                "language": "javascript",
                "code": "class Solution {\n  int strStr(String haystack, String needle) {\n      //Check if the haystack bigger than needle, if not return -1.\n    if(needle.length > haystack.length){\n        return -1;\n     }\n    var result = -1;\n    //After that iterate over all of the characters in haystack\n    for (int i = 0; i < haystack.length; i++){\n        //Find the same as first needle character\n      if (haystack[i] == needle[0]){\n        var index = i;\n        var j = 0;\n        if (haystack.length - i >= needle.length){\n        //Start looking for others\n        while (haystack[index] == needle[j]){\n          if (j == needle.length - 1){\n            return i;\n          }\n        index++;\n        j++;\n        }\n        }\n        \n      }\n}\n    return result;\n  }\n}"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        return haystack.find(needle)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int strStr(string h, string n) {\n        // here n =needle and h=haystack\n\n        long long int q=31, m=1e9+7; \n        long long int P=n.length();\n        long long int S=h.length();\n        if(S<P) return -1;   // example: needle='aaaa' and haystack = \"aaa\"\n        vector<long long int> power(S, 1);\n        \n        for(int i=1;i<S;i++)  //precomputation of powers with base q\n        {\n            power[i]=(power[i-1]*q)%m;\n        }\n\n        long long int hash_n=0;  \n        for(int i=0;i<P;i++)  // precompute the hash value of needle\n        {\n            hash_n=(hash_n+((n[i]-'a'+1)*power[i])%m)%m;\n        }\n        vector<long long int> hash(S+1, 0);\n        for(int i=0;i<S;i++)   // precompute the hash value of haystack substring from 0 till ith index \n        {\n            hash[i+1]=(hash[i]+((h[i]-'a'+1)*power[i])%m)%m;\n        }\n        for(int i=0;i+P-1<S;i++)  \n        {\n            long long int cur_h=(hash[i+P]-hash[i]+m)%m;   // hash value of the window whose length is equal to the length of the needle string \n            if(cur_h==(hash_n*power[i])%m)  // basic concept of Hashing => value matches with a substing in haystack => return the index\n            {\n                return i;\n            }\n        }\n        return -1;  //needle is not found \n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        \n        if(haystack.contains(needle)){\n            for(int i=0;i<haystack.length()-needle.length()+1;i++){\n                if(haystack.charAt(i)==needle.charAt(0)){\n                    int count=0;\n                    int k=i;\n                    int j=0;\n                    while(haystack.charAt(k)==needle.charAt(j)){\n                        k++;\n                        j++;\n                        count++;\n                        if(count==needle.length()){\n                        return i;\n                        }\n                    }\n                    \n                }\n            }\n        }\n        else{\n            return -1;\n        }\n\n        return -1;\n    }\n}"
            },
            {
                "language": "rust",
                "code": "impl Solution {\n    pub fn str_str(haystack: String, needle: String) -> i32 {\n        let s: Vec<u8> = needle\n            .bytes()\n            .chain(\"#\".bytes())\n            .chain(haystack.bytes())\n            .collect();\n\n        let mut pi = vec![0usize; s.len()];\n\n        for i in 1..s.len() {\n            let mut j = pi[i - 1];\n            while j > 0 && s[j] != s[i] {\n                j = pi[j - 1];\n            }\n            if s[i] == s[j] {\n                j += 1;\n            }\n            pi[i] = j;\n        }\n\n        for i in needle.len() + 1..s.len() {\n            if pi[i] == needle.len() {\n                return (i - needle.len() * 2) as i32;\n            }\n        }\n        return -1;\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        for(int i=0;i<haystack.length();i++)\n        {\n            int j=i;\n            int ptr=0;\n            int count=0;\n            while(haystack[j]==needle[ptr] && ptr<needle.length())\n            {\n                j++;\n                ptr++;\n                count++;\n            }\n            if(count==needle.length()) return i;\n        }\n        return -1;\n    }\n};"
            }
        ]
    },
    "28": {
        "question_id": 29,
        "title": "Divide Two Integers",
        "difficulty": 2,
        "description": "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.Return the quotient after dividing dividend by divisor.Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231. ",
        "examples": [
            {
                "input": "dividend = 10, divisor = 3",
                "output": "3",
                "explanation": "10/3 = 3.33333.. which is truncated to 3."
            },
            {
                "input": "dividend = 7, divisor = -3",
                "output": "-2",
                "explanation": "7/-3 = -2.33333.. which is truncated to -2."
            }
        ],
        "constraints": [
            "-231 <= dividend, divisor <= 231 - 1",
            "divisor != 0"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if (divisor == 0) {\n            return 0;\n        }\n        if (dividend == Integer.MIN_VALUE && divisor == -1) {\n            return Integer.MAX_VALUE;\n        }\n        int quotient = 0;\n        boolean negative = (dividend < 0) != (divisor < 0);\n        long longDividend = Math.abs((long) dividend);\n        long longDivisor = Math.abs((long) divisor);\n        while (longDividend >= longDivisor) {\n            int shift = 0;\n            while (longDividend >= (longDivisor << shift)) {\n                shift++;\n            }\n            shift--;\n            longDividend -= longDivisor << shift;\n            quotient += 1 << shift;\n        }\n        return negative ? -quotient : quotient;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "int divide(long long int dividend, long long int divisor){\n    if (dividend / divisor > pow(2,31) - 1)\n    {\n        return(pow(2,31) - 1);\n    }\n    else\n     {\n        return (dividend / divisor);\n    }\n}"
            },
            {
                "language": "lisp",
                "code": " dividend = (quotient) * divisor + remainder"
            },
            {
                "language": "javascript",
                "code": " 58 = (2^3 + 2^1 + 2^0) * 5 + 3                // --- (I)\n 58 = [(2^3 * 5) + (2^1 * 5) + (2^0 * 5)] + 3  // --- (II)"
            },
            {
                "language": "javascript",
                "code": " 5 << 0 = 5               // less than dividend\n 5 << 1 = 5*2 = 10        // less than dividend\n 5 << 2 = 5*2*2 = 20      // less than dividend\n 5 << 3 = 5*2*2*2 = 40    // less than dividend\n 5 << 4 = 5*2*2*2*2 = 80  // (stop and consider the previous value as the result is greater than dividend"
            },
            {
                "language": "lisp",
                "code": " 58 - (2^3 * 5)  =  (something * 5) + rem\n 58 - (8 * 5) = something * 5 + rem\n 58 - 40 = something * 5 + rem\n 18 = something * 5 + rem"
            },
            {
                "language": "javascript",
                "code": " 5 << 0 = 5           // less than dividend\n 5 << 1 = 5*2 = 10    // less than dividend\n 5 << 2 = 5*2*2 = 20  // (stop and consider the previous value as the result is greater than dividend"
            },
            {
                "language": "lisp",
                "code": " 18  =  (2^1 * 5) + (something * 5) + rem\n 58 - (2^3 * 5) = (2^1 * 5) + (something * 5) + rem\n 58 =  (2^3 * 5) + (2^1 * 5) + (something * 5) + rem"
            },
            {
                "language": "lisp",
                "code": " 18 - (2^1 * 5)  =  (something * 5) + rem\n 18 - (2 * 5) = something * 5 + rem\n 18 - 10 = something * 5 + rem\n 8 = something * 5 + rem"
            },
            {
                "language": "javascript",
                "code": " 5 << 0 = 5           // less than dividend\n 5 << 1 = 5*2 = 10    // (stop and consider the previous value as the result is greater than dividend"
            },
            {
                "language": "erlang",
                "code": " 8 = (2^0 * 5) + (something * 5) + rem\n 8 - 5 = something * 5 + rem\n 3 = something * 5 + rem"
            },
            {
                "language": "lisp",
                "code": " 3 = 0*5 + rem\n 8 = (2^0 * 5) + 3\n 18  =  (2^0 * 5) + (2^1 * 5) + 3\n 58 = (2^3 * 5) + (2^1 * 5) + (2^0 * 5) + 3"
            },
            {
                "language": "cpp",
                "code": " int divide(int dividend, int divisor) {\n        if(dividend == divisor)\n            return 1;\n        bool isPositive = (dividend<0 == divisor<0);    // if both are of same sign, answer is positive\n        unsigned int a = abs(dividend);\n        unsigned int b = abs(divisor);\n        unsigned int ans = 0;\n        while(a >= b){  // while dividend is greater than or equal to divisor\n            short q = 0;\n            while(a > (b<<(q+1)))\n                q++;\n            ans += (1<<q);  // add the power of 2 found to the answer\n            a = a - (b<<q);  // reduce the dividend by divisor * power of 2 found\n        }\n        if(ans == (1<<31) and isPositive)   // if ans cannot be stored in signed int\n            return INT_MAX;\n        return isPositive ? ans : -ans;\n    }"
            },
            {
                "language": "lisp",
                "code": "58 = (2^3 + 2^1 + 2^0) * 5 + 3 "
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(log(N)*log(N)), The time complexity of the code is O(log(N)*log(N)) since the outer loop\n    and the inner loop both runs log(N) times, where N is the dividend.\n\n    Space Complexity : O(1), The space complexity of the above code is O(1) since we\u2019re using constant extra\n    space.\n\n    Solved using Math + Bit Manipulation.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        if(dividend == INT_MIN && divisor == -1){\n            return INT_MAX;\n        }\n        long long dvd = labs(dividend), dvs = labs(divisor), result = 0;\n        int sign = (dividend > 0) ^ (divisor > 0) == 0 ? 1 : -1;\n        while(dvd >= dvs){\n            long long temp = dvs, mul = 1;\n            while(temp << 1 <= dvd){\n                temp <<= 1;\n                mul <<= 1;\n            }\n            dvd -= temp;\n            result += mul;\n        } \n        return sign*result;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(1), Constant Operation.\n\n    Space Complexity : O(1), Constant space.\n\n    Solved using Math.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        if(dividend == INT_MIN && divisor == -1){\n            return INT_MAX;\n        }\n        return dividend/divisor;\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "if(sign == -1) result = 0 - result;\nreturn result;"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        if (dividend == INT_MIN && divisor == -1) {\n            return INT_MAX;\n        }\n        long dvd = labs(dividend), dvs = labs(divisor), ans = 0;\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\n        while (dvd >= dvs) {\n            long temp = dvs, m = 1;\n            while (temp << 1 <= dvd) {\n                temp <<= 1;\n                m <<= 1;\n            }\n            dvd -= temp;\n            ans += m;\n        }\n        return sign * ans;\n    }\n};"
            },
            {
                "language": "java",
                "code": "public int divide(int dividend, int divisor) {\n    //other code...\n    if(dividend==Integer.MIN_VALUE){\n        if(divisor==-1) return Integer.MAX_VALUE;\n        else if(divisor==1)  return dividend;"
            },
            {
                "language": "cpp",
                "code": "public int divide(int dividend, int divisor) {\n    if(divisor==0||dividend==Integer.MIN_VALUE&&divisor==-1) return Integer.MAX_VALUE;\n    int res=0;\n    int sign=(dividend<0)^(divisor<0)?-1:1;\n    long dvd=Math.abs((long)dividend);\n    long dvs=Math.abs((long)divisor);\n    while(dvs<=dvd){\n        long temp=dvs,mul=1;"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int divide(int dividend, int divisor) {\n        int sign = (dividend<0)^(divisor<0) ? -1 : 1, quotient = 0;\n        if(dividend == Integer.MIN_VALUE){\n            if(divisor == -1) return Integer.MAX_VALUE;\n            if(divisor == Integer.MIN_VALUE) return 1;\n            dividend += Math.abs(divisor);"
            },
            {
                "language": "java",
                "code": "class Solution {\npublic:\n    int divide(int dividend, int divisor);\n};\n\n// a / b\nint Solution::divide(int a, int b) {\n    // First, deal with bunch of special conditions"
            },
            {
                "language": "cpp",
                "code": "    public static int divide(int dividend, int divisor) {\n        if (divisor == 0 || //divide by zero\n                dividend == Integer.MIN_VALUE && divisor == -1 //overflow check\n                ) {\n            return Integer.MAX_VALUE;\n        }\n\n        int sign = 1;"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        # Handle division by zero\n        if divisor == 0:\n            return 2**31 - 1\n        \n        # Handle overflow case\n        if dividend == -2**31 and divisor == -1:\n            return 2**31 - 1\n        \n        # Get the sign of the result\n        sign = 1\n        if dividend < 0:\n            dividend = -dividend\n            sign = -sign\n        if divisor < 0:\n            divisor = -divisor\n            sign = -sign\n        \n        # Find the largest multiple of the divisor that is less than or equal to the dividend\n        multiple = 1\n        while dividend >= (divisor << 1):\n            divisor <<= 1\n            multiple <<= 1\n        \n        # Perform division using binary search\n        quotient = 0\n        while multiple > 0:\n            if dividend >= divisor:\n                dividend -= divisor\n                quotient += multiple\n            divisor >>= 1\n            multiple >>= 1\n        \n        # Apply the sign to the result\n        return sign * quotient"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        m,n=abs(dividend),abs(divisor)\n        answer=0\n        while (m-n)>=0:\n            count=0\n            while (m-(n<<1<<count))>=0:\n                count+=1\n            answer+=1<<count\n            m-=n<<count\n        if  dividend<0 and divisor<0:\n            if answer>2**31-1:\n                return 2**31-1\n            else:\n                return answer\n        elif dividend<0 or divisor<0:\n            if answer<-2**31:\n                return -2**31\n            return -answer\n        else:\n            if answer>2**31-1:\n                return 2**31-1\n            return answer\n\n\n\n\n        \n        \n\n\n      "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        \n        //Handling corner cases\n        if(dividend==INT_MIN && divisor==-1) return INT_MAX;\n        if(dividend==INT_MIN && divisor==1) return INT_MIN;\n\n        \n        //Converting divisors and dividend to their positive values\n        long int dd = abs(dividend), dv = abs(divisor);\n        \n        //Result Variables\n        int res=0;\n        while(dv<=dd) {\n            long int mul=dv, tmp=1;\n            while(mul<=dd-mul) {\n                mul+=mul;\n                tmp+=tmp;\n            }\n            res+=tmp;\n            dd-=mul;\n        }\n        \n        //If either of dividend or divisor is negative our result will be negative\n        if((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\n        \n        return res;\n        \n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "if (dividend < 0 ^ divisor < 0)\n    return -res;\nelse\n    return res;"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int divide(int dividend, int divisor)\n    {\n        if (dividend == INT_MIN && divisor == -1)\n            return INT_MAX;\n        if (dividend == INT_MIN && divisor == 1)\n            return INT_MIN;"
            },
            {
                "language": "cpp",
                "code": "    int divide(int A, int B) {\n        if (A == INT_MIN && B == -1) return INT_MAX;\n        int a = abs(A), b = abs(B), res = 0, x = 0;\n        while (a - b >= 0) {\n            for (x = 0; a - (b << x << 1) >= 0; x++);\n            res += 1 << x;\n            a -= b << x;\n        }\n        return (A > 0) == (B > 0) ? res : -res;\n    }"
            },
            {
                "language": "cpp",
                "code": "    public int divide(int A, int B) {\n        if (A == 1 << 31 && B == -1) return (1 << 31) - 1;\n        int a = Math.abs(A), b = Math.abs(B), res = 0, x = 0;\n        while (a - b >= 0) {\n            for (x = 0; a - (b << x << 1) >= 0; x++);\n            res += 1 << x;\n            a -= b << x;\n        }\n        return (A > 0) == (B > 0) ? res : -res;\n    }"
            },
            {
                "language": "cpp",
                "code": "    int divide(int A, int B) {\n        if (A == INT_MIN && B == -1) return INT_MAX;\n        int a = abs(A), b = abs(B), res = 0;\n        for (int x = 31; x >= 0; x--)\n            if ((signed)((unsigned)a >> x) - b >= 0)\n                res += 1 << x, a -= b << x;\n        return (A > 0) == (B > 0) ? res : -res;\n    }"
            },
            {
                "language": "cpp",
                "code": "    public int divide(int A, int B) {\n        if (A == 1 << 31 && B == -1) return (1 << 31) - 1;\n        int a = Math.abs(A), b = Math.abs(B), res = 0;\n        for (int x = 31; x >= 0; x--)\n            if ((a >>> x) - b >= 0) {\n                res += 1 << x;\n                a -= b << x;\n            }\n        return (A > 0) == (B > 0) ? res : -res;\n    }"
            },
            {
                "language": "python",
                "code": "    def divide(self, A, B):\n        if (A == -2147483648 and B == -1): return 2147483647\n        a, b, res = abs(A), abs(B), 0\n        for x in range(32)[::-1]:\n            if (a >> x) - b >= 0:\n                res += 1 << x\n                a -= b << x\n        return res if (A > 0) == (B > 0) else -res"
            },
            {
                "language": "cpp",
                "code": "    public static int divide(int dividend, int divisor) {\n        if (Integer.MIN_VALUE == dividend && divisor == -1) {\n            return Integer.MAX_VALUE;\n        }\n        int res = 0;\n        int a = Math.abs(dividend);\n        int b = Math.abs(divisor);\n        while (a - b >= 0) {\n            int tmp = b;"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        if (divisor == INT_MIN) {"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int divide(int A, int B) {\n        // for the corner case, If A is INT_MIN, and B is -1, \n        // the result will be 1 + INT_MAX, hence overflowing \n        // 32 bits, handle it first\n        if (A == INT_MIN && B == -1) "
            },
            {
                "language": "cpp",
                "code": "int divide(int A, int B) {\n    if (A == INT_MIN && B == -1) return INT_MAX;\n    if (A == INT_MIN && B == 1) return INT_MIN;\n    if (B == INT_MIN) return A == INT_MIN;\n    int a = abs(A), b = abs(B), res = 0, n = 0;\n    if (A == INT_MIN){\n        res = 1;\n        a = abs(A + b);"
            },
            {
                "language": "cpp",
                "code": "class Solution\n{\npublic:\n int divide(int dividend, int divisor)\n {\n  int result;\n  if (dividend >= INT_MAX && divisor == 1) result = INT_MAX;\n  else if(dividend <= INT_MIN && divisor == 1) result = INT_MIN;\n  else if(dividend <= INT_MIN && divisor == -1) result = abs(INT_MAX);\n  else result  = dividend / divisor;\n     return result;\n }\n};"
            }
        ]
    },
    "29": {
        "question_id": 30,
        "title": "Substring with Concatenation of All Words",
        "difficulty": 3,
        "description": "You are given a string s and an array of strings words. All the strings of words are of the same length.A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.For example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.Return the starting indices of all the concatenated substrings in s. You can return the answer in any order. ",
        "examples": [
            {
                "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
                "output": "[0,9]",
                "explanation": "Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\nThe output order does not matter. Returning [9,0] is fine too."
            },
            {
                "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
                "output": "[]",
                "explanation": "Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\nWe return an empty array."
            },
            {
                "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
                "output": "[6,9,12]",
                "explanation": "Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words."
            }
        ],
        "constraints": [
            "1 <= s.length <= 104",
            "1 <= words.length <= 5000",
            "1 <= words[i].length <= 30",
            "s and words[i] consist of lowercase English letters."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n struct matcher {\n  struct info { int mtindex, count; };\n  unordered_map<string_view, info>dict;\n  int different_word_count;\n\n  vector<int>slot;\n  int maching_slot_count;\n\n  matcher(const vector<string>& words) {\n   int mtind = 0;\n   for (auto& word : words) {\n    auto find = dict.find(word);\n    if (find != dict.end()) {\n     ++find->second.count;\n    }\n    else { dict[word] = { mtind++,1 }; }\n   }\n   different_word_count = mtind;\n   slot = vector<int>(different_word_count, 0);\n   maching_slot_count = 0;\n  }\n\n  void reset() {\n   for (auto& i : slot) { i = 0; }\n   maching_slot_count = 0;\n  }\n  bool match() {\n   return maching_slot_count == different_word_count;\n  }\n  void push(string_view sv) {\n   auto find = dict.find(sv);\n   if (find == dict.end())return;\n   if (++slot[find->second.mtindex] == find->second.count) {\n    ++maching_slot_count;\n   }\n  }\n  void pop(string_view sv) {\n   auto find = dict.find(sv);\n   if (find == dict.end())return;\n   if (--slot[find->second.mtindex] == find->second.count - 1) {\n    --maching_slot_count;\n   }\n  }\n };\n vector<int> findSubstring(string s, const vector<string>& words) {\n  int word_count = words.size();\n  int word_len = words[0].size();\n\n  matcher matcher(words);\n\n  const char* str = s.c_str();\n  int len = s.size();\n  vector<int> ret;\n\n  for (int off = 0; off < word_len; off++) {\n   const char* beg = str + off, * end = str + len;\n   if (beg + word_len * word_count <= end) {\n    matcher.reset();\n    for (int i = 0; i < word_count; i++) {\n     string_view sv(beg + i * word_len, word_len);\n     matcher.push(sv);\n    }\n    if (matcher.match()) {\n     ret.push_back(beg - str);\n    }\n    const char* pos = beg + word_len * word_count;\n    while (pos + word_len <= end) {\n     string_view del(beg, word_len);\n     string_view add(pos, word_len);\n     beg += word_len;\n     pos += word_len;\n     matcher.pop(del);\n     matcher.push(add);\n     if (matcher.match()) {\n      ret.push_back(beg - str);\n     }\n    }\n   }\n  }\n  return ret;\n }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    bool checkSubstring(unordered_map<string, int> wordCount, string s, int wordLen) {\n        for(int j=0; j<s.size(); j+=wordLen) {\n            string w = s.substr(j, wordLen);\n            if(wordCount.find(w) != wordCount.end()) {\n                if(--wordCount[w] == -1) {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> res;\n        int wordLen = words[0].size();\n        int sLen = s.size();\n        int wordsWindow = words.size() * wordLen;\n        \n        unordered_map<string, int> wordCount;\n        for(int i=0; i<words.size(); i++) {\n            wordCount[words[i]]++;\n        }\n        \n        int i = 0;\n        while(i + wordsWindow <= sLen) {\n            if(checkSubstring(wordCount, s.substr(i, wordsWindow), wordLen)) {\n                res.push_back(i);\n            }\n            i++;\n        }\n        return res;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words){\n        int n = s.length(), k = words.size(), wordLength = words[0].length(), totalLength = wordLength * k;\n        \n        unordered_map<string, int> wordCount;\n        for(string word: words)\n            ++wordCount[word];\n wordLength, int totalLength, vector<int> &res) {"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> ans;\n        \n        int wordLen = words[0].size(), total = words.size(), len = s.size();\n        \n        unordered_map<string, int> mx;\n        for (int i = 0; i < total; i++) mx[words[i]]++;"
            },
            {
                "language": "go",
                "code": "class Solution {\npublic:\n    unordered_map<string, int> ump;\n    bool helper(string s, int idx, int k, int len){\n        int count = 0;\n        unordered_map<string, int> temp = ump;\n        for(int i = idx; i < idx + len * k; i += len){\n            string curr = s.substr(i, len);\n            if(temp.find(curr) != temp.end()){\n                temp[curr]--;\n                if(temp[curr] == 0) temp.erase(curr);\n                count++;\n            }\n            else break;\n        }\n        return count == k;\n    }\n    \n    vector<int> findSubstring(string s, vector<string>& words) {\n        int len = words[0].size();\n        int k = words.size();\n        for(string word : words){\n            ump[word]++;\n        }\n        vector<int> ans;\n        for(int i = 0; i < s.size() - k * len + 1; i++){\n            if(helper(s, i, k, len)) ans.push_back(i);\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        unordered_map<string, int> mp, temp;\n        vector<int> ans;\n        for(string &w:words) mp[w]++;\n\n        int ws = words[0].size(), sn = s.size(), wn = words.size();\n        int k = ws*wn;\n\n        for(int i=0;i+k<=sn;i++)\n        {\n            bool flag = true;\n            temp = mp;\n            for(int j=0;j<wn and flag;j++)\n            {\n                string substr=\"\";\n                for(int d=0;d<ws;d++)\n                substr+=s[i+j*ws+d];\n\n                if(temp[substr])\n                {\n                    temp[substr]--;\n                }\n                else\n                flag = false;\n            }\n            if(flag)\n            ans.push_back(i);\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "go",
                "code": "class Solution {\npublic:\n    unordered_map<string, int>m, m1;\n    bool check(string s, int len){\n        m1 = m;\n        for(int i = 0; i <= s.size()-len; i += len){\n            string tmp = s.substr(i, len);\n            if(m1.find(tmp) == m1.end())return false;"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        # remove empty cases\n        if not s or words==[]:\n            return []  \n        len_str=len(s)\n        len_word=len(words[0])\n        len_substr=len(words)*len_word"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        int n = s.size();\n        unordered_map<string, int> ump;\n        for(auto word : words)\n            ump[word]++;\n        int uniq = words.size();"
            },
            {
                "language": "python",
                "code": "import collections\n\nclass TrieNode:\n    def __init__(self):\n        self.val = ''\n        self.children = {}"
            },
            {
                "language": "csharp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int>ans;\n        int n=words.size();\n        int m=words[0].size();\n        int total=n*m;"
            },
            {
                "language": "dart",
                "code": ""
            },
            {
                "language": "python",
                "code": "class Solution {\npublic:\n    unordered_map<string,int>m,m1;\n    bool pos(string s, int i, int len)\n    {\n        string str;\n        if(!m1.size())return true;\n        for(int ii=0;ii<len; ii++)\n        {"
            },
            {
                "language": "cpp",
                "code": "bool checkSubstring(unordered_map<string, int> wordCount, string s, int wordLen) {\n    for(int j=0; j<s.size(); j+=wordLen) {\n        string w = s.substr(j, wordLen);\n        if(wordCount.find(w) != wordCount.end()) {\n            if(--wordCount[w] == -1) {\n                return false;\n            }\n        } else {"
            },
            {
                "language": "rust",
                "code": "bar -> foo -> foo -> bar -> the -> foo -> bar -> man\nignore b -> arf -> oof -> oob -> art -> hef -> oob -> arm -> ignore an\nignore ba -> rfo -> ofo -> oba -> rth -> efo -> oba -> rma -> ignore n"
            },
            {
                "language": "rust",
                "code": "1) word_count.get(word, 0) >= 0 \n    -> word_count[word] -= 1 as it uses one of the string in words\n -> queue.append(word)\n \n2) word_count.get(word, 0) == 0 \n    -> while queue.pop()\n  -> queue.pop() == word\n   -> queue.append(queue.pop()) # Only the beginning word is dropped, the remaining words are still in use\n   -> break\n  -> queue.pop() != word\n   # Since the beginning word is dropped, the count of beginning word should be added 1.\n   -> word_dict[last_element] += 1\n    -> word_dict[last_element] exceeds its original value, reset the whole word_dict\n   -> continue"
            },
            {
                "language": "go",
                "code": "from collections import deque, defaultdict\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        word_len = len(words[0])\n        ori_word_dict = defaultdict(int)\n  \n        for word in words:\n            ori_word_dict[word] += 1\n        \n        all_word_len = len(words) * word_len\n        result = []\n        for i in range(word_len):\n            queue = deque()\n            word_dict = ori_word_dict.copy()\n            for j in range(i, len(s) - word_len + 1, word_len):\n                word = s[j:j + word_len]\n                if word_dict.get(word, 0) != 0:\n                    word_dict[word] -= 1\n                    queue.append(word)\n                    if sum(word_dict.values()) == 0:\n                        result.append(j - all_word_len + word_len)\n                        last_element = queue.popleft()\n                        word_dict[last_element] = word_dict.get(last_element, 0) + 1\n                else:\n                    while len(queue):\n                        last_element = queue.popleft()\n                        if last_element == word:\n                            queue.append(word)\n                            break\n                        else:\n                            word_dict[last_element] = word_dict.get(last_element, 0) + 1\n                            if word_dict[last_element] > ori_word_dict[last_element]:\n                                word_dict = ori_word_dict.copy()\n\n        return result"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        def check_presence(i):\n            WC = collections.Counter(words)\n            words_found = 0\n\n            for j in range(i, i+size, words_len):\n                sub = s[j:j+words_len]"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        word_len = len(words[0])\n        all_word_len  = word_len * len(words)\n        target = Counter(words)  \n        res = []\n        "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        map<string,int>mp;\n        int ws=words.size();\n        int wsz=words[0].size();\n        for(auto w:words)mp[w]++;\n        int window=ws*wsz;\n        vector<int>ans;\n        for(int i=0;i<s.size()-window+1;i++){\n           unordered_map<string,int>seen;\n           bool f=true;\n           for(int j=0;j<ws;j++){\n              string t=s.substr(i+j*wsz,wsz);\n               seen[t]++;\n               if(seen[t]>mp[t]){\n                   f=false;\n                   break;\n               }\n           }\n           if(f)\n           ans.push_back(i);\n\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "rust",
                "code": " i  ---> i+w ---> i+2w ----> i+3w ----> i+4w  (These all can re-use their computations)\n "
            },
            {
                "language": "rust",
                "code": "        i  ---> i+w ---> i+2w ----> i+3w ----> i+4w \n  "
            },
            {
                "language": "lisp",
                "code": "        (i+1)  ---> (i+1)+w ---> (i+1)+2w ----> (i+1)+3w ----> (i+1)+4w "
            },
            {
                "language": "lisp",
                "code": "        (i+2)  ---> (i+2)+w ---> (i+2)+2w ----> (i+2)+3w ----> (i+2)+4w \n  "
            },
            {
                "language": "lisp",
                "code": "        (i+3)  ---> (i+3)+w ---> (i+3)+2w ----> (i+3)+3w ----> (i+3)+4w \n  "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        unordered_map<string, int> dict;\n        for(auto &w: words) dict[w]++;\n        vector<int> res;\n        int n = s.length(), m = words[0].length(), w = words.size();"
            },
            {
                "language": "python",
                "code": "    int n = words.size();\n    int len = words[0].size();\n    vector<int> ans;\n    \n    unordered_map<string, int> mp;\n    \n    for(string &str : words) {\n        mp[str]++;\n    }\n    \n    for(int i=0; i<s.size()-(n*len)+1; i++) {\n        unordered_map<string, int>m;\n        for(int j=i; j<i+n*len; j+=len) {\n            string str = s.substr(j, len);\n            m[str]++;\n        }\n        if(mp == m) {\n            ans.push_back(i);\n        }\n       \n    }\n    return ans;\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n vector<int> findSubstring(string s, vector<string>& words) {\n  unordered_map<string, int>m;\n  int sz=0, len=words[0].size();\n  for(int i=0; i<words.size(); i++){\n   m[words[i]]++;\n   sz+=words[i].size();\n  }\n  vector<int>ans;\n  for(int i=0; i<s.size()-sz+1; i++){\n   unordered_map<string, int>m1(m);\n   //vector<int>v;\n   int i1=i, j1=i+sz-1;\n   //cout<<i1<<\" \"<<j1<<endl;\n   while(i1<=j1){\n    //cout<<s.substr(i1, len)<<\" \"<<i1<<endl;\n    if(m1[s.substr(i1, len)]>0){\n     //v.push_back(i1);\n     //cout<<s.substr(i1, len)<<\" \"<<i1<<endl;\n     m1[s.substr(i1, len)]--;\n     if(m1[s.substr(i1, len)]==0){\n      m1.erase(s.substr(i1, len));\n     }\n    }\n    else{\n     //cout<<\"here\"<<endl;\n     break;\n    }\n    i1+=len;\n   }\n   //cout<<m1.size()<<endl;\n   if(m1.size()==0){ans.push_back(i);}\n  }\n  return ans;\n }\n};"
            }
        ]
    },
    "30": {
        "question_id": 31,
        "title": "Next Permutation",
        "difficulty": 2,
        "description": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).For example, the next permutation of arr = [1,2,3] is [1,3,2].Similarly, the next permutation of arr = [2,3,1] is [3,1,2].While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.Given an array of integers nums, find the next permutation of nums.The replacement must be in place and use only constant extra memory. ",
        "examples": [
            {
                "input": "nums = [1,2,3]",
                "output": "[1,3,2]",
                "explanation": null
            },
            {
                "input": "nums = [3,2,1]",
                "output": "[1,2,3]",
                "explanation": null
            },
            {
                "input": "nums = [1,1,5]",
                "output": "[1,5,1]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 100",
            "0 <= nums[i] <= 100"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N), Since we traverse the entire Array(nums) once in the worst case. Where N = size of\n    the Array(nums).\n\n    Space Complexity : O(1), Constant Space.\n\n    Solved using Array + Two Pointers.\n\n*/\n\n\n/***************************************** Approach 1 First Code *****************************************/\n\nclass Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        int n = nums.size(), index = -1;\n        for(int i=n-2; i>=0; i--){\n            if(nums[i] < nums[i+1]){\n                index = i;\n                break;\n            }\n        }\n        for(int i=n-1; i>=index && index != -1; i--){\n            if(nums[i] > nums[index]){\n                swap(nums[i], nums[index]);\n                break;\n            }\n        }\n        reverse(nums.begin() + index + 1, nums.end());\n    }\n};\n\n\n\n\n\n\n/***************************************** Approach 1 Second Code *****************************************/\n\nclass Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        next_permutation(nums.begin(), nums.end());\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public void nextPermutation(int[] nums) {\n        if(nums == null || nums.length <= 1) return;\n\n        int i = nums.length-2;\n        while(i >=0 && nums[i]>=nums[i+1]) \n            i--;\n\n        if(i>=0){\n            int j = nums.length-1;\n            while(nums[j] <= nums[i]){\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i+1, nums.length-1);\n    }\n    public void swap(int[] nums, int i, int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    public void reverse(int[] arr, int i, int j){\n        while(i < j)\n            swap(arr, i++, j--);\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        int start = nums.size() - 1;\n        while(start >= 1 && nums[start] <= nums[start-1]) {\n            start--;\n        }\n        if(start > 0) {\n            int temp = nums.size()-1;\n            while(nums[temp] <= nums[start-1]) temp--;\n            swap(nums[start-1], nums[temp]);\n        }\n        reverse(nums.begin()+start, nums.end());\n    }\n};"
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar nextPermutation = function(nums) {\n    for (let i = nums.length - 2; i >= 0; i--) {\n        let currentIndexSwap = i;\n        for (let j = i + 1; j < nums.length; j++) {\n            if ((nums[j] > nums[i] && nums[j] < nums[currentIndexSwap]) || (nums[j] > nums[currentIndexSwap] && currentIndexSwap === i)) {\n                currentIndexSwap = j;\n            }\n        }\n        if (i !== currentIndexSwap) {\n            [nums[i], nums[currentIndexSwap]] = [nums[currentIndexSwap], nums[i]];\n            for (let k = i + 1; k < nums.length; k++) {\n                for (let p = k + 1; p < nums.length; p++) {\n                    if (nums[p] < nums[k]) {\n                        [nums[k], nums[p]] = [nums[p], nums[k]];\n                    }\n                }\n            }\n            return nums;\n        }\n    }\n\n    return nums.sort((a, b) => a - b);\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        int i=nums.size()-1,j=nums.size()-1;\n        while(i && nums[i-1]>=nums[i]) i--;\n        if(!i) return reverse(nums.begin(),nums.end());\n        while(nums[i-1]>=nums[j]) j--;\n        swap(nums[i-1],nums[j]);\n        return reverse(nums.begin()+i,nums.end());\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public void nextPermutation(int[] A) {\n        if (A == null || A.length <= 1) return;\n        int i = A.length - 2;\n        while (i >= 0 && A[i] >= A[i + 1]) i--;\n        if (i >= 0) {\n            int j = A.length - 1;\n            while (A[j] <= A[i]) j--;\n            swap(A, i, j);\n        }\n        reverse(A, i + 1, A.length - 1);\n    }\n\n    public void swap(int[] A, int i, int j) {\n        int tmp = A[i];\n        A[i] = A[j];\n        A[j] = tmp;\n    }\n\n    public void reverse(int[] A, int i, int j) {\n        while (i < j) swap(A, i++, j--);\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        //next_permutation(nums.begin(),nums.end());      //STL Build-In function\n\n        int n = nums.size(),k,l;\n\n        for(k = n-2;k>=0;k--)       //iterte from back\n        {\n            if(nums[k] < nums[k+1])\n            {\n                break;\n            }\n        }\n\n        if(k<0)      //for edge case\n        {\n            reverse(nums.begin(),nums.end());\n        }\n        else\n        {\n            for(l = n-1 ; l >=k ; l--)\n            {\n                if(nums[l] > nums[k])\n                {\n                    break;\n                }\n            }\n\n            swap(nums[k], nums[l]);\n\n            reverse(nums.begin()+k+1,nums.end());\n        }\n    }\n};"
            },
            {
                "language": "python",
                "code": "    \"\"\"\n    1. From right to left find the one with misorer match that is the one that not in ascending            order\n    2.Swap the element with next greatest element from its rigth sub array\n    3.the reverse the right sub arrray (but here it is already reversed)\n    \"\"\"\n    right_subarr,n=[],len(nums)\n    right_subarr.append(nums[-1]) \n    for i in range(n-2,-1,-1):\n        if nums[i]>=right_subarr[-1]:right_subarr.append(nums[i])\n        else:\n            temp=right_subarr[:]\n            temp.sort()\n            for next_greatest in temp:\n                if next_greatest>nums[i]:\n                    m=next_greatest\n                    break\n            ind=right_subarr.index(m)\n            \n            nums[i],right_subarr[ind]=right_subarr[ind],nums[i]\n            break\n    if len(right_subarr)==n: nums[:]=right_subarr[:]\n    else: nums[i+1:n]=right_subarr[:]\n    print(right_subarr,nums)\n    \n    \n            "
            },
            {
                "language": "",
                "code": ""
            },
            {
                "language": "rust",
                "code": "                    Do upvote for me!"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public void nextPermutation(int[] nums) {\n        int ind1=-1;\n        int ind2=-1;\n        for(int i=nums.length-2;i>=0;i--){\n            if(nums[i]<nums[i+1]){\n                ind1=i;\n                break;\n            }\n        }\n        if(ind1==-1){\n            reverse(nums,0);\n        }\n        else{\n            for(int i=nums.length-1;i>=0;i--){\n                if(nums[i]>nums[ind1]){\n                    ind2=i;\n                    break;\n                }\n            }\n            swap(nums,ind1,ind2);\n            reverse(nums,ind1+1);\n        }\n    }\n    void swap(int[] nums,int i,int j){\n        int temp=nums[i];\n        nums[i]=nums[j];\n        nums[j]=temp;\n    }\n    void reverse(int[] nums,int start){\n        int i=start;\n        int j=nums.length-1;\n        while(i<j){\n            swap(nums,i,j);\n            i++;\n            j--;\n        }\n    }\n}"
            }
        ]
    },
    "31": {
        "question_id": 32,
        "title": "Longest Valid Parentheses",
        "difficulty": 3,
        "description": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring. ",
        "examples": [
            {
                "input": "s = \"(()\"",
                "output": "2",
                "explanation": "The longest valid parentheses substring is \"()\"."
            },
            {
                "input": "s = \")()())\"",
                "output": "4",
                "explanation": "The longest valid parentheses substring is \"()()\"."
            },
            {
                "input": "s = \"\"",
                "output": "0",
                "explanation": null
            }
        ],
        "constraints": [
            "0 <= s.length <= 3 * 104",
            "s[i] is '(', or ')'."
        ],
        "solutions": [
            {
                "language": "python",
                "code": "class Solution {\n    public int longestValidParentheses(String s) {\n        \n        Stack<Integer> stk = new Stack<>() ;\n       if(!s.isEmpty())\n        stk.push(0);\n        for(int i = 1 ; i< s.length() ;i++){\n            if(stk.isEmpty())\n                stk.push(i);\n           \n            else if(s.charAt(stk.peek()) == '(' && s.charAt(i) == ')')\n            {\n\n                stk.pop();\n            }\n            else \n                stk.push(i);\n                \n        }\n       \n        if(stk.isEmpty())\n        return s.length() ;\n        \n        if(stk.size()==1 && s.length()!=1 && ((stk.peek()==0)|| (stk.peek()==s.length()-1)))\n        return s.length()-1;\n      \n       \n         int max = 0 ;\n        int len = s.length() -1;\n        while(!stk.isEmpty()){\n            int a =stk.pop();\n             max = Math.max(len-a,max);\n            len = a-1;\n            \n        }\n         \n        return Math.max(max,len-0+1) ;\n        \n    }\n}"
            },
            {
                "language": "cpp",
                "code": "//IN THIS PROBLEM I FIND LONGEST LONGEST VALID PRENTHESIS SUBSTRING\nclass Solution\n{\npublic:\n    int longestValidParentheses(string s)\n    {\n        vector<int> v;\n        for (int i = 0; i < s.length(); i++)\n        {\n            if (s[i] == '(')\n            {\n                v.push_back(i);\n            }\n            else\n            {\n                if (v.size() > 0 && s[v.back()] == '(')\n                {\n                    v.pop_back();\n                }\n                else\n                {\n                    v.push_back(i);\n                }\n            }\n        }\n        if (v.size() == 0)//ARRAY WE STORE INDICES WHERE OUR SUBSTRINGS WILL BE INCOREECT & EXTRA OPENING BRACKET'S INDICES\n            return s.length();\n        int ans = 0, a = 0, b = s.length();\n        while (v.size() > 0)\n        {\n            a = v.back();\n            v.pop_back();\n            ans = max(ans, b - a - 1);\n            b = a;\n        }\n        ans = max(ans,b);\n        return ans;\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def longestValidParentheses(self, s):\n        x=0\n        s=list(s)\n        f=[]\n        z=0\n        q=0\n        for _ in s:\n            if s[x]==\"(\":\n                s[x]=1\n                z=1\n\n            else:\n                s[x]=-1\n                q=1\n            x=x+1\n        x=0\n        w=0\n        c=[]\n        if z==0 or q==0:\n            return 0\n        x=0\n        for _ in s:\n            y=0\n            d=1\n            p=1\n            if s[x]==-1:\n                x=x+1\n            else:\n                for _ in range( 0,len(s)-x-1):\n                    \n                    d=d+s[y+x+1]\n                    if d<=0:\n                        f.append (y+2)       \n                        if d<0:\n                            break                    \n                    y=y+1\n                if d==1 and s[y+x]==1:\n                    c.append([x,y-1])\n                \n                if d==-1 or d==0:\n                    c.append([x,y])\n                x=x+1\n        print(f)\n        x=0\n        k=0\n        \n        if len(c)==0:\n            return (0)\n        for _ in c:\n            l=c[x][1]\n            if l>k:\n                k=l+1\n                \n            x=x+1\n        print(k)\n        \n        if len(f)>0:\n            \n            x=0\n            for _ in f:\n                if f[x]%2!=0:\n                    f[x]=f[x]-1\n                if k<f[x]:\n                    k=f[x]\n                x=x+1\n            \n        return(k)\n        "
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar longestValidParentheses = function (s) {\n    // Variable to store the longest valid parentheses\n    let count = 0;\n    // Left counter will count the number of '('\n    let left = 0;\n    // Right counter will count the number of ')'\n    let right = 0;\n    // Loop through the string from left to right.\n    // This will take care of extra right parentheses\n    for (let i = 0; i < s.length; i++) {\n        // Current character\n        let c = s[i];\n        if (c === '(') {\n            left++;\n        }\n        if (c === ')') {\n            right++;\n        }\n        // If both left and right are equal,\n        // it means we have a valid substring\n        if (left === right) {\n            count = Math.max(count, left + right);\n        }\n        // If right is greater than left,\n        // it means we need to set both\n        // counters to zero\n        if (right > left) {\n            left = right = 0;\n        }\n    }\n    // Reset left and right\n    left = right = 0;\n    // Follow the same approach but now loop the string\n    // from right to left. This will take care of extra\n    // left parentheses\n    for (let i = s.length - 1; i >= 0; i--) {\n        // Current character\n        let c = s[i];\n        if (c === '(') {\n            left++;\n        }\n        if (c === ')') {\n            right++;\n        }\n        // If both left and right are equal,\n        // it means we have a valid substring\n        if (left === right) {\n            count = Math.max(count, left + right);\n        }\n        // If right is greater than left,\n        // it means we need to set both\n        // counters to zero\n        if (left > right) {\n            left = right = 0;\n        }\n    }\n    return count;\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int left=0;\n        int right=0;\n        int ans=0;\n        int n=s.size();\n        for(int i=0;i<n;i++){\n            if(s[i]=='(')left++;\n            else right++;\n            if(left==right)ans=max(ans,right*2);\n            else if(right>left)left=right=0;\n        }\n        left=right=0;\n        for(int i=n-1;i>=0;i--){\n            if(s[i]==')')right++;\n            else left++;\n            if(left==right)ans=max(ans,right*2);\n            else if(left>right)left=right=0;\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "php",
                "code": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int n = s.length(), longest = 0;\n        stack<int> st;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '(') st.push(i);\n            else {\n                if (!st.empty()) {\n                    if (s[st.top()] == '(') st.pop();\n                    else st.push(i);\n                }\n                else st.push(i);\n            }\n        }\n        if (st.empty()) longest = n;\n        else {\n            int a = n, b = 0;\n            while (!st.empty()) {\n                b = st.top(); st.pop();\n                longest = max(longest, a-b-1);\n                a = b;\n            }\n            longest = max(longest, a);\n        }\n        return longest;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        stack<int> stk;\n        stk.push(-1);\n        int ans = 0;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == '(') {"
            },
            {
                "language": "cpp",
                "code": "public int longestValidParentheses(String s) {\n    boolean valid[] = new boolean[s.length()];\n\n    Stack<Integer> stack = new Stack<>();\n    for (int i = 0; i < s.length(); i++) {\n        if (s.charAt(i) == '(') stack.push(i);\n        else if (!stack.isEmpty()) {"
            },
            {
                "language": "python",
                "code": "public int longestValidParentheses(String s) {\n    char[] S = s.toCharArray();\n    int[] V = new int[S.length];\n    int open = 0;\n    int max = 0;"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\npublic int longestValidParentheses(String s) {\n    int max = Integer.MIN_VALUE;\n    s += \"x\";\n    Stack<Integer> stack = new Stack<>();\n    for(int i = 0; i < s.length(); i++){\n        if(s.charAt(i) == ')' && !stack.empty() && s.charAt(stack.peek())== '(')"
            },
            {
                "language": "cpp",
                "code": "int longestValidParentheses(string s) {\n    int size = s.size(), res = 0;\n    if(size < 2) return res;\n    stack<int> si;\n    for(int i = 0; i < size; ++i) {\n        if('(' == s[i]) si.push(i);"
            },
            {
                "language": "cpp",
                "code": "    def longestValidParentheses(self, s):\n         stack, res, s = [0], 0, ')'+s\n         for i in xrange(1, len(s)):\n             if s[i] == ')' and s[stack[-1]] == '(':\n                 stack.pop()\n                 res = max(res, i - stack[-1])\n             else:\n                 stack.append(i)"
            },
            {
                "language": "python",
                "code": "    public int longestValidParenthesesOnline(String s) {\n        if (s == null) return -1;\n        if (s.length() == 0) return 0;"
            },
            {
                "language": "cpp",
                "code": "    public int longestValidParentheses(String s) {\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') stack.push(i);\n            else if (!stack.empty() && s.charAt(stack.peek()) == '(') stack.pop();  \n            else stack.push(i);\n        }\n        if (stack.empty()) return s.length();\n        int res = 0, high = s.length();"
            },
            {
                "language": "csharp",
                "code": "    int longestValidParentheses(string s) {\n        calcInvalid(s, '(');\n        reverse(s.begin(), s.end());\n        return calcInvalid(s, ')');\n    }\n    \n    int calcInvalid(string& s, char plus) {\n        int stack_ = 0, invalid = 0, longest = 0, length = 0;"
            },
            {
                "language": "php",
                "code": "Example - '()())()'\nInitial stack(from bottom to top) :  [ -1 ] , MAX = 0\n\n1. i = 0          |   s[i] = '('        =>     case-1: push current index into stack\nstack : [-1, 0]   |   MAX = 0\n\n2. i = 1          |   s[i] = ')'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\nstack : [-1]      |   MAX = max(0, 1 - (-1)) = 2.\n\n'NOTE : Since the index starts from 0, having index preceding to the start of valid parentheses will give us actual length of the valid parentheses,\ninstead of us having to add 1 to it everytime.'\n\n3. i = 2          |   s[i] = '('        =>     case-1: push current index into stack\nstack : [-1, 1]   |   MAX = 2.\n\n4. i = 3          |   s[i] = ')'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\nstack : [-1]      |   MAX = max(2, 3 - (-1)) = 4.\n\n5. i = 4          |   s[i] = ')'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\nThis denotes any valid parentheses from now will start from next index and previous valid parentheses cant be extended further.\nstack : [4]       |   MAX = 4.\n\n6. i = 5          |   s[i] = '('        =>     case-1: push current index into stack\nstack : [4, 5]    |   MAX = 4.\n\n7. i = 6          |   s[i] = ')'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\nstack : [4]       |   MAX = max(4, 6 - 4) = 4."
            },
            {
                "language": "cpp",
                "code": "int longestValidParentheses(string s) {\n int MAX = 0;  // denotes length of maximum valid parentheses\n stack<int> stk;\n stk.push(-1); // bottom of stack will always hold index preceding to potential start of valid parentheses\n for(int i = 0; i < size(s); i++)\n  if(s[i] == '(') stk.push(i);            \n  else{                \n   stk.pop();\n   if(stk.empty()) stk.push(i);\n   else MAX = max(MAX, i - stk.top());\n  }        \n return MAX;\n}"
            },
            {
                "language": "cpp",
                "code": "int n=s.length();\n        if(n==0)\n            return 0;\n        Stack<Character> stack=new Stack<Character>();\n        int max=0;\n        int count=0;\n        for(int i=0;i<n;i++)"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        pos=[]\n        left=[]\n        index=-1\n        max_num=0\n        max_list=[0]\n        i = 0\n        while i < len(s):\n            if s[i] == '(':    \n                left.append(0)\n                pos.append(i)\n            elif s[i] == ')' and len(pos) != 0:\n                left[pos.pop()] = 1\n                left.append(1)\n            elif s[i] == ')' and len(pos) == 0:\n                left.append(0)\n           \n            i += 1\n \n        for i in left:\n            if i == 1:\n                max_num += 1\n            if i == 0:\n                max_list.append(max_num)\n                max_num = 0\n            max_list.append(max_num)\n\n        return max(max_list)\n\n                    "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int longestValidParentheses(string str) {\n        \n        int n = str.size();\n        \n        int maxi = 0;\n        \n        // dp[i] will store the maximum length of balanced parenthesis ending at i\n        \n        vector<int> dp(n, 0);\n        \n        // st will store the index of '('\n        \n        stack<int> st;\n        \n        for(int i = 0; i < n; i++)\n        {\n            if(str[i] == '(')\n            {\n                st.push(i);\n            }\n            else if(str[i] == ')')\n            {\n                if(st.empty())\n                {\n                    dp[i] = 0;\n                }\n                else\n                {\n                    int idx = st.top();\n                    \n                    st.pop();\n                    \n                    if(idx > 0)\n                    {\n                        dp[i] = dp[idx - 1] + dp[i - 1] + 2;\n                    }\n                    else\n                    {\n                        dp[i] = dp[i - 1] + 2;\n                    }\n                }\n            }\n            \n            // update maxi\n            \n            maxi = max(maxi, dp[i]);\n        }\n        \n        return maxi;\n    }\n};"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        stack = [-1]\n        max_len = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n        return max_len"
            }
        ]
    },
    "32": {
        "question_id": 33,
        "title": "Search in Rotated Sorted Array",
        "difficulty": 2,
        "description": "There is an integer array nums sorted in ascending order (with distinct values).Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.You must write an algorithm with O(log n) runtime complexity. ",
        "examples": [
            {
                "input": "nums = [4,5,6,7,0,1,2], target = 0",
                "output": "4",
                "explanation": null
            },
            {
                "input": "nums = [1], target = 0",
                "output": "-1",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 5000",
            "-104 <= nums[i] <= 104",
            "All values of nums are unique.",
            "nums is an ascending array that is possibly rotated.",
            "-104 <= target <= 104"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\n    public int search(int[] arr, int x) {\n        int l=arr.length;\n        int i=0;\n        while(i+1<l&&arr[i]<arr[i+1])\n        {\n            i++;\n        }\n        Arrays.sort(arr);\n         int beg=0,end=l-1,mid;\n        while(beg<=end)\n        {\n            mid=(beg+end)/2;\n            if(x==arr[mid])\n            {\n                if((mid+i)>=(l-1))\n                return mid+i-l+1;\n                return mid+i+1;\n            }\n            else if(arr[mid]<x)\n            beg=mid+1;\n            else\n            end=mid-1;\n        \n        }\n        return -1;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n     int n = nums.size();\n      int left = 0;\n      int right = n-1;\n      int mid= left + (right - left) / 2;\n      while(left <= right){\n      mid = left + (right - left) / 2;\n        if(nums[mid] == target)\n         return mid;\n        if(nums[mid] >= nums[left]) {\n          if(target >= nums[left] && target <= nums[mid])\n            {\n                right = mid - 1;\n            }\n           else left = mid + 1;\n        } \n        else {\n          if(target >= nums[mid] && target <= nums[right]) \n            left = mid + 1;\n          else right = mid - 1;\n        }\n          mid = left + (right - left) / 2;\n      }\n      return -1;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int search(int[] nums, int target) {\n      int start=0;\n        int end=nums.length-1;\n        \n        while(start<=end){\n        int mid= start+(end-start) /2;\n        if(nums[mid]==target) return mid;\n        if(nums[start]<=nums[mid]){\n            if(target<=nums[mid] && target>=nums[start]){\n                end=mid-1;\n            }else{\n                start=mid+1;\n            }\n        }\n        else{\n            if(target>=nums[mid] && target<=nums[end]){  \n                start=mid+1;\n            }else{\n                end=mid-1;\n            }\n        }\n        }\n        return -1;\n    }\n    \n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int size=nums.size();\n        int left=0;\n        int right=size-1;\n        int mid;\n        while(left<=right){\n            mid=(left+right)/2;\n            if(nums[mid]==target) return mid;\n\n            if(nums[mid]>=nums[left]){\n                if(target>=nums[left] && target<=nums[mid]){\n                    right=mid-1;\n                }else left=mid+1;\n            }else{\n                if(target>=nums[mid] && target<=nums[right])\n                   left=mid+1;\n                else\n                right=mid-1;   \n            }\n        }\n        return -1;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int search(int[] nums, int target) {\n        int ans = bs(nums, target, 0, nums.length-1);\n        return ans;\n\n        \n    }\n\n    int bs(int[] nums, int t, int s, int e){\n        if(s>e) return -1;\n        \n        int mid = s + (e-s)/2;\n        if(nums[mid]==t) return mid;\n        // check if we are in left sorted array\n        if(nums[mid]>=nums[s]){\n            // check target is in left sorted array\n            if(t>=nums[s] && t<=nums[mid]){\n                return bs(nums, t, s, mid-1);\n            }\n            return bs(nums, t, mid+1, e);\n        }\n        else{\n            if(t>=nums[mid] && t<=nums[e]){\n                return bs(nums, t, mid+1, e);\n            }\n            return bs(nums, t, s, mid-1);\n        }\n\n    }\n\n}\n\n// [0,1,2,4,5,6,7]\n// rotate by 1 time - [1,2,4,5,6,7,0]\n// 2 times- [2,4,5,6,7,0,1]\n\n// [4,5,6,7          ,0,1,2] \n// s          mid         e\n// check mid is greater than start\n//         check target greater than start and less than mid{\n//             put end as mid-1\n//         }\n//         else(put start as mid+1)\n// else\n//     check target is greater than mid and less than end{\n//         start = mid+1\n//     }\n//     else end = mid-1;"
            },
            {
                "language": "java",
                "code": "class Solution {\nprivate:\nint getPivot(vector<int>& arr) {\n\n    int s = 0;\n    int e = arr.size()-1;\n    int mid = s + (e-s)/2;\n\n    while(s<e) {\n\n        if(arr[mid] >= arr[0])\n        {\n            s = mid+1;\n        }\n        else{\n            e = mid;\n        }\n        mid = s + (e-s)/2;\n    }\n    return s;\n}\nint binarySearch(vector<int>& nums, int target , int start , int end) {\n        while(start <= end){\n            int mid = start + (end - start)/2;\n            if(nums[mid] == target){\n                return mid;\n            }\n            if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n        }\n        return -1;\n    }\npublic:\n    int search(vector<int>& nums, int target) {\n        int n = nums.size();\n        int pivot = getPivot(nums);\n        if(target >= nums[pivot] && target<=nums[n-1]){\n            return binarySearch(nums,target,pivot,n-1);\n        }\n        else{\n            return binarySearch(nums,target,0,pivot-1);\n        }\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\npublic:\n    int findPivot(vector<int> arr){\n       int s = 0;\n       int e = arr.size()-1;\n\n       int mid = s + (e-s)/2;\n\n       while(s<=e){\n\n           if(s==e){\n               return s;\n           }\n\n           if(((mid+1)<arr.size()) && \n                arr[mid]>arr[mid+1]){\n                    return mid;\n            }\n            else if(((mid-1)>=0) && \n                arr[mid-1]>arr[mid]){\n                    return mid-1;\n                }\n\n            if(arr[s]>arr[mid]){\n                e = mid-1;\n            }else{\n                s = mid+1;\n            }\n           mid = s + (e-s)/2;\n       }     \n return -1;\n    }\n    int binarySearch(vector<int> arr,int t,int start,int end){\n        int s = start;\n        int e = end;\n        int mid = s + (e-s)/2;\n        cout<<s<<\" s \"<<e<<\" e \"<<mid<<\" mid \"<<endl;\n        while(s<=e){\n            if(arr[mid] == t){\n                return mid;\n            }\n            if(t>arr[mid]){\n                s = mid+1;\n            }else{\n                e = mid-1;\n            }\n            mid = s + (e-s)/2;\n            cout<<\"mid in between \"<<mid;\n        }\n        return -1;\n\n    }\n    int search(vector<int>& nums, int target) {\n          //  cout<<findPivot(nums)<<\" n\";\n            int pi = findPivot(nums);\n\n            if(target>=nums[0] && target<=nums[pi]){\n                return binarySearch(nums,target,0,pi);\n            }\n            if(((pi+1)<nums.size())\n            &&target>=nums[pi+1] && target<=nums[nums.size()-1]){\n                return binarySearch(nums,target,pi+1,nums.size()-1);\n            }\n\n        return -1;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int search(int[] nums, int target) {\n        for(int i = 0; i < nums.length; i++)\n        {\n            if(nums[i] == target)\n            {\n                return i;\n            }\n        }\n        return -1;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        for(int i = 0; i < nums.size(); i++)\n        {\n            if(nums[i] == target)\n            {\n                return i;\n            }\n        }\n        return -1;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        if target in nums:\n            return nums.index(target)\n        return -1"
            },
            {
                "language": "java",
                "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n\nint n=nums.size();\n\n// find pivot\n  int s = 0;\n  int e = n - 1;\n  while (s < e) \n  {\n    int mid = s + (e - s) / 2;\n    if (nums[mid] >= nums[0]) \n    {\n      s = mid + 1;\n    } \n    else\n      e = mid;\n  }\n  int pivot = e;\n\n  // apply binary search\n  int index=-1;\n  if (target <= nums[n - 1] && target >= nums[pivot])\n  {\n    int start = pivot;\n    int end = n - 1;\n    while (start <= end) \n    {\n      int mid = start + (end - start) / 2;\n      if (nums[mid] == target) \n      {\n        index = mid;\n        break;\n      } \n      else if (nums[mid] > target) \n      {\n        end = mid - 1;\n      } \n      else if (nums[mid] < target) \n      {\n        start = mid + 1;\n      }\n    }\n  }\n  else\n  {\n    int start = 0;\n    int end = pivot - 1;\n    while (start <= end) {\n      int mid = start + (end - start) / 2;\n      if (nums[mid] == target) \n      {\n        index = mid;\n        break;\n      } \n      else if (nums[mid] > target) \n      {\n        end = mid - 1;\n      } \n      else if (nums[mid] < target) \n      {\n        start = mid + 1;\n      }\n    }\n  }\n  return index;\n\n\n\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        for i in range(len(nums)):\n            if nums[i]==target:\n                return nums.index(nums[i])\n                break\n        else:\n            return -1"
            }
        ]
    },
    "33": {
        "question_id": 34,
        "title": "Find First and Last Position of Element in Sorted Array",
        "difficulty": 2,
        "description": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.If target is not found in the array, return [-1, -1].You must write an algorithm with O(log n) runtime complexity. ",
        "examples": [
            {
                "input": "nums = [5,7,7,8,8,10], target = 8",
                "output": "[3,4]",
                "explanation": null
            },
            {
                "input": "nums = [], target = 0",
                "output": "[-1,-1]",
                "explanation": null
            }
        ],
        "constraints": [
            "0 <= nums.length <= 105",
            "-109\u00a0<= nums[i]\u00a0<= 109",
            "nums is a non-decreasing array.",
            "-109\u00a0<= target\u00a0<= 109"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int n = nums.length;\n        start(nums,target,0,n-1);\n        end(nums,target,0,n-1);\n        int arr[] = new int[2];\n        arr[0] =str;\n        arr[1] =en;\n        return arr;\n    }\n    int str =-1;\n    public void start(int[] a , int t , int s , int e){\n    if(s>e){\n    return;\n    }\n\n    int mid = (s+e)/2;\n\n    if(a[mid]==t)\n    str =mid;\n\n    if(a[mid]>=t){\n    start(a,t,s,mid-1);\n    }\n    else{\n    start(a,t,mid+1,e);\n        }\n    }\n    int en =-1;\n    public void end(int[] a , int t , int s , int e){\n        if(s>e){\n        return;\n        }\n\n        int mid = (s+e)/2;\n\n        if(a[mid]==t)\n    en = mid;\n\n        if(a[mid]<=t){\n            end(a,t,mid+1,e);\n        }else{\n            end(a,t,s,mid-1);\n        }\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N), because in the worst case we traverse the <= N element. Where N is the size of the\n    Array(nums).\n                    \n    Space Complexity : O(1), the space complexity is constant.\n\n    Solved using Linear Search.\n\n*/\n\n\n/***************************************** Approach 1 First Code *****************************************/\n\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int startingPosition = -1, endingPosition = -1;\n        int n = nums.size();\n        for(int i=0; i<n; i++){\n            if(nums[i] == target){\n                startingPosition = i;\n                break;\n            }\n        }\n        for(int i=n-1; i>=0; i--){\n            if(nums[i] == target){\n                endingPosition = i;\n                break;\n            }\n        }\n        return {startingPosition, endingPosition};\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\n    is logarithmic.\n\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\n    constant.\n\n    Solved using Binary Search.\n\n*/\n\n\n/***************************************** Approach 2 First Code *****************************************/\n\nclass Solution {\nprivate:\n    int lower_bound(vector<int>& nums, int low, int high, int target){\n        while(low <= high){\n            int mid = (low + high) >> 1;\n            if(nums[mid] < target){\n                low = mid + 1;\n            }\n            else{\n                high = mid - 1;\n            }\n        }\n        return low;\n    }\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int low = 0, high = nums.size()-1;\n        int startingPosition = lower_bound(nums, low, high, target);\n        int endingPosition = lower_bound(nums, low, high, target + 1) - 1;\n        if(startingPosition < nums.size() && nums[startingPosition] == target){\n            return {startingPosition, endingPosition};\n        }\n        return {-1, -1};\n    }\n};\n\n\n\n\n\n\n/***************************************** Approach 2 Second Code *****************************************/\n\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int startingPosition = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\n        int endingPosition = lower_bound(nums.begin(), nums.end(), target+1) - nums.begin() - 1;\n        if(startingPosition < nums.size() && nums[startingPosition] == target){\n            return {startingPosition, endingPosition};\n        }\n        return {-1, -1};\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int c=-1,d=-1;;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==target){\n                c=i;\n                break;\n            }\n        }\n         for(int i=nums.length-1;i>=0;i--){\n            if(nums[i]==target){\n                d=i;\n                break;\n            }\n        }\n        int a[]=new int[2];\n        for(int i=0;i<2-1;i++){\n            a[i]=c;\n            a[i+1]=d;\n        }\n        return a;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "int first_element_of_the_array(vector<int>& arr,int target){\n        int low= 0;\n        int high = arr.size()-1;\n        int res = -1;\n            while(low <= high){\n                int mid = low +(high-low)/2;\n                if(arr[mid] == target){\n                    res = 1;\n                    high = mid-1;\n                }if(arr[mid] < target){\n                    low = mid+1;\n                }if(arr[mid] > target){\n                    high = mid-1;\n                }\n            }\n            if(res == -1){\n                    return -1;\n            }\nreturn low; \n}\nint last_element_of_the_array(vector<int>& arr,int target){\n        int low= 0;\n        int high = arr.size()-1;\n        int res = -1;\n            while(low <= high){\n                int mid = low +(high-low)/2;\n                if(arr[mid] == target){\n                    res = 1;\n                    low = mid+1;\n                }if(arr[mid] > target){\n                    high = mid-1;\n                }if(arr[mid] < target){\n                    low = mid+1;\n                }\n            }\n            if(res == -1){\n                return -1;\n            }\n    return high;\n}\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        vector<int>result;\n        if(nums.size()== 0){\n            result.push_back(-1);\n            result.push_back(-1);\n            return result;\n        }\n        result.push_back(first_element_of_the_array(nums,target));\n        result.push_back(last_element_of_the_array(nums,target));\n        return result;\n    }\n};"
            },
            {
                "language": "ruby",
                "code": " def search_range(nums, target)\n     records = Hash.new([])\n     for i in 0...nums.length\n       records[nums[i]]=[]\n     end\n     for i in 0...nums.length\n       records[nums[i]] <<i\n     end\n     return records[target].empty? ? [-1, -1] : [records[target][0],records[target][-1]]\n end"
            },
            {
                "language": "ruby",
                "code": "def search_range(nums, target)\n  flag_first_index=false\n  ans=[-1,-1]\n  if !(nums.include?(target))\n    return ans\n  end\n  records = Hash.new(0)\n  for i in 0...nums.length\n    records[i]=nums[i]\n  end\n  records.each do |k,v|\n    if v==target && !flag_first_index\n      ans[0]=k\n      flag_first_index=true\n    elsif flag_first_index && v==target\n      ans[1]=k\n    end\n  end\n  ans[1] = ans[1]==-1? ans[0]: ans[1]\n  return ans\nend"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        \n        def binarySearch (nums, target):\n            if not nums:\n                return -1\n            start, end = 0, len(nums) - 1\n\n            while start + 1 < end:\n                mid = (start + end) // 2\n                if nums[mid] < target:\n                    start = mid\n                else: \n                    end = mid\n            \n            if nums[start] == target:\n                return start\n            \n            if nums[end] == target:\n                return end\n            return -1\n            \n        pos = binarySearch (nums, target)\n\n        if pos != -1:\n            start = end = pos\n\n            while end < len(nums) - 1 and nums[end] == target:\n                if nums[end + 1] == target:\n                    end += 1\n                else:\n                    break\n                \n            return [start, end]\n        else:\n            return [-1,-1]"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        vector<int> v;\n        v.push_back(-1);\n        v.push_back(-1);\n        int st=0;int end=nums.size()-1;\n        while(st<=end){\n           int mid=(st+end)/2;\n           if(nums[mid]==target){\n               v[0]=mid;\n               end=mid-1;\n           }else if(nums[mid]<target){\n               st=mid+1;\n           }else{\n               end=mid-1;\n           }\n          \n        }\n         st=0;end=nums.size()-1;\n         while(st<=end){\n           int mid=(st+end)/2;\n           if(nums[mid]==target){\n               v[1]=mid;\n               st=mid+1;\n           }else if(nums[mid]<target){\n               st=mid+1;\n           }else{\n               end=mid-1;\n           }\n        }\n        return v;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int low = 0, high = nums.size()-1;\n        int start = -1, end = -1;\n\n        // Searching the start index of target\n        while(low<=high){\n            int mid = low + (high-low)/2;\n            if(nums[mid] < target){ low = mid+1; }\n            else if(nums[mid] > target){ high = mid-1; }\n            else{   // nums[mid] == target\n                start = mid;\n                high = mid-1;\n            }\n        }\n        \n        // Searching the end index of target\n        if(start!=-1){\n            low = 0, high = nums.size()-1;\n            while(low<=high){\n                int mid = low + (high-low)/2;\n                if(nums[mid] < target){ low = mid+1; }\n                else if(nums[mid] > target){ high = mid-1; }\n                else{   // nums[mid] == target\n                    end = mid;\n                    low = mid+1;\n                }\n            }\n        }\n\n        return {start, end};\n    }\n\n    // Author - Mufaddal Saifuddin\n};"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        startingPos = -1\n        endingPos = -1\n        m = len(nums)\n        if (m != 0) and (target>=nums[0]) and (target<=nums[m-1]):\n            for i in range(m):\n                if startingPos == -1:\n                    if nums[i] == target:\n                        startingPos = i\n                        endingPos = i    \n                elif nums[i] == target:\n                    endingPos = i\n                else:     \n                    break\n        return [startingPos, endingPos]\n            "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n   int lower_bound(vector<int>& arr, int x)\n{\n  int n=arr.size();\n    int low=0, high=n-1, mid;\n    \n    while(low<high)\n    {\n        mid=(low+high)/2;\n        if(arr[mid]<x)\n        {\n            low=mid+1;\n        }\n        else\n        {\n            high=mid;\n        }\n    }\n    return low;\n     \n}\nint upper_bound(vector<int>& arr, int x)\n{    int n=arr.size();\n     int low=0, high=n-1, mid;\n    while(low<high)\n    {\n        mid=(low+high)/2;\n        if(arr[mid]<=x)\n        {\n            low=mid+1;\n        }\n        else\n        {\n            high=mid;\n        }\n    }\n    return low;\n}\n    vector<int> searchRange(vector<int>& arr, int x) {\n    int n=arr.size();\n    if(!n) return {-1, -1};\n    auto idx1=lower_bound(arr,  x);\n    auto idx2=upper_bound(arr, x);\n    if(arr[idx1]!=x) return {-1, -1};\n    if(arr[idx2]!=x) idx2--;\n    \n      return {idx1, idx2};\n    \n    }\n};"
            }
        ]
    },
    "34": {
        "question_id": 35,
        "title": "Search Insert Position",
        "difficulty": 1,
        "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.You must write an algorithm with O(log n) runtime complexity. ",
        "examples": [
            {
                "input": "nums = [1,3,5,6], target = 5",
                "output": "2",
                "explanation": null
            },
            {
                "input": "nums = [1,3,5,6], target = 2",
                "output": "1",
                "explanation": null
            },
            {
                "input": "nums = [1,3,5,6], target = 7",
                "output": "4",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 104",
            "-104 <= nums[i] <= 104",
            "nums contains distinct values sorted in ascending order.",
            "-104 <= target <= 104"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int start = 0;\n        int end = nums.length-1;\n\n        while (start <= end) {\n            int mid = start + (end-start)/2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] > target) end = mid-1;\n            else start = mid+1;\n        }\n\n        return start;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "int searchInsert(int* nums, int numsSize, int target){\n    int index1 = -1;\n    int index2 = -1;\n\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] == target) {\n            index1 = i;\n            break;\n        }\n        else if (nums[i] >= target) {\n            index2 = i;\n            break;\n        }\n    }\n    \n    if (index1 == -1 && index2 == -1) return numsSize;\n\n    return index1 != -1 ? index1 : index2;\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n int binarySearch(vector<int>&nums,int start,int end,int target){\n        while(start<=end){\n            int mid = start + (end-start)/2;\n\n            if(nums[mid]<target){\n                start = mid+1;\n            }\n            else if(nums[mid]>=target){\n                end = mid-1;\n            }\n        }\n        return start;\n    }\n\n\n    int searchInsert(vector<int>& nums, int target) {\n\n        return binarySearch(nums,0,nums.size()-1,target);\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        if target < nums[0]:\n            return 0\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) >> 1\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        print(l, r, mid)\n        return l"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)\n\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n\n        return left"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        return bisect_left(nums, target)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n            int start = 0 , end = nums.size()-1;\n    while(start<=end){\n        int mid = (start+end)/2;\n        if(nums[mid]==target){\n            return mid;\n        }\n        else if (nums[mid]>target){\n            end = mid-1;\n        }\n        else{\n            start = mid + 1;\n        }\n    }\n        return end+1;\n\n        \n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        \n    int n=nums.size();\n    int start = 0;\n    int end = n - 1;\n    int ans;\n    while (start <= end)\n    {\n        int mid = start + (end - start) / 2;\n\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            break;\n        }\n        else if (nums[mid] > target)\n        {\n            end = mid - 1;\n            if (start > end)\n            {\n                ans = start;\n            }\n        }\n        else if (nums[mid] < target)\n        {\n            start = mid + 1;\n            if (start > end)\n            {\n                ans = start;\n            }\n        }\n    }\n    return ans;\n\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if target <= nums[mid]:\n                right = mid\n            else:\n                left = mid + 1\n            \n        return left "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int searchInsert(vector<int>& v, int target) {\n        \n        auto it = lower_bound( v.begin() ,v.end() , target );\n        return (it == v.end()) ?  v.size() : (it - v.begin());\n        \n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l=0;\n        int r=nums.size()-1;\n        int m;\n        while(l<=r){\n            m=(l+r)/2;\n            if(nums[m]==target){\n                return m;\n            }else if(nums[m]>target){\n                r=m-1;\n            }\n            else{\n                l=m+1;\n            }\n        }\n        return l;\n    }\n};"
            }
        ]
    },
    "35": {
        "question_id": 36,
        "title": "Valid Sudoku",
        "difficulty": 2,
        "description": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:Each row must contain the digits 1-9 without repetition.Each column must contain the digits 1-9 without repetition.Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.Note:A Sudoku board (partially filled) could be valid but is not necessarily solvable.Only the filled cells need to be validated according to the mentioned rules. ",
        "examples": [
            {
                "input": "board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
                "output": "true",
                "explanation": null
            },
            {
                "input": "board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
                "output": "false",
                "explanation": "Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid."
            }
        ],
        "constraints": [
            "board.length == 9",
            "board[i].length == 9",
            "board[i][j] is a digit 1-9 or '.'."
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        def valid(arr):\n            s=''.join(arr).replace('.','')\n            return len(s)==len(set(s))\n        def checkrow():\n            for row in board:\n                if not valid(row):\n                    return False\n            return True\n        def checkcol():\n            for col in zip(*board):\n                if not valid(col):\n                    return False\n            return True\n        def square():\n            for r in range(0,9,3):\n                for c in range(0,9,3):\n                    nums=[board[r+i][c+j] for i in range(3) for j in range(3)]\n                    if not valid(nums):\n                        return False\n            return True\n        return checkrow() and checkcol() and square()\n\n//please upvote me it would encourage me alot"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        row=defaultdict(set)\n        col=defaultdict(set)\n        square=defaultdict(set)\n        for r in range(9):\n            for c in range(9):\n                x=board[r][c]\n                if board[r][c]==\".\":\n                    continue\n                if x in row[r] or x in col[c] or x in square[(r//3,c//3)]:\n                    return False\n                row[r].add(board[r][c])\n                col[c].add(board[r][c])\n                square[(r//3,c//3)].add(board[r][c])\n        return True\n        "
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def isValidSudoku(self, board):\n        res = []\n        for i in range(9):\n            for j in range(9):\n                element = board[i][j]\n                if element != '.':\n                    res += [(i, element), (element, j), (i // 3, j // 3, element)]\n        return len(res) == len(set(res))"
            },
            {
                "language": "java",
                "code": "public boolean isValidSudoku(char[][] board) {\n    Set seen = new HashSet();\n    for (int i=0; i<9; ++i) {\n        for (int j=0; j<9; ++j) {\n            if (board[i][j] != '.') {\n                String b = \"(\" + board[i][j] + \")\";\n                if (!seen.add(b + i) || !seen.add(j + b) || !seen.add(i/3 + b + j/3))\n                    return false;\n            }\n        }\n    }\n    return true;\n}"
            },
            {
                "language": "typescript",
                "code": "public boolean isValidSudoku(char[][] board) {\n    Set seen = new HashSet();\n    for (int i=0; i<9; ++i) {\n        for (int j=0; j<9; ++j) {\n            char number = board[i][j];\n            if (number != '.')\n                if (!seen.add(number + \" in row \" + i) ||\n                    !seen.add(number + \" in column \" + j) ||\n                    !seen.add(number + \" in block \" + i/3 + \"-\" + j/3))\n                    return false;\n        }\n    }\n    return true;\n}"
            },
            {
                "language": "php",
                "code": "public boolean isValidSudoku(char[][] board) {\n        for(int i = 0;i < 9;i++){\n            boolean[] rowCheck = new boolean[9];\n            boolean[] colCheck = new boolean[9];\n            boolean[] boxCheck = new boolean[9];\n            for(int j = 0;j< 9;j++){\n                if(board[i][j] == '.'){}\n                else if(rowCheck[board[i][j] - '1']) return false;"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public static boolean isValidSudoku(char[][] board) {\n        if(!checkRows(board)){\n            return false;\n        }\n        if(!checkColumns(board)){\n            return false;\n        }\n        if(!checkSquares(board)){\n            return false;\n        }\n\n        return true;\n    }\n\n    public static boolean checkSquares(char[][] board){\n        List<Character> existsNumbers = new ArrayList<>();\n        int rowCounter = 0;\n        int columnCounter = 0;\n        int currentSquareLine = 0;\n        while(true){\n            if(board[rowCounter][columnCounter] != '.'){\n                existsNumbers.add(board[rowCounter][columnCounter]);\n            }\n            if(rowCounter % 3 == 2 && columnCounter % 3 == 2){\n                if(isRepeatNumbers(existsNumbers)){\n                    return false;\n                } else {\n                    if (rowCounter == 8 && columnCounter == 8){\n                        break;\n                    } else {\n                        existsNumbers = new ArrayList<>();\n                    }\n                \n                }\n            }\n            if(rowCounter % 3 == 2){\n                if(columnCounter == 8){\n                    columnCounter = 0;\n                    currentSquareLine += 3;\n                    rowCounter = currentSquareLine;\n                } else {\n                    ++columnCounter;\n                    rowCounter = currentSquareLine;\n                }\n            } else {\n                ++rowCounter;\n            }\n\n        }\n        return true;\n\n    }\n\n    public static boolean checkRows(char[][] board){\n        List<Character> existsNumbers = new ArrayList<>();\n        for (int i = 0; i < board.length; ++i) {\n            for (int j = 0; j < board[0].length; ++j) {\n                if (board[i][j] != '.') {\n                    existsNumbers.add(board[i][j]);\n\n                }\n            }\n            if (isRepeatNumbers(existsNumbers)) {\n                return false;\n            }\n            existsNumbers = new ArrayList<>();\n        }\n        return true;\n    }\n\n    public static boolean checkColumns(char[][] board){\n        List<Character> existsNumbers = new ArrayList<>();\n        for (int i = 0; i < board.length; ++i) {\n            for (int j = 0; j < board[0].length; ++j) {\n                if (board[j][i] != '.') {\n                    existsNumbers.add(board[j][i]);\n\n                }\n            }\n            if (isRepeatNumbers(existsNumbers)) {\n                return false;\n            }\n            existsNumbers = new ArrayList<>();\n        }\n        return true;\n    }\n\n    public static boolean isRepeatNumbers(List<Character> numbers) {\n        for (int i = 0; i < numbers.size() - 1; ++i) {\n            for (int j = numbers.size() - 1; j > i; --j) {\n                if (numbers.get(i) == numbers.get(j)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}"
            },
            {
                "language": "",
                "code": "O(162) || O(N^2)"
            },
            {
                "language": "javascript",
                "code": "A Lot of space occupied!\nLike - Number of elements having their own hashmap!\nWorst Case O(N^N)"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        cross3 = {}\n        for i in range(3):\n            for j in range(3):\n                cross3 = {}\n                for x in range(i*3, i*3+3):\n                    for y in range(j*3, j*3+3):\n                        if board[x][y] != '.':\n                            if board[x][y] not in cross3:\n                                cross3[board[x][y]] = ''\n                            else:\n                                return False\n        Big_Location = {\"1x\":{}, \"2x\":{}, \"3x\":{}, \"4x\":{}, \"5x\":{}, \"6x\":{}, \"7x\":{}, \"8x\":{}, \"9x\":{}, \"1y\":{}, \"2y\":{}, \"3y\":{}, \"4y\":{}, \"5y\":{}, \"6y\":{}, \"7y\":{}, \"8y\":{}, \"9y\":{}}\n        for x in range(len(board)):\n            for y in range(len(board[x])):\n                if board[x][y] != '.':\n                    if x in Big_Location[board[x][y]+\"x\"] or y in Big_Location[board[x][y]+\"y\"]:\n                        return False\n                    else:\n                        Big_Location[board[x][y]+\"x\"][x] = \"f\"\n                        Big_Location[board[x][y]+\"y\"][y] = \"f\"\n        return True"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"        \n        columns = [[row[id] for row in board] for id in range(len(board[0]))] # transposition\n        for row, row2 in zip(board, columns):\n            for num, num2 in zip(row, row2):\n                if (num.isdigit() and row.count(num) != 1) or (num2.isdigit() and row2.count(num2) != 1): #checking for reps in rows and columns\n                    return False\n\n        ###### Division into 3x3 blocks\n        temp_arr = []\n        arr = [] \n        for num in range(0,9,3): # division matrix to 3 columns 3x9\n            for col in board:\n                temp_arr.append(col[num:num+3])\n        for num in range(0,27,3): # division columns to 9 blocks 3x3\n            arr.append(temp_arr[num:num+3])\n        # temp_arr:     List[List[str, str, str]]\n        # arr:          List[List[List[str, str, str]]]\n        ######\n\n        values_arr = [] # Counting the temp_arr\n        for quad in arr:\n            temp_arr = [] # Temp list for 1 of 9 3\u04453 blocks\n\n            for row in quad: # conversion matrix 3x3 to 1x9\n                temp_arr += row\n\n            for value in temp_arr: # Counting the number of each digit in a 3x3 block\n                if value.isdigit():\n                    values_arr.append(temp_arr.count(value))\n\n        if values_arr != []:\n            if max(values_arr) > 1: # if max(values_arr) > 1 -> sudoku invalid\n                return False\n\n        return True\n            \n            "
            },
            {
                "language": "ruby",
                "code": "# @param {Character[][]} board\n# @return {Boolean}\n\ndef is_valid_sudoku(board)\n    areas = Array.new(27, 0) # 9 + 9 +  9 = 27\n    9.times do |i|\n        9.times do |j|\n            el = board[i][j]            \n            next if el == ?.\n            mask = 1 << (el.to_i - 1)\n            col = j + 9 # cols are in (9..17), rows are in (0..8)\n            box = 3 * (i / 3) + j / 3 + 18 # boxes are in (18..26)\n            return false unless mask & (areas[i] | areas[col] | areas[box]) == 0\n            areas[i] |= mask\n            areas[col] |= mask\n            areas[box] |= mask\n        end\n    end\n    true\nend"
            },
            {
                "language": "ruby",
                "code": "require 'test/unit'\nclass Test_is_valid_sudoku < Test::Unit::TestCase\n    def test_\n        board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        assert_equal true, is_valid_sudoku(board)\n        board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        assert_equal false, is_valid_sudoku(board)\n    end\nend"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \n        # Given an arr of row/col/sub,\n        # check if there are duplicates.\n        def isValid(arr):\n            s = ''.join(arr).replace('.','')\n            return len(s) == len(set(s))\n        \n        # Check each row in the board\n        def checkRow():\n            for row in board:\n                if not isValid(row):\n                    return False\n            return True\n        \n        # Check each col in the board,\n        # To access each col, we first unpack the board into sperate lists using *\n        # We then zip these rows together into columns.\n        def checkCol():\n            for col in zip(*board):\n                if not isValid(col):\n                    return False\n            return True\n        \n        # To get each sub-box, we first get the top-left indices of each sub-box,\n        # We then go 3 steps on each row and 3 steps on each col to construct the box.\n        def checkSub():\n            for r in range(0,9,3):\n                for c in range(0,9,3):\n                    sub = [board[r+dr][c+dc] for dr in range(3) for dc in range(3)]\n                    if not isValid(sub):\n                        return False\n            return True\n        \n        # In order to be a valid Sudoku, all row, col, and sub-box need to be valid\n        return checkRow() and checkCol() and checkSub()"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \n        # Row, Col, and subBox will each contain 9 sets to keep track of the visited element.\n        # Using 0-8 as the id for each row, col, and sub-box.\n        # At any time if the same number is visited twice, return False. \n        Row = defaultdict(set)\n        Col = defaultdict(set)\n        subBox = defaultdict(set)\n        \n        for r in range(9):\n            for c in range(9):\n                \n                cur = board[r][c]\n                if cur=='.':\n                    continue\n                \n                # r is the id for Row \n                if cur in Row[r]:\n                    return False\n                Row[r].add(cur)\n                \n                # c is the id for Col\n                if cur in Col[c]:\n                    return False\n                Col[c].add(cur)\n                \n                # sub-box id is a little bit tricky\n                # r//3*3 will map the number 0-8 to 0,3,6 which is the starting id for each row.\n                # c//3 will map the number 0-8 to 0,1,2, which is the column.\n                # So r//3*3+c//3 is corresponding to sub-box id as shown\n                                                             ----- ----- -----\n                boxId = r//3*3+c//3                         |  0  |  1  |  2  |\n                if cur in subBox[boxId]:                     ----- ----- -----\n                    return False                            |  3  |  4  |  5  |\n                subBox[boxId].add(cur)                       ----- ----- -----\n                                                            |  6  |  7  |  8  |\n                                                             ----- ----- -----\n        # We passed all the tests, return True\n        return True"
            },
            {
                "language": "kotlin",
                "code": "from collections import defaultdict\n\n\nclass Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        rows, cols, subboxes = defaultdict(set), defaultdict(set), defaultdict(set)\n        for i in range(9):\n            for j in range(9):"
            },
            {
                "language": "cpp",
                "code": "bool safe(vector<vector<char>> &board, int row, int col, char num)\n{\n    if (safeRow(board, row, col, num) && safeCol(board, row, col, num) && safeGrid(board, row, col, num))\n    {\n        return true;\n    }\n    return false;\n}\n\nbool isValidSudoku(vector<vector<char>> &board)\n{\n    for (int i = 0; i < 9; i++)\n    {\n        for (int j = 0; j < 9; j++)\n        {\n            if (board[i][j] == '.')\n            {\n                continue;\n            }\n            char num = board[i][j];\n            if (!safe(board, i, j, num))\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        block = [[set() for _ in range(3)] for _ in range(3)]\n\n        for i in range(9):\n            for j in range(9):\n                curr = board[i][j]\n                if curr == '.':\n                    continue\n                if (curr in rows[i]) or (curr in cols[j]) or (curr in block[i // 3][j // 3]):\n                    return False\n                rows[i].add(curr)\n                cols[j].add(curr)\n                block[i // 3][j // 3].add(curr)\n        return True"
            }
        ]
    },
    "36": {
        "question_id": 37,
        "title": "Sudoku Solver",
        "difficulty": 3,
        "description": "Write a program to solve a Sudoku puzzle by filling the empty cells.A sudoku solution must satisfy all of the following rules:Each of the digits 1-9 must occur exactly once in each row.Each of the digits 1-9 must occur exactly once in each column.Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.The '.' character indicates empty cells. ",
        "examples": [
            {
                "input": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
                "output": "[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\nExplanation:\u00a0The input board is shown above and the only valid solution is shown below:\n\n",
                "explanation": null
            }
        ],
        "constraints": [
            "board.length == 9",
            "board[i].length == 9",
            "board[i][j] is a digit or '.'.",
            "It is guaranteed that the input board has only one solution."
        ],
        "solutions": [
            {
                "language": "go",
                "code": "func solveSudoku(board [][]byte)  {\n    rows := make([]int, 9)\n    cols := make([]int, 9)\n    boxs := make([]int, 9)\n\n    for r := 0; r < 9; r++ {\n        for c := 0; c < 9; c++ {\n            if board[r][c] != '.' {\n                num := int(board[r][c] - '0')\n                set(rows, r, num)\n                set(cols, c, num)\n                set(boxs, (r/3) * 3 + c/3, num)\n            }\n        }\n    }\n\n    solve(board, 0, 0, rows, cols, boxs)\n}\n\nfunc solve(board [][]byte, row, col int, rows, cols, boxs []int) bool {\n    if row == 9 {\n        return true\n    }\n\n    if col == 9 {\n        return solve(board, row+1, 0, rows, cols, boxs)\n    }\n\n    if board[row][col] != '.' {\n        return solve(board, row, col+1, rows, cols, boxs)\n    }\n\n    for i := 1; i <= 9; i++ {\n        if canSet(rows, cols, boxs, row, col, i) {\n            fill(board, rows, cols, boxs, row, col, i)\n            if solve(board, row, col+1, rows, cols, boxs) {\n                return true\n            }\n            unfill(board, rows, cols, boxs, row, col, i)\n        }\n    }\n\n    return false\n}\n \nfunc canSet(rows, cols, boxs []int, row, col, num int) bool {\n    boxId := (row/3) * 3 + col/3\n    if isSet(rows, row, num) || isSet(cols, col, num) || isSet(boxs, boxId, num) {\n        return false\n    }\n    return true\n}\n\nfunc fill(board [][]byte, rows, cols, boxs []int, row, col, num int) {\n    boxId := (row/3) * 3 + col/3\n    board[row][col] = byte('0' + num)\n    set(rows, row, num)\n    set(cols, col, num)\n    set(boxs, boxId, num)\n}\n\nfunc unfill(board [][]byte, rows, cols, boxs []int, row, col, num int) {\n    boxId := (row/3) * 3 + col/3\n    board[row][col] = '.'\n    unset(rows, row, num)\n    unset(cols, col, num)\n    unset(boxs, boxId, num)\n}\n\nfunc set(arr []int, idx, num int) {\n    arr[idx] |=  (1 << (num-1))\n}\n\nfunc unset(arr []int, idx, num int) {\n    arr[idx] ^=  (1 << (num-1))\n}\n\nfunc isSet(arr []int, idx, num int) bool {\n    return (arr[idx] & (1 << (num-1))) != 0\n}"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    \n    def solveSudoku(self, board: List[List[str]]) -> None:\n        row = { i:[0]*10 for i in range(0,9) }\n        col = { i:[0]*10 for i in range(0,9) }\n        box = { i:[0]*10 for i in range(0,9) }\n        n,m = len(board),len(board[0])\n        for i in range(0,n):\n            for j in range(0,m):\n                box_index = 3*(i//3) + j//3 \n                c = ord(board[i][j][0]) - ord('0')\n                if( c < 0 or c > 9 ):\n                    board[i][j] = 0\n                else: \n                    board[i][j] = c ;\n                    row[i][c] = 1\n                    col[j][c] = 1\n                    box[box_index][c] = 1\n\n        \n        def rec(i,j):\n            if( board[i][j] > 0 and board[i][j] <= 9  ):\n                if( j < 8 ):\n                    if( rec(i,j+1)):\n                        return True\n                elif( i < 8 ):\n                    if( rec(i+1,0) ):\n                        return True \n                elif( i == 8 and j == 8 ):\n                    return True ;\n            else:\n                box_index = 3*(i//3) + j//3   \n                for k in range(1,10):\n                    if( row[i][k] == col[j][k] == box[box_index][k] == 0 ):\n                        row[i][k] = col[j][k] = box[box_index][k] = 1\n                        board[i][j] = k \n                        if( j < 8 ):\n                            if(rec(i,j+1)):\n                                return True;\n                        elif( i < 8 ):\n                            if( rec(i+1,0) ):\n                                return True ;\n                        else:\n                            return True;\n                        board[i][j] = 0 \n                        row[i][k] = col[j][k] = box[box_index][k] = 0\n                \n            return False;\n        \n        rec(0,0)\n\n        \n        for i in range(0,9):\n            for j in range(0,9):\n                board[i][j] = chr(board[i][j]+ord('0'))\n\n\n        return board;\n\n        "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n\n    bool isSafe(int row, int col, vector<vector<char>>& board, char val){\n        int n=board.size();\n        for(int i=0; i<n; i++){\n            //row check\n            if(board[row][i]==val){\n                return false;\n            }\n            //col check\n            if(board[i][col]==val){\n                return false;\n            }\n            //3*3 small matrix check\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==val){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool solve(vector<vector<char>>& board){\n        int n=board.size();\n        for(int i=0; i<n;i++){\n            for(int j=0; j<n;j++){\n                //checking for empty cell\n                if(board[i][j]=='.'){\n                    //now each empty cell can be filled with 1 to 9 digits, \n //So lets check them one by one.\n                    for(char val='1'; val<='9';val++){\n                        //checking is the value which we are trying  to put int board[i][j]\n                        //is valid or not according to rule\n                        //here basically we are checking the specified rule\n                        //calling isSafe function\n                        if(isSafe(i, j, board,val)){\n                            board[i][j]=val;\n                            //recursive call\n                            //recursive call to find next solution\n                            bool aageKaSolution=solve(board);\n                            if(aageKaSolution==true){\n                                return true;\n                            }\n                            else{\n                            //backtracking\n                            board[i][j]='.';\n                            }\n\n                        }\n                    }\n                    //if 1 to 9 tak koi bhi solution nhi nikala, current cell pr \n                    //that means ki piche kahi wrong value put ho gyi hai \n                    //therefore go back by returning false\n                    return false;\n                }\n                \n            }\n        }\n        return true;\n        \n    }\n\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isSafe(int row,int col,char &c,vector<vector<char>>& board){\n        for(int i=0;i<9;i++){\n            if(board[i][col]==c) //Checking Row\n                return false;\n            if(board[row][i]==c) //Checking Column\n                return false;\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==c) //Checking 3*3 sub-matrix for unique number betweeen 1-9\n                return false;\n        }\n        return true;\n    }\n    bool solve(vector<vector<char>>& board){\n        for(int i=0;i<9;i++){ // Traversal through each element in 9*9 Sudoku\n            for(int j=0;j<9;j++){\n                if(board[i][j]=='.'){ // If Empty\n                    for(char c='1';c<='9';c++){\n                        if(isSafe(i,j,c,board)==true){ //Checking whether 1-9 which numbers sets the 3 Sudoku Criteria\n                            board[i][j]=c;\n                            if(solve(board)==true) //Condition Checking\n                                return true;\n                            else\n                                board[i][j]='.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);        \n    }\n};"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(9^(N*N)) : For every unassigned index there are 9 possible options so the worst-case time\n    complexity of sudoku solver is O(9^(N*N)).\n\n    Space Complexity : O(1), Constant space.\n\n    Solved using Matrix + Backtracking.\n\n*/\n\nclass Solution {\nprivate:\n    bool isValid(vector<vector<char>>& board, int row, int col, char ch){\n        for(int i=0; i<9; i++){\n            if(board[i][col] == ch){\n                return false;\n            }\n            if(board[row][i] == ch){\n                return false;\n            }\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3] == ch){\n                return false;\n            }\n        }\n        return true;\n    }\n    bool solve(vector<vector<char>>& board) {\n        for(int i=0; i<board.size(); i++){\n            for(int j=0; j<board[0].size(); j++){\n                if(board[i][j] == '.'){\n                    for(char ch='1'; ch<='9'; ch++){\n                        if(isValid(board, i, j, ch)){\n                            board[i][j] = ch;\n                            if(solve(board) == true){\n                                return true;\n                            }\n                            board[i][j] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\npublic:\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\n};"
            },
            {
                "language": "javascript",
                "code": "                        board[i][j] = '.';"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n\n    bool isSafe(vector<vector<char>>& board, int row, int col, char value){\n        int n = board.size();\n\n        for(int i=0; i<n;i++){\n            // checking if the value is already exist in the current row\n            if(board[row][i]==value)\n                return false;\n            // checking if the value is already exist in the current column\n            if(board[i][col]==value)\n                return false;\n            // checking if the value is already present in the same 3*3 small matrix \n            if(board[3*(row/3)+(i/3)][3*(col/3)+(i%3)]==value)\n                return false;\n        }\n        return true;\n    }\n    bool solve(vector<vector<char>>& board){\n        int n=board.size();\n        for(int i =0;i<n ;i++){\n            for(int j =0; j<n;j++){\n                // find a vacant cell \n                if(board[i][j]=='.'){\n                    // try to fill digit 1-9\n                    for(char value = '1'; value<='9'; value++){\n                        // if the digit we are trying to place id safe to be placed here, this work is done by isSafe function\n                        if(isSafe(board, i, j, value)){\n                            // insert the value\n                            board[i][j]= value;\n                            // recursive call\n                            bool nextsolution = solve(board);\n                            if(nextsolution==true)\n                                // here we are returning true because the question clearly states that there will be only one answer.\n                                return true;\n                            else\n                                // backtrack\n                                board[i][j]='.';\n                        }\n                    }\n                    // if we were not able to fill the current cell by any of digit 1-9 that means we put wrong value in previous cell, so returning false to go back \n                    return false;\n                }\n            }\n        }\n        // if we reach this line that means we ahve filled the sudoku correctly.\n        return true;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public void solveSudoku(char[][] board) {\n        solve(board);\n    }\n    public boolean solve(char[][]board){\n        for(int i=0;i<9;i++){\n            for(int j=0;j<9;j++){\n\n                if(board[i][j]=='.'){\n\n                    for(char num='1';num<='9';num++){\n                        if(isPossible(board,i,j,num)){\n                            board[i][j]=num;\n                            if(solve(board)){\n                                return true;\n                            }\n                            //if the solve function return false then the prev num must be in wrong pos so then backtrack\n                            //and fill that with '.'. \n                            else{\n                                board[i][j]='.';\n                            }\n                        }\n                    }\n\n                    //if it is not possible to select a number from 1 to 9 the solve function return false;\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public boolean isPossible(char[][]board,int row,int col,char c){\n        for(int i=0;i<9;i++){\n            if(board[i][col]==c) return false;//col check\n\n            if(board[row][i]==c) return false; //row check\n\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==c) return false;//checking in each 3 x 3 matrix\n        }\n        return true;\n\n    }\n}"
            },
            {
                "language": "erlang",
                "code": "if you have any query ask me on comment and upvote the solution."
            },
            {
                "language": "java",
                "code": "class Solution {\n    public void solveSudoku(char[][] board) {\n        solve(board);\n    }\n    public boolean solve(char[][]board){\n        for(int i=0;i<9;i++){\n            for(int j=0;j<9;j++){\n\n                if(board[i][j]=='.'){\n\n                    for(char num='1';num<='9';num++){\n                        if(isPossible(board,i,j,num)){\n                            board[i][j]=num;\n                            if(solve(board)){\n                                return true;\n                            }\n                            else{\n                                board[i][j]='.';\n                            }\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public boolean isPossible(char[][]board,int row,int col,char c){\n        for(int i=0;i<9;i++){\n            if(board[i][col]==c) return false;\n            if(board[row][i]==c) return false;\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==c) return false;//checking in each 3 x 3 matrix\n        }\n        return true;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool check(vector<vector<char>>& board, int row, int col, char c)\n    {\n        for(int i = 0; i < 9; i++) \n            if(board[i][col] == c) \n                return false;\n\n        for(int i = 0; i < 9; i++) \n            if(board[row][i] == c) \n                return false;\n\n        int x0 = (row/3) * 3, y0 = (col/3) * 3;\n        for(int i = 0; i < 3; i++) {\n            for(int j = 0; j < 3; j++) {\n                if(board[x0 + i][y0 + j] == c) return false;\n            }\n        }\n        return true;\n    }\n    \n    bool solve(vector<vector<char>>& board, int r, int c)\n    {\n        if(r==9)\n        return true;\n        if(c==9)\n        return solve(board, r+1, 0);\n        if(board[r][c]!='.')\n        return solve(board, r, c+1);\n        for(char i='1';i<='9';i++)\n        {\n            if(check(board, r, c, i))\n            {\n                board[r][c]=i;\n                if(solve(board, r, c+1))\n                return true;\n                board[r][c]='.';\n            }\n        }\n        return false;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board, 0, 0);\n    }\n};"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public void solveSudoku(char[][] board) {\n        if(board == null || board.length == 0)\n            return;\n        solve(board);\n    }\n    \n    public boolean solve(char[][] board){\n        for(int i = 0; i < board.length; i++){\n            for(int j = 0; j < board[0].length; j++){\n                if(board[i][j] == '.'){\n                    for(char c = '1'; c <= '9'; c++){//trial. Try 1 through 9\n                        if(isValid(board, i, j, c)){\n                            board[i][j] = c; //Put c for this cell\n                            \n                            if(solve(board))\n                                return true; //If it's the solution return true\n                            else\n                                board[i][j] = '.'; //Otherwise go back\n                        }\n                    }\n                    \n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    private boolean isValid(char[][] board, int row, int col, char c){\n        for(int i = 0; i < 9; i++) {\n            if(board[i][col] != '.' && board[i][col] == c) return false; //check row\n            if(board[row][i] != '.' && board[row][i] == c) return false; //check column\n            if(board[3 * (row / 3) + i / 3][ 3 * (col / 3) + i % 3] != '.' && \nboard[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; //check 3*3 block\n        }\n        return true;\n    }\n}"
            },
            {
                "language": "java",
                "code": "    public void solveSudoku(char[][] board) {\n        doSolve(board, 0, 0);\n    }\n    "
            },
            {
                "language": "java",
                "code": "    private boolean isValid(char[][] board, int row, int col, char c){\n        int regionRow = 3 * (row / 3);  //region start row\n        int regionCol = 3 * (col / 3);    //region start col"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: void Do not return anything, modify board in-place instead.\n        \"\"\"\n        if not board or len(board) == 0:"
            },
            {
                "language": "java",
                "code": "    public boolean solve(char[][] board, int i, int j) {\n        if(i == 9 && j == 0) return true;\n        if(board[i][j] != '.') return solve(board, (j+1) == 9? i+1 : i, (j+1) == 9? 0 : j+1);\n        \n        for(char num = '1'; num <= '9'; num++) {\n            if(isValid(board, i, j, num)){\n                board[i][j] = num;\n                if(solve(board, (j+1) == 9? i+1 : i, (j+1) == 9? 0 : j+1)) return true;"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board, 0);\n    }\n    \n bool solve(vector<vector<char>>& board, int cur) {  "
            },
            {
                "language": "java",
                "code": "private boolean isValid(char[][] board, int row, int col, char c) {\n    for(int i=0; i<9; i++) {\n        if(board[i][col] != '.' && board[i][col] == c) return false;\n        if(board[row][i] != '.' && board[row][i] == c) return false;\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3] != '.' && board[3*(row/3)+i/3][3*(col/3)+i%3] == c) return false;\n    }\n    return true;\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\nprivate:\n    bool solve(vector<vector<char>>& board) {\n        for (int r = 0; r < 9; r++) {"
            }
        ]
    },
    "37": {
        "question_id": 38,
        "title": "Count and Say",
        "difficulty": 2,
        "description": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:countAndSay(1) = \"1\"countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.To determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.For example, the saying and conversion for digit string \"3322251\":Given a positive integer n, return the nth term of the count-and-say sequence. ",
        "examples": [
            {
                "input": "n = 1",
                "output": "\"1\"",
                "explanation": "This is the base case."
            },
            {
                "input": "n = 4",
                "output": "\"1211\"\nExplanation:\ncountAndSay(1) = \"1\"\ncountAndSay(2) = say \"1\" = one 1 = \"11\"\ncountAndSay(3) = say \"11\" = two 1's = \"21\"\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= n <= 30"
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "class Solution\n{\npublic:\n string countAndSay(int n)\n {\n  if (n == 1)\n   return \"1\";\n\n  string result = \"\", prev = countAndSay(n - 1) + \" \";\n  char val = prev[0];\n  int freq(0);\n\n  for (char c : prev)\n   if (c == val)\n    freq++;\n   else\n   {\n    result += to_string(freq) + val;\n    val = c;\n    freq = 1;\n   }\n\n  return result;\n }\n};"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        dp = [ \"\" for i in range(0,n+1)]\n        dp[1] = \"1 \"\n        i = 2 ;\n        while( i < n+1 ):\n            print(f'i:{i} dp[{i-1}]:{dp[i-1]}')\n            c = 0 \n            for j in range(0,len(dp[i-1])-1):\n                if( dp[i-1][j] == dp[i-1][j+1]):\n                    c += 1;\n                else:\n                    dp[i] += chr(c+1+ord('0')) + dp[i-1][j] ;\n                    c=0;\n            dp[i] += ' ';\n            i +=1\n            \n\n        return dp[-1][:-1];"
            },
            {
                "language": "",
                "code": "i:2 dp[1]:1 \ni:3 dp[2]:11 \ni:4 dp[3]:21 \ni:5 dp[4]:1211 \ni:6 dp[5]:111221 \ni:7 dp[6]:312211 \ni:8 dp[7]:13112221 \ni:9 dp[8]:1113213211 \ni:10 dp[9]:31131211131221 \ni:11 dp[10]:13211311123113112211 \ni:12 dp[11]:11131221133112132113212221 \ni:13 dp[12]:3113112221232112111312211312113211 \ni:14 dp[13]:1321132132111213122112311311222113111221131221 \ni:15 dp[14]:11131221131211131231121113112221121321132132211331222113112211"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n//THIS FUNCTION THAT MAPS AN INTEGER TO PAIRS OF ITS DIGITS AND THEIR FREQUENCIES.\n    vector<pair<char,int>> helper1(string n){    \n        \n      vector<pair<char,int>> ans;\n        int count=1;\n        \n        for(int i=0;i<n.size();i++) {\n           if(n[i]==n[i+1]) { count++; }\n            \n        else{\n            ans.push_back({n[i],count});\n            count=1;\n            }\n        }\n        \n        return ans;\n    }\n    // THIS FUNCTION THAT TAKES THE ARRAY OF PAIRS AND CREATES A NEW STRING .\n string helper2(vector<pair<char,int>> a){\n        \n        string st=\"\";\n        \n        for(auto i : a){\n            char ch1=i.first;\n            string ch2=to_string(i.second);\n            st+= ch1+ch2;\n        }\n        \n        return st;\n    }\n\n        string countAndSay(int n) {\n            \n           string ans=\"1\";\n           string temp=\"\";\n            \n           if(n==1)return ans;  //BASE CASE\n            \n        for(int i=1;i<n;i++){  ans=helper2(helper1(ans));} \n            \n        for(int i=ans.size()-1;i>=0;i--) { temp+=ans[i]; }  // REVERSE THE STRING\n            \n        return temp;\n        }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string countAndSay(int n) {\n        \n        string curr = \"1\"; //will store latest string after ith iteration\n        \n        if(n == 1) return curr;\n        \n\n        for(int nn = 2; nn <= n; nn++){\n            \n            string store = \"\"; // will store current iteration answer\n            \n            int i = 0, len = curr.length();\n            while(i < len){\n                char ch = curr[i];\n                int j = i + 1;\n                while(j < len && curr[j] == ch) j++;\n                \n                int times = j - i; //frequency of current(ch) consecutive same character\n                store += (times + '0'); \n                store += ch;\n                \n                i = j;\n            }\n            \n            curr = store;// will save current iteration answer to curr \n        }\n        \n        return curr;\n     }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string countAndSay(int n)\n    {\n        return counting(n);\n    }\n\n    string  counting(int n)\n    {\n        deque<int>      dq;\n        string          res, temp_outer_loop, temp_inner_loop;\n        int             count, len, i;\n\n        if (n == 1)\n            return \"1\";\n        res = \"11\";\n        while (--n > 1)\n        {\n            len = res.length();\n            count = 1;\n            i = 0;\n            temp_outer_loop = \"\";\n            while (i < len)\n            {\n                temp_inner_loop = \"\";\n                if (i + 1 < len && res[i] == res[i + 1])\n                {\n                    count += 1;\n                    i += 1;\n                }\n                else if (i + 1 == len || (i + 1 < len && res[i] != res[i + 1]))\n                {\n                    temp_inner_loop += count + '0';\n                    temp_inner_loop += res[i];\n                    count = 1;\n                    i += 1;\n                }\n                \n                temp_outer_loop += temp_inner_loop;\n            }\n            res = temp_outer_loop;\n            cout << \"n = \" << n << \"\\ncurrent step = \" << res << \"\\n\";\n        }\n        return res;\n    }\n};\n\n/*\n\n1   1\n2   11\n3   21\n4   1211\n5   111221\n6   312211\n7   13112221\n8   1113213211\n9   31131211131221\n10  13211311123113112211\n\n\n\n*/"
            },
            {
                "language": "python",
                "code": "string m[31]={\"\"};\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        m[1]=\"1\";\n        string next,prev;\n        int i,j,len;\n  \n  //generating the say(i)\n        for(i=2;i<n+1;i++)\n        {\n            if(m[i]!=\"\")\n                continue;\n            next=\"\";\n            prev=m[i-1];\n            len=prev.size();\n            int count=1;\n   \n   //reading out the say(i-1) i.i string prev\n            for(j=1;j<len;j++)\n            {\n                if(prev[j-1]==prev[j])\n                    count++;\n                else\n                {\n                    next=next+to_string(count)+prev[j-1];\n                    count=1;\n                }\n                \n            }\n            next=next+to_string(count)+prev[j-1];\n            m[i]=next;\n        }\n        return m[n];\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution {\npublic:\n    string countAndSay(int n) {\n        if(n == 1) {\n            string str = \"\";\n            str += '1';\n            return str;\n        }\n        string ans = countAndSay(n-1);\n        string str = \"\";\n        for(int i=0; i<ans.size(); i++) {\n            int count = 1;\n            while(i != ans.size()-1 && ans[i] == ans[i+1]) {\n                count++;\n                i++;\n            }\n            str += (count + '0');\n            str += ans[i];\n        }\n        return str;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "n = 3\nprevAnswer = countAndSay(3-1) = \"1211\"\nnewAnswer = malloc(...) = [_, _, _, _, _, _, _]\n\n// The first sequence of identical numbers is a single 1 (\"1 | 211\")\n// then we add the count and the char to the array, in that order\nnewAnswer = [1, 1, _, _, _, _, _]\n\n// continue iterating--the next sequence of identical numbers is a single 2 (\"2 | 11\")\nnewAnswer = [1, 1, 1, 2, _, _, _]\n\n// continue iterating--the next sequence of identical numbers is two 1s (\"11\")\nnewAnswer = [1, 1, 1, 2, 2, 1, _]\n\n// Now we just null-terminate the string and return\nnewAnswer = [1, 1, 1, 2, 2, 1, \\0]"
            },
            {
                "language": "cpp",
                "code": "char * countAndSay(int n){\n // base case\n    if (n == 1) return \"1\";\n \n // all other cases\n char *response = countAndSay(n-1); // get previous case\n char *newresponse = malloc(strlen(response) * (n > 20 ? 2 : 3)); // slight memory optimization\n  \n // initialize variables \n int ctr, curpos=0; // counter, current position in array\n char curval, *iter=response; // current character, array traversal\n char *head = response; // pointer to head to free memory later\n\n // main loop\n while (*response){\n  // reset counter to zero and curval to current character\n  ctr = 0;\n  curval = *response;\n  while (*iter && *iter == curval){\n   // traverse array, incrementing ctr as long as iter==curval\n   ctr++;\n   iter++;\n  }\n  // save count and number into array\n  newresponse[curpos] = ctr + '0';\n  newresponse[curpos+1] = curval;\n  curpos += 2;\n  response = iter;\n }\n // Add a null terminator to the array\n newresponse[curpos] = '\\0';\n curpos++;\n // reallocate the array so we don't have wasted space\n newresponse = realloc(newresponse, curpos);\n \n // free memory from last call so we don't leak it \n // (note checking for n>2 since case where (n-1)==1 doesn't malloc an array)\n if (n > 2) free(head);\n return newresponse;\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string countAndSay(int n) {\n        string ans=\"1\";\n        if(n==1) return ans;\n        for(int i=1;i<n;i++){\n            string s=ans,temp=\"\";\n            ans=\"\";\n            int count=1;\n            for(int j=0;j<s.size()-1;j++){\n                if(s[j]==s[j+1]) count++;\n                else{\n                    ans+=to_string(count)+s[j];\n                    count=1;\n                }\n            }\n            ans+=to_string(count)+s.back();\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "rust",
                "code": "for Example:\n  let , prev = \"11223333666778\"\n  curr=\"\"\n  1 present's 2 times : curr will be \"21\"\n  2 present's 2 times : curr will be \"21\"+\"22\" =\"2122\"\n  3 present's 4 times : curr will be \"2122\"+\"43\"=\"212243\"\n  6 present's 3 times : curr will be \"212243\"+\"36\"=\"21224336\" ans so on....\n  \n  hence , at  the end curr string will be \"212243362718\""
            },
            {
                "language": "csharp",
                "code": "class Solution \n{\n    public:\n    string countAndSay(int n) \n    {\n        string prev=\"1\";\n        while(--n)\n        {\n            string curr=\"\";\n            int i=0;\n            while(i<prev.length())\n            {\n                int count=1;\n                int j=i+1;\n                while(j<prev.length() && prev[j]==prev[i])\n                {\n                    count++;\n                    j++;\n                }\n                curr+=to_string(count)+prev[i];\n                i=j;\n            }\n            prev=curr;\n        }\n        return prev;\n    }\n};"
            }
        ]
    },
    "38": {
        "question_id": 39,
        "title": "Combination Sum",
        "difficulty": 2,
        "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input. ",
        "examples": [
            {
                "input": "candidates = [2,3,6,7], target = 7",
                "output": "[[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.",
                "explanation": null
            },
            {
                "input": "candidates = [2,3,5], target = 8",
                "output": "[[2,2,2,2],[2,3,3],[3,5]]",
                "explanation": null
            },
            {
                "input": "candidates = [2], target = 1",
                "output": "[]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= candidates.length <= 30",
            "2 <= candidates[i] <= 40",
            "All elements of candidates are distinct.",
            "1 <= target <= 40"
        ],
        "solutions": [
            {
                "language": "erlang",
                "code": "1. If the sum of the current combination is greater than target, then even if we move forward with this combination, the sum will only increase, so there is no fun to moving further with such a combination as we can never achieve the target sum from this. So backtrack from this.\n2. If the sum of the current combination is equal to the target, then we have a solution, so store this combination in the answers. Now moving forward with this combnation also will only increase the sum and we can't achieve the target sum again from this ever. So backtrack from here.\n3. if we are here then that means the sum of the combination is still less that the target sum, and we have a scope of finding a combination whose sum can be equal to the target.\n  i) Now consider all possible options into this combination, one at a time.\n  ii) Go check if considering the current option can give us the solution.\n  iii) Now when this option backtracks to this place again, now remove this option and try another option. e.g. at [2, 2, _ ] we have 3 options to fill the 3rd place i.e. [2, 3, 5].\n  So firstly we will go on with [2, 2, 2]. Then when this backtracks to this place again, remove the last 2 and try the next option which is 3 that means [2, 2, 3].\n  When this also backtracks remove 3 to try 5, that means [2, 2, 5].\n  Now as all the options are exhausted for [2, 2, _ ], now backtrack to its previous state which is [2, 2], and so on..."
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    void combination(vector<int>& candidates, int target, vector<int> currComb, int currSum, int currIndex, vector<vector<int>>& ans){\n        if(currSum>target) return; //backtrack\n        if(currSum==target){\n            ans.push_back(currComb); //store the solution and backtrack\n            return;\n        }\n        \n        for(int i=currIndex; i<candidates.size(); i++){ //try all possible options for the next level\n            currComb.push_back(candidates[i]); //put 1 option into the combination\n            currSum+=candidates[i];\n            combination(candidates, target, currComb, currSum, i, ans); //try with this combination, whether it gives a solution or not.\n            currComb.pop_back(); //when this option backtrack to here, remove this and go on to the next option.\n            currSum-=candidates[i];\n        }\n        \n    }\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        vector<vector<int>> ans;\n        vector<int> currComb;\n        combination(candidates, target, currComb, 0, 0, ans);\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    void combination(const vector<int>& candidates, int target, vector<int> &currComb, int currSum, int currIndex, vector<vector<int>>& ans){\n        if(currSum>target) return; //backtrack\n        if(currSum==target){\n            ans.push_back(currComb); //store the solution and backtrack\n            return;\n        }\n        "
            },
            {
                "language": "swift",
                "code": "Let's take an example not given in question -\nSuppose our array is given to us as arr[]: [2, 3] and target as 6\n\nThen, all possible combinations of array whose sum is equal to 6 is-\n[[2,2,2] , [3,3]]"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> ans; // 2 D vector to store our answer\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target)\n    {\n        // if our target becomes zero at any point, then yess!! we wil find a possible combination\n        if(target == 0) \n        {\n            ans.push_back(temp); // include that combination in our answer\n            return; // and then return, we are now not gonna explore more possiblity\n        }\n        \n        // if at any point target becomes less than zero, then simply return, saying that no it is notpossible to our target combination sum\n        if(target < 0)\n            return;\n        \n        // if index crosses the last index, we will return saying that no more element is left to choosee\n        if(i == arr.size())\n            return;\n        \n        // As we dicussed for every element we have two choices whether to include in our answer or not include in our answer. \n  //so now, we are doing that\n        \n        // we are not taking the ith element,\n        // so without decreasing sum we will move to next index because it will not contribute in making our sum\n        solve(i + 1, arr, temp, target);\n        \n        // we are taking the ith element and not moving onto the next element because it may be possible that this element again contribute in making our sum.\n        // but we decrease our target sum as we are consediring that this will help us in making our target sum\n        \n        temp.push_back(arr[i]); // including ith element\n        solve(i, arr, temp, target - arr[i]); // decreasing sum,and call again function\n        temp.pop_back(); // backtrack\n        \n    }\n    vector<vector<int>> combinationSum(vector<int>& arr, int target) {\n        ans.clear(); // clear global array, make to sure that no garbage value is present in it\n        \n        vector<int> temp; // temporary vector that tries all possible combination\n        \n        solve(0, arr, temp, target); // calling function, and see we start from index zero\n        \n        return ans; // finally return the answer array\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    // for the sake of convience, not to include again and again in my function call, I declare target here\n    int target;\n    \n    vector<vector<int>> ans; // 2-D vector to store our answer\n    \n    void solve(vector<int>& arr, int i, int sum, vector<int> op)\n    {\n        // if i crosses the array size, we will return saying that no more possibilty is left to choose\n        \n        if(i >= arr.size()) \n        {\n            return;\n        }\n        \n        // if value at ith index + sum becomes equal to target, then we will store it in our answer array, saying that yes it is a possible combination\n        if(arr[i] + sum == target)\n        {\n            op.push_back(arr[i]);\n            ans.push_back(op);\n            return;\n        }\n        \n        // if value at ith index + sum is less than target, then we have two choices i.e whether to include this value in our possible combiation array or not include that,\n        if(arr[i] + sum < target)\n        {\n            // we make two output vector, one for calling function at same index and anthor for calling function frm next index. Because for every element we have unlimited choices, that it will contribute in making our sum any number of times.\n            vector<int> op1 = op;\n            vector<int> op2 = op;\n            \n            op2.push_back(arr[i]);\n            solve(arr, i, sum + arr[i], op2);\n            solve(arr, i + 1, sum, op1);\n        }\n        else\n        {\n            solve(arr, i + 1, sum, op); // call for the next index\n        }\n    }\n    \n    vector<vector<int>> combinationSum(vector<int>& arr, int required_target) {\n        ans.clear(); //clear global array, make to sure that no garbage value is present in it\n        \n        target = required_target; // give target what he wants \n        vector<int> op; // op array to try all possible combination\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\n        solve(arr, 0, 0, op); // call function\n        \n        return ans; // return the final answer array\n    }\n};"
            },
            {
                "language": "lisp",
                "code": "(defn into-set [acc coll]\n  (if (some #{(frequencies coll)} (map frequencies acc)) acc (conj acc coll)))\n(defn combisum [inp targ]\n  (cond\n    (<= targ 0) []\n    :else (reduce\n           (fn [acc [ntar n]]\n             (reduce into-set acc (map (fn [r] (conj r n)) (combisum inp ntar))))"
            },
            {
                "language": "cpp",
                "code": "void solve(vector<int> &cand, vector<vector<int>> &ans, vector<int> v, int i, int sum, int target){\n        if(i>=cand.size()){\n            return;\n        }\n        \n        if(sum==target){\n            ans.push_back(v);\n            return;"
            },
            {
                "language": "python",
                "code": "1. Easy C++\n2. Line by Line Explanation with Comments.\n3. Please Upvote if it helps\u2b06\ufe0f\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \u2b07\ufe0f"
            },
            {
                "language": "python",
                "code": "1. Sort the vector(non-decreasing).\n2. First remove all the duplicates from vector.\n3. Then use recursion and backtracking to solve \n   the problem.\n   (A) If at any time sub-problem sum == 0 then \n       add that vector to the result (vector of \n       vectors).\n   (B) Else if sum is negative then ignore that \n       sub-problem.\n   (C) Else insert the present index in that \n       vector to the current vector and call \n       the function with sum = sum-ar[index] and\n       index = index, then pop that element from \n       current index (backtrack) and call the \n       function with sum = sum and index = index+1"
            },
            {
                "language": "cpp",
                "code": "     // \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09Please upvote if it helps \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09\nclass Solution {\npublic:\n\n    void Sum(vector<int>& candidates, int target, vector<vector<int> >& res, vector<int>& r, int i)\n    {\n        \n        if(target == 0)\n        {\n            // if we get exact answer\n            res.push_back(r);\n            return;\n        }\n        \n        while(i <  candidates.size() && target - candidates[i] >= 0)\n        {\n            // Till every element in the array starting\n            // from i which can contribute to the target\n            r.push_back(candidates[i]);// add them to vector\n            \n            // recur for next numbers\n            Sum(candidates,target - candidates[i],res,r,i);\n            ++i;\n            \n            // Remove number from vector (backtracking)\n            r.pop_back();\n        }\n}\n    \n     \n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        sort(candidates.begin(),candidates.end()); // sort candidates array\n        \n        // remove duplicates\n        candidates.erase(unique(candidates.begin(),candidates.end()),candidates.end());\n        \n        vector<int> r;\n        vector<vector<int> > res;\n        \n        Sum(candidates,target,res,r,0);\n        \n        return res;\n    }\n};"
            },
            {
                "language": "javascript",
                "code": "sort(candidates.begin(),candidates.end()); // sort candidates array\n        \n// remove duplicates\ncandidates.erase(unique(candidates.begin(),candidates.end()),candidates.end());"
            },
            {
                "language": "csharp",
                "code": ">> result) {"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    vector<vector<int>> ans;\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        vector<int> temp;\n        dfs(0,target,candidates,temp);\n        return ans;\n    }"
            },
            {
                "language": "ruby",
                "code": "candidates.erase(unique(candidates.begin(),candidates.end()),candidates.end());"
            },
            {
                "language": "cpp",
                "code": "void dfs(vector<int>&arr,int target,int start,vector<vector<int>>&ans,vector<int>&v)\n{\n    // base case\n    // the current path is a valid subset\n        if(target == 0)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void helper(vector<int> &res, int &sum, vector<int>& candidates, int &target, set<vector<int>> &ans){\n        if(sum==target){\n            sort(res.begin(), res.end());\n            ans.insert(res);\n            return;"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>>ans=new ArrayList<>();\n        solve(0,candidates,target,ans,new ArrayList<>());\n        return ans;\n    }\n    public void solve(int ind,int[]candidates,int target,List<List<Integer>>ans,ArrayList<Integer>temp){\n        if(ind==candidates.length){\n            if(target==0){\n                ans.add(new ArrayList<>(temp));\n            }\n            return;\n        }\n\n        if(candidates[ind]<=target){\n            temp.add(candidates[ind]);\n            solve(ind,candidates,target-candidates[ind],ans,temp);\n            temp.remove(temp.size()-1);\n        }\n        solve(ind+1,candidates,target,ans,temp);\n\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>>ans;\n    void help(int i,int t,vector<int>&c,vector<int>&vec){\n        if(t==0){\n            ans.push_back(vec);\n            return;\n        }\n        if(t<0){\n            return;\n        }\n        if(i==c.size()){\n            return;\n        }\n        help(i+1,t,c,vec); // if ith ele is ignored\n        vec.push_back(c[i]);\n        help(i,t-c[i],c,vec);// if ith ele is not ignored\n        vec.pop_back();\n    }\n    vector<vector<int>> combinationSum(vector<int>& c, int t) {\n        vector<int>vec;\n        help(0,t,c,vec);\n        return ans;\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n        if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n} "
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> permute(int[] nums) {\n   List<List<Integer>> list = new ArrayList<>();\n   // Arrays.sort(nums); // not necessary\n   backtrack(list, new ArrayList<>(), nums);\n   return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n   if(tempList.size() == nums.length){\n      list.add(new ArrayList<>(tempList));\n   } else{\n      for(int i = 0; i < nums.length; i++){ \n         if(tempList.contains(nums[i])) continue; // element already exists, skip\n         tempList.add(nums[i]);\n         backtrack(list, tempList, nums);\n         tempList.remove(tempList.size() - 1);\n      }\n   }\n} "
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> permuteUnique(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\n    if(tempList.size() == nums.length){\n        list.add(new ArrayList<>(tempList));\n    } else{\n        for(int i = 0; i < nums.length; i++){\n            if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\n            used[i] = true; \n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, used);\n            used[i] = false; \n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> combinationSum(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\n    if(remain < 0) return;\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\n    else{ \n        for(int i = start; i < nums.length; i++){\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> combinationSum2(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n    \n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\n    if(remain < 0) return;\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\n    else{\n        for(int i = start; i < nums.length; i++){\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i + 1);\n            tempList.remove(tempList.size() - 1); \n        }\n    }\n} "
            },
            {
                "language": "typescript",
                "code": "public List<List<String>> partition(String s) {\n   List<List<String>> list = new ArrayList<>();\n   backtrack(list, new ArrayList<>(), s, 0);\n   return list;\n}\n\npublic void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\n   if(start == s.length())\n      list.add(new ArrayList<>(tempList));\n   else{\n      for(int i = start; i < s.length(); i++){\n         if(isPalindrome(s, start, i)){\n            tempList.add(s.substring(start, i + 1));\n            backtrack(list, tempList, s, i + 1);\n            tempList.remove(tempList.size() - 1);\n         }\n      }\n   }\n}\n\npublic boolean isPalindrome(String s, int low, int high){\n   while(low < high)\n      if(s.charAt(low++) != s.charAt(high--)) return false;\n   return true;\n} "
            },
            {
                "language": "kotlin",
                "code": "if(tempList.contains(nums[i])) continue;"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n\n// Time Complexity : O(2^target + K), K is the maximum size of a combination\n\nprivate:\n    vector<vector<int>> res;\n    vector<int> temp;\n    \n    void helper(int idx, int target, vector<int> &nums){\n        if(idx >= nums.size()){\n            if(target == 0){\n                res.push_back(temp);\n            }\n            \n            return;\n        }\n        \n        // Optimisation\n        if(target == 0){\n            res.push_back(temp);\n            return;\n        }\n        \n        // Include\n        if(nums[idx] <= target){\n            temp.push_back(nums[idx]);\n            helper(idx, target-nums[idx], nums);\n            temp.pop_back();\n        }\n        \n        // Exclude\n        helper(idx+1, target, nums);\n    }\n    \npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        helper(0, target, candidates);\n        return res;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void Helper(vector<int>& arr, int target, vector<vector<int> >& res, vector<int>& r, int i)\n    {\n        if(target == 0){ // if subtracking reached 0, means we've got result\n            res.push_back(r); // insert the current result vector to ans\n            return;\n        }\n        \n        while(i <  arr.size() && target - arr[i] >= 0){\n            r.push_back(arr[i]); // if target hasn't reached 0, insert element\n            Helper(arr,target - arr[i],res,r,i); // recursive func\n            r.pop_back(); // while returning stepwise reset to initial input\n            i++; // increment i and try the previous 3 processes again for next element if sum is still less than target\n        }\n    }\n\n    vector<vector<int>> combinationSum(vector<int>& arr, int target) {\n  vector<vector<int> > res;  // stores answer\n  vector<int> r; // stores individual response and inserts to answer\n        sort(arr.begin(),arr.end()); // sorting before removing unique element via below method\n        arr.erase(unique(arr.begin(),arr.end()),arr.end()); // remove non unique              \n        Helper(arr, target, res, r, 0);       \n        return res;\n    }\n};"
            },
            {
                "language": "python",
                "code": "def comboSum(target,candidates):\n    '''\n    1. No duplicates\n    2. Same number can be repeated\n    3. Same combo is not repeated\n\n    '''\n\n    result = []\n\n    def helper(start,sum_so_far,subset,level=0):\n        space= ' '*level\n        print(f'{space} {subset}')\n        if sum_so_far == target:\n            result.append(subset[::])\n            return\n        if sum_so_far > target:\n            return\n\n        for i in range(start,len(candidates)):\n            num = candidates[i]\n            subset.append(num)\n            sum_so_far +=num\n            level+=1\n            helper(i,sum_so_far,subset,level)\n            level-=1\n            sum_so_far -=num\n            subset.pop()\n\n    helper(0,0,[])\n    return result\n\nif __name__ == \"__main__\":\n    candidates = [1,2,3]\n    target = 3\n    print(comboSum(target,candidates))\n ```"
            },
            {
                "language": "1_c++_recursive",
                "code": ""
            },
            {
                "language": "combinations",
                "code": ""
            },
            {
                "language": "subset",
                "code": ""
            },
            {
                "language": "comsum1",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\nvoid solve(vector<int> A, int sum,int target,int currentVal,vector<int> output,vector<vector<int>> &ans){\n    //if sum==target add the derived output to ans vector\n    if(sum==target){\n        ans.push_back(output);\n        return;\n    }\n    //Iterate over the array to generate combination\n    //Start from currentVal so that we don't have to check\n    //for previous values\n    for(int i=currentVal;i<A.size();i++){\n        //Call recursively only if the sum+A[i]<=target \n        if(sum+A[i]<=target){\n            sum+=A[i];\n            output.push_back(A[i]);\n            solve(A,sum,target,i,output,ans);\n            /* Backtrack to get different combinations for next\n               iterations */\n            output.pop_back();\n            sum-=A[i];\n        }\n    }\n\n}\n    vector<vector<int>> combinationSum(vector<int>& A, int target) {\n    vector<vector<int>> ans;\n    vector<int> output;\n    solve(A,0,target,0,output,ans);\n\n    return ans;\n    }\n};"
            }
        ]
    },
    "39": {
        "question_id": 40,
        "title": "Combination Sum II",
        "difficulty": 2,
        "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.Each number in candidates may only be used once in the combination.Note: The solution set must not contain duplicate combinations. ",
        "examples": [
            {
                "input": "candidates = [10,1,2,7,6,1,5], target = 8",
                "output": "\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]",
                "explanation": null
            },
            {
                "input": "candidates = [2,5,2,1,2], target = 5",
                "output": "\n[\n[1,2,2],\n[5]\n]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <=\u00a0candidates.length <= 100",
            "1 <=\u00a0candidates[i] <= 50",
            "1 <= target <= 30"
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        List<List<Integer>>ans=new ArrayList<>();\n        solve(0,target,candidates,ans,new ArrayList<>());\n        return ans;\n    }\n    public void solve(int ind,int target,int[]candidates,List<List<Integer>>ans,ArrayList<Integer>temp){\n        if(target==0){\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n\n        for(int i=ind;i<candidates.length;i++){\n            if(i!=ind && candidates[i]==candidates[i-1]) continue;\n            if(candidates[i]>target) break;\n\n            temp.add(candidates[i]);\n            solve(i+1,target-candidates[i],candidates,ans,temp);\n            temp.remove(temp.size()-1);\n        }\n    }    \n}"
            },
            {
                "language": "typescript",
                "code": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum2 = function(candidates, target) {\n    candidates = candidates.sort((a, b) => a - b);\n    const output = [];\n    const hashmap = new Map();\n\n    const backtracking = (curr, remaining, target) => {\n        if (target < remaining[0] || !remaining.length) return;\n        const checkedHashmap = new Map();\n\n        for (let i = 0; i < remaining.length; i++) {\n            const number = remaining[i];\n            if (checkedHashmap.has(number)) continue;\n            if (number > target) return;\n\n            const newRemaining = [...remaining];\n            const newCurr = [...curr];\n            newCurr.push(number);\n            newRemaining.splice(i, 1);\n\n            if (target - number === 0) {\n                const key = newCurr.sort((a, b) => a - b).toString();\n                if (hashmap.has(key)) return;\n                hashmap.set(key, 1);\n                return output.push(newCurr);\n            }\n\n            checkedHashmap.set(number, 1);\n            backtracking(newCurr, newRemaining, target - number);\n        }\n    }\n\n    backtracking([], candidates, target);\n\n    return output;\n};"
            },
            {
                "language": "typescript",
                "code": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum2 = function(candidates, target) {\n    candidates = candidates.sort((a, b) => a - b)\n    const result = []"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n\nvector<int> vec;\nvector <vector<int>> ans;\nvoid func(int n, vector<int>& v,int i)\n{\n    if(n<0) return ;\n    if(n==0)\n    {\n      ans.push_back(vec);\n        return ; \n    } \n   for (int j = i; j < v.size(); j++) {\n    if (n - v[j] < 0) break;  // check if index j is within bounds of v\n    vec.push_back(v[j]);\n    func(n - v[j], v, j + 1);\n    vec.pop_back();\n    while (j + 1 < v.size() && v[j] == v[j + 1]) j++; // skip duplicates\n}\n\n}\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n     \n     sort(candidates.begin(),candidates.end());\nfunc(target,candidates,0);\n\n       \n       \n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(),candidates.end());\n        vector <vector <int>> ans;\n        vector <int> v;\n        solution(0,target,candidates,ans,v);\n        return ans;\n    }\n    void solution(int i,int target,vector <int> &candidates,vector <vector <int>> &ans,vector <int> &v){\n        if(target==0){\n           ans.push_back(v);\n            return;\n        }\n        for(int index=i;index<candidates.size();index++){\n            if(index>i && candidates[index]==candidates[index-1]) continue;\n            if(candidates[index]>target) break;\n            v.push_back(candidates[index]);\n            solution(index+1,target-candidates[index],candidates,ans,v);\n            v.pop_back();\n        }\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def combinationSum2(self, candidates, target):\n        candidates.sort()                      \n        result = []\n        def combine_sum_2(nums, start, path, result, target):\n            if not target:\n                result.append(path)\n                return\n            for i in range(start, len(nums)):\n                if i > start and nums[i] == nums[i - 1]:\n                    continue\n                if nums[i] > target:\n                    break\n                combine_sum_2(nums, i + 1, path + [nums[i]], result, target - nums[i])\n        combine_sum_2(candidates, 0, [], result, target)\n        return result"
            },
            {
                "language": "cpp",
                "code": "Class Solution {\npublic:\n    void Solve(vector<int>& candidates, int target, int sum, vector<vector<int>>& output, vector<int>& ans, int index){\n        if(target == sum){\n            output.push_back(ans);\n            return;\n        }\n        if(candidates.size() == index)\n            return;\n        if(sum > target)\n            return;\n        ans.push_back(candidates[index]);\n        Solve(candidates, target, sum + candidates[index], output, ans, index + 1);\n        ans.pop_back();\n        while(index < candidates.size()-1 && candidates[index] == candidates[index + 1])\n            index++;\n        Solve(candidates, target, sum, output, ans, index + 1);\n    }\n\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<vector<int>> output;\n        vector<int> ans;\n        sort(candidates.begin(), candidates.end());\n        Solve(candidates, target, 0, output, ans, 0);\n        return output;\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        ans=[]\n        n=len(candidates)\n        candidates.sort()\n        def solve(idx,lst,sum):\n            # nonlocal ans,candidates\n            if sum==target:\n                ans.append(lst)\n                return \n            for i in range(idx,n):\n                if i>idx and candidates[i]==candidates[i-1]:\n                    continue\n                if sum+candidates[i]>target:\n                    break\n                solve(i+1,lst+[candidates[i]],sum+candidates[i])\n        solve(0,[],0)\n        return ans"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        \n        sort(candidates.begin(),candidates.end());\n        vector<vector<int>> ans;\n        vector<int> ds;\n        findCombination(0,target,candidates,ans,ds);\n        return ans;\n    }\n\n    void findCombination(int index, int target, vector<int>& candidates, vector<vector<int>>& ans, vector<int>& ds ){\n\n        if(target==0)\n        {\n            ans.push_back(ds);\n            return;\n        }\n\n        for(int i=index;i<candidates.size();i++)\n        {\n            if(i>index && candidates[i]==candidates[i-1]) continue;\n            if(candidates[i]>target) break;\n            ds.push_back(candidates[i]);\n            findCombination(i+1,target-candidates[i],candidates,ans,ds);\n            ds.pop_back();\n\n\n        }\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> ans;\n    void helper(vector<int> nums, int target, vector<int> temp, int k){\n        if(target==0){\n            ans.push_back(temp);\n            return;\n        }"
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time complexity : O(2^N*K), For every index, we make 2 recursion calls and there are N elements and for\n    every subset we are checking duplicates in output and in worst case it can contain K subset. so total time\n    complexity is O(2^N*K).\n\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \n    space on average so total space complexity is O(N*K).\n\n    Solved using Array + BackTracking.\n\n    Note : This approach will give TLE.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\nprivate: \n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\n        if(index == candidates.size()){\n            if(target == 0){\n                bool isPresent = find(output.begin(), output.end(), temp) != output.end();\n                if(!isPresent){\n                    output.push_back(temp);\n                }\n            }\n            return;\n        }\n        if(candidates[index] <= target){\n            temp.push_back(candidates[index]);\n            combinationSum2(candidates, target-candidates[index], output, temp, index+1);\n            temp.pop_back();\n        }\n        combinationSum2(candidates, target, output, temp, index+1);\n    }\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        vector<vector<int>> output;\n        vector<int> temp;\n        combinationSum2(candidates, target, output, temp, 0);\n        return output;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(2^N).\n\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \n    space on average so total space complexity is O(N*K).\n\n    Solved using Array + BackTracking.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\nprivate: \n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\n        if(target < 0){\n            return;\n        }\n        else if(target == 0){\n            output.push_back(temp);\n        }\n        else{\n            for(int i=index; i<candidates.size(); i++){\n                if(i>index && candidates[i] == candidates[i-1]){\n                    continue;\n                }\n                temp.push_back(candidates[i]);\n                combinationSum2(candidates, target-candidates[i], output, temp, i+1);\n                temp.pop_back();\n            }\n        }\n    }\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        vector<vector<int>> output;\n        vector<int> temp;\n        combinationSum2(candidates, target, output, temp, 0);\n        return output;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> result;\n    \n    void powerset(vector<int> nums, int curr, vector<int> res, int n){\n        if(curr == n){\n            result.push_back(res);\n            return;\n        }\n        powerset(nums, curr+1, res, n);\n        res.push_back(nums[curr]);\n        powerset(nums, curr+1, res, n);\n    }\n    vector<vector<int>> subsets(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> res;\n        powerset(nums, 0, res, n);\n        return result;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> result;\n    \n    void subs(vector<int> &nums, int curr, vector<int> &res){\n        result.push_back(res);\n        for(int i = curr; i < nums.size(); i++){\n            if(i!=curr && nums[i]==nums[i-1]){\n                continue;\n            }\n            res.push_back(nums[i]);\n            subs(nums, i+1, res);\n            res.pop_back();\n            \n        }\n    }\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        if(nums.size() == 0){\n            return result;\n        }\n        vector<int> res;\n        sort(nums.begin(), nums.end());\n        subs(nums, 0, res);\n        return result;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    vector<vector<int>> result;\n    \n    vector<int> swap(vector<int> &nums, int a, int b){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n        return nums;\n    }\n    \n    void perm(vector<int> &nums, int l, int r){\n        if(l==r){\n            result.push_back(nums);\n            return;\n        }\n        for(int i = l; i <= r; i++){\n            nums = swap(nums, l, i);\n            perm(nums, l+1, r);\n            nums = swap(nums, l, i);\n        }\n    }\n    \n    vector<vector<int>> permute(vector<int>& nums) {\n        perm(nums, 0, nums.size()-1);\n        return result;\n    } \n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> result;\n    \n    vector<int> swap(vector<int> &nums, int a, int b){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n        return nums;\n    }\n    \n    void perm(vector<int> &nums, int l, int r){\n        if(l==r){\n            result.push_back(nums);\n            return;\n        }\n        set<int> s;\n        for(int i = l; i <= r; i++){\n                if(s.find(nums[i]) != s.end() )\n                    continue;\n                s.insert(nums[i]);\n                nums = swap(nums, l, i);\n                perm(nums, l+1, r);\n                nums = swap(nums, l, i);  \n        }\n    }\n    \n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        perm(nums, 0, nums.size()-1);\n        return result;  \n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> result;\n    \n    void comSum(vector<int> &curr, int curInd, int sum, vector<int> &candidates, int target, int n){\n        if(sum == target){\n            result.push_back(curr);\n            return;\n        }      \n        else if(sum > target){\n            return;\n        }\n        \n        for(int i = curInd; i < n; i++){\n            curr.push_back(candidates[i]);\n            sum += candidates[i];\n            comSum(curr, i, sum, candidates, target, n);\n            sum -= candidates[i];\n            curr.pop_back();\n        }\n    }\n    \n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        vector<int> curr;\n        int sum = 0;\n        int n = candidates.size();\n        comSum(curr, 0, sum, candidates, target, n);\n        return result;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> result;\n    \n    void comsum(vector<int> &curr, int target, int sum, vector<int> &candidates, int curInd, int n){\n        if(target == sum){\n            result.push_back(curr);\n            return;\n        }\n        else if(sum>target){\n            return;\n        }\n        \n        for(int i = curInd; i < n; i++){\n            if(i != curInd && candidates[i]==candidates[i-1])               //to avoid picking up the same combnations i.e. we don't pick same element for certain kth position of a combination \n                continue;\n            sum += candidates[i];\n            curr.push_back(candidates[i]);\n            comsum(curr, target, sum, candidates, i+1, n);\n            sum -= candidates[i];\n            curr.pop_back();\n        }\n        \n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> curr;\n        int n = candidates.size();\n        sort(candidates.begin(), candidates.end());\n        comsum(curr, target, 0, candidates, 0, n);\n        return result;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> result;\n    void comsum(vector<int> &curr, int k, int n, int sum, int size, int index){\n        if(size==k && sum == n){\n            result.push_back(curr);\n            return;\n        }\n        else if(size>k || sum>n)\n            return;\n        \n        for(int i = index; i <= 9; i++){\n            sum += i;\n            curr.push_back(i);\n            comsum(curr, k, n, sum, size+1, i+1);\n            sum -= i;\n            curr.pop_back();\n        }\n    }\n    vector<vector<int>> combinationSum3(int k, int n) {\n        vector<int> curr;\n        comsum(curr, k, n, 0, 0, 1);\n        return result;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> ans;\n    void helper(vector<int> nums, int target, vector<int> temp, int k){\n        if(target==0){\n            ans.push_back(temp);\n            return;\n        }"
            },
            {
                "language": "cpp",
                "code": "void helper(vector<int>& candidates, set<vector<int>> &ans, int index, int &target, int &sum, vector<int> &res){\n        if(sum > target || index>=candidates.size()) return;\n        if(sum==target){\n            vector<int> temp(res);\n            sort(temp.begin(), temp.end());\n            ans.insert(temp);\n            return;"
            }
        ]
    },
    "40": {
        "question_id": 41,
        "title": "First Missing Positive",
        "difficulty": 3,
        "description": "Given an unsorted integer array nums, return the smallest missing positive integer.You must implement an algorithm that runs in O(n) time and uses constant extra space. ",
        "examples": [
            {
                "input": "nums = [1,2,0]",
                "output": "3",
                "explanation": "The numbers in the range [1,2] are all in the array."
            },
            {
                "input": "nums = [3,4,-1,1]",
                "output": "2",
                "explanation": "1 is in the array but 2 is missing."
            },
            {
                "input": "nums = [7,8,9,11,12]",
                "output": "1",
                "explanation": "The smallest positive integer 1 is missing."
            }
        ],
        "constraints": [
            "1 <= nums.length <= 105",
            "-231 <= nums[i] <= 231 - 1"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        \n        int ans[] = new int[nums.length + 1];\n\n        // mark the presence of each positive integer in the input array\n        for(int i = 0; i < nums.length; i++){\n            int val = nums[i];\n            if(val > 0 && val <= nums.length) { // check to avoid index out of bounds\n                ans[val] = 1;\n            }\n        }\n\n        // find the smallest missing positive integer by checking the array of marked integers\n        for(int i = 1; i < ans.length; i++){\n            if(ans[i] == 0){\n                return i;\n            }\n        }\n\n        // if no missing positive integer is found, return the length of the array\n    return ans.length;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        set<int> s(nums.begin(),nums.end());\n        int i=1;\n        int n=s.size();\n        while(i<=n)\n        {\n            if(s.find(i)!=s.end())\n            {\n                i++;\n            }\n            else\n            {\n                return i;\n            }\n        }\n        return n+1;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int n=nums.size();\n        set<int>s;\n        for(int i=0;i<n;i++){\n            s.insert(nums[i]);\n        }\n        int i=1;\n\n        while(i<=n){\n            if(s.find(i)!=s.end()){\n                i++;\n            }\n            else{\n                return i;\n            }\n          \n        }\n          return n+1;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution\n{\npublic:\n    int firstMissingPositive(int A[], int n)\n    {\n        for(int i = 0; i < n; ++ i)\n            while(A[i] > 0 && A[i] <= n && A[A[i] - 1] != A[i])\n                swap(A[i], A[A[i] - 1]);\n        \n        for(int i = 0; i < n; ++ i)\n            if(A[i] != i + 1)\n                return i + 1;\n        \n        return n + 1;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic: \n    int firstMissingPositive(vector<int>& nums) {\n        int n = nums.size(); \n        for (int i = 0; i < n; i++)\n            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\n                swap(nums[i], nums[nums[i] - 1]);"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int i = 0;\n        int n = nums.size();\n        while (i < n)\n        {\n            if (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])"
            },
            {
                "language": "java",
                "code": "public int firstMissingPositive(int[] nums) {\n        if(nums == null || nums.length == 0) return 1;          //case: nums == null or nums == [], return 1\n        for(int i = 0;i < nums.length;i++){                     //use nums array itself, the ideal array should be {1,2,3,4}\n            int curr = nums[i];                                 //swap if nums[index] != index + 1;\n            while(curr - 1 >= 0 && curr - 1 < nums.length && curr != nums[curr-1]){\n                int next = nums[curr-1];\n                nums[curr-1] = curr;"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\npublic int firstMissingPositive(int[] nums) {\n    int n = nums.length;\n    for(int i = 0; i < n; i++) {\n        while(nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1])\n            swap(nums, i, nums[i] - 1);\n    }\n    for(int i = 0; i < n; i++)"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        HashSet<Integer> set = new HashSet<>();\n        //Adding all the values to set\n        for(int i=0;i<nums.length;i++)\n        {\n            set.add(nums[i]);\n        }\n\n        //Looking for missing integer in ranger 1 to length of array \n        int i=1;\n        while(i<=nums.length)\n        {\n            if(set.contains(i))\n            {\n                i++;\n            }\n            else\n            {\n                return i;\n            }\n        }\n\n        //If not found returning the length+1 value\n        return nums.length+1;\n    }\n}"
            },
            {
                "language": "python",
                "code": " def firstMissingPositive(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n     Basic idea:\n    1. for any array whose length is l, the first missing positive must be in range [1,...,l+1], \n        so we only have to care about those elements in this range and remove the rest.\n    2. we can use the array index as the hash to restore the frequency of each number within \n         the range [1,...,l+1] \n    \"\"\"\n    nums.append(0)\n    n = len(nums)\n    for i in range(len(nums)): #delete those useless elements\n        if nums[i]<0 or nums[i]>=n:\n            nums[i]=0\n    for i in range(len(nums)): #use the index as the hash to record the frequency of each number\n        nums[nums[i]%n]+=n\n    for i in range(1,len(nums)):\n        if nums[i]/n==0:\n            return i\n    return n"
            },
            {
                "language": "csharp",
                "code": "    def firstMissingPositive(self, nums: List[int]) -> int:\n        \"\"\"\n        For nums with length n, the possible result is in the range of\n        [1 : n + 1], we want to know the smallest integer in the range \n        of [1 : n] that is not in nums, if [1 : n] are all in nums,\n        the result is n + 1\n        "
            },
            {
                "language": "go",
                "code": " nums.append(0)"
            },
            {
                "language": "python",
                "code": "        nums = list(set(nums)) + [0]\n        n = len(nums)\n        for i in range(len(nums)):  # delete those useless elements\n            if nums[i] < 0 or nums[i] >= n:\n                nums[i] = 0\n        for i in range(len(nums)):  # use the index as the hash to record the frequency of each number\n            nums[nums[i] % n] += n\n        for i in range(1, len(nums)):"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        int n=nums.length;\n       int i=0;\n       while(i<n){\n           int a=nums[i];\n           if(a>=1 && a<=n){\n               if(nums[a-1]!=a){\n                   nums[i]=nums[a-1];\n                   nums[a-1]=a;\n               }\n               else i++;\n           }\n           else{\n               i++;\n           }\n       }\n      for(int j=0;j<n;j++){\n          if(nums[j]!=j+1)return j+1;\n      }\n      return n+1;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int n = nums.size(),i;\n        for(auto &i: nums){\n            if(i<=0||i>n){\n                i = n+1;\n            }\n        }\n        for(auto &i: nums){\n            if(abs(i)==n+1||nums[abs(i)-1]<0)continue;\n            nums[abs(i)-1] *= -1;\n        }\n        for(i = 1; i <= n; i++){\n            if(nums[i-1]>0)return i;\n        }\n        return i;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        int n = nums.length;\n        \n        // Move all positive integers to the front of the array\n        int j = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] > 0) {\n                int temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n                j++;\n            }\n        }\n        \n        // Mark indices that correspond to positive integers\n        for (int i = 0; i < j; i++) {\n            int idx = Math.abs(nums[i]) - 1;\n            if (idx < j && nums[idx] > 0) {\n                nums[idx] = -nums[idx];\n            }\n        }\n        \n        // Find the first missing positive integer\n        for (int i = 0; i < j; i++) {\n            if (nums[i] > 0) {\n                return i + 1;\n            }\n        }\n        \n        return j + 1;\n    }\n}"
            },
            {
                "language": "dart",
                "code": "public class Solution {\npublic int firstMissingPositive(int[] nums) {\n    int n = nums.length;\n    \n    // 1. mark numbers (num < 0) and (num > n) with a special marker number (n+1) \n    // (we can ignore those because if all number are > n then we'll simply return 1)\n    for (int i = 0; i < n; i++) {\n        if (nums[i] <= 0 || nums[i] > n) {\n            nums[i] = n + 1;\n        }\n    }\n    // note: all number in the array are now positive, and on the range 1..n+1\n    \n    // 2. mark each cell appearing in the array, by converting the index for that number to negative\n    for (int i = 0; i < n; i++) {\n        int num = Math.abs(nums[i]);\n        if (num > n) {\n            continue;\n        }\n        num--; // -1 for zero index based array (so the number 1 will be at pos 0)\n        if (nums[num] > 0) { // prevents double negative operations\n            nums[num] = -1 * nums[num];\n        }\n    }\n    \n    // 3. find the first cell which isn't negative (doesn't appear in the array)\n    for (int i = 0; i < n; i++) {\n        if (nums[i] >= 0) {\n            return i + 1;\n        }\n    }\n    \n    // 4. no positive numbers were found, which means the array contains all numbers 1..n\n    return n + 1;\n}\n}"
            },
            {
                "language": "erlang",
                "code": "if (nums[i] >= 0) {"
            }
        ]
    },
    "41": {
        "question_id": 42,
        "title": "Trapping Rain Water",
        "difficulty": 3,
        "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. ",
        "examples": [
            {
                "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
                "output": "6",
                "explanation": "The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped."
            },
            {
                "input": "height = [4,2,0,3,2,5]",
                "output": "9",
                "explanation": null
            }
        ],
        "constraints": [
            "n == height.length",
            "1 <= n <= 2 * 104",
            "0 <= height[i] <= 105"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "class Solution {\n    public int trap(int[] h) {\n        int n=h.length;\n        int sum=0;\n        int l[]=new int[n];\n        int r[]=new int[n];\n        l[0]=h[0];\n        for(int i=1;i<n;i++)\n        l[i]=Math.max(h[i],l[i-1]);\n         r[n-1]=h[n-1];\n        for(int i=n-2;i>=0;i--)\n        r[i]=Math.max(h[i],r[i+1]);\n        for(int i=0;i<n;i++)\n        {\n            sum+=Math.min(l[i],r[i])-h[i];\n        }\n        return sum;\n        // PLEASE UPVOTE\n        // LOVE FOR YOU BY TRIPPY THE CODER  \u2764\ufe0f \u2764\ufe0f\n    }\n}"
            },
            {
                "language": "",
                "code": " 1   5   3   0   4   0\n     |\n     |   w   w   |\n     |   |   w   |\n     |   |   w   |   \n |   |   |   w   | "
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int trap(int[] arr) {\n        int n = arr.length;\n        int[] ltr =new int[n];\n        int[] rtl = new int[n];\n        ltr[0] = arr[0];\n        rtl[n-1] = arr[n-1];\n\n        for(int i =1;i<n;i++){\n            ltr[i] = Math.max(arr[i],ltr[i-1]);\n        }\n\n        for(int i =n-2;i>=0;i--){\n            rtl[i] = Math.max(arr[i],rtl[i+1]); \n        }\n\n        int count =0;\n\n        for(int i =0;i<n;i++){\n            int min = Math.min(ltr[i],rtl[i]);\n            count += ((min-arr[i])>0) ? (min-arr[i]) : 0;\n        }\n\n        return count;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "//   Approach 1 \n //   TC-->O(N)+O(N)+O(N)= 3*O(N) = O(N)\n //   SC-->O(N)+O(N)= 2*O(N) = O(N)\n    int trap(vector<int>& height) {\n        int n = height.size();\n        vector<int> premax(n),suffixmax(n);\n        // Computing prefixmax for each element in height array\n        premax[0]=height[0];\n        for(int i=1;i<height.size();i++)\n            premax[i] = max(height[i],premax[i-1]);\n        // Computing suffixmax for each element in height array\n        suffixmax[n-1] = height[n-1];\n        for(int i=n-2;i>=0;i--)\n           suffixmax[i] = max(height[i],suffixmax[i+1]);\n        // computing the water trapped using the below formula\n        int water = 0;\n        for(int i=0;i<n;i++)\n        {\n            water += (min(premax[i],suffixmax[i])-height[i]);\n        }\n        return water;\n    }"
            },
            {
                "language": "cpp",
                "code": " //   Approach 2 (Most optimal)\n //   TC-->O(N)\n //   SC-->O(1)\n        int trap(vector<int>& height) {\n        int n = height.size();\n        int l=0,r=n-1,water=0;\n        int leftmax=0,rightmax=0;\n        while(l<=r)\n        {\n            if(height[l]<=height[r])\n            {\n                if(height[l]>leftmax)\n                   leftmax = height[l];\n                else\n                   water+=leftmax-height[l];\n                l++;\n            }\n            else\n            {\n                if(height[r]>rightmax)\n                   rightmax = height[r];\n                else\n                   water+=rightmax-height[r];\n                r--;\n            }\n        }\n        return water;\n    }"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size(),i;\n        vector<int> v,l(n,-1),r(n,-1);\n        for(i = 0; i < n; i++){\n            while(v.size()&&v.back()<height[i]){\n                v.pop_back();\n            }\n            if(v.size()){\n                l[i] = v.back();\n            }\n            if(v.size()==0||height[i]>v.back())\n            v.push_back(height[i]);\n        }\n        v.clear();\n        for(i = n-1; i >= 0; i--){\n            while(v.size()&&v.back()<height[i]){\n                v.pop_back();\n            }\n            if(v.size()){\n                r[i] = v.back();\n            }\n            if(v.size()==0||height[i]>v.back())\n            v.push_back(height[i]);\n        }\n        // for(auto &i: height)cout<<i<<\" \";cout<<endl;\n        // for(auto &i: l)cout<<i<<\" \";cout<<endl;\n        // for(auto &i: r)cout<<i<<\" \";\n        int ans = 0;\n        for(i = 0; i < n; i++){\n            \n            ans += max(0,min(l[i],r[i])-height[i]);\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        int left[n];\n        int right[n];\n\n        int maxtillnow = height[0];\n\n        for(int i=0; i<n; i++){    \n            maxtillnow = max(maxtillnow, height[i]);\n            left[i] = maxtillnow;\n        }\n\n        maxtillnow = height[n-1];\n\n        for(int j=n-1; j>=0;j--){\n            maxtillnow = max(maxtillnow, height[j]);\n            right[j] = maxtillnow;\n        }\n\n        int total=0;\n\n        for(int k = 0; k<n; k++){\n            total = total + (min(right[k], left[k]) - height[k]);\n        }\n\n        return total;\n        \n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int trap(int[] height) {\n        int left = 0; \n        int right = height.length - 1;\n        int ans = 0; \n        int lMax = 0, rMax = 0;\n        while(left <= right){\n            lMax = Math.max(height[left], lMax);\n            rMax = Math.max(height[right], rMax);     \n            \n            if (lMax < rMax){\n                ans += lMax - height[left++];\n            }\n            else {\n                ans += rMax - height[right--];\n            }\n        }\n        return ans;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void damn(vector<int> &h, vector<int> &right, vector<int> &left){\n        int n = h.size();\n        int mx = -1;\n        for(int i=0; i<n; i++){\n            left[i] = mx;\n            mx = max(mx, h[i]);\n        }\n        mx = -1;\n        for(int i=n-1; i>=0; i--){\n            right[i] = mx;\n            mx = max(mx, h[i]);\n        }\n    }\n\n    int trap(vector<int>& height) {\n        int n = height.size();\n        vector<int> right(n), left(n);\n        damn(height, right, left);\n        int ans = 0;\n\n        for(int i=0; i<n; i++){\n            if(min(right[i], left[i])>height[i])\n            ans += min(right[i], left[i]) - height[i];\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int trap(vector<int>& h) {\n        int l=0,r=h.size()-1;\n        int l_max=0,r_max=0,res=0;\n        while(l<=r)\n        {\n            if(h[l]<=h[r])\n            {\n                if(h[l]>=l_max)\n                {\n                    l_max=h[l];\n                }\n                else\n                {\n                    res+=l_max-h[l];\n                }\n                l++;\n            }\n            else\n            {\n                if(h[r]>=r_max)\n                {\n                    r_max=h[r];\n                }\n                else\n                {\n                    res+=r_max-h[r];\n                }\n                r--;\n            }\n        }\n        return res;\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int trap(int[] arr) {\n        int ans=0;\n\n        for(int i=0;i<arr.length;i++){\n            int left =0;\n            for(int j=0;j<=i;j++){\n                left =Math.max(left,arr[j]);\n            }\n            int right = Integer.MIN_VALUE;\n            for(int j=i;j<=arr.length-1;j++){\n                right = Math.max(right,arr[j]);\n            }\n            ans += Math.min(left,right)-arr[i];\n        }\n\n        return ans;\n    }\n}"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int trap(int[] height) {\n\n        int n = height.length;\n\n        //set left and right pointers\n\n        int left = 0;\n        int right = n-1;\n\n        int res = 0;\n\n        int maxleft = 0;\n        int maxright = 0;\n\n        // loop until left and right pointers meet\n        while(left <= right){\n\n            // if height[left] is smaller or equal to height[right]\n            if(height[left] <= height[right]){\n\n                // if height[left] is greater than or equal to maxleft,\n                // update maxleft to height[left]\n                if(height[left] >= maxleft){\n                    maxleft = height[left];\n                }\n                \n                // if height[left] is smaller than maxleft,\n                // it means there is a potential to trap water\n                else{\n                    // add the difference between maxleft and height[left] to res\n                    // this represents the amount of water trapped at the current position\n                    res += maxleft - height[left];\n                }\n                // move the left pointer to the next position\n                left++; \n            }\n            // if height[left] is greater than height[right]\n            else{\n                // if height[right] is greater than or equal to maxright,\n                // update maxright to height[right]\n                if(height[right] >= maxright){\n                    maxright = height[right];\n                }\n                // if height[right] is smaller than maxright,\n                // it means there is a potential to trap water\n                else{\n                    // add the difference between maxright and height[right] to res\n                    // this represents the amount of water trapped at the current position\n                    res += maxright - height[right];\n                }\n                // move the right pointer to the previous position\n                right--;\n            }\n        }\n        // return the total amount of trapped water\n        return res;\n    }\n}"
            }
        ]
    },
    "42": {
        "question_id": 43,
        "title": "Multiply Strings",
        "difficulty": 2,
        "description": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.Note: You must not use any built-in BigInteger library or convert the inputs to integer directly. ",
        "examples": [
            {
                "input": "num1 = \"2\", num2 = \"3\"",
                "output": "\"6\"",
                "explanation": null
            }
        ],
        "constraints": [],
        "solutions": [
            {
                "language": "dart",
                "code": "class Solution {\n    public String multiply(String num1, String num2) {        \n        String res=\"\";\n        int c=0;\n        String z=\"\";\n        if(num1.equals(\"0\") || num2.equals(\"0\"))\n            return \"0\";\n        if(num1.length()==1 && num2.length()==1)\n        {\n            int num = Integer.parseInt(num1)*Integer.parseInt(num2);\n            return Integer.toString(num);\n        }\n        int min = num1.length()<num2.length()?num1.length():num2.length();\n        String[] arr = new String[min];\n        for(int i=0;i<min;i++)\n            arr[i]=\"\";\n        if(min==num1.length())\n        {\n            for(int i=num1.length()-1;i>=0;i--)\n            {\n                c=0;\n                for(int j=num2.length()-1;j>=0;j--)\n                {\n                    int num= c+((num1.charAt(i)-'0') * (num2.charAt(j)-'0'));\n                    arr[i] = Integer.toString(num%10)+arr[i];\n                    c=num/10;\n                }\n                if (c!=0)\n                    arr[i] = Integer.toString(c)+arr[i];\n                arr[i] = arr[i]+z;\n                z=z+\"0\";\n            }\n        }\n        else if(min==num2.length())\n        {\n            for(int i=num2.length()-1;i>=0;i--)\n            {\n                c=0;\n                for(int j=num1.length()-1;j>=0;j--)\n                {\n                    int num= c+((num2.charAt(i)-'0') * (num1.charAt(j)-'0'));\n                    arr[i] = Integer.toString(num%10)+arr[i];\n                    c=num/10;\n                }\n                if (c!=0)\n                    arr[i] = Integer.toString(c)+arr[i];\n                arr[i] = arr[i]+z;\n                z=z+\"0\";\n            }\n        }\n        int max=0;\n        for(String str:arr)            \n            if(str.length()>max)max=str.length();      \n        for(int i=0;i<arr.length;i++)\n        {           \n            int diff=max-arr[i].length();\n            while(diff!=0)\n            {\n                arr[i]=\"0\"+arr[i];\n                diff--;\n            }\n        }\n        c=0;\n        int sum=0;\n        for(int i=max-1;i>=0;i--)\n        {\n            sum=0;\n            for(int j=0;j<arr.length;j++)\n            {\n                sum+=(arr[j].charAt(i)-'0');\n            }\n            sum=sum+c;\n            res = Integer.toString((sum)%10)+res;            \n            c=sum/10;\n            sum =sum%10;\n        }\n        if(c!=0)\n            res = Integer.toString(c)+res;\n        for(String i:arr)\n            System.out.println(i);\n        return res;\n    }\n}"
            },
            {
                "language": "typescript",
                "code": "import java.math.BigInteger;\n\nclass Solution {\n    public String multiply(String num1, String num2) {\n        BigInteger a = new BigInteger(num1);\n        BigInteger b = new BigInteger(num2);\n\n        BigInteger mul = a.multiply(b);\n\n        // BigInteger mul=a*b;\n        String c=String.valueOf(mul);\n        return c;\n\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\nstring addStrings(string num1, string num2) {\n    int sum = 0, i = num1.length() - 1, j = num2.length() - 1;\n    string str;\n    while (i >= 0 || j >= 0 || sum > 0) {\n        if (i >= 0) sum += (num1[i--] - '0');\n        if (j >= 0) sum += (num2[j--] - '0');\n        str.insert(0, 1, (sum % 10) + '0');\n        sum /= 10;\n    }\n    return str;\n}\n     void to_multiple (string a , string b, int i , string &ans,int carry,int x,string& pre){\n     \n        if (i < 0 ) return;\n         int index = 0;\n        while( index++ < x)  ans+='0';\n    \n        for(int j = a.size()-1 ; j>=0;j--){\n        \n         int multiple =  (((a[j] - '0') * (b[i] - '0')) + carry);\n    \n        if(multiple <= 9  ){\n            ans +=(multiple + '0');\n            carry = 0;\n        }\n        else{\n            carry = multiple/10;\n            ans += ((multiple%10) + '0');\n        }\n    }\n         if(carry != 0) ans += (carry + '0');\n           carry = 0;\n\n         reverse(ans.begin(),ans.end()); \n          pre = addStrings(ans,pre);\n         ans = \"\";\n         to_multiple(a,b,i-1,ans,carry,x+1,pre);\n}\n    string multiply(string a, string b) {\n        \n     if( a [0] == '0' || b[0] == '0')  return \"0\";\n       \n        string ans = \"\",pre = \"\";\n   \n       while(a.size() < b.size())  a.insert(0, \"0\");\n       while(b.size() < a.size())  b.insert(0, \"0\");\n    \n        int i = a.size()-1;\n        \n       to_multiple(a,b,i,ans,0,0,pre);\n       \n       while(pre[0] == '0') pre.erase(pre.begin());\n   \n       return pre;\n        \n    }\n};"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n           public string Multiply(string num1, string num2)\n        {\n            int n1 = num1.Length;\n            int n2 = num2.Length;\n            int[] products = new int[n1 + n2];\n\n            for (int i = n1 - 1; i >= 0; i--)\n            {\n                for (int j = n2 - 1; j >= 0; j--)\n                {\n                    int p1 = i + j;\n                    int p2 = p1 + 1;\n                    int sum = (num1[i] - '0') * (num2[j] - '0') + products[p2];\n\n                    products[p1] += sum / 10;\n                    products[p2] = sum % 10;\n                }\n            }\n\n            StringBuilder sb = new StringBuilder();\n            foreach(int num in products)\n            {\n                if (!(sb.Length == 0 && num == 0))\n                {\n                    sb.Append(num);\n                }\n            }\n\n            return sb.Length == 0 ? \"0\" : sb.ToString();\n        }\n}"
            },
            {
                "language": "javascript",
                "code": " `num1[i] * num2[j]` will be placed at indices `[i + j`, `i + j + 1]` "
            },
            {
                "language": "java",
                "code": "public String multiply(String num1, String num2) {\n    int m = num1.length(), n = num2.length();\n    int[] pos = new int[m + n];\n   \n    for(int i = m - 1; i >= 0; i--) {\n        for(int j = n - 1; j >= 0; j--) {\n            int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0'); \n            int p1 = i + j, p2 = i + j + 1;\n            int sum = mul + pos[p2];\n\n            pos[p1] += sum / 10;\n            pos[p2] = (sum) % 10;\n        }\n    }  \n    \n    StringBuilder sb = new StringBuilder();\n    for(int p : pos) if(!(sb.length() == 0 && p == 0)) sb.append(p);\n    return sb.length() == 0 ? \"0\" : sb.toString();\n}"
            },
            {
                "language": "csharp",
                "code": "public String multiply(String num1, String num2) {\n        if(num1.equals(\"0\") || num2.equals(\"0\")) return \"0\";\n        int[] nums = new int[num1.length() + num2.length()];\n        for(int i = 0;i<num1.length();i++){\n            for(int j = 0;j<num2.length();j++){             //scan from back to head and store in reverse order in nums.\n                nums[i+j] += (num1.charAt(num1.length()-1-i)-'0') * (num2.charAt(num2.length()-1-j)-'0');\n            }"
            },
            {
                "language": "python",
                "code": "pos[p1] += sum / 10;\npos[p2] = (sum) % 10;"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        ret = [0] * (len(num1) + len(num2))"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if (num1 == \"0\" || num2 == \"0\") return \"0\";\n        \n        vector<int> res(num1.size()+num2.size(), 0);\n        \n        for (int i = num1.size()-1; i >= 0; i--) {\n            for (int j = num2.size()-1; j >= 0; j--) {\n                res[i + j + 1] += (num1[i]-'0') * (num2[j]-'0');\n                res[i + j] += res[i + j + 1] / 10;\n                res[i + j + 1] %= 10;\n            }\n        }\n        \n        int i = 0;\n        string ans = \"\";\n        while (res[i] == 0) i++;\n        while (i < res.size()) ans += to_string(res[i++]);\n        \n        return ans;\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        dic={\n            '1':1,\n            '2':2,\n            '3':3,\n            '4':4,\n            '5':5,\n            '6':6,\n            '7':7,\n            '8':8,\n            '9':9,\n            '0':0\n        }\n        h=list(num1)\n        l=list(num2)\n        s=len(num1)-1\n        s1=len(l)-1\n        k=0\n        k1=0\n        p=0\n        p1=0\n        while h:\n            r=h.pop(s)\n            p1+=(10**k)*dic[r]\n            k+=1\n            s-=1\n        while l:\n            r=l.pop(s1)\n            p+=(10**k1)*dic[r]\n            k1+=1\n            s1-=1\n        return str((p1*p))\n        "
            },
            {
                "language": "java",
                "code": "import java.math.BigInteger;\nclass Solution {\n    public String multiply(String num1, String num2) {\n\n        if(num1.equals(\"0\") || num2.equals(\"0\")) return \"0\";\n\n        int l1=num1.length();\n        int l2=num2.length();\n\n        int a[]=new int[l1+l2];\n\n        int i=l2-1;\n        int pf=0;\n\n        while(i>=0){\n            int ival=num2.charAt(i)-'0';\n            i--;\n\n            int j=l1-1;\n            int k=a.length-1-pf;\n            int carry=0;\n\n            while(carry!=0 || j>=0){\n                int jval=j>=0 ? num1.charAt(j)-'0':0;\n               \n                j--;\n\n                int product=ival*jval+carry+a[k];\n                \n                a[k]=product%10;\n                carry=product/10;\n                k--;    \n\n            }\n            pf++;\n        }\n\n        //for removing leading zero\n        String ans=\"\";\n        boolean flag=false;\n\n        for(int e:a){\n            if(e==0 && flag==false){\n                continue;\n            }\n            else{\n                flag=true;\n                ans+=e;\n            }\n        }\n\n        return ans;\n    }\n}"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n\n        x = {}\n        for i in range(0,10):\n            x[str(i)] = i\n        i1 = []\n        i2 = []\n        mul = 10\n        for i,j in enumerate(num1[::-1]):\n            i1.append(x[j] * (mul**i))\n        for i,j in enumerate(num2[::-1]):\n            i2.append(x[j] * (mul**i)) \n        return (str(sum(i1)*sum(i2))) \n        "
            },
            {
                "language": "php",
                "code": "class Solution {\npublic:\n    string addi(string ans, string curr){\n        int carry=0;\n        string ans1;\n        while (!ans.empty() || !curr.empty() || carry>0){\n            int v1=0, v2=0;\n            if (!ans.empty()){\n                v1= ans.back()-'0';\n                ans.pop_back();\n            }\n            if (!curr.empty()){\n                v2= curr.back()-'0';\n                curr.pop_back();\n            }\n            int val= v1+v2+carry;\n            carry= val/10;\n            string tmp;\n            tmp+= ((val%10)+'0');\n            ans1= tmp+ans1;\n        }\n        return ans1;\n    }\n    string multiply(string num1, string num2) {\n        if (num1==\"0\" || num2==\"0\")return \"0\";\n        string ans;\n        int cnt=0;\n        while (!num2.empty()){\n            int dig= num2.back()-'0';\n            num2.pop_back();\n            int carry=0;\n            string curr;\n            for (int i= num1.size()-1; i>=0; i--){\n                int val= (num1[i]-'0')*dig;\n                val+= carry;\n                carry= val/10;\n                string v;\n                v+= ((val%10)+'0');\n                curr= v +curr;\n            }\n            if (carry!=0){string tmp; tmp+= (carry+'0'); curr= tmp+curr;}\n            for (int i=0; i<cnt; i++)curr+='0';\n            if (ans.size()==0)ans= curr;\n            else ans= addi(ans,curr);\n            cout<<\"Curr: \"<<curr<<\", \"<<ans<<endl;\n            cnt++;\n        }\n        \n        return ans;\n    }\n};"
            }
        ]
    },
    "43": {
        "question_id": 44,
        "title": "Wildcard Matching",
        "difficulty": 3,
        "description": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:'?' Matches any single character.'*' Matches any sequence of characters (including the empty sequence).The matching should cover the entire input string (not partial). ",
        "examples": [
            {
                "input": "s = \"aa\", p = \"a\"",
                "output": "false",
                "explanation": "\"a\" does not match the entire string \"aa\"."
            },
            {
                "input": "s = \"aa\", p = \"*\"",
                "output": "true\nExplanation:\u00a0'*' matches any sequence.",
                "explanation": null
            },
            {
                "input": "s = \"cb\", p = \"?a\"",
                "output": "false\nExplanation:\u00a0'?' matches 'c', but the second letter is 'a', which does not match 'b'.",
                "explanation": null
            }
        ],
        "constraints": [
            "0 <= s.length, p.length <= 2000",
            "s contains only lowercase English letters.",
            "p contains only lowercase English letters, '?' or '*'."
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution {\n    public boolean isMatch(String s, String p) {\n        int dp[][]=new int[s.length()][p.length()];\n        for(int ar[]:dp)\n         Arrays.fill(ar,-1);\n        return match(s.length()-1,p.length()-1,s,p,dp)==0?false:true;\n    }\n    static int match(int i,int j,String s,String p,int dp[][]){\n        if(i<0&&j<0)\n         return 1;\n        if(i<0){\n            for(int j1=0;j1<=j;j1++){\n                if(p.charAt(j1)!='*')\n                 return 0;\n            }\n            return 1;\n          }\n           if(j<0)\n          return 0;\n          if(dp[i][j]!=-1)\n          return dp[i][j];\n        if(s.charAt(i)==p.charAt(j)||p.charAt(j)=='?')\n          return  dp[i][j]=match(i-1, j-1, s, p,dp);\n        int ans=0;\n        if(p.charAt(j)=='*'){\n            for(int a=0;a<=s.length();a++){\n                ans=ans+match(i-a, j-1, s, p,dp);\n            }\n            return  dp[i][j]=ans;\n          }\n        return  dp[i][j]=0;\n    }\n\n}"
            },
            {
                "language": "rust",
                "code": "    def isMatch(self, s: str, p: str) -> bool:\n        n = len(s);\n        m = len(p);\n        dp = [[0]*(m+1) for _ in range(0,n+1)]\n\n        dp[0][0] = 1\n        for j in range(1,m+1):\n            if(p[j-1] == '*' ): dp[0][j] = dp[0][j-1];\n\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                if(s[i-1] == p[j-1] or p[j-1] == '?' ): dp[i][j] = dp[i-1][j-1]\n                elif( p[j-1] == '*' ):\n                    # did we match without the chracter in s or did we match with the character before '*' in p\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\n\n        return dp[-1][-1]\n    \n               "
            },
            {
                "language": "kotlin",
                "code": "public class Solution\n{\n    public bool IsMatch(string s, string p)\n    {\n        var i = 0;\n        var j = 0;\n        var star = -1;\n        var m = -1;\n\n        while (i < s.Length)\n        {\n            if (j < p.Length && (p[j] == '?' || p[j] == s[i]))\n            {\n                i++;\n                j++;\n\n                continue;\n            }\n\n            if (j < p.Length && p[j] == '*')\n            {\n                star = j++;\n                m = i;\n\n                continue;\n            }\n\n            if (star >= 0)\n            {\n                j = star + 1;\n                i = ++m;\n\n                continue;\n            }\n\n            return false;\n        }\n\n        while (j < p.Length && p[j] == '*')\n        {\n            j++;\n        }\n\n        return j == p.Length;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        vector<vector<bool>> dp(s.size() + 1, vector(p.size() + 1, false));\n        dp[0][0] = true;\n        for (int j = 0; j < p.size() && p[j] == '*'; ++j) {\n            dp[0][j + 1] = true;\n        }\n        \n        for (int i = 1; i <= s.size(); ++i) {\n            for (int j = 1; j <= p.size(); ++j) {\n                if (p[j - 1] == '*') {\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n                } else {\n                    dp[i][j] = (s[i - 1] == p[j - 1] || p[j - 1] == '?') && dp[i - 1][j - 1];\n                }\n            }\n        }\n\n        return dp[s.size()][p.size()];\n    }\n};"
            },
            {
                "language": "cpp",
                "code": " bool isMatch(const char *s, const char *p) {\n        const char* star=NULL;\n        const char* ss=s;\n        while (*s){\n            //advancing both pointers when (both characters match) or ('?' found in pattern)\n            //note that *p will not advance beyond its length \n            if ((*p=='?')||(*p==*s)){s++;p++;continue;} \n\n            // * found in pattern, track index of *, only advancing pattern pointer \n            if (*p=='*'){star=p++; ss=s;continue;} \n\n            //current characters didn't match, last pattern pointer was *, current pattern pointer is not *\n            //only advancing pattern pointer\n            if (star){ p = star+1; s=++ss;continue;} \n\n           //current pattern pointer is not star, last patter pointer was not *\n           //characters do not match\n            return false;\n        }\n\n       //check for remaining characters in pattern\n        while (*p=='*'){p++;}\n\n        return !*p;  \n    }"
            },
            {
                "language": "rust",
                "code": "boolean comparison(String str, String pattern) {\n        int s = 0, p = 0, match = 0, starIdx = -1;            \n        while (s < str.length()){\n            // advancing both pointers\n            if (p < pattern.length()  && (pattern.charAt(p) == '?' || str.charAt(s) == pattern.charAt(p))){\n                s++;\n                p++;\n            }\n            // * found, only advancing pattern pointer\n            else if (p < pattern.length() && pattern.charAt(p) == '*'){\n                starIdx = p;\n                match = s;\n                p++;\n            }\n           // last pattern pointer was *, advancing string pointer\n            else if (starIdx != -1){\n                p = starIdx + 1;\n                match++;\n                s = match;\n            }\n           //current pattern pointer is not star, last patter pointer was not *\n          //characters do not match\n            else return false;\n        }\n        \n        //check for remaining characters in pattern\n        while (p < pattern.length() && pattern.charAt(p) == '*')\n            p++;\n        \n        return p == pattern.length();\n}"
            },
            {
                "language": "csharp",
                "code": "// greedy solution with idea of DFS\n// starj stores the position of last * in p\n// last_match stores the position of the previous matched char in s after a *\n// e.g. \n// s: a c d s c d\n// p: * c d"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int m = s.length(), n = p.length();\n        int i = 0, j = 0, asterick = -1, match;\n        while (i < m) {\n            if (j < n && p[j] == '*') {"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int n=s.size(), m=p.size();\n        vector<vector<bool>>dp(m+1, vector<bool>(n+1, false));\n        dp[0][0]=true;\n        for(int i=1; i<n; i++){\n            dp[0][i]=false;\n        }\n        for(int i=1; i<=m; i++){\n            int chk=1;\n            for(int k=1; k<=i; k++){\n                if(p[k-1]!='*'){\n                    dp[i][0]=false;\n                    chk=-1;\n                }\n            }\n            if(chk==1){\n                dp[i][0]=true;\n            }\n        }\n        for(int i=1; i<=m; i++){\n            for(int j=1; j<=n; j++){\n                if(p[i-1]==s[j-1] || p[i-1]=='?'){\n                    dp[i][j]=dp[i-1][j-1];\n                }\n                else if(p[i-1]=='*'){\n                    dp[i][j]=dp[i-1][j]|dp[i][j-1];\n                }\n                else{dp[i][j]=false;}\n            }\n        }\n        return dp[m][n];\n    }\n};"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def isallstar(self,p,i) -> bool:\n        for ii in range (1,i+1):\n            if (p[ii-1]!=\"*\"):\n                return False\n        return True\n\n    def memo(self,p,s,i,j,dp):\n        if (i<0 and j<0):\n            return True\n        if (i<0 and j>=0):\n            return False\n        if (j<0 and i>=0):\n            for ii in range (i+1):\n                if p[ii]!=\"*\":\n                    return False\n            else:\n                return True\n        \n        if dp[i][j]!=-1:\n            return dp[i][j]\n        if (p[i]==s[j] or p[i]==\"?\"):\n            dp[i][j]= self.memo(p,s,i-1,j-1,dp) \n        \n        elif (p[i]==\"*\"):\n            dp[i][j]= (self.memo(p,s,i-1,j,dp) or self.memo(p,s,i,j-1,dp))\n        else:\n            dp[i][j]=  False\n        return dp[i][j]\n    \n    def tabulation(self,p,s,n,m):\n        dp=[[0 for  i in range (m+1)] for j in range (n+1)]\n        dp[0][0]=True\n        for j in range (1,m+1):\n            dp[0][j]=False\n        \n        for i in range (1,n+1):\n            dp[i][0]=self.isallstar(p,i)\n        \n        for i in range (1,n+1):\n            for j in range (1,m+1):\n                if (p[i-1]==s[j-1] or p[i-1]==\"?\"):\n                    dp[i][j]= dp[i-1][j-1] \n                \n                elif (p[i-1]==\"*\"):\n                    dp[i][j]= (dp[i-1][j]  or dp[i][j-1])\n                else:\n                    dp[i][j]=  False\n        return dp[n][m]\n    \n    def spaceOptimization(self,s,p,n,m):\n        prev=[0 for i in range (m+1)]\n        curr=[0 for i in range (m+1)]\n        prev[0]=True\n        for i in range (1,n+1):\n            curr[0]=self.isallstar(p,i)\n            for j in range (1,m+1):\n                if (p[i-1]==s[j-1] or p[i-1]==\"?\"):\n                    curr[j]= prev[j-1] \n                elif (p[i-1]==\"*\"):\n                    curr[j]= (prev[j]  or curr[j-1])\n                else:\n                    curr[j]=  False\n            prev=[val for val in curr]\n        return prev[m]\n    \n        \n    def isMatch(self, s: str, p: str) -> bool:\n        n=len(p)\n        m=len(s)\n        dp=[[-1 for  i in range (m+1)] for j in range (n+1)]\n        # return self.memo(p,s,n-1,m-1,dp)\n        # return self.tabulation(p,s,n,m)\n        return self.spaceOptimization(s,p,n,m)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        vector<vector<bool>> dp(s.size() + 1, vector(p.size() + 1, false));\n        dp[0][0] = true;\n        for (int j = 0; j < p.size() && p[j] == '*'; ++j) {\n            dp[0][j + 1] = true;\n        }\n        \n        for (int i = 1; i <= s.size(); ++i) {\n            for (int j = 1; j <= p.size(); ++j) {\n                if (p[j - 1] == '*') {\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n                } else {\n                    dp[i][j] = (s[i - 1] == p[j - 1] || p[j - 1] == '?') && dp[i - 1][j - 1];\n                }\n            }\n        }\n\n        return dp[s.size()][p.size()];\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        vector<bool> dp(p.size() + 1, false);\n        dp[0] = true;\n        for (int j = 0; j < p.size() && p[j] == '*'; ++j) {\n            dp[j + 1] = true;\n        }\n        \n        for (int i = 1; i <= s.size(); ++i) {\n            dp[0] = false;\n            bool neighborLastRow = i == 1;\n            for (int j = 1; j <= p.size(); ++j) {\n                bool currLastRow = dp[j];\n                if (p[j - 1] == '*') {\n                    dp[j] = currLastRow || dp[j - 1];\n                } else {\n                    dp[j] = (s[i - 1] == p[j - 1] || p[j - 1] == '?') && neighborLastRow;\n                }\n                neighborLastRow = currLastRow;\n            }\n        }\n\n        return dp[p.size()];\n    }\n};"
            },
            {
                "language": "javascript",
                "code": "if (p[j - 1] == '*') {\n     dp[i][j] = dp[i - 1][j] || dp[i][j - 1] || dp[i - 1][j - 1];\n}"
            },
            {
                "language": "python",
                "code": "for (int j = 1; j < =p.size() && p[j-1] == '*'; ++j) \n            dp[0][j] = dp[0][j -1];"
            },
            {
                "language": "javascript",
                "code": "var isMatch = function (s, p) {\n\n     let dp = Array(s.length + 1).fill(Array(p.length + 1).fill(false));\n\n    dp[0][0] = true;\n\n    for (let j = 1; j <= p.length; j++) {\n\n        if (p[j \u2014 1] == \u201c*\u201d) {\n\n            dp[0][j] = dp[0][j \u2014 1];\n\n        }\n\n    }\n\n    for (let i = 1; i < s.length + 1; i++) {\n\n        for (let j = 1; j < p.length + 1; j++) {\n\n            if (p[j \u2014 1] == \u201c?\u201d || p[j \u2014 1] == s[i \u2014 1]) {\n\n                dp[i][j] = dp[i][j] || dp[i \u2014 1][j \u2014 1];\n\n            } else if (p[j \u2014 1] == \u201c*\u201d) {\n\n                dp[i][j] = dp[i \u2014 1][j] || dp[i][j \u2014 1];\n\n            }\n\n        }\n\n    }\n\n    return dp[s.length][p.length];\n\n};"
            }
        ]
    },
    "44": {
        "question_id": 45,
        "title": "Jump Game II",
        "difficulty": 2,
        "description": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:0 <= j <= nums[i] andi + j < nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1]. ",
        "examples": [
            {
                "input": "nums = [2,3,1,1,4]",
                "output": "2",
                "explanation": "The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index."
            },
            {
                "input": "nums = [2,3,0,1,4]",
                "output": "2",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 104",
            "0 <= nums[i] <= 1000",
            "It's guaranteed that you can reach nums[n - 1]."
        ],
        "solutions": [
            {
                "language": "java",
                "code": "public class Solution {\n    public int Jump(int[] nums) {\n        var minIndex = 0;\n        var maxIndex = 0;\n        var steps = 0;\n        while (maxIndex < nums.Length-1) {\n            var newMaxIndex = maxIndex;\n            for (var i=minIndex; i<=maxIndex; i++) {"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int jump(int[] nums) {\n     int jumps = 0, curEnd = 0, curFarthest = 0;\n  for (int i = 0; i < nums.length - 1; i++) {\n  curFarthest = Math.max(curFarthest, i + nums[i]);\n  if (i == curEnd) {\n   jumps++;\n   curEnd = curFarthest;"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        \n        curr_farthest = curr_end = jumps = 0 \n        for i in range(len(nums)-1) :\n            curr_farthest = max(curr_farthest, i + nums[i])\n            if i == curr_end :\n                jumps += 1 \n                curr_end = curr_farthest"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        \"\"\"\n        O(n) O(1)\n        \"\"\"\n        if (target_i := len(nums) - 1) == 0:\n   return 0"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int jump(vector<int>& nums) {\n        int l, r, step;\n        l = r = step = 0;\n        while (r < nums.size() - 1) {\n            int max_r = 0;\n            for (int i = l; i <= r; ++i)"
            },
            {
                "language": "kotlin",
                "code": ""
            },
            {
                "language": "java",
                "code": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        steps, left, right = 0, 0 ,1\n        while right < len(nums):\n            steps += 1"
            },
            {
                "language": "java",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int jump(int[] nums) {\n        int jump=0,n=nums.length;\n        int l=0,r=0;\n\n        while(r<n-1){\n            int farthest=0;\n            for(int i=l;i<=r;i++){"
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function(nums) {\n    let l=0,r=0;\n    let count=0;\n    while(r<nums.length-1){"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int minjump(int i,vector<int>& nums,vector<int>& dp){\n        if(i >= nums.size()-1){\n            return 0;\n        }\n        if (dp[i] != -1 ) return dp[i];\n        int mini= 1e9;\n        for(int k=i+1;k<=i+nums[i];k++){\n            mini = min(mini,1+minjump(k,nums,dp));\n        }\n        return dp[i]=mini;\n    }\n    int jump(vector<int>& nums) {\n        vector<int> dp(nums.size()+1,-1);\n        return minjump(0,nums,dp);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int>dp;\n\n    int util(vector<int>& nums, int idx){\n        if(idx>=nums.size()-1){\n            return 0;\n\n        }\n        if(dp[idx]!=-1)return dp[idx];\n\n        if(nums[idx]==0)return (int)1e5+5;\n\n        int ans= 1e5+5;\n        for(int i= nums[idx]; i>=1; i--){\n            ans= min(ans, util(nums, idx+i)+1);\n        }\n        return dp[idx]= ans;\n    }\n    int jump(vector<int>& nums) {\n        dp.resize(nums.size()+1, -1);\n\n        return util(nums, 0);\n\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n\n    int jump(vector<int>& nums) {\n\n      for(int i = 1; i < nums.size(); i++)\n      {\n        nums[i] = max(nums[i] + i, nums[i-1]);\n      }\n\n      int ind = 0;\n      int ans = 0;\n\n      while(ind < nums.size() - 1)\n      {\n        ans++;\n        ind = nums[ind];\n      }\n\n      return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\n    public int Jump(int[] nums) {\n        \n        int[] dp = new int[nums.Length];\n\n        for(int i = 1; i < nums.Length; i++) {\n            for(int j = 0; j < i; j++) {\n                if (j + nums[j] >= i) {\n                    dp[i] = 1 + dp[j];\n                    break;\n                }\n            }\n        }\n\n        return dp[^1];\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\n    public int Jump(int[] nums) {\n        \n        int ans = 0, currEnd = 0, currFar = 0;\n\n        for(int i = 0; i < nums.Length - 1; i++) {  \n            currFar = Math.Max(currFar, i + nums[i]);\n\n            if (i == currEnd) {\n                ans++;\n                currEnd = currFar;\n            }\n        }   \n\n        return ans;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int jump(vector<int>& nums) \n    {\n        if(nums.size()==1)\n        {\n            return 0;\n        }\n        if(nums[0]+1>=nums.size())\n        {\n            return 1;\n        }\n        int count=0 ,i=0;\n        while(i<nums.size())\n        {\n            if(i==nums.size()-1)\n            {\n                return count;\n            }\n            int maxjump=nums[i],jumpinx=i;\n            for(int j=i+1;j<=i+nums[i] && j<nums.size();j++)\n            {\n                if(maxjump+jumpinx<=nums[j]+j)\n                {\n                    maxjump=nums[j];\n                    jumpinx=j;\n                }\n                if(j==nums.size()-1)\n                {\n                    return count+1;\n                }\n            }\n            i=jumpinx;\n            count++;\n        }\n        return count;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int jump(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> dp(n,INT_MAX);\n        dp[n-1] = 0; // dp[i] stores min steps to reach from i to n-1\n        for(int i=n-2;i>=0;i--){\n            int low = 1e4+1;\n            for(int j=i+1;j<=min(n-1,i+nums[i]);j++){\n                low = min(low,dp[j]);\n            }\n            dp[i] = low+1;\n        }\n        return dp[0];\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "int jump(vector<int>& nums, int pos = 0) {\n if(pos >= size(nums) - 1) return 0;        \n int minJumps = 10001;  // initialising to max possible jumps + 1\n for(int j = 1; j <= nums[pos]; j++)  // explore all possible jump sizes from current position\n  minJumps = min(minJumps, 1 + jump(nums, pos + j));        \n return minJumps;\n}"
            },
            {
                "language": "cpp",
                "code": "int jump(vector<int>& nums) {\n vector<int> dp(size(nums), 10001); // initialise all to max possible jumps + 1 denoting dp[i] hasn't been computed yet\n return solve(nums, dp, 0);\n}\n// recursive solver to find min jumps to reach end\nint solve(vector<int>& nums, vector<int>& dp, int pos) {\n if(pos >= size(nums) - 1) return 0;    // when we reach end, return 0 denoting no more jumps required\n if(dp[pos] != 10001) return dp[pos];    // number of jumps from pos to end is already calculated, so just return it\n // explore all possible jump sizes from current position. Store & return min jumps required\n for(int j = 1; j <= nums[pos]; j++)\n  dp[pos] = min(dp[pos], 1 + solve(nums, dp, pos + j));        \n return dp[pos];\n}"
            },
            {
                "language": "cpp",
                "code": "int jump(vector<int>& nums) {\n int n = size(nums);\n vector<int> dp(n, 10001);\n dp[n - 1] = 0;  // start from last index. No jumps required to reach end if we are already here\n // same as above. For each index, explore all jump sizes and use the one requiring minimum jumps to reach end\n for(int i = n - 2; i >= 0; i--) \n  for(int jumpLen = 1; jumpLen <= nums[i]; jumpLen++) \n   dp[i] = min(dp[i], 1 + dp[min(n - 1, i + jumpLen)]);  // min(n-1, i + jumpLen) for bounds handling\n return dp[0];\n}"
            },
            {
                "language": "cpp",
                "code": "int jump(vector<int>& nums) {\n int n = size(nums), i = 0, maxReachable = 0, lastJumpedPos = 0, jumps = 0;\n while(lastJumpedPos < n - 1) {  // loop till last jump hasn't taken us till the end\n  maxReachable = max(maxReachable, i + nums[i]);  // furthest index reachable on the next level from current level\n  if(i == lastJumpedPos) {     // current level has been iterated & maxReachable position on next level has been finalised\n   lastJumpedPos = maxReachable;     // so just move to that maxReachable position\n   jumps++;                          // and increment the level\n // NOTE: jump^ only gets updated after we iterate all possible jumps from previous level\n //       This ensures jumps will only store minimum jump required to reach lastJumpedPos\n  }            \n  i++;\n }\n return jumps;\n}"
            },
            {
                "language": "cpp",
                "code": "int minJump(vector<int> &A){\n    \n    int n = A.size();\n    \n    if (n <= 1)\n        return 0;"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        #print(nums)\n        L=len(nums)\n        if L==1:\n            return 0\n        steps=[0]\n        for i in range(nums[0]):\n            steps.append(1)\n        for index in range(1,L):\n            len_steps=len(steps)\n            if len_steps >= nums[index]+index+1:\n                index += 1\n            elif len_steps < nums[index]+index+1:\n                for j in range(nums[index]+index-len_steps+1):\n                    #print(index-1,steps[index-1])\n                    steps.append(steps[index]+1)\n            #print(steps)\n        return steps[L-1]"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int jump(vector<int>& nums) {\n        int n = nums.size();\n        int dp[n];\n        memset(dp,10001,sizeof(dp));\n        dp[0]=0;\n        for(int i=0;i<n-1;i++){\n            if(i+nums[i]>=n-1) {\n                dp[n-1]=min(dp[i]+1,dp[n-1]);\n                break;\n            }\n            for(int j=i+1;j<=i+nums[i];j++){\n                dp[j]=min(dp[j],dp[i]+1);\n            }\n        }\n        return dp[n-1];\n    }\n};"
            }
        ]
    },
    "45": {
        "question_id": 46,
        "title": "Permutations",
        "difficulty": 2,
        "description": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. ",
        "examples": [
            {
                "input": "nums = [1,2,3]",
                "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
                "explanation": null
            },
            {
                "input": "nums = [1]",
                "output": "[[1]]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 6",
            "-10 <= nums[i] <= 10",
            "All the integers of nums are unique."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "public List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n        if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n} "
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> permute(int[] nums) {\n   List<List<Integer>> list = new ArrayList<>();\n   // Arrays.sort(nums); // not necessary\n   backtrack(list, new ArrayList<>(), nums);\n   return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n   if(tempList.size() == nums.length){\n      list.add(new ArrayList<>(tempList));\n   } else{\n      for(int i = 0; i < nums.length; i++){ \n         if(tempList.contains(nums[i])) continue; // element already exists, skip\n         tempList.add(nums[i]);\n         backtrack(list, tempList, nums);\n         tempList.remove(tempList.size() - 1);\n      }\n   }\n} "
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> permuteUnique(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\n    if(tempList.size() == nums.length){\n        list.add(new ArrayList<>(tempList));\n    } else{\n        for(int i = 0; i < nums.length; i++){\n            if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\n            used[i] = true; \n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, used);\n            used[i] = false; \n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> combinationSum(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\n    if(remain < 0) return;\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\n    else{ \n        for(int i = start; i < nums.length; i++){\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> combinationSum2(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n    \n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\n    if(remain < 0) return;\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\n    else{\n        for(int i = start; i < nums.length; i++){\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i + 1);\n            tempList.remove(tempList.size() - 1); \n        }\n    }\n} "
            },
            {
                "language": "typescript",
                "code": "public List<List<String>> partition(String s) {\n   List<List<String>> list = new ArrayList<>();\n   backtrack(list, new ArrayList<>(), s, 0);\n   return list;\n}\n\npublic void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\n   if(start == s.length())\n      list.add(new ArrayList<>(tempList));\n   else{\n      for(int i = start; i < s.length(); i++){\n         if(isPalindrome(s, start, i)){\n            tempList.add(s.substring(start, i + 1));\n            backtrack(list, tempList, s, i + 1);\n            tempList.remove(tempList.size() - 1);\n         }\n      }\n   }\n}\n\npublic boolean isPalindrome(String s, int low, int high){\n   while(low < high)\n      if(s.charAt(low++) != s.charAt(high--)) return false;\n   return true;\n} "
            },
            {
                "language": "csharp",
                "code": "    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> ret = new ArrayList<>();\n\n int[] nums) {"
            },
            {
                "language": "lisp",
                "code": "if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;"
            },
            {
                "language": "csharp",
                "code": "    public List<List<Integer>> permute(int[] nums) {"
            },
            {
                "language": "csharp",
                "code": " list.add(new ArrayList<>(tempList));"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> list=new ArrayList<List<Integer>>();\n        backtrack(list,new ArrayList<Integer>(),n,k,1);\n        return list;\n    }\n    public void backtrack(List<List<Integer>> list,ArrayList<Integer> templist,int n, int k,int start){\n        if(templist.size()==k)"
            },
            {
                "language": "cpp",
                "code": "class Solution\n{\n\n    /*\n        Time Complexity : O(n*n!)\n        Space Complexity : O(n)\n    */\n\nprivate:\n    vector<vector<int>> res;\n    vector<int> temp;\n\n    void helper(vector<int> &nums, vector<bool> &freq)\n    {\n        if (temp.size() == nums.size())\n        {\n            res.push_back(temp);\n            return;\n        }\n\n        for (int i = 0; i < nums.size(); i++)\n        {\n            if (!freq[i])\n            {\n                freq[i] = true;\n                temp.push_back(nums[i]);\n                helper(nums, freq);\n                temp.pop_back();\n                freq[i] = false;\n            }\n        }\n    }\n\npublic:\n    vector<vector<int>> permute(vector<int> &nums)\n    {\n        int n = nums.size();\n        vector<bool> freq(n, false);\n        helper(nums, freq);\n\n        return res;\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def permute(self, arr: List[int]) -> List[List[int]]:\n        \n        ans  = []\n        def bt(res,check) :\n            if len(res) == len(arr) :\n                ans.append(res[:])\n                return\n            \n            for i in arr :\n                if i not in check :\n                    check.add(i)\n                    res.append(i)\n                    bt(res,check)\n                    res.remove(i)\n                    check.remove(i)\n        bt([],set())\n        return ans"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>>ans=new ArrayList<>();\n        solve(0,nums,ans);\n        return ans;\n    }\n    public void solve(int ind,int[] nums,List<List<Integer>>ans){\n        if(ind==nums.length){\n            ArrayList<Integer>arr=new ArrayList<>();\n            for(int i=0;i<nums.length;i++){\n                arr.add(nums[i]);\n            }\n            ans.add(new ArrayList<>(arr));\n            return;\n        }\n\n        for(int i=ind;i<nums.length;i++){\n            swap(i,ind,nums);\n            solve(ind+1,nums,ans);\n            swap(i,ind,nums);//backtrack\n        }\n    }\n\n    public void swap(int i,int j,int[]nums){\n        int temp=nums[i];\n        nums[i]=nums[j];\n        nums[j]=temp;\n    }\n\n}"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    func permute(_ nums: [Int]) -> [[Int]] {\n        if nums.count == 1 { return [nums] }\n        \n        var (res, nums) = ([[Int]](), nums)\n        \n        for i in 0..<nums.count{\n            let n = Int(nums.removeFirst())\n            var perms = permute(nums)\n            \n            for i in 0..<perms.count{\n                perms[i].append(n)\n            }\n            \n            res += perms\n            nums.append(n)\n        }\n        \n        return  res\n    }\n}"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        boolean [] visited = new boolean[nums.length];\n        FindAllPermutation(res,nums, new ArrayList(),visited);\n        return res;\n    }\n    void FindAllPermutation(List<List<Integer>> res, int[] nums, List<Integer> curr, boolean [] visited){\n        if(curr.size()==nums.length){\n            res.add(new ArrayList(curr));\n            return;\n        }\n\n        for(int i =0;i<nums.length;i++){\n            if(visited[i]==true)\n            continue;\n            curr.add(nums[i]);\n            visited[i]= true;\n            FindAllPermutation(res,nums,curr,visited);\n            curr.remove(curr.size()-1);\n            visited[i]=false;\n        }\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N!), Because there are N! permutations and N! function calls. Where N is the size of the\n    array(nums) and ! stands for factorial. \n\n    Space Complexity: O(N!*N), since we have to store all the possible solutions which are N! in size where N is\n    the size of the array and ! stands for factorial.\n\n    Solved using Array + BackTracking. \n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {   \nprivate :\n    void permute(vector<int> &nums, vector<vector<int>> &ans, vector<int> &temp, int index){\n        if(index == nums.size()){\n            ans.push_back(temp);\n            return;\n        }\n        for(int i=index; i<temp.size(); i++){\n            swap(temp[index] , temp[i]);\n            permute(nums, ans, temp, index+1);\n            swap(temp[index] , temp[i]);\n        }\n    }\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> ans;\n        vector<int> temp = nums;\n        permute(nums, ans, temp, 0);\n        return ans;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N!), Because there are N! permutations and N! function calls. Where N is the size of the\n    array(nums) and ! stands for factorial. \n\n    Space Complexity: O(N!*N), since we have to store all the possible solutions which are N! in size where N is\n    the size of the array and ! stands for factorial.\n\n    Solved using Array + BackTracking. \n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {    \nprivate :\n    void permute(vector<int> &nums, vector<vector<int>> &ans, vector<int> temp, int index){\n        if(index == nums.size()){\n            ans.push_back(temp);\n            return;\n        }\n        for(int i=index; i<temp.size(); i++){\n            swap(temp[index] , temp[i]);\n            permute(nums, ans, temp, index+1);\n        }\n    }\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> ans;\n        vector<int> temp = nums;\n        permute(nums, ans, temp, 0);\n        return ans;\n    }\n};"
            },
            {
                "language": "python",
                "code": "def permute(self, nums):\n # helper\n def recursive(nums, perm=[], res=[]):\n  if not nums: # -- NOTE [1] \n   res.append(perm[::]) #  -- NOTE [2] - append a copy of the perm at the leaf before we start popping/backtracking\n\n  for i in range(len(nums)): # [1,2,3]\n   newNums = nums[:i] + nums[i+1:]\n   perm.append(nums[i])\n   recursive(newNums, perm, res) # - recursive call will make sure I reach the leaf\n   perm.pop() # -- NOTE [3] \n  return res\n\nreturn recursive(nums)\n\n# NOTE [1]:\n# --------\n# nums is empty at the leaf of the recursive tree\n\n# NOTE [2]:\n# --------\n# at the leaf -> we know we have exaushted one path/permutation (each path is a permutation in a recursive tree)\n# reason why we are copying here is because at lists are passed by reference and since we are maintaining only one path/perm variable throughput, we are gonna be modifiying that path variable (popping it to be precise) in order to revert the path to a previous state (aka parent node) in preperation to make a lateral/horizontal move to a sibling node. See explanation below for further understanding.\n\n# NOTE [3]:\n# ---------\n# See below"
            },
            {
                "language": "python",
                "code": "for i in range(len(nums)): # [1,2,3]\n newNums = nums[:i] + nums[i+1:]\n perm.append(nums[i])\n recursive(newNums, perm, res) \n perm.pop() # -- BACKTRACK"
            },
            {
                "language": "python",
                "code": "def sumPosNumLessThanN(N, res=0):\n if N == 0:\n  return res\n else:\n  res = 1 + sumPosNumLessThanN(N-1)\n return res"
            },
            {
                "language": "python",
                "code": "def recursive(nums, perm=[], res=[]):\n        \n            if not nums: \n                res.append(perm) # --- no need to copy as we are not popping/backtracking. Instead we're passing a new variable each time \n\n            for i in range(len(nums)): \n                newNums = nums[:i] + nums[i+1:]\n                # perm.append(nums[i]) # --- instead of appending to the same variable\n                newPerm = perm + [nums[i]] # --- new copy of the data/variable\n                recursive(newNums, newPerm, res) \n                # perm.pop()  # --- no need to backtrack\n            return res\n        \n        return recursive(nums)"
            },
            {
                "language": "python",
                "code": "def recursive(nums):\n  stack = [(nums, [])]   # -- nums, path (or perms)\n  res = []\n  while stack:\n   nums, path = stack.pop()\n   if not nums:\n    res.append(path)\n   for i in range(len(nums)):   # -- NOTE [4]\n    newNums = nums[:i] + nums[i+1:]\n    stack.append((newNums, path+[nums[i]]))  # --  just like we used to do (path + [node.val]) in tree traversal\n  return res\n\n# NOTE [4]\n# The difference between itertaive tree/graph traversal we did before and this one is that\n# in most tree/graph traversals we are given the DS (tree/graph/edges) whereas here we have to build the nodes before we # traverse them\n# Generating the nodes is very simple, we Each node will be (nums, pathSofar)"
            },
            {
                "language": "python",
                "code": "def recursive(nums):\n from collections import deque\n q = deque()\n q.append((nums, []))  # -- nums, path (or perms)\n res = []\n while q:\n  nums, path = q.popleft()\n  if not nums:\n   res.append(path)\n  for i in range(len(nums)):\n   newNums = nums[:i] + nums[i+1:]\n   q.append((newNums, path+[nums[i]]))\n return res\n        "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> ans;\n        sort(nums.begin(),nums.end());\n        do{\n            ans.emplace_back(nums);\n        }while(next_permutation(nums.begin(),nums.end()));\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void Permutations(vector<int> &nums, vector<vector<int>> &ans, vector<int> &ds, int freq[]){\n        if(ds.size() == nums.size()){\n            ans.emplace_back(ds);\n            return;\n        }\n        for(int i=0 ; i<nums.size() ; i++){\n            if(!freq[i]){\n                ds.emplace_back(nums[i]);\n                freq[i]++;\n                Permutations(nums, ans, ds, freq);\n                freq[i]--;\n                ds.pop_back();\n            }\n        }\n    }   \n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> ans;\n        vector<int> ds;\n        int freq[nums.size()];\n        for(int i=0 ; i<nums.size() ; i++) \n            freq[i]=0;\n        Permutations(nums, ans, ds, freq);\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void Permutations(int ind, vector<int> &nums, vector<vector<int>> &ans){\n        if(ind == nums.size()){\n            ans.emplace_back(nums);\n            return;\n        }\n        for(int i=ind ; i<nums.size() ; i++){\n            swap(nums[ind],nums[i]);\n            Permutations(ind+1, nums, ans);\n            swap(nums[ind],nums[i]);\n        }\n    }   \n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> ans;\n        Permutations(0, nums, ans);\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "vector<vector<int>> permute(vector<int>& nums) {\n sort(nums.begin(),nums.end());\n    vector<vector<int>>ans;\n    do\n    {\n        ans.push_back(nums);\n    }\n    while(next_permutation(nums.begin(),nums.end()));\n    return ans;\n}"
            }
        ]
    },
    "46": {
        "question_id": 47,
        "title": "Permutations II",
        "difficulty": 2,
        "description": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order. ",
        "examples": [
            {
                "input": "nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]",
                "output": "ums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]",
                "explanation": null
            },
            {
                "input": "nums = [1,2,3]",
                "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 8",
            "-10 <= nums[i] <= 10"
        ],
        "solutions": [
            {
                "language": "ruby",
                "code": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        return set(permutations(nums)) "
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        per = permutations(nums)\n        l = []\n        for i in per:\n            if i not in l:\n                l.append(i)\n        return l      "
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        ans = []\n        def helper(nums,temp):\n            if len(nums) == 0:\n                ans.append(temp)\n                return\n            for i in range(len(nums)):\n                helper(nums[:i]+nums[i+1:],temp+[nums[i]]) \n        helper(nums,[])\n        return set(tuple(ele) for ele in ans) \n        "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n        vector<vector<int>> ans;\n        set <vector<int>> s;  //set used to remove duplicates\n    void helper(vector<int> &vec,vector<int>& nums,vector<int> &present,int j)\n    {\n        if(j>=nums.size())\n        {\n            s.insert(vec);\n        }\n        if(nums.size()<j)\n            return;\n        for(int i=0;i<nums.size();i++)\n        { \n             if(present[i]==0)\n        {\n            vec.push_back(nums[i]);\n            present[i]=1;\n            helper(vec,nums,present,j+1);\n            vec.pop_back();\n            present[i]=0;\n        }\n        }\n    }\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n         vector<int> vec;\n        vector<int> present;\n       sort(nums.begin(),nums.end());\n        for(int i=0;i<nums.size();i++)\n        {\n            present.push_back(0);\n        }\n        helper(vec,nums,present,0);  \n        for(auto it:s){\n            ans.push_back(it);      \n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N!*KlogK), In worst case when all element of Array(nums) will different then there will\n    be N! permutations and N! function calls and for every permutation we have to check in Hash Table(set) for\n    inserting which take O(KlogK) time .Where N is the size of the array(nums) and ! stands for factorial. K is\n    the worst case size of Array(output). \n\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\n    factorial.\n\n    Solved using Array + BackTracking + Hash Table(set). \n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\nprivate: \n    void permuteUnique(vector<int>& nums, set<vector<int>>& set, vector<int> temp, int index){\n        if(index == nums.size()){\n            set.insert(temp);\n            return;\n        }\n        for(int i=index; i<temp.size(); i++){\n            swap(temp[index], temp[i]);\n            permuteUnique(nums, set, temp, index+1);\n        }\n    }\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        vector<vector<int>> output;\n        vector<int> temp = nums;\n        sort(temp.begin(), temp.end());\n        set<vector<int>> set;\n        permuteUnique(nums, set, temp, 0);\n        for(auto it : set){\n            output.push_back(it);\n        }\n        return output;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N!*K), In worst case when all element of Array(nums) will different then there will be N!\n    permutations and N! function calls and for every permutation we have to check in Array(output) for\n    duplicated which take O(K) time .Where N is the size of the array(nums) and ! stands for factorial. K is the\n    worst case size of Array(output). \n\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\n    factorial.\n\n    Solved using Array + BackTracking. \n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\nprivate: \n    void permuteUnique(vector<int>& nums, vector<vector<int>>& output, vector<int> temp, int index){\n        if(index == nums.size()){\n            output.push_back(temp);\n            return;\n        }\n        for(int i=index; i<temp.size(); i++){\n            swap(temp[index], temp[i]);\n            bool isPresent = find(output.begin(), output.end(), temp) != output.end();\n            if(isPresent){\n                continue;\n            }\n            permuteUnique(nums, output, temp, index+1);\n        }\n    }\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        vector<vector<int>> output;\n        vector<int> temp = nums;\n        sort(temp.begin(), temp.end());\n        permuteUnique(nums, output, temp, 0);\n        return output;\n    }\n};\n\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N!), In worst case when all element of Array(nums) will different then there will be N!\n    permutations and N! function calls. Where N is the size of the array(nums) and ! stands for factorial. \n\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\n    factorial.\n\n    Solved using Array + BackTracking. \n\n*/\n\n\n/***************************************** Approach 3 *****************************************/\n\nclass Solution {\nprivate: \n    void permuteUnique(vector<int>& nums, vector<vector<int>>& output, vector<int> temp, vector<bool>& visited){\n        if(temp.size() == nums.size()){\n            output.push_back(temp);\n            return;\n        }\n        for(int i=0; i<nums.size(); i++){\n            if(visited[i] || i>0 && nums[i] == nums[i-1] && !visited[i-1]) continue;\n            visited[i] = true;\n            temp.push_back(nums[i]);\n            permuteUnique(nums, output, temp, visited);\n            temp.pop_back();\n            visited[i] = false;\n        }\n    }\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> output;\n        vector<int> temp;\n        vector<bool> visited(nums.size(), 0); \n        permuteUnique(nums, output, temp, visited);\n        return output;\n    }\n};"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        if(nums==null || nums.length==0) return res;\n        boolean[] used = new boolean[nums.length];\n        List<Integer> list = new ArrayList<Integer>();\n        Arrays.sort(nums);\n        dfs(nums, used, list, res);\n        return res;\n    }\n\n    public void dfs(int[] nums, boolean[] used, List<Integer> list, List<List<Integer>> res){\n        if(list.size()==nums.length){\n            res.add(new ArrayList<Integer>(list));\n            return;\n        }\n        for(int i=0;i<nums.length;i++){\n            if(used[i]) continue;\n            if(i>0 &&nums[i-1]==nums[i] && !used[i-1]) continue;\n            used[i]=true;\n            list.add(nums[i]);\n            dfs(nums,used,list,res);\n            used[i]=false;\n            list.remove(list.size()-1);\n        }\n    }\n}"
            },
            {
                "language": "csharp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n<!-- this function is to identify the next permutation and will be added to the sol -->\n    void Permu(vector<vector<int>>&sol, vector<int> &nums){\n        int n = nums.size(), i, j;\n\n        for(i=n-2; i>=0; i--){\n            if(nums[i] < nums[i+1]) {\n                break;\n            }\n        }\n<!-- this is the base condition -->\n        if(i < 0){\n            return;\n        } \n        else{\n            for(j=n-1; j>i; j--){\n                if(nums[j] > nums[i]){\n                    break;\n                } \n            }\n            swap(nums[i], nums[j]);\n            reverse(nums.begin() + i + 1, nums.end());\n        }\n        sol.push_back(nums);\n        Permu(sol, nums);\n    }\n\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n    <!-- input array is sorted  -->\n        vector <vector <int>> sol;\n        sol.push_back(nums);\n        Permu(sol, nums);\n        return sol;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution \n{\npublic:\n    void swap(int a, int b, vector<int>& nums)\n    {\n        int t=nums[a];\n        nums[a]=nums[b];\n        nums[b]=t;\n    }\n    void permute(vector<int>& nums, int i, set<vector<int>> &ans, int n)\n    {\n        if(i>=n)\n        {\n            ans.insert(nums);\n            return;\n        }\n        for(int x=i; x<n; x++)\n        {\n            swap(i,x,nums);\n            permute(nums,i+1,ans,n);\n            swap(i,x,nums);\n        }\n    }\n    vector<vector<int>> permuteUnique(vector<int>& nums) \n    {\n        set<vector<int>> ans;\n        int n=nums.size();\n        permute(nums,0,ans,n);\n        vector<vector<int>> a;\n        for(auto it: ans) a.push_back(it);\n        return a;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        vector<vector<int>> vc;\n        int i,j,n=nums.size()-1;\n        do{\n            i=j=n;\n            while(i && nums[i-1]>=nums[i]) i--;\n            if(i){\n                while(nums[i-1]>=nums[j]) j--;\n                swap(nums[i-1],nums[j]);\n            }\n            reverse(nums.begin()+i,nums.end());\n            vc.push_back(nums);\n        }while(i);\n        return vc;\n    }\n};"
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permuteUnique = function(nums) {\n    nums.sort((a,b)=>a-b)\n    let res = []\n\n    let iterate = (arr,temp) =>{\n        if(arr.length == 1){\n            res.push([...temp,arr[0]])\n            return;\n        }\n        for(let i =0;i<arr.length;i++){\n            if(arr[i] == arr[i-1]) continue;\n            iterate(arr.filter((num,idx)=>idx !=i),[...temp,arr[i]])\n        }\n    }\n    iterate(nums,[])\n    return res\n};"
            }
        ]
    },
    "47": {
        "question_id": 48,
        "title": "Rotate Image",
        "difficulty": 2,
        "description": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. ",
        "examples": [
            {
                "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
                "output": "[[7,4,1],[8,5,2],[9,6,3]]",
                "explanation": null
            },
            {
                "input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
                "output": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
                "explanation": null
            }
        ],
        "constraints": [
            "n == matrix.length == matrix[i].length",
            "1 <= n <= 20",
            "-1000 <= matrix[i][j] <= 1000"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\n    public void rotate(int[][] matrix) \n    {\n        int n =matrix.length;\n        int matrix1[][] = new int[n][n];\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                matrix1[i][j]=matrix[n-1-j][i];\n            }\n        }\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                matrix[i][j]=matrix1[i][j];\n            }\n        }\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "/*\n * clockwise rotate\n * first reverse up to down, then swap the symmetry \n * 1 2 3     7 8 9     7 4 1\n * 4 5 6  => 4 5 6  => 8 5 2\n * 7 8 9     1 2 3     9 6 3\n*/\nvoid rotate(vector<vector<int> > &matrix) {\n    reverse(matrix.begin(), matrix.end());\n    for (int i = 0; i < matrix.size(); ++i) {\n        for (int j = i + 1; j < matrix[i].size(); ++j)\n            swap(matrix[i][j], matrix[j][i]);\n    }\n}\n\n/*\n * anticlockwise rotate\n * first reverse left to right, then swap the symmetry\n * 1 2 3     3 2 1     3 6 9\n * 4 5 6  => 6 5 4  => 2 5 8\n * 7 8 9     9 8 7     1 4 7\n*/\nvoid anti_rotate(vector<vector<int> > &matrix) {\n    for (auto vi : matrix) reverse(vi.begin(), vi.end());\n    for (int i = 0; i < matrix.size(); ++i) {\n        for (int j = i + 1; j < matrix[i].size(); ++j)\n            swap(matrix[i][j], matrix[j][i]);\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "public void rotate(int[][] matrix) {\n    int s = 0, e = matrix.length - 1;\n    while(s < e){\n        int[] temp = matrix[s];\n        matrix[s] = matrix[e];\n        matrix[e] = temp;\n        s++; e--;\n    }"
            },
            {
                "language": "javascript",
                "code": "/*\n * clockwise rotate\n * first swap the symmetry (i.e. transpose the matrix), then reverse each row\n * 1 2 3     1 4 7     7 4 1\n * 4 5 6  => 2 5 8  => 8 5 2\n * 7 8 9     3 6 9     9 6 3\n * \n * anti-clockwise rotate"
            },
            {
                "language": "java",
                "code": ""
            },
            {
                "language": "python",
                "code": "for (int j = i + 1; j < matrix[i].size(); ++j)"
            },
            {
                "language": "python",
                "code": "for (int j = 0; j < i; ++j)"
            },
            {
                "language": "ruby",
                "code": ""
            },
            {
                "language": "java",
                "code": "/* Clockwise Rotate */\npublic void rotate(int[][] matrix) {\n    if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return;\n    int rows = matrix.length;\n    int cols = matrix[0].length;\n    for(int first=0, last=rows-1; first<last; first++,last--) {\n        int[] tmp = matrix[first];\n        matrix[first] = matrix[last];"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N^2), Where N is the number of row and column of matrix. Here two nested loops creates\n    the time complexity.\n\n    Space Complexity : O(N^2), temp matrix space.\n\n    Solved using Matrix + Math.\n\n*/\n\n\n/***************************************** Approach 1 Code *****************************************/\n\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        vector<vector<int>> temp(n, vector<int>(m, 0));\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                temp[j][n-1-i] = matrix[i][j];\n\n            }\n        }\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                matrix[i][j] = temp[i][j];\n            }\n        }\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^2), Where N is the number of row and column of matrix. Here two nested loops creates\n    the time complexity.\n\n    Space Complexity : O(1), Constant space.\n\n    Solved using Matrix + Math.\n\n*/\n\n\n/***************************************** Approach 2 Code *****************************************/\n\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        vector<vector<int>> temp(n, vector<int>(m, 0));\n        for(int i=0; i<n; i++){\n            for(int j=0; j<i; j++){\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n        for(int i=0; i<n; i++){\n            reverse(matrix[i].begin(), matrix[i].end());\n        }\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n\n /*\n  Time Complexity : O(n/2*n/2) + O(n*n/2)\n  Space Complexity : O(1)\n */\n\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        \n        // Take a tranpose of the matrix\n        for(int i=0; i<n; i++){\n            for(int j=i+1; j<n; j++){\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n        \n        // Reverse each row of the matrix to get the output\n        for(int i=0; i<n; i++){\n            reverse(matrix[i].begin(), end(matrix[i]));\n        }\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution\n{\npublic:\n void rotate(vector<vector<int>> &matrix)\n {\n  int n = matrix.size();\n\n  for (int i = 0; i < n; i++)\n  {\n   for (int j = i; j < n; j++)\n   {\n    swap(matrix[i][j], matrix[j][i]);\n   }\n  }\n\n  for (int i = 0; i < n; i++)\n  {\n   for (int j = 0, k = n - 1; j < k; j++, k--)\n   {\n    swap(matrix[i][j], matrix[i][k]);\n   }\n  }\n }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n\n    public void rotate(int[][] matrix) {\n\n        // dim is the extreme end of an array\n        int dim = matrix.length - 1;\n\n        for (int row = 0; row <= dim/2; row++) {\n            // This loop covers outer squares one by one\n\n            for (int i = row; i < dim - row; i++) {\n                // this loop rotates the current square under consideration\n\n                //Define four points on the matrix\n                Point pt1 = new Point(row, i);\n                Point pt2 = new Point(i, dim - row);\n                Point pt3 = new Point(dim - row, dim - i);\n                Point pt4 = new Point(dim - i, row);\n\n                // We need 3 swaps to rotate 4 points by 90 degrees\n                swap(matrix, pt1, pt2);\n                swap(matrix, pt3, pt4);\n                swap(matrix, pt1, pt3);\n            }\n        }\n    }\n\n    // ultility function to swap two locations in the array\n    public void swap(int[][] matrix, Point pt1, Point pt2) {\n        int temp = matrix[pt1.x][pt1.y];\n        matrix[pt1.x][pt1.y] = matrix[pt2.x][pt2.y];\n        matrix[pt2.x][pt2.y] = temp;\n    }\n}\n\n\n// A class to represent a Point on the matrix\nclass Point {\n    public int x;\n    public int y;\n\n    Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    // you can use this function to print the Point details for debugging\n    public void print(String label, int[][] matrix) {\n        System.out.println(\"Point \" + label + \"] x = \" + this.x + \"\\ty = \" + this.y + \"\\tvalue = \" + matrix[this.x][this.y]);\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public void rotate(int[][] matrix) {\n        int r=matrix.length-1;\n        int c=matrix.length-1;\n        // int i=0;\n        int[][] arr=new int[r+1][r+1];\n        for(int i=0;i<=r;i++)\n        {\n            int k=c;\n            for(int j=0;j<=r;j++)\n            {\n                 arr[i][j]=matrix[k][i];\n                 k--;\n            }  \n        }\n        for(int i=0;i<=r;i++)\n        {\n            for(int j=0;j<=r;j++)\n            {\n                 matrix[i][j]=arr[i][j];\n            }  \n        }\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void rotate(vector<vector<int>>& mat) {\n        int n=mat.size();\n        int m=mat[0].size();\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<i;j++)\n            {\n                swap(mat[i][j],mat[j][i]);\n\n            }\n        }\n        for(int i=0;i<n;i++)\n        {\n            reverse(mat[i].begin(),mat[i].end());\n        }\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public void rotate(int[][] matrix) {\n\n        //Transpose\n        for(int i=0;i<matrix.length;i++){\n            for(int j=i;j<matrix[0].length;j++){\n                int temp=matrix[i][j];\n                matrix[i][j]=matrix[j][i];\n                matrix[j][i]=temp;\n            }\n        }\n\n        //Reverse\n         for(int i=0;i<matrix.length;i++){\n            for(int j=0;j<matrix[0].length/2;j++){\n                int temp=matrix[i][j];\n                matrix[i][j]=matrix[i][matrix.length-1-j];\n                matrix[i][matrix.length-1-j]=temp;\n            }\n        }\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public void rotate(int[][] matrix) {\n        \n        \n       int m = matrix.length;\n        int n = matrix[0].length;\n        \n        for(int i=1;i<m;i++){\n            for(int j=0;j<i;j++){\n                \n                matrix[i][j]=matrix[i][j]-matrix[j][i];\n                matrix[j][i]=matrix[i][j]+matrix[j][i];\n                matrix[i][j]= matrix[j][i]-matrix[i][j];\n            }\n        }\n        \n        for(int i=0;i<m;i++){\n            for(int j=0;j<n/2;j++){\n                \n                matrix[i][j]=matrix[i][j]-matrix[i][n-j-1];\n                matrix[i][n-j-1]=matrix[i][j]+matrix[i][n-j-1];\n                matrix[i][j]= matrix[i][n-j-1]-matrix[i][j];\n            }\n                    \n        \n    }\n    }\n}"
            }
        ]
    },
    "48": {
        "question_id": 49,
        "title": "Group Anagrams",
        "difficulty": 2,
        "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. ",
        "examples": [
            {
                "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
                "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
                "explanation": null
            },
            {
                "input": "strs = [\"a\"]",
                "output": "[[\"a\"]]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= strs.length <= 104",
            "0 <= strs[i].length <= 100",
            "strs[i] consists of lowercase English letters."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": " \nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        \n       vector<vector<string>>ans;\n        \n       unordered_map<string, vector<string>>mp;\n        \n         /*\n                Consider example 1 : strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n                \n                After the below opeartion of for loop map will contain\n                \n                aet -- eat, tea, ate\n                ant -- tan, nat\n                abt -- bat\n        */\n        \n        for(int i = 0 ; i < strs.size() ; i++)\n        {\n            string s = strs[i];\n            sort(strs[i].begin(),strs[i].end());\n            mp[strs[i]].push_back(s);\n        }\n        \n        //now simply put the elements  of second column of map in ans\n        \n        for(auto i : mp)\n        {\n            ans.push_back(i.second);\n        }\n\n        return ans;\n        \n    }\n};"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        int mod = 1_000_000_007;\n\n 71, 73, 79, 83, 89, 97, 101};"
            },
            {
                "language": "typescript",
                "code": ""
            },
            {
                "language": "typescript",
                "code": ""
            },
            {
                "language": "dart",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "python",
                "code": "strs.groupBy(_.sorted).values.map(_.toList).toList"
            },
            {
                "language": "python",
                "code": "for (let str of strs) {\n    let sortedStr = str.split('').sort().join('');\n    if (sortedStr in obj) {\n        obj[sortedStr].push(str)\n    } else {"
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        vector<vector<string>> ans; \n        unordered_map<string,vector<string>> umap; \n        for(auto x:strs){\n            string temp=x; "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<string,vector<string>>mp;\n        vector<vector<string>> result;\n        int slength;\n        int n = strs.size();\n        for(int i=0;i < n ; i++)\n        {\n            vector<int>v(26,0);\n            slength = strs[i].length();\n            for(int j=0;j<slength;j++)\n                v[strs[i][j]-'a']++;\n            string s=\"\";    \n            for(int j=0;j<26;j++)\n            {\n                s.append(\"#\");\n                s.append(to_string(v[j]));\n            }    \n            mp[s].push_back(strs[i]);\n        }\n        for(auto i=mp.begin();i!=mp.end();i++)\n            result.push_back(i->second);\n        return result;\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        res=defaultdict(list)\n        for i in strs:\n            c=[0]*26\n            for p in i:\n                count=ord(p)-ord('a')\n                c[count]+=1\n            res[tuple(c)].append(i)\n        return res.values()\n        "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> mp;\n        for(int i=0;i<strs.size();i++){\n            string str = strs[i];\n            sort(str.begin(), str.end());\n            mp[str].push_back(strs[i]);\n        }\n        vector<vector<string>> ans;\n        for(auto &pr:mp){\n            vector<string> temp;\n            for(int i=0;i<(pr.second).size();i++){\n                temp.push_back(pr.second[i]);\n            }\n            ans.push_back(temp);\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic.\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        string s=\"\";\n        vector<string> tmp;\n        vector<vector<string>> v;\n        int size=strs.size();\n        int arr[size];\n        string a,b;\n        int i,j;\n        for(i=0;i<size;i++) arr[i]=0;\n        for(i=0;i<size;i++)\n        {\n            if(arr[i]) continue;\n            for(j=i+1;j<size;j++)\n            {\n                if(arr[j]) continue;\n                if(strs[i].size()!=strs[j].size()) continue;\n                else\n                {\n                    a=strs[i];\n                    b=strs[j];\n                    sort(a.begin(),a.end());\n                    sort(b.begin(),b.end());\n                    if(a==b) \n                    {\n                        tmp.push_back(strs[j]);\n                        arr[j]=1;\n                    }\n                }\n            }\n            tmp.push_back(strs[i]);\n            v.push_back(tmp);\n            tmp.clear();\n            arr[i]=1;\n        }\n        return v;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        if(strs.size()==1) return {{strs[0]}};\n        vector<vector<string>> v;\n        unordered_map<string,vector<string>> m;\n        int i,size;\n        size=strs.size();\n        string str;\n        for(i=0;i<size;i++)\n        {\n            str=strs[i];\n            sort(strs[i].begin(),strs[i].end()); \n            m[strs[i]].push_back(str);          \n        }\n        unordered_map<string,vector<string>>::iterator it;\n        for(it=m.begin();it!=m.end();++it) v.push_back(it->second);  \n    return v;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n       vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        vector<vector<string>> vt;\n        unordered_map<string,vector<string>> map;\n        for(auto i:strs){\n            string temp = i;\n            sort(temp.begin(),temp.end());\n            map[temp].push_back(i);\n        }\n        for(auto i:map) vt.push_back(i.second);\n        return vt;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,vector<string>>mp;\n        for(int i=0;i<strs.size();i++){\n            string tmp = strs[i];\n            sort(tmp.begin(),tmp.end());\n            mp[tmp].push_back(strs[i]);\n        }\n            \n        vector<vector<string>>ans;\n        for(auto it:mp)\n            ans.push_back(it.second);\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,vector<string>> m;\n        for(string s: strs){\n            string temp=s;\n            sort(temp.begin(),temp.end());\n            m[temp].push_back(s);   \n        }\n        vector<vector<string>> ans;\n        for(auto x: m){\n            ans.push_back(x.second);\n        }\n        return ans;\n    }"
            },
            {
                "language": "cpp",
                "code": "vector<vector<string>> groupAnagrams(vector<string>& strs) {\n    vector<pair<string, string>>v;\n    for(int i=0; i<strs.size(); i++){\n        string s=strs[i];\n        sort(s.begin(), s.end());\n        v.push_back({s, strs[i]});\n    }\n    sort(v.begin(), v.end());\n    unordered_map<string, vector<string>>m;\n    for(int i=0; i<v.size(); i++){\n        m[v[i].first].push_back(v[i].second);\n    }\n    vector<vector<string>>ans;\n    for(auto it: m){\n        ans.push_back(it.second);\n    }\n    return ans;\n}"
            }
        ]
    },
    "49": {
        "question_id": 50,
        "title": "Pow(x, n)",
        "difficulty": 2,
        "description": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn). ",
        "examples": [
            {
                "input": "x = 2.00000, n = 10",
                "output": "1024.00000",
                "explanation": null
            },
            {
                "input": "x = 2.10000, n = 3",
                "output": "9.26100",
                "explanation": null
            },
            {
                "input": "x = 2.00000, n = -2",
                "output": "0.25000",
                "explanation": "2-2 = 1/22 = 1/4 = 0.25"
            }
        ],
        "constraints": [
            "-100.0 < x < 100.0",
            "-231 <= n <= 231-1",
            "n is an integer.",
            "-104 <= xn <= 104"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    double myPow(double x, int n) {\n        return pow(x, n);   \n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    double calc(double x, int n){\n        int temp = 1;\n        for(double i = 1; i <= n; i++)\n            temp *= x;\n        return temp;\n    }\n    double myPow(double x, int n) {\n        double temp = 1;\n        if(n >= 0)\n        return calc(x,n);\n        else\n            return 1.0/ calc(x,-n);\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    double power(double x, int n){\n        if( x == 0)\n        return 0;\n        if(n == 0)\n        return 1; \n        return x * power(x, n-1);;\n    }\n    double myPow(double x, int n) {\n        if(n == INT_MAX){\n            if(x == 1)\n            return 1;\n            else{\n                if(x == -1)\n                return -1;\n                else \n                return 0;\n            }\n        }\n        if(n == INT_MIN){\n            if(x == 1|| x == -1)\n            return 1;\n            else \n            return 0;\n        }\n        if(n >= 0)\n            return power(x,n);\n        else{\n            n = -n;\n            return 1.0/power(x,n);\n        }\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    double myPow(double x, int n) {\n\n        if(n==0 || x==1)\n         return 1;\n\n        double val= myPow(x,n/2);\n        val*=val;\n\n        if(n%2==0)\n         return val;\n\n        else{\n\n            if(n<0)\n             return val*(1/x);\n\n            return val*x;\n        }\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N), because we call the recurtion until we multiply the base exponent times. Thus the\n    time complexity is linear.\n\n    Space Complexity : O(N), Recursion stack space.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\nprivate:\n    double power(double x, int n){\n        if(n==0){\n            return 1;\n        }\n        return x * power(x, n-1);\n    }\npublic:\n    double myPow(double x, int n) {\n        if (n == INT_MAX) return (x == 1) ? 1 : (x == -1) ? -1 : 0;\n        if (n == INT_MIN) return (x == 1 || x == -1) ? 1 : 0;\n        double num = 1;\n        if(n>=0){\n            num = power(x, n);\n        }\n        else{\n            n = -n;\n            num = power(x, n);\n            num = 1.0/num;\n        }\n        return num;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N), because we loop until we multiply the base exponent times. Thus the time complexity\n    is linear.\n\n    Space Complexity : O(1), Constant space.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        if (n == INT_MAX) return (x == 1) ? 1 : (x == -1) ? -1 : 0;\n        if (n == INT_MIN) return (x == 1 || x == -1) ? 1 : 0;\n        double num = 1;\n        if(n>=0){\n            while(n>0){\n                num *= x;\n                n--;\n            }\n        }\n        else{\n            n = -n;\n            while(n>0){\n                num *= x;\n                n--;\n            }\n            num = 1.0/num;\n        }\n        return num;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(logN).\n\n    Space Complexity : O(logN), Recursion stack space.\n\n*/\n\n\n/***************************************** Approach 3 *****************************************/\n\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        if(n==0) return 1;\n        if(n<0) {\n            n = abs(n);\n            x = 1/x;\n        }\n        if(n%2==0){\n            return myPow(x*x, n/2);\n        }\n        else{\n            return x*myPow(x, n-1);\n        }\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(logN).\n\n    Space Complexity : O(1), Constant space.\n\n*/\n\n\n/***************************************** Approach 4 *****************************************/\n\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        double num = 1;\n        long long nn = n;\n        if(nn < 0) nn = -nn;\n        while(nn>0){\n            if(nn%2==1){\n                num = num * x;\n                nn--;\n            }\n            else{\n                x = x*x;\n                nn/=2;\n            }\n        }\n        if(n < 0){\n            num = 1.0/num;\n        }\n        return num;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(logN).\n\n    Space Complexity : O(logN), Constant space.\n\n*/\n\n\n/***************************************** Approach 5 *****************************************/\n\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        return pow(x, n);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public double myPow(double x, int n) {\n        double a=Math.pow(x,n);\n        return a;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    double myPow(double x, int n) {\n    if (n == 0) {\n        return 1.0;\n    }\n    double res = 1.0;\n    long long p = abs((long long) n);\n    while (p > 0) {\n        if (p % 2 == 1) {\n            res *= x;\n        }\n        x *= x;\n        p /= 2;\n    }\n    if (n < 0) {\n        return 1.0 / res;\n    } else {\n        return res;\n    }\n}\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    double myPow(double x, int n) {\n        return pow(x,n);\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    double myPow(double x, int n) {\n\n        if(n==0 || x==1)\n         return 1;\n\n        double val= myPow(x,n/2);\n        val*=val;\n\n        if(n%2==0)\n         return val;\n\n        else{\n\n            if(n<0)\n             return val*(1/x);\n\n            return val*x;\n        }\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    double myPow(double x, int n) {\n\n        if(n==0 || x==1)\n         return 1;\n\n        double val= myPow(x,n/2);\n        val*=val;\n\n        if(n%2==0)\n         return val;\n\n        else{\n\n            if(n<0)\n             return val*(1/x);\n\n            return val*x;\n        }\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "double pow = 1;\nwhile(n != 0){\n if((n & 1) != 0) // equivalent to if((n % 2) != 0) i.e. multiply only when the number is odd  \n pow *= x;\n\n x *= x;\n n >>>= 1; // equivalent to n = n / 2; i.e. keep dividing the number by 2\n\n}"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n < 0:\n            x = 1/x\n            n = abs(n)\n            \n        ans = 1\n        while n:\n            if n & 1:\n                ans *= x\n            x *= x\n            n //= 2\n        return ans"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        return pow(x,n)"
            }
        ]
    },
    "50": {
        "question_id": 51,
        "title": "N-Queens",
        "difficulty": 3,
        "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively. ",
        "examples": [
            {
                "input": "n = 4",
                "output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]",
                "explanation": "There exist two distinct solutions to the 4-queens puzzle as shown above"
            },
            {
                "input": "n = 1",
                "output": "[[\"Q\"]]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= n <= 9"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void solve(int col, int n, vector<vector<string>> &ans, vector<string> &board, vector<int> &leftRow, vector<int> &lowDiagonal, vector<int> &upDiagonal) {\n    if(col == n) {\n        ans.push_back(board);\n        return;\n    }\n    for(int row=0; row<n; row++){\n        if(leftRow[row]==0 && lowDiagonal[row+col]==0 && upDiagonal[n-1-row+col]==0){\n            board[row][col] = 'Q';\n            leftRow[row] = 1;\n            lowDiagonal[row+col] = 1; \n            upDiagonal[n-1-row+col] = 1;\n            solve(col+1, n, ans, board, leftRow, lowDiagonal, upDiagonal);\n            board[row][col] = '.';\n            leftRow[row] = 0;\n            lowDiagonal[row+col] = 0; \n            upDiagonal[n-1-row+col] = 0;\n        }\n    }\n}\n    vector<vector<string>> solveNQueens(int n) {\n        vector<vector<string>> ans;\n    vector<string> board(n);\n    string s = \"\";\n    for(int i=0; i<n; i++){\n        s.push_back('.');\n    }\n    for(int i=0; i<n; i++){\n        board[i] = s;\n    }\n    vector<int> leftRow(n, 0);\n    vector<int> lowDiagonal(2*n - 1, 0);\n    vector<int> upDiagonal(2*n - 1, 0);\n\n    solve(0, n, ans, board, leftRow, lowDiagonal, upDiagonal);\n    return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool valid(int row,int col,vector<string> arr)\n    {\n        int n = arr.size();\n        for(int i=0;i<n;i++){\n            if(arr[row][i]!='.'){\n                return false;\n            }\n        }\n        for(int i=0;i<n;i++){\n            if(arr[i][col]!='.'){\n                return false;\n            }\n        }\n\n        int i=row;\n        int j=col;\n        while(i>=0 && j>=0)\n        {\n            if(arr[i][j]!='.'){\n                return false;\n            }\n            i--;\n            j--;\n        }\n        i=row;\n        j=col;\n        while(i>=0 && j<n)\n        {\n            if(arr[i][j]!='.'){\n                return false;\n            }\n            i--;\n            j++;\n        }\n\n        return true;\n    }\n    void dfs(int index,int count,int n,vector<string> arr,vector<vector<string>> &ans)\n    {\n        if(count==n)\n        {\n            ans.push_back(arr);\n            return;\n        }\n        if(index>=n)\n        {\n            return;\n        }\n\n        for(int i=0;i<n;i++){\n            if(valid(index,i,arr))\n            {\n                arr[index][i] = 'Q';\n                dfs(index+1,count+1,n,arr,ans);\n                arr[index][i] = '.';\n            }\n        }\n    }\n    vector<vector<string>> solveNQueens(int n) {\n        vector<string> arr;\n        string curr;\n        vector<vector<string>> ans;\n        for(int i=0;i<n;i++){\n            curr+='.';\n        }\n        for(int i=0;i<n;i++){\n            arr.push_back(curr);\n        }\n\n        dfs(0,0,n,arr,ans);\n\n        return ans;\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<String>> solveNQueens(int n) {\n        //creating a empty chessboard\n        char[][]board=new char[n][n];\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                board[i][j]='.';\n            }\n        }\n\n        List<List<String>>ans=new ArrayList<>();\n        int leftrow[]=new int[n];\n        int upperDiagonal[]=new int[2*n-1];\n        int lowerDiagonal[]=new int[2*n-1];\n        solve(0,ans,board,leftrow,upperDiagonal,lowerDiagonal);\n        return ans;\n\n    }\n    public void solve(int col,List<List<String>>ans,char[][]board,int leftrow[],int upperDiagonal[],int lowerDiagonal[]){\n        //Add the constructed list in a list of list.\n        if(col==board.length){\n            ans.add(construct(board));\n            return;\n        }\n        for(int row=0;row<board.length;row++){\n            if(leftrow[row]==0 && upperDiagonal[board.length-1+col-row]==0 && lowerDiagonal[row+col]==0){\n                //put the queen\n                board[row][col]='Q';\n                leftrow[row]=1;\n                upperDiagonal[board.length-1+col-row]=1;\n                lowerDiagonal[row+col]=1;\n\n                //call the recursion \n                solve(col+1,ans,board,leftrow,upperDiagonal,lowerDiagonal);\n\n                //backtracking part\n                board[row][col]='.';\n                leftrow[row]=0;\n                upperDiagonal[board.length-1+col-row]=0;\n                lowerDiagonal[row+col]=0;\n            }\n        }\n    }\n    //construct the string from every row and add them in a list;\n    public List<String> construct(char [][] board){\n        List<String>cur=new ArrayList<>();\n        for(int i=0;i<board.length;i++){\n            String str=new String(board[i]);\n            cur.add(str);\n        }\n        return cur;\n}\n}"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        output = []\n\n        #intialize the board\n        board = [['.']*n for i in range(n)]\n\n        #create a hash map of column, row , diagonal left and right in order to see if the queens can attack each other.\n        queenColumn = {}\n        queenRow = {}\n        queenDiagonalLeft = {}\n        queenDiagonalRight = {}\n\n        #validate the row,column and diagonal before putting a queen\n        def valid(row, col):\n            return not (row in queenRow or col in queenColumn or row + col in queenDiagonalLeft or row - col in queenDiagonalRight)\n\n        \n        def backtrack(row):\n            #base case if we finish the board we have found a way to put all the queens\n            if row == n:\n                newBoard = []\n                for i in range(n):\n                    newBoard.append(''.join(board[i]))\n                output.append(newBoard)\n                return\n\n            #iteratively put and backtrack the queens\n            for i in range(n):\n                if valid(row,i):\n                    queenColumn[i] = True\n                    queenRow[row] = True\n                    queenDiagonalLeft[row+i] = True\n                    queenDiagonalRight[row-i] = True\n                    board[row][i] = 'Q'\n\n                    backtrack(row+1)\n\n                    board[row][i] = '.'\n                    queenColumn.pop(i)\n                    queenRow.pop(row)\n                    queenDiagonalLeft.pop(row+i)\n                    queenDiagonalRight.pop(row-i)\n\n\n        backtrack(0)\n\n        return output"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void solve(int col,vector<string>&board , vector<vector<string>>&ans,\n    vector<int>leftRow,vector<int>&upperDiagonal,vector<int>&lowerDiagonal,int n){\n        if(col==n){\n            ans.push_back(board);\n            return;\n        }\n        for(int row =0 ; row<n ; row++){\n           if(leftRow[row]==0 && lowerDiagonal[row+col]==0 && upperDiagonal[n-1+col-row]==0){\n               board[row][col]='Q';\n               leftRow[row]=1;\n               lowerDiagonal[row+col]=1;\n               upperDiagonal[n-1+col-row]=1;\n               solve(col+1,board,ans,leftRow,upperDiagonal,lowerDiagonal,n);\n               board[row][col]='.';\n               leftRow[row]=0;\n               lowerDiagonal[row+col]=0;\n               upperDiagonal[n-1+col-row]=0;\n\n           }\n        }\n    }\n\n    vector<vector<string>> solveNQueens(int n) {\n        vector<vector<string>> ans;\n        vector<string>board(n);\n        string s(n,'.');\n        for(int i =0 ; i< n; i++){\n            board[i]=s;\n        }\n        vector<int> leftRow(n,0);\n        vector<int>upperDiagonal(2*n-1,0);\n        vector<int>lowerDiagonal(2*n-1,0);\n        solve(0,board,ans,leftRow,upperDiagonal,lowerDiagonal,n);\n        return ans;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    \n    private boolean isValid(int[][] grid, int x, int y) {\n        //check row\n        for(int i=0; i<grid.length; i++) {\n            if(grid[x][i] == 1) return false;\n        }\n        \n        //check column\n        for(int i=0; i<grid.length; i++) {\n            if(grid[i][y] == 1) return false;\n        }\n        \n        //check left diagnol \\\n        for(int i=0; i<grid.length; i++) {\n            if(x+i < grid.length && y+i<grid.length) {\n                if(grid[x+i][y+i] == 1) return false;\n            }\n        }\n        for(int i=0; i<grid.length; i++) {\n            if(x-i >= 0 && y-i>= 0) {\n                if(grid[x-i][y-i] == 1) return false;\n            }\n        }\n        \n        //check right diagnol /\n        for(int i=0; i<grid.length; i++) {\n            if(x+i < grid.length && y-i>=0) {\n                if(grid[x+i][y-i] == 1) return false;\n            }\n        }\n        for(int i=0; i<grid.length; i++) {\n            if(x-i >=0 && y+i < grid.length) {\n                if(grid[x-i][y+i] == 1) return false;\n            }\n        }\n        return true;\n    }\n    \n    private List<String> parseMatrix(int[][] grid) {\n        List<String> res = new ArrayList();\n        \n        for(int i=0; i<grid.length; i++) {\n            StringBuilder sb = new StringBuilder();\n            for(int j=0; j<grid.length; j++) {\n                if(grid[i][j] == 1) {\n                    sb.append(\"Q\");\n                } else {\n                    sb.append(\".\");\n                }\n            }\n            res.add(sb.toString());\n        }\n        \n        return res;\n    }\n    \n    \n    private void backtrack(int[][] grid, int x, int y, int qCount, int n, List<List<String>> res) {\n        if(qCount == n) {\n            List<String> combination = parseMatrix(grid);\n            res.add(combination);\n            return;\n        }\n        \n        if(x >= n) {\n            return;\n        }\n        \n        int newX = -1;\n        int newY = -1;\n        \n        if(y == n-1) {\n            newX = x+1;\n            newY = 0;\n        } else {\n            newX = x;\n            newY = y+1;\n        }\n        \n        \n        if(isValid(grid, x, y)) {\n            grid[x][y] = 1;\n            backtrack(grid, newX, newY, qCount+1, n, res);\n            grid[x][y] = 0;\n        }\n        backtrack(grid, newX, newY, qCount, n, res);\n        \n    }\n    public List<List<String>> solveNQueens(int n) {\n        int[][] grid = new int[n][n];\n        List<List<String>> res = new ArrayList();\n        backtrack(grid, 0, 0, 0, n, res);\n        return res;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool check(int i,int j,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl){\n        if(r[i]||c[j]||lr[i-j+n]||rl[i+j]){\n            return false;\n        }\n        return true;\n    }\n    void solve(int i,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl,vector<vector<string>> &ans,vector<string> &tmp){\n        if(i==n){\n            ans.push_back(tmp);\n            return;\n        }\n        for(int j = 0; j < n; j++){\n            if(check(i,j,n,r,c,lr,rl)){\n                string str(n,'.');\n                str[j] = 'Q';\n                tmp.push_back(str);\n                r[i] = true;\n                c[j] = true;\n                rl[i+j] = true;\n                lr[i-j+n] = true;\n                solve(i+1,n,r,c,lr,rl,ans,tmp);\n                r[i] = false;\n                c[j] = false;\n                rl[i+j] = false;\n                lr[i-j+n] = false;\n                tmp.pop_back();\n            }\n        }\n    }\n    vector<vector<string>> solveNQueens(int n) {\n        vector<bool> r(n,false);\n        vector<bool> c(n,false);\n        vector<bool> lr(2*n,false);\n        vector<bool> rl(2*n,false);\n        vector<vector<string>> ans;\n        vector<string> v;\n        solve(0,n,r,c,lr,rl,ans,v);\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N!), Where N is the size of chess board. For the first row, we check N columns; for the\n    second row, we check the N - 1 column and so on. Hence, the time complexity will be N * (N-1) * (N-2) \u2026. i.e.\n    O(N!).\n    \n    Space Complexity : O(N^2), Vector of string(nQueens) space. Extra space is allocated for the vector of vector\n    string(output), however the output does not count towards the space complexity.\n\n    Solved using Array + Backtracking.\n\n*/\n\nclass Solution {\nprivate: \n    bool isSafePlace(int n, vector<string>& nQueens, int row, int col){\n        for(int i=0; i<n; i++){\n            if(nQueens[i][col] == 'Q'){\n                return false;\n            }\n        }\n        for(int i=row-1, j=col-1; i>=0 && j>=0; i--, j--){\n            if(nQueens[i][j] == 'Q'){\n                return false;\n            }\n        }\n        for(int i=row-1, j=col+1; i>=0 && j<n; i--, j++){\n            if(nQueens[i][j] == 'Q'){\n                return false;\n            }\n        }\n        return true;\n    }\n    void solveNQueens(int n, vector<vector<string>>& output, vector<string>& nQueens, int row){\n        if(row == n){\n            output.push_back(nQueens);\n            return;\n        }\n        for(int col=0; col<n; col++){\n            if(isSafePlace(n, nQueens, row, col)){\n                nQueens[row][col] = 'Q';\n                solveNQueens(n, output, nQueens, row+1);\n                nQueens[row][col] = '.';\n            }\n        }\n    }\npublic:\n    vector<vector<string>> solveNQueens(int n) {\n        vector<vector<string>> output;\n        vector<string> nQueens(n , string(n, '.'));\n        solveNQueens(n, output, nQueens, 0);\n        return output;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "    for (int i = x, j = y; i >= 0 && j >= 0; i--, j--)\n    {\n        if (maze[i][j] == 'Q')\n        {\n            return false;\n        }\n    }\n    for (int i = x, j = y; i >= 0 && j < size; i--, j++)\n    {\n        if (maze[i][j] == 'Q')\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid queen(vector<vector<string>> &hold, vector<string> &hold1, int m, int size)\n{\n    if (m >= size)\n    {\n        hold.push_back(hold1);\n    }\n\n    for (int i = 0; i < size; i++)\n    {\n        if (safe(hold1, m, i, size))\n        {\n            hold1[m][i] = 'Q';\n            queen(hold, hold1, m + 1, size);\n            hold1[m][i] = '.';\n        }\n    }\n}\n\nvector<vector<string>> solveNQueens(int n)\n{\n    vector<vector<string>> hold;\n    vector<string> hold1;\n\n    for (int i = 0; i < n; i++)\n    {\n        string str = \"\";\n        for (int j = 0; j < n; j++)\n        {\n            str += \".\";\n        }\n        hold1.push_back(str);\n    }\n\n    queen(hold, hold1, 0, n);\n    return hold;\n}"
            },
            {
                "language": "kotlin",
                "code": " vector<vector<string>> ans;\n    vector<vector<string>> solveNQueens(int n) {\n        if(n==1) return{{\"Q\"}};\n        \n        string s(n,'.');\n        vector<string> v(n,s);\n        \n        \n        fun(0,n,v);\n        return  ans;  \n    }\n    void fun(int col,int n,vector<string> &v)\n    {\n        if(col==n) {\n            ans.push_back(v);\n            return;\n        }\n        for(int r=0;r<n;r++)\n            if(okTogo(r,col,n,v))\n            {\n                v[r][col]='Q';\n                fun(col+1,n,v);\n                v[r][col]='.';\n            }\n    }\n\n    bool okTogo(int r,int c,int n,vector<string> &v)\n    {\n        int row =r,col =c;\n        \n        //digonal check uppr left\n        while(r>=0 && c>=0)\n        {\n            if(v[r][c]=='Q') return false;\n            r--;c--;\n        }\n        // lower left diagonal\n        r=row;c=col;\n        while(r<n && c>=0)\n        {\n            if(v[r][c]=='Q') return false;\n            r++;c--;\n        }\n        \n         //check horizontal left side\n        while(col>=0)\n        {\n            if(v[row][col]=='Q') return false;\n            col--;\n        }\n        return true;\n    }\n........................\n    vector<vector<string>> ans;\n    vector<vector<string>> solveNQueens(int n) {\n        if(n==1) return{{\"Q\"}};\n        \n        string s(n,'.');\n        vector<string> v(n,s);\n        \n        //col_wize fill ->optimize map\n        vector<int> RowChk(n,0),\n                    lorDiag((2*n)-1,0),\n                    uprDiag((2*n)-1,0);\n\n        fun(0,n,v,RowChk,lorDiag,uprDiag);\n        return  ans;  \n    }\n    void fun(int col,int n,vector<string> &v,vector<int> &RowChk,vector<int>  &lorDiag,vector<int> &uprDiag){\n\n    if(col==n) {\n       ans.push_back(v); \n       return;\n    }\n    for(int r=0;r<n;r++) //upr -> n-1-r+col\n       if(RowChk[r]==0 && lorDiag[r+col]==0 && uprDiag[n-1+col-r]==0)     \n            {\n                v[r][col]='Q';\n                RowChk[r]=1;\n                lorDiag[r+col]=1;\n                uprDiag[n-1+col-r]=1; \n                //next pos\n                fun(col+1,n,v,RowChk,lorDiag,uprDiag);\n                //backtrack\n                v[r][col]='.';\n                RowChk[r]=0;\n                lorDiag[r+col]=0;\n                uprDiag[n-1+col-r]=0; \n            }\n    }"
            }
        ]
    },
    "51": {
        "question_id": 52,
        "title": "N-Queens II",
        "difficulty": 3,
        "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.Given an integer n, return the number of distinct solutions to the n-queens puzzle. ",
        "examples": [
            {
                "input": "n = 4",
                "output": "2",
                "explanation": "There are two distinct solutions to the 4-queens puzzle as shown."
            },
            {
                "input": "n = 1",
                "output": "1",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= n <= 9"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int totalNQueens(int n) {\n vector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\n return solve(col, diag, anti_diag, 0);\n}\n   \nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\n int n = size(col), count = 0;\n    if(row == n) return 1;\n for(int column = 0; column < n; column++)           \n  if(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){ \n   col[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;\n   count += solve(col, diag, anti_diag, row + 1); \n   col[column] = diag[row + column] = anti_diag[row - column + n - 1] = false; \n  }                                \n return count;\n}\n};"
            },
            {
                "language": "",
                "code": "N-Quuens I"
            },
            {
                "language": "",
                "code": "N-Quuens II"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    int ans = 0;\n    void dfs(int col, vector<int>&left, vector<int>&updig, vector<int>&lowdig, int n){\n        if(col == n){\n            ans++;\n            return;\n        }"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        res,col,pos,neg=0,set(),set(),set()\n        def backtracking(r):\n            if n==r:\n                nonlocal res\n                res+=1\n            for c in range(n):\n                if c in col or (c+r) in pos or (r-c) in neg:\n                    continue\n                col.add(c)\n                pos.add(c+r)\n                neg.add(r-c)\n                backtracking(r+1)\n                col.remove(c)\n                pos.remove(c+r)\n                neg.remove(r-c)\n        backtracking(0)\n        return res\n    #please upvote me it would encourage me alot"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool check(int i,int j,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl){\n        if(r[i]||c[j]||lr[i-j+n]||rl[i+j]){\n            return false;\n        }\n        return true;\n    }\n    void solve(int i,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl,vector<vector<string>> &ans,vector<string> &tmp){\n        if(i==n){\n            ans.push_back(tmp);\n            return;\n        }\n        for(int j = 0; j < n; j++){\n            if(check(i,j,n,r,c,lr,rl)){\n                string str(n,'.');\n                str[j] = 'Q';\n                tmp.push_back(str);\n                r[i] = true;\n                c[j] = true;\n                rl[i+j] = true;\n                lr[i-j+n] = true;\n                solve(i+1,n,r,c,lr,rl,ans,tmp);\n                r[i] = false;\n                c[j] = false;\n                rl[i+j] = false;\n                lr[i-j+n] = false;\n                tmp.pop_back();\n            }\n        }\n    }\n    vector<vector<string>> solveNQueens(int n) {\n        vector<bool> r(n,false);\n        vector<bool> c(n,false);\n        vector<bool> lr(2*n,false);\n        vector<bool> rl(2*n,false);\n        vector<vector<string>> ans;\n        vector<string> v;\n        solve(0,n,r,c,lr,rl,ans,v);\n        return ans;\n    }\n    int totalNQueens(int n) {\n        return solveNQueens(n).size();\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        ans=0\n        left,upleft,lowleft=[0]*n,[0]*(2*n-1),[0]*(2*n-1)\n        def solve(col,board):\n            nonlocal ans\n            if col==n:\n                ans+=1\n                return \n            for row in range(n):\n                if not left[row] and not upleft[row+col] and not lowleft[n-1+row-col]:\n                    board[row][col]=\"Q\"\n                    left[row],upleft[row+col],lowleft[n-1+row-col]=1,1,1\n                    solve(col+1,board)\n                    board[row][col]=\".\"\n                    left[row],upleft[row+col],lowleft[n-1+row-col]=0,0,0\n        board=[[\".\" for i in range(n)] for _ in range(n)]\n        solve(0,board)\n        return ans"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isSafe(int row , int col , vector<vector<int>> &board , int n){\n    //check for same row\n    int x = row;\n    int y = col;\n    \n    while(y >= 0){\n        if(board[x][y] == 1)\n            return false;\n        y--;\n    }\n    \n    //no need to check for columns as we are adding one queen in one column\n    \n    //check for diagonals\n    //check for North West(NW) diagonal\n    x = row;\n    y = col;\n    \n    while(x>=0 && y >= 0){\n        if(board[x][y] == 1)\n            return false;\n        y--;\n        x--;\n    }\n    \n    //check for SW diagonal\n    x = row;\n    y = col;\n    \n    while(x<n && y >= 0){\n        if(board[x][y] == 1)\n            return false;\n        y--;\n        x++;\n    }\n    //no need to check for NE and SE diagonals as queen hasn't been added to the right.\n    return true;\n}\n\n    void solve(int col , vector<vector<int>> &ans , vector<vector<int>> &board , int n , int &count){\n    //base case\n    if(col == n){\n        count++;\n        return ;\n    }\n    \n    //solve for 1 column, rest recursion will take care\n    for(int row = 0 ; row < n ; row++){\n        if(isSafe(row,col,board,n)){\n            board[row][col] = 1;\n            solve(col+1 , ans , board , n , count);\n            //backtrack\n            board[row][col] = 0;\n        }\n    }\n}\n\n    int totalNQueens(int n) {\n        vector<vector<int>> board(n , vector<int>(n,0));\n        vector<vector<int>> ans;\n        int count = 0;\n        \n        solve(0 , ans , board , n , count);\n        return count;\n    }\n};"
            },
            {
                "language": "javascript",
                "code": "const verif = (M, row, col) => {\n    // checking the vertical row until the we are now (j).\n    for (let i = row - 1; i >= 0; i--) {\n        // if already there's a queen\n        if (M[i][col]) {\n            return false;\n        }\n    }\n\n    // checking the left diagonal\n    let j = col;\n    let i = row;\n    while (j >= 0 && i >= 0) {\n        if (M[i][j]) {\n            // already there's a queen there\n            return false;\n        } else {\n            i--;\n            j--;\n        }\n    }\n\n    // checking the right diagonal\n    j = col;\n    i = row;\n    while (j <= M.length - 1 && i >= 0) {\n        if (M[i][j]) {\n            // already there's a queen there\n            return false;\n        } else {\n            i--;\n            j++;\n        }\n    }\n\n    return true;\n};\n\n\n\n\n\nfunction totalNQueens(n) {\n    function queens(M, i, j) {\n    // i is the row and j is col\n    if (i === M.length) {\n        // we're out of the matrix => kemmelna\n        count++;        // adding to the count\n    } else {\n        for (let j = 0; j < M.length; j++) {\n            if (!M[i][j]) {\n                if (verif(M, i, j)) {\n                    // can we put the queen in M[i,j] or not.\n                    M[i][j] = true; // putting the queen\n                    queens(M,i + 1, j);\n                    M[i][j] = false; // this is the backtracking\n                }\n            }\n        }\n    }\n}\n    \n\n    let M = [];\n    for (let i = 0; i < n; i++) {\n        M[i] = [];\n        for (let j = 0; j < n; j++) {\n            M[i][j] = false;\n        }\n    }\n    let count = 0;\n    \n    queens(M,0,0);\n    return count ;\n};"
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar totalNQueens = function(n) {\n    const cols = new Set();\n    const posDiag = new Set();\n    const negDiag = new Set();\n    let solutionCount = 0;\n    \n    function computePositionForRow(row) {\n        if (row === n) {\n            solutionCount += 1;\n            return;\n        }\n        \n        for (let col = 0; col < n; col += 1) {\n            if (cols.has(col) || posDiag.has(row + col) || negDiag.has(row - col)) {\n                continue;\n            }\n            \n            cols.add(col);\n            posDiag.add(row + col);\n            negDiag.add(row - col);\n            \n            computePositionForRow(row + 1);\n            \n            cols.delete(col);\n            posDiag.delete(row + col);\n            negDiag.delete(row - col);\n        }\n    }\n    \n    computePositionForRow(0);\n    \n    return solutionCount;\n};"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        rows = [0 for _ in range(n)]\n        ldiags = [0 for _ in range(2 * n + 1)]\n        rdiags = [0 for _ in range(2 * n + 1)]\n        total = 0\n\n        def backtrack(i, j_range=None):\n            nonlocal rows\n            nonlocal ldiags\n            nonlocal rdiags\n            nonlocal total\n\n            for j in range(*j_range) if j_range else range(n):\n                if not (\n                    rows[j] or rdiags[(r := i + j)] or ldiags[(l := i - j + n - 1)]\n                ):\n                    if i + 1 == n:\n                        total += 1\n                    else:\n                        rows[j] = 1\n                        ldiags[l] = 1\n                        rdiags[r] = 1\n                        backtrack(i + 1)\n                        rows[j] = 0\n                        ldiags[l] = 0\n                        rdiags[r] = 0\n\n        backtrack(0, (0, n // 2))\n        total *= 2\n        if n % 2:\n            backtrack(0, (n // 2, n // 2 + 1))\n\n        return total"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def IsSafe(self,row,column,n,board):\n        for i in range(column):\n            if board[row][i] == \"Q\":\n                return False\n        i,j = row,column\n        while(i>=0 and j>=0):\n            if(board[i][j] == \"Q\"):\n                return False\n            i -= 1\n            j -= 1\n        i,j = row,column\n        while(i<n and j>=0):\n            if(board[i][j] == \"Q\"):\n                return False\n            i += 1\n            j -= 1\n        return True\n    def solveQueens(self,column,n,board,result):\n        if column == n:\n            result.append([\"\".join(i) for i in board])\n            return\n        for row in range(n):\n            if(self.IsSafe(row,column,n,board)):\n                board[row][column] = \"Q\"\n                self.solveQueens(column+1,n,board,result)\n                board[row][column] = \".\"\n        return\n    def totalNQueens(self, n: int) -> int:\n        board = [[\".\" for i in range(n)] for i in range(n)]\n        result = []\n        self.solveQueens(0,n,board,result)\n        return len(result)"
            }
        ]
    },
    "52": {
        "question_id": 53,
        "title": "Maximum Subarray",
        "difficulty": 2,
        "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum. ",
        "examples": [
            {
                "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
                "output": "6",
                "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
            },
            {
                "input": "nums = [1]",
                "output": "1",
                "explanation": "The subarray [1] has the largest sum 1."
            },
            {
                "input": "nums = [5,4,-1,7,8]",
                "output": "23",
                "explanation": "The subarray [5,4,-1,7,8] has the largest sum 23."
            }
        ],
        "constraints": [
            "1 <= nums.length <= 105",
            "-104 <= nums[i] <= 104"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int n = size(nums), ans = INT_MIN;\n        for(int i = 0; i < n; i++) \n            for(int j = i, curSum = 0; j < n ; j++) \n                curSum += nums[j],\n                ans = max(ans, curSum);        \n        return ans;\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxSubArray(self, nums):\n        ans = -inf\n        for i in range(len(nums)):\n            cur_sum = 0\n            for j in range(i, len(nums)):\n                cur_sum += nums[j]\n                ans = max(ans, cur_sum)\n        return ans"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {    \n        return solve(nums, 0, false);\n    }\n    int solve(vector<int>& A, int i, bool mustPick) {\n  // our subarray must contain atleast 1 element. If mustPick is false at end means no element is picked and this is not valid case\n        if(i >= size(A)) return mustPick ? 0 : -1e5;       \n        if(mustPick)\n            return max(0, A[i] + solve(A, i+1, true));                  // either stop here or choose current element and recurse\n        return max(solve(A, i+1, false), A[i] + solve(A, i+1, true));   // try both choosing current element or not choosing\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxSubArray(self, nums):\n        def solve(i, must_pick):\n            if i >= len(nums): return 0 if must_pick else -inf\n            return max(nums[i] + solve(i+1, True), 0 if must_pick else solve(i+1, False))\n        return solve(0, False)"
            },
            {
                "language": "erlang",
                "code": "                                                f(0, False)                       \ud83d\udd3d => repeated calculations\n                               /             \\ \n                                f(1, False)              f(1, True)\n                         /          \\       \ud83d\udd3d          \\      \ud83d\udd3d\n                    f(2, False)      f(2, True)           f(2, True)\n       /            \\  \ud83d\udd3d       \\   \ud83d\udd3d           \\  \ud83d\udd3d\n      f(3, False)   f(3,True)     f(3, True)           f(3, True)\n      /        \\            \\           \\                  \\\n          ...        ...          ...         ...                ..."
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {    \n        vector<vector<int>> dp(2, vector<int>(size(nums), -1));\n        return solve(nums, 0, false, dp);\n    }\n    int solve(vector<int>& A, int i, bool mustPick, vector<vector<int>>& dp) {\n        if(i >= size(A)) return mustPick ? 0 : -1e5;\n        if(dp[mustPick][i] != -1) return dp[mustPick][i];\n        if(mustPick)\n            return dp[mustPick][i] = max(0, A[i] + solve(A, i+1, true, dp));\n        return dp[mustPick][i] = max(solve(A, i+1, false, dp), A[i] + solve(A, i+1, true, dp));\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxSubArray(self, nums):\n        @cache\n        def solve(i, must_pick):\n            if i >= len(nums): return 0 if must_pick else -inf\n            return max(nums[i] + solve(i+1, True), 0 if must_pick else solve(i+1, False))\n        return solve(0, False)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        vector<vector<int>> dp(2, vector<int>(size(nums)));\n        dp[0][0] = dp[1][0] = nums[0];\n        for(int i = 1; i < size(nums); i++) {\n            dp[1][i] = max(nums[i], nums[i] + dp[1][i-1]);\n            dp[0][i] = max(dp[0][i-1], dp[1][i]);\n        }\n        return dp[0].back();\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxSubArray(self, nums):\n        dp = [[0]*len(nums) for i in range(2)]\n        dp[0][0], dp[1][0] = nums[0], nums[0]\n        for i in range(1, len(nums)):\n            dp[1][i] = max(nums[i], nums[i] + dp[1][i-1])\n            dp[0][i] = max(dp[0][i-1], dp[1][i])\n        return dp[0][-1]"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        vector<int> dp(nums);\n        for(int i = 1; i < size(nums); i++) \n            dp[i] = max(nums[i], nums[i] + dp[i-1]);        \n        return *max_element(begin(dp), end(dp));\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxSubArray(self, nums):\n        dp = [*nums]\n        for i in range(1, len(nums)):\n            dp[i] = max(nums[i], nums[i] + dp[i-1])\n        return max(dp)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int curMax = 0, maxTillNow = INT_MIN;\n        for(auto c : nums)\n            curMax = max(c, curMax + c),\n            maxTillNow = max(maxTillNow, curMax);\n        return maxTillNow;\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxSubArray(self, nums):\n        cur_max, max_till_now = 0, -inf\n        for c in nums:\n            cur_max = max(c, cur_max + c)\n            max_till_now = max(max_till_now, cur_max)\n        return max_till_now"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        return maxSubArray(nums, 0, size(nums)-1);\n    }\n    int maxSubArray(vector<int>& A, int L, int R){\n        if(L > R) return INT_MIN;\n        int mid = (L + R) / 2, leftSum = 0, rightSum = 0;\n        // leftSum = max subarray sum in [L, mid-1] and starting from mid-1\n        for(int i = mid-1, curSum = 0; i >= L; i--)\n            curSum += A[i],\n            leftSum=max(leftSum, curSum);\n        // rightSum = max subarray sum in [mid+1, R] and starting from mid+1\n        for(int i = mid+1, curSum = 0; i <= R; i++)\n            curSum += A[i],\n            rightSum = max(rightSum, curSum);        \n  // return max of 3 cases \n        return max({ maxSubArray(A, L, mid-1), maxSubArray(A, mid+1, R), leftSum + A[mid] + rightSum });\n    } \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxSubArray(self, nums):\n        def maxSubArray(A, L, R):\n            if L > R: return -inf\n            mid, left_sum, right_sum, cur_sum = (L + R) // 2, 0, 0, 0\n            for i in range(mid-1, L-1, -1):\n                left_sum = max(left_sum, cur_sum := cur_sum + A[i])\n            cur_sum = 0\n            for i in range(mid+1, R+1):\n                right_sum = max(right_sum, cur_sum := cur_sum + A[i])\n            return max(maxSubArray(A, L, mid-1), maxSubArray(A, mid+1, R), left_sum + A[mid] + right_sum)\n        return maxSubArray(nums, 0, len(nums)-1)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> pre, suf;\n    int maxSubArray(vector<int>& nums) {\n        pre = suf = nums;\n        for(int i = 1; i < size(nums); i++)  pre[i] += max(0, pre[i-1]);\n        for(int i = size(nums)-2; ~i; i--)   suf[i] += max(0, suf[i+1]);\n        return maxSubArray(nums, 0, size(nums)-1);\n    }\n    int maxSubArray(vector<int>& A, int L, int R){\n        if(L == R) return A[L];\n        int mid = (L + R) / 2;\n        return max({ maxSubArray(A, L, mid), maxSubArray(A, mid+1, R), pre[mid] + suf[mid+1] });\n    } \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxSubArray(self, nums):\n        pre, suf = [*nums], [*nums]\n        for i in range(1, len(nums)):       pre[i] += max(0, pre[i-1])\n        for i in range(len(nums)-2,-1,-1):  suf[i] += max(0, suf[i+1])\n        def maxSubArray(A, L, R):\n            if L == R: return A[L]\n            mid = (L + R) // 2\n            return max(maxSubArray(A, L, mid), maxSubArray(A, mid+1, R), pre[mid] + suf[mid+1])\n        return maxSubArray(nums, 0, len(nums)-1)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n int maxSubArray(vector<int>& nums) {\n  vector<int> pre = nums;\n  for(int i = 1; i < size(nums); i++) pre[i] += max(0, pre[i-1]);\n  return *max_element(begin(pre), end(pre));\n }\n};"
            },
            {
                "language": "cpp",
                "code": "//And also print that subarray\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int n = nums.size();\n        \n        int maxi = nums[0];\n        int start = 0, end = 0; // the final start and end position of the maximum sum subarray\n<<\"] = \"<<nums[end]<<endl;"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int maxCount=INT_MIN, temp=0;"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int sum = 0 , maxi = Integer.MIN_VALUE;;\n        int i = 0 , j = 0;\n        while(j<nums.length){\n           \n            if(sum < 0 && nums[j] >= sum){\n                sum = 0;\n                i = j;\n            }\n             sum += nums[j];\n            maxi = Math.max(maxi , sum);\n            j++;\n        }\n        return maxi;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int max_so_far=0,max_ending_here=INT_MIN;\n        for(int i=0;i<nums.size();i++){\n            max_so_far +=nums[i];\n              max_ending_here=max(max_so_far,max_ending_here);\n            if(max_so_far<0)\n            max_so_far=0;\n           }\n        return max_ending_here;\n       \n    }\n};"
            },
            {
                "language": "rust",
                "code": "firstly I prepared pref sum and build seg tree then  i considered that I should find max [l, r] where sum of [l, r]\nmaximum and I considered each i as r for segment and I looked for l as minimum prefix before r - 1 inclusive and for sure I just check for maximum in each [1, r]  "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n  void build(int u, int l, int r, std::vector<std::vector<int>>& t, std::vector<int>& p) {\n    if (l == r) {\n      t[u][1] = p[l - 1];\n      t[u][2] = p[l - 1];\n      return;\n    }\n    int m = l + r >> 1, L = u << 1, R = L | 1;\n    build(L, l, m, t, p);\n    build(R, m + 1, r, t, p);\n    t[u][1] = std::max(t[L][1], t[R][1]); \n    t[u][2] = std::min(t[L][2], t[R][2]);\n  }\n\n  int get_max(int u, int ul, int ur, int l, int r, std::vector<std::vector<int>>& t) {\n    if (ul > r || ur < l) return -1e9; \n    if (l <= ul && ur <= r) return t[u][1];\n    int um = ul + ur >> 1, L = u << 1, R = L | 1;\n    return std::max(get_max(L, ul, um, l, r, t), get_max(R, um + 1, ur, l, r, t));\n  }\n\n  int get_min(int u, int ul, int ur, int l, int r, std::vector<std::vector<int>>& t) {\n    if (ul > r || ur < l) return 1e9;\n    if (l <= ul && ur <= r) return t[u][2];\n    int um = ul + ur >> 1, L = u << 1, R = L | 1;\n    return std::min(get_min(L, ul, um, l, r, t), get_min(R, um + 1, ur, l, r, t));\n  }\n\n  int maxSubArray(vector<int>& a) {\n    int n = a.size();\n    std::vector<int> p(n);\n    p[0] = a[0];\n    for (int i = 1; i < n; ++i) {\n      p[i] = p[i - 1] + a[i];\n    }\n    std::vector<vector<int>> t(n * 4, std::vector<int>(4, 0));\n    build(1, 1, n, t, p);\n    \n    int res = a[0];\n\n    for (int i = 1; i < n; ++i) {\n      int x = get_min(1, 1, n, 1, i, t);\n      res = std::max(res, p[i] - x);\n      res = std::max(res, p[i]);\n    }\n\n    return res;\n  }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int n = nums.size();\n        //maximumSum will calculate our ans and currSumSubarray will calculate maximum sum subarray till ith position \n        int maximumSum = INT_MIN, currSumSubarray = 0;\n        for (int i = 0; i < n; i++) {\n            currSumSubarray += nums[i]; \n            maximumSum = max(maximumSum, currSumSubarray);\n            //here we are taking max with 0 bcz if currSumSubarray = -1 or any negative value then it again starts with currSumSubarray = 0\n            currSumSubarray = max(currSumSubarray, 0);\n        } \n        return maximumSum;\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int n = nums.length;\n        int max = Integer.MIN_VALUE, sum = 0;\n        \n        for(int i=0;i<n;i++){\n            sum += nums[i];\n            max = Math.max(sum,max);\n            \n            if(sum<0) sum = 0;\n        }\n        \n        return max;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "//And also print that subarray\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int n = nums.size();\n        \n        int maxi = nums[0];\n        int start = 0, end = 0; // the final start and end position of the maximum sum subarray\n<<\"] = \"<<nums[end]<<endl;"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        max_sum=nums[0]\n        temp=0\n        for i in range(len(nums)):\n            if temp<0:\n                temp=0\n            temp+=nums[i]\n            if temp>max_sum:\n                max_sum=temp\n        return max_sum"
            },
            {
                "language": "swift",
                "code": "class Solution {\n    func maxSubArray(_ nums: [Int]) -> Int {\n        var sum = 0\n        return nums.reduce(into: nums[0]){sum = max($1, sum+$1); $0 = max($0, sum)}\n    }\n}"
            },
            {
                "language": "swift",
                "code": "class Solution {\n    func maxSubArray(_ nums: [Int]) -> Int {\n        \n        var (sum, ans) = (0, nums[0])\n        \n        for num in nums {\n            sum = max(num, sum + num)\n            ans = max(ans, sum)\n        }\n        \n        return ans\n    }\n}"
            },
            {
                "language": "python",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int ans = 0 , sum = 0; \n        int n = nums.size() ; \n        // checking if all element are negative then returning max of all\n        if(*max_element(nums.begin() , nums.end())<0){\n            \n            return *max_element(nums.begin() , nums.end()) ;\n        }\n\n        // if all element are not negative then aplying kadanes algorithm .\n        for(int i = 0 ; i<n ; i++){\n            sum += nums[i];\n\n            if(sum<0)\n                sum = 0;\n            ans = max(ans,sum);\n        }\n        return ans ;\n        \n        \n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        \n        int sum=0;\n        int maxi=nums[0];\n        \n        for(int i=0;i<nums.size();i++){\n\n            sum=sum+nums[i];\n            maxi=max(sum,maxi);\n            \n            if(sum<0)\n                sum=0;\n        \n        }\n        \n        return maxi;\n    }\n};"
            }
        ]
    },
    "53": {
        "question_id": 54,
        "title": "Spiral Matrix",
        "difficulty": 2,
        "description": "Given an m x n matrix, return all elements of the matrix in spiral order. ",
        "examples": [
            {
                "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
                "output": "[1,2,3,6,9,8,7,4,5]",
                "explanation": null
            },
            {
                "input": "matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]",
                "output": "[1,2,3,4,8,12,11,10,9,5,6,7]",
                "explanation": null
            }
        ],
        "constraints": [
            "m == matrix.length",
            "n == matrix[i].length",
            "1 <= m, n <= 10",
            "-100 <= matrix[i][j] <= 100"
        ],
        "solutions": [
            {
                "language": "go",
                "code": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        row = len(matrix)\n        col = len(matrix[0])\n\n        start_row = 0\n        start_col = 0\n\n        end_row = row\n        end_col = col\n\n        curr_row = 0\n        curr_col = col - 1\n\n        spiral = []\n\n        while(len(spiral) < row*col):\n            \n            #Left -> Right\n            for i in range(curr_row, end_col):\n                spiral.append(matrix[curr_row][i])\n            curr_row += 1\n            end_col -= 1\n\n            if len(spiral) == row*col:\n                break\n            \n            # Top right -> Top down\n            for i in range(curr_row, end_row):\n                spiral.append(matrix[i][curr_col])\n            curr_col -= 1\n            end_row -= 1\n\n            if len(spiral) == row*col:\n                break\n            \n            #Bottom Right -> Bottom Left\n            for i in range(curr_col, start_col-1, -1):\n                spiral.append(matrix[end_row][i])\n            start_col += 1\n\n            if len(spiral) == row*col:\n                break\n            \n            #Bottom left -> Top Left\n            for i in range(end_row-1, start_row, -1):\n                spiral.append(matrix[i][start_col-1])\n            start_row += 1\n        return spiral\n\n\n\n        "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        int top = 0 , left = 0 ;\n        int bot = matrix.size() - 1 , right = matrix[0].size()-1;\n        int n = matrix.size() , m = matrix[0].size();\n        vector<int>ans;\n        int cnt = 0 ;\n        while( ans.size() < n*m)\n        {\n            cnt++;\n            if( left <= right)\n            {\n                for(int i = left ;i<= right ;i++ )\n                {\n                    ans.push_back( matrix[top][i]);\n                }\n                top++;\n\n            }\n            if( top <= bot and ans.size() < n*m )\n            {\n                 for(int i = top ;i<=bot ;i++ )\n                {\n                    ans.push_back( matrix[i][right]);\n                }\n                right--;\n\n            }\n\n            if( right >= left and ans.size() < n*m ) \n            {\n                for(int i = right ;i>=left ;i-- )\n                {\n                    ans.push_back( matrix[bot][i]);\n\n                }\n                bot--;\n\n            }\n            if( bot >= top and ans.size() < n*m)\n            {\n                for(int i = bot ;i>= top ;i--)\n                {\n                    ans.push_back(matrix[i][left]);\n                }\n\n                left++;\n\n            }\n          \n        }\n        cout<<cnt;\n        return ans;\n\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "vector<int> ans;\n    int m=matrix[0].size();\n    int n=matrix.size();\n    int top=0;\n    int bottom=n-1;\n    int left=0;\n    int right=m-1;\n    while(left<=right&&top<=bottom&&ans.size()<n*m){"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int top=0,left=0,down=matrix.length-1,right=matrix[0].length-1;\n        List<Integer> list=new ArrayList<>();\n        int dir=0;\n        while(top<=down && left<=right){\n            if(dir==0){\n                for(int i=left;i<=right;i++){\n                    list.add(matrix[top][i]);\n                }\n                top+=1;\n            }\n            else if(dir==1){\n                for(int i=top;i<=down;i++){\n                    list.add(matrix[i][right]);\n                }\n                right-=1;\n            }\n            else if(dir==2){\n                for(int i=right;i>=left;i--){\n                    list.add(matrix[down][i]);\n                }\n                down-=1;\n            }\n            else if(dir==3){\n                for(int i=down;i>=top;i--){\n                    list.add(matrix[i][left]);\n                }\n                left+=1;\n            }\n            dir=(dir+1)%4;\n        }\n        return list;\n    }\n}"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        L=[]\n        m = len(matrix)\n        n = len(matrix[0])\n        if m == 1:\n            for j in range(n):\n                L.append(matrix[0][j])\n            return L\n        if n == 1:\n            for i in range(m):\n                L.append(matrix[i][0])\n            return L\n        r = 1\n\n        while m- 2*r >= 0 and n-2*r >=-1:\n            for j in range(-1+r,n-r):\n                L.append(matrix[r-1][j])\n            #print(L)\n            for i in range(r-1,m-r):\n                L.append(matrix[i][n-r])\n           # print(L)\n            if m == 2*r-1:\n                return L\n            for j in range(n-r,r-1,-1):\n                i = m-r\n                L.append(matrix[i][j])\n            #print(L)\n            if n == 2*r -1:\n                L.append(matrix[m-r][n-r])\n                return L\n            for i in range(m-r,r-1,-1):\n                j = r-1\n                L.append(matrix[i][j])\n            #print(L)\n            r += 1\n            #print(r)\n        if m - 2*r == -1 and n-2*r >= -1:\n            for j in range (r-1,n-r+1):\n                L.append(matrix[r-1][j])\n\n        return L\n\n\n            "
            },
            {
                "language": "java",
                "code": "class Solution {\nboolean[][] visited;\nint[] x=new int[]{0,1,0,-1};\nint[] y=new int[]{1,0,-1,0};\nint[][] matrix;\npublic List<Integer> spiralOrder(int[][] matrix) {\n    visited=new boolean[matrix.length][matrix[0].length];\n    this.matrix=matrix;\n    List<Integer> result=new LinkedList<>();\n    spiral(0,0,0,result);\n    return result;\n}\npublic void spiral(int i,int j,int c,List<Integer> result){\n    result.add(matrix[i][j]);\n    visited[i][j]=true;\n      if(checkValid(i,j,c)){\n        c++;\n        if(c>x.length-1)\n            c=0;\n    }\n    if(checkValid(i,j,c))\n        return;\n    spiral(i+x[c],j+y[c],c,result);\n}\npublic boolean checkValid(int i,int j,int c){\n    if(i+x[c]>matrix.length-1 || i+x[c]<0 || j+y[c]>matrix[0].length-1 || j+y[c]<0 || visited[i+x[c]][j+y[c]])   \n        return true;\n    return false;\n}"
            },
            {
                "language": "ruby",
                "code": "class Solution(object):\n    def spiralOrder(self, matrix):\n        result = []\n        while matrix:\n            result += matrix.pop(0) # 1\n\n            if matrix and matrix[0]: # 2 \n                for line in matrix:\n                    result.append(line.pop())\n\n            if matrix: # 3\n                result += matrix.pop()[::-1]\n\n            if matrix and matrix[0]: # 4\n                for line in matrix[::-1]:\n                    result.append(line.pop(0))\n        return result"
            },
            {
                "language": "",
                "code": "result += matrix.pop(0)"
            },
            {
                "language": "go",
                "code": "for line in matrix:\n    result.append(line.pop())"
            },
            {
                "language": "ruby",
                "code": "result += matrix.pop()[::-1]"
            },
            {
                "language": "ruby",
                "code": "for line in matrix[::-1]:\n    result.append(line.pop(0))"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        elements = []\n        while matrix:\n            elements += matrix.pop(0) ## top\n            elements += [row.pop() for row in matrix] ## right\n            if not matrix or not matrix[0]: break\n            elements += matrix.pop()[::-1] ## bottom"
            },
            {
                "language": "ruby",
                "code": "def spiralOrder(self, matrix):\n    return matrix and list(matrix.pop(0)) + self.spiralOrder(zip(*matrix)[::-1])"
            },
            {
                "language": "ruby",
                "code": "def spiralOrder(self, matrix):\n    return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])"
            },
            {
                "language": "ruby",
                "code": "def spiral_order(matrix)\n  (row = matrix.shift) ? row + spiral_order(matrix.transpose.reverse) : []\nend"
            },
            {
                "language": "ruby",
                "code": "def spiral_order(matrix)\n  matrix[0] ? matrix.shift + spiral_order(matrix.transpose.reverse) : []\nend"
            },
            {
                "language": "dart",
                "code": "    |1 2 3|      |6 9|      |8 7|      |4|  =>  |5|  =>  ||\n    |4 5 6|  =>  |5 8|  =>  |5 4|  =>  |5|\n    |7 8 9|      |4 7|"
            },
            {
                "language": "",
                "code": "    |1 2 3|      |6 9|      |8 7|      |4|      |5|"
            },
            {
                "language": "csharp",
                "code": "  spiral_order([[1, 2, 3],\n                [4, 5, 6],\n                [7, 8, 9]])\n\n= [1, 2, 3] + spiral_order([[6, 9],\n                            [5, 8],\n                            [4, 7]])\n\n= [1, 2, 3] + [6, 9] + spiral_order([[8, 7],\n                                     [5, 4]])\n\n= [1, 2, 3] + [6, 9] + [8, 7] + spiral_order([[4],\n                                              [5]])\n\n= [1, 2, 3] + [6, 9] + [8, 7] + [4] + spiral_order([[5]])\n\n= [1, 2, 3] + [6, 9] + [8, 7] + [4] + [5] + spiral_order([])\n\n= [1, 2, 3] + [6, 9] + [8, 7] + [4] + [5] + []\n\n= [1, 2, 3, 6, 9, 8, 7, 4, 5]"
            },
            {
                "language": "ruby",
                "code": "def spiralOrder(self, matrix):\n    return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        while matrix:"
            },
            {
                "language": "python",
                "code": "    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if (len(matrix) == 0):\n            return []\n        "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = m ? matrix[0].size() : 0, u = 0, d = m - 1, l = 0, r = n - 1, p = 0;\n        vector<int> order(m * n);\n        while (u <= d && l <= r) {\n            for (int col = l; col <= r; col++) {\n                order[p++] = matrix[u][col];\n            }\n            if (++u > d) {\n                break;\n            }\n            for (int row = u; row <= d; row++) {\n                order[p++] = matrix[row][r];\n            }\n            if (--r < l) {\n                break;\n            }\n            for (int col = r; col >= l; col--) {\n                order[p++] = matrix[d][col];\n            }\n            if (--d < u) {\n                break;\n            }\n            for (int row = d; row >= u; row--) {\n                order[p++] = matrix[row][l];\n            }\n            if (l++ > r) {\n                break;\n            }\n        }\n        return order;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n      vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        int row = matrix.size();\n        int col = matrix[0].size();\n\n        int count =0;\n        int total = row*col;\n        vector<int> ans;\n\n        int sRow = 0, sCol=0, eRow =row-1, eCol = col-1;\n\n        while(count<total){\n\n            for(int i=sCol; i<=eCol && count<total; i++){\n                ans.push_back(matrix[sRow][i]);\n                count++;\n            }\n            sRow++;\n\n            for(int i=sRow; i<=eRow && count<total; i++){\n                ans.push_back(matrix[i][eCol]);\n                count++;\n            }\n            eCol--;\n\n            for(int i=eCol; i>=sCol && count<total; i--){\n                ans.push_back(matrix[eRow][i]);\n                count++;\n            }\n            eRow--;\n\n            for(int i=eRow; i>=sRow && count<total; i--){\n                ans.push_back(matrix[i][sCol]);\n                count++; \n            }\n            sCol++;\n        }\n         return ans;\n      }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n    vector<int> ans;\n    if (matrix.empty()) return ans; // Check if matrix is empty\n\n    int rows = matrix.size();\n    int cols = matrix[0].size();\n\n    int left = 0, right = cols - 1, top = 0, bottom = rows - 1;\n\n    while (left <= right && top <= bottom) {\n        // Traverse right\n        for (int i = left; i <= right; i++) {\n            ans.push_back(matrix[top][i]);\n        }\n        top++;\n\n        // Traverse down\n        for (int i = top; i <= bottom; i++) {\n            ans.push_back(matrix[i][right]);\n        }\n        right--;\n\n        // Traverse left\n        if (top <= bottom) {\n            for (int i = right; i >= left; i--) {\n                ans.push_back(matrix[bottom][i]);\n            }\n            bottom--;\n        }\n\n        // Traverse up\n        if (left <= right) {\n            for (int i = bottom; i >= top; i--) {\n                ans.push_back(matrix[i][left]);\n            }\n            left++;\n        }\n    }\n\n    return ans;\n}\n\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def spiralOrder(self, x: List[List[int]]) -> List[int]:\n        \n        return x and [*x.pop(0)] + self.spiralOrder([*zip(*x)][::-1])"
            }
        ]
    },
    "54": {
        "question_id": 55,
        "title": "Jump Game",
        "difficulty": 2,
        "description": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.Return true if you can reach the last index, or false otherwise. ",
        "examples": [
            {
                "input": "nums = [2,3,1,1,4]",
                "output": "true",
                "explanation": "Jump 1 step from index 0 to 1, then 3 steps to the last index."
            },
            {
                "input": "nums = [3,2,1,0,4]",
                "output": "false",
                "explanation": "You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index."
            }
        ],
        "constraints": [
            "1 <= nums.length <= 104",
            "0 <= nums[i] <= 105"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution {\n    public boolean canJump(int[] nums) {\n        int n=nums.length,i=n-2;\n        int goal=n-1;\n        while(i>=0){\n            if(i+nums[i]>=goal){\n                goal=i;\n                i--;"
            },
            {
                "language": "ruby",
                "code": "class Solution: \n    def canJump(self, nums: List[int]) -> bool:\n        \"\"\"\n        O(n) O(1)\n        \"\"\"\n        max_pos = 0\n        for curr_pos, max_jump in enumerate(nums):"
            },
            {
                "language": "cpp",
                "code": "class Solution {"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        if nums[0] == 0 and len(nums) > 1:\n            return False\n        maxReach = nums[0]\n        j = 1\n        while j < len(nums):\n            while j < len(nums) and nums[j] != 0:\n                maxReach = max(maxReach, j + nums[j])"
            },
            {
                "language": "cpp",
                "code": "bool canJump(vector<int>& nums) {\n        int n = nums.size();\n        vector<bool>arr(n,false);\n        arr[n-1] = true;\n        // for(auto it : arr){"
            },
            {
                "language": "python",
                "code": "class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        \n      \n      int next =0;\n        for(int i=0;i<nums.size();i++){\n            \n            if(next<i)return false;\n\n            next = max(i+nums[i],next);\n            \n        }\n        return true;\n\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int n = nums.size(); // get size of input array\n        int dp[n]; // create an array to store maximum index that can be reached from each index\n        dp[0] = nums[0]; // set base case\n        for (int i = 1; i< n; i++){ // iterate over input array\n            if (dp[i - 1] < i) // if we cannot reach current index from any previous index\n                return false; // return false\n            dp[i] = max(dp[i - 1], i + nums[i]); // calculate maximum index that can be reached from current index\n        }\n        return true; // if we can reach last index, return true\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int currentnbr = nums[0];\n        if ((currentnbr == 0) && nums.size()>1) return false;\n        for (int i = 1; i <nums.size(); i++){\n            if (nums[i] == nums.size()-i-1) return true;\n            currentnbr = max(currentnbr-1, nums[i]);\n            if ((currentnbr<=0) && i!=nums.size()-1) return false;    \n        }\n        return true;\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "var canJump = function(nums) {\n    if (nums.length === 1) return true;\n    const backtracking = (current) => {\n        if (current < nums[0]) return true;\n        for (let i = 0; i < current; i++) {\n            if (nums[i] >= current - i) {\n                return backtracking(i);\n            }\n        }\n        return false;\n    }\n    return backtracking(nums.length - 1);\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int max_jump = 0;\n\n        for(int i=0;i<nums.size();i++){\n            max_jump = max(max_jump, i+nums[i]);\n            if(max_jump < i+1)\n            {\n                break;\n            }\n\n        }\n        return max_jump >= nums.size()-1; \n    }\n};"
            },
            {
                "language": "go",
                "code": "class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int close = nums.size()-1;\n        for(int i=close;i>=0;i--){\n            if(i+nums[i] >= close) close = i;\n        }\n\n        return close == 0;\n    }     "
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def dp(self,i,nums,dct):\n        if i>=len(nums):\n            return False\n        if i==len(nums)-1:\n            return True\n        if i in dct:\n            return dct[i]\n        x=False\n        for j in range(1,nums[i]+1):\n            x=x or self.dp(i+j,nums,dct)\n        dct[i]=x\n        return x\n    def canJump(self, nums: List[int]) -> bool:\n        n=len(nums)\n        tr=n-1\n        for i in range(n-2,-1,-1):\n            if i+nums[i]>=tr:\n                tr=i\n        return tr==0"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        if(nums.size()<=1)return true;\n        int maxi(nums[0]);        \n        for(int i=1;i<nums.size()-1;i++){\n            if(maxi>0)maxi--;else return false;\n            maxi=max(nums[i],maxi);\n        }\n        if(maxi<=0)return false;\n        return true;\n    }\n};"
            },
            {
                "language": "go",
                "code": "func canJump(nums []int) bool {\n reachable := 0\n for i, n := range nums {\n  if reachable < i {\n   return false\n  }\n  if i+n > reachable {\n   reachable = i + n\n  }\n }\n return true\n}"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean canJump(int[] nums) {\n        if(nums.length==1)\n        {\n            return true;\n        }\n        if(nums.length==2)\n        {\n            if(nums[0]>=1)\n            {\n                return true;\n            }\n            else{\n                return false;\n            }\n        }\n        boolean[]nearesttrue= new boolean[nums.length-1];\n        \n        int val= nums[nums.length-2];\n        int nearesttrueindex= nums.length-1;\n\n        if(val>0)\n        {\n            nearesttrue[nums.length-2]=true;\n            nearesttrueindex= nums.length-2;\n        }\n        int zz= nums.length-3;\n        for(int i= zz;i>=0;i--)\n        {\n            int temp= nums[i];\n            \n            int temp2= temp+i;\n\n            if(temp2>=nums.length-1 || temp2>=nearesttrueindex)\n            {\n                nearesttrue[i]=true;\n                nearesttrueindex= i;\n                continue;\n            }\n\n        }\n        return nearesttrue[0];\n        \n    }\n}"
            }
        ]
    },
    "55": {
        "question_id": 56,
        "title": "Merge Intervals",
        "difficulty": 2,
        "description": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. ",
        "examples": [
            {
                "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
                "output": "[[1,6],[8,10],[15,18]]",
                "explanation": "Since intervals [1,3] and [2,6] overlap, merge them into [1,6]."
            },
            {
                "input": "intervals = [[1,4],[4,5]]",
                "output": "[[1,5]]",
                "explanation": "Intervals [1,4] and [4,5] are considered overlapping."
            }
        ],
        "constraints": [
            "1 <= intervals.length <= 104",
            "intervals[i].length == 2",
            "0 <= starti <= endi <= 104"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>&ii) {\n        sort(ii.begin(),ii.end());\n        vector<vector<int>>ans;\n        int n=ii.size();\n        int a=ii[0][0];\n        int b=ii[0][1];\n        for(int i=1;i<n;i++){\n            if(ii[i][0]<=b){\n                b=max(b,ii[i][1]);\n            }\n            else{\n                ans.push_back({a,b});\n                a=ii[i][0];\n                b=ii[i][1];\n\n            }\n        }\n        ans.push_back({a,b});\n        return ans;\n        \n    }\n};"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(NlogN), Sorting the array(intervals) costs O(NlogN). Where N is the size of\n    the Vector(intervals).\n\n    Space Complexity : O(1), Constant Space. Extra space is only allocated for the Vector(output)\n    which can go upto size N , however the output does not count towards the space complexity.\n\n    Solved using Array + Sorting.\n\n*/\n\nclass Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        int n = intervals.size();\n        sort(intervals.begin(), intervals.end());\n        vector<vector<int>> output;\n        for(auto interval : intervals){\n            if(output.empty() || output.back()[1] < interval[0]){\n                output.push_back(interval);\n            }\n            else{\n                output.back()[1] = max(output.back()[1], interval[1]);\n            }\n        }\n        return output;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n       vector<vector<int>> ans;\n       vector<int> temp;\n\n       int n = intervals.size();\n\n       //we will sort the interval array because some of the cases are not sorted. Ans this will help us to perform the merge operation in O(n) TIME COMPLEXITY.\n      sort(intervals.begin(),intervals.end());\n      //if there are no elements in the array then we will just return our empty arrar;\n       if ( n == 0 )return ans;\n       \n       //here we will be storing our first element.\n       temp = intervals[0];\n\n       for(auto it : intervals)\n       {\n           // here if we will find the current vector's starting is smaller tha the previous seen non overlapped range then we will merge those array.\n           if( it[0] <= temp[1])\n           {\n               //here we are doing overlapping.\n              temp[1] = max(temp[1],it[1]);\n              temp[0] = min(temp[0],it[0]);\n\n             //we will not modify the previous overlapping yet, do not perform this operation here ( temp =  it)  as temp will already hold our overlapper range till then ;\n           }\n           else{\n               //now if we will find a range which cannot be overlapped then we will add the previously overlapped range.\n               ans.push_back(temp);\n\n               //here as we will start overlapping from the current range which is not overlapping for further ranges.\n               temp =  it;\n           }\n       }\n\n       //at last we will add the last overlapped/non-uverlapped range range\n       ans.push_back(temp);\n       return ans;\n        \n    }\n};"
            },
            {
                "language": "swift",
                "code": "class Solution {\n    func merge(_ intervals: [[Int]]) -> [[Int]] {\n        \n        let sorted = intervals.sorted { $0[0] < $1[0] }\n        var ans: [[Int]] = [sorted[0]]\n        \n        for item in sorted[1..<sorted.count] {\n            if item[0] > ans.last![1] {\n                ans.append(item)\n                \n            } else {\n                ans[ans.count-1][1] = max(item[1], ans.last![1])\n            }\n        }\n        \n        return ans\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    static bool sortcol(const vector<int>& v1, const vector<int>& v2){\n        return v1[0] < v2[0];\n    }\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), this->sortcol);\n        vector<vector<int>> mergedIntervals;\n        mergedIntervals.push_back(intervals[0]);\n        for(int i=1;i<intervals.size();i++){\n            if(mergedIntervals[mergedIntervals.size()-1][1]>=\n                intervals[i][0]){\n                    mergedIntervals[mergedIntervals.size()-1][1] = \n                    max(mergedIntervals[mergedIntervals.size()-1][1], intervals[i][1]);\n                }else{\n                    mergedIntervals.push_back(intervals[i]);\n                }\n        }\n        return mergedIntervals;\n    }\n};"
            },
            {
                "language": "rust",
                "code": "impl Solution {\n    pub fn merge(mut intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        intervals.sort_unstable_by_key(|val| val[0] );\n        let mut res = Vec::with_capacity(intervals.len());\n        let last = intervals.iter().fold((intervals[0][0], intervals[0][1]),|(l,r), curent| {\n            if curent[0] > r {\n                res.push(vec![l,r]);\n                return (curent[0], curent[1])\n            }\n            (l, r.max(curent[1]))\n        });\n        res.push(vec![last.0, last.1]);\n        res\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        vector<vector<int>> mergedIntervals;\n        sort(intervals.begin(), intervals.end());\n        int start = intervals[0][0];\n        int end = intervals[0][1];\n        for (auto interval : intervals) {\n            if (interval[0] <= end) {\n                end = max(end, interval[1]);\n            } else {\n                mergedIntervals.push_back({start, end});\n                start = interval[0];\n                end = interval[1];\n            }\n        }\n        mergedIntervals.push_back({start, end});\n        return mergedIntervals;\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public int[][] Merge(int[][] intervals) {\n        List<int[]> res=new();\n        intervals = intervals.OrderBy(i=>i[0]).ToArray();\n        int s=intervals[0][0],\n            e=intervals[0][1];\n        for(int i=1;i<intervals.Length;i++){\n            if(intervals[i][0]>e){\n                res.Add(new int[] {s,e});\n                s=intervals[i][0];\n                e=intervals[i][1];\n            }\n            else\n                e=Math.Max(e,intervals[i][1]);\n        }\n        res.Add(new int[] {s,e});\n        return res.ToArray();\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\nvector<int> ans;\nvector<vector<int>> v;\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end());\n        merger(intervals, intervals[0][0], intervals[0][1], 0, 1);\n        return v;\n    }\npublic:\n    void merger(vector<vector<int>>& intervals, int start, int end, int i, int j){\n          if(j == intervals.size() and v.size() == 0){\n              ans.push_back(start);\n              ans.push_back(end);\n              v.push_back(ans);\n          }\n          if(j >= intervals.size()){\n              return;\n          }\n          if(end >= intervals[j][0]){\n            start = min(start, intervals[j][0]);\n            end = max(end, intervals[j][1]);\n            if (j+1 == intervals.size()){\n                ans.push_back(start);\n                ans.push_back(end);\n                v.push_back(ans);\n            }\n          }\n          if(end < intervals[j][0]){\n              ans.push_back(start);\n              ans.push_back(end);\n              v.push_back(ans);\n              ans.clear();\n              start = intervals[j][0];\n              end = intervals[j][1];\n              if (j+1 == intervals.size()){\n                ans.push_back(start);\n                ans.push_back(end);\n                v.push_back(ans);\n            }\n          }\n          merger(intervals, start, end, j, j+1);\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def merge(self, intr: List[List[int]]) -> List[List[int]]:\n        i=0\n        intr.sort()\n        if len(intr)==0:\n            return []\n        elif len(intr)==1:\n            return list(intr)\n        else:\n            while i<len(intr)-1:\n                if(intr[i][1]>=intr[i+1][0] and intr[i][1]>=intr[i+1][1]):\n                    intr.append([intr[i][0],intr[i][1]])\n                    intr.remove(intr[i])\n                    intr.remove(intr[i])\n                    intr.sort()\n\n                elif(intr[i][1]>=intr[i+1][0] and intr[i][1]<intr[i+1][1]):\n                    intr.append([intr[i][0],intr[i+1][1]])\n                    intr.remove(intr[i])\n                    intr.remove(intr[i])\n                    intr.sort()\n                else:\n                    i+=1\n            return intr"
            }
        ]
    },
    "56": {
        "question_id": 57,
        "title": "Insert Interval",
        "difficulty": 2,
        "description": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).Return intervals after the insertion. ",
        "examples": [
            {
                "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
                "output": "[[1,5],[6,9]]",
                "explanation": null
            },
            {
                "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
                "output": "[[1,2],[3,10],[12,16]]",
                "explanation": "Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]."
            }
        ],
        "constraints": [
            "0 <= intervals.length <= 104",
            "intervals[i].length == 2",
            "0 <= starti <= endi <= 105",
            "intervals is sorted by starti in ascending order.",
            "newInterval.length == 2",
            "0 <= start <= end <= 105"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& inter, vector<int>& nInter) {\n        vector<int>a,b;\n        vector<vector<int>>ans;\n        for(auto &val:inter){\n            a.push_back(val[0]);\n            b.push_back(val[1]);\n        }\n[1],inter[y][1])});"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n      List<int[]> ans = new ArrayList<>();\n        int[] toAdd = newInterval;\n         for (int i = 0; i < intervals.length; i ++) {\n            if (intervals[i][0] > toAdd[1]) {\n                ans.add(toAdd);\n                toAdd = intervals[i];"
            },
            {
                "language": "cpp",
                "code": "//TIME COMPLEXITY: O(n), where n is the number of intervals in intervals\n//SPACE COMPLEXITY: O(1)\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        \n        if(intervals.size() == 0)\n        {\n\n\n\n\n[i][0]) )"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def insert(self, inter, new):\n        flag = False\n        res = []\n        for li in inter:\n            if not flag:\n                if li[0] > new[1]:\n                    res.append(new)\n                    res.append(li)\n                    flag = True\n                elif li[1] < new[0]:\n                    res.append(li)\n                elif new[0] >= li[0] and new[1] >= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif new[0] >= li[0] and new[0] <= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif li[0] >= new[0] and li[0] <= new[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n            else:\n                if res[-1][0] <= li[0] and li[0] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] >= res[-1][0] and li[1] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] <= res[-1][0] and res[-1][1] >= li[0]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                else:\n                    res.append(li)\n        if not flag: res.append(new)\n        return res"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        n=newInterval\n        j=intervals\n        i=0\n        m=n[0]\n        m1=n[1]\n        while i<len(j):\n            if n[0] in range(j[i][0],j[i][1]+1) or n[1] in range(j[i][0],j[i][1]+1) or (n[1]>=j[i][1] and n[0]<=j[i][0]):\n                if j[i][0]<m:\n                    m=j[i][0]\n                if j[i][1]>m1:\n                    m1=j[i][1]\n                j.pop(i)\n                if i<=0:\n                    i=0\n                else:\n                    i-=1\n            else:\n                i+=1\n        s1=[m,m1]\n        j.append(s1)\n        j.sort()\n        return j\n        \n\n        "
            },
            {
                "language": "csharp",
                "code": "class Solution {\n     List<List<Integer>> list=new ArrayList<>();\n     List<Integer> l=new ArrayList<>();\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        for(int i=0;i<intervals.length;i++)\n        {\n        int first=intervals[i][0];\n        int second=intervals[i][1];\n        if(newInterval[1]<first){\n            return help(newInterval,intervals,i);\n        }else if(intervals[i][1]<newInterval[0])\n        {\n            l.add(intervals[i][0]);\n            l.add(intervals[i][1]);\n            list.add(l);\n            l=new ArrayList<>();\n        }else{\n            newInterval[0]=Math.min(newInterval[0],intervals[i][0]);\n            newInterval[1]=Math.max(newInterval[1],intervals[i][1]);\n        }\n        }\n\n        return help(newInterval,intervals,intervals.length);\n\n        }\n    public int[][] help(int newInterval[],int a[][],int index)\n    {\n         l=new ArrayList<>();\n        l.add(newInterval[0]);\n        l.add(newInterval[1]);\n        list.add(l);\n       for(int i=index;i<a.length;i++)\n       {\n           l=new ArrayList<>();\n           l.add(a[i][0]);\n           l.add(a[i][1]);\n           list.add(l);\n       }\n       int res[][]=new int[list.size()][2];\n       for(int j=0;j<res.length;j++)\n       {\n           res[j][0]=list.get(j).get(0);\n           res[j][1]=list.get(j).get(1);\n       }\n       return res;\n\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "```//Do not need any new containers with this approach.\n//1. re-arrange the vector\n//2. Adjust the index when merge occrus, and pop the redundant   elements.\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        intervals.push_back(newInterval);\n        int i = intervals.size() - 1;\n        int count = 0;\n        for(; i> 0; i--)\n        {\n            if(intervals[i][1] < intervals[i-1][0])\n                swap(intervals[i], intervals[i-1]);\n            else if(intervals[i][0] > intervals[i-1][1])\n                break;\n            else\n            {\n                intervals[i-1][0] = min(intervals[i-1][0], intervals[i][0]);\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1]);\n                count++;\n            }\n        }\n        i++;\n        if(count)\n        {\n            int len = intervals.size();\n            while(i != len)\n            {\n                if(i + count < len)\n                    swap(intervals[i], intervals[i+count]);\n                else\n                    intervals.pop_back();\n                i++;\n            }\n        }\n        return intervals;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    boolean isOverlap(int[] a, int[] b) {\n        return Math.min(a[1], b[1]) - Math.max(a[0], b[0]) >= 0;\n    }\n\n    int[] merge(int[] a, int[] b) {\n        int[] newInterval = {Math.min(a[0], b[0]), Math.max(a[1], b[1])};\n        return newInterval;\n    }\n\n    int UpperBound(int[][] intervals, int[] newInterval) {\n        if (intervals.length == 0)\n            return 0;\n\n        int start = 0, end = intervals.length - 1;\n        int ans = intervals.length;\n        while (start <= end) {\n            int mid = (start + end) / 2;\n\n            if (intervals[mid][0] > newInterval[0]) {\n                ans = mid;\n                end = mid - 1;\n            }\n            else\n                start = mid + 1;\n        }\n\n        return ans;\n    }\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        List<int[]> list = new ArrayList<>(Arrays.asList(intervals));\n        int index = UpperBound(intervals, newInterval);\n\n        if (index != intervals.length)\n            list.add(index, newInterval);\n        else\n            list.add(newInterval);\n\n        intervals = list.toArray(new int[list.size()][2]);\n\n        List<int[]> answer = new ArrayList<>();\n        for (int i = 0; i < intervals.length; i++) {\n            int[] temp = {intervals[i][0], intervals[i][1]};\n            while (i < intervals.length && isOverlap(temp, intervals[i]))\n                temp = merge(temp, intervals[i++]);\n            i--;\n            answer.add(temp);\n        }\n\n        return answer.toArray(new int[answer.size()][2]);\n    }\n}"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        int i = 0;\n        while (i < intervals.length && newInterval[0] > intervals[i][1]) {\n            i++;\n        }\n        int start = i;\n\n        while (i < intervals.length && newInterval[1] >= intervals[i][0]) {\n            i++;\n        }\n\n        int end = i;\n        int curIntervalCounter = 0;\n        int[][] finalIntervals = new int[intervals.length - end + start + 1][];\n\n        for (curIntervalCounter = 0; curIntervalCounter < start; curIntervalCounter++) {\n            int[] interval = new int[2];\n            interval[0] = intervals[curIntervalCounter][0];\n            interval[1] = intervals[curIntervalCounter][1];\n            finalIntervals[curIntervalCounter] = interval;\n        }\n\n        if (start == end) {\n            int[] interval = new int[2];\n            interval[0] = newInterval[0];\n            interval[1] = newInterval[1];\n            finalIntervals[curIntervalCounter++] = interval;\n        } else {\n            int[] mergedInterval = new int[2];\n            mergedInterval[0] = Math.min(newInterval[0], intervals[start][0]);\n            mergedInterval[1] = Math.max(newInterval[1], intervals[end - 1][1]);\n            finalIntervals[curIntervalCounter++] = mergedInterval;\n        }\n\n        for (int j = end; j < intervals.length; j++) {\n            int[] interval = new int[2];\n            interval[0] = intervals[j][0];\n            interval[1] = intervals[j][1];\n            finalIntervals[curIntervalCounter++] = interval;\n        }\n\n        return finalIntervals;\n    }\n}"
            },
            {
                "language": "go",
                "code": "func binarySearch(intervals [][]int, val int) int {\n left, right := 0, len(intervals)-1\n mid := right / 2\n\n for left <= right {\n\n  if val < intervals[mid][0] {\n   right = mid - 1\n  } else if val > intervals[mid][1] {\n   left = mid + 1\n  } else {\n   return mid\n  }\n  mid = (right-left)/2 + left\n }\n\n return left\n}\n\nfunc includeIntervalValue(interval []int, val int) bool {\n return val >= interval[0] && val <= interval[1]\n}\n\nfunc minInterval(startInterval, newInterval []int) []int {\n if startInterval[0] < newInterval[0] {\n  newInterval[0] = startInterval[0]\n }\n\n return newInterval\n}\n\nfunc maxInterval(endInterval, newInterval []int) []int {\n if endInterval[1] > newInterval[1] {\n  newInterval[1] = endInterval[1]\n }\n\n return newInterval\n}\n\nfunc insert(intervals [][]int, newInterval []int) [][]int {\n var (\n  startIndex = binarySearch(intervals, newInterval[0])\n  endIndex   = binarySearch(intervals, newInterval[1])\n  result     = make([][]int, 0, startIndex+len(intervals)-endIndex+1)\n )\n result = append(result, intervals[:startIndex]...)\n\n if startIndex < len(intervals) && includeIntervalValue(intervals[startIndex], newInterval[0]) {\n  newInterval = minInterval(intervals[startIndex], newInterval)\n }\n if endIndex < len(intervals) && includeIntervalValue(intervals[endIndex], newInterval[1]) {\n  newInterval = maxInterval(intervals[endIndex], newInterval)\n }\n\n result = append(result, newInterval)\n if endIndex < len(intervals) && includeIntervalValue(intervals[endIndex], newInterval[1]) {\n  endIndex++\n }\n \n return append(result, intervals[endIndex:]...)\n}"
            },
            {
                "language": "go",
                "code": "func binarySearch(intervals [][]int, val int) int {\n var (\n  left  = 0\n  right = len(intervals) - 1\n  mid   = right / 2\n )\n\n for left <= right {\n  if val < intervals[mid][0] {\n   right = mid - 1\n  } else if val > intervals[mid][1] {\n   left = mid + 1\n  } else {\n   return mid\n  }\n\n  mid = (right-left)/2 + left\n }\n\n return left\n}\n\nfunc intervalInclude(interval []int, val int) bool {\n return interval[0] <= val && interval[1] >= val\n}\n\nfunc insert(intervals [][]int, newInterval []int) [][]int {\n var (\n  startIndex = binarySearch(intervals, newInterval[0])\n  endIndex   = binarySearch(intervals, newInterval[1])\n  result     = append(make([][]int, 0, startIndex+len(intervals)-endIndex+1), intervals[:startIndex]...)\n )\n\n if startIndex != len(intervals) && intervalInclude(intervals[startIndex], newInterval[0]) {\n  newInterval[0] = intervals[startIndex][0]\n }\n\n if endIndex != len(intervals) && intervalInclude(intervals[endIndex], newInterval[1]) {\n  newInterval[1] = intervals[endIndex][1]\n }\n\n result = append(result, newInterval)\n\n if endIndex != len(intervals) && intervalInclude(intervals[endIndex], newInterval[1]) {\n  endIndex++\n }\n\n return append(result, intervals[endIndex:]...)\n}"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def insert(self, intervals, newInterval):\n\n\n        # Checking if intervals is list empty\n        if intervals==[]:\n            intervals.append(newInterval)\n            return intervals\n\n\n        # Checking for start element of overlapping\n        def findStart(intervals,newInterval):\n            for i in range(len(intervals)):\n                if newInterval[0]<=intervals[i][1]:\n                    if newInterval[0]<=intervals[i][0]:\n                        start = newInterval[0]\n                    else:\n                        start = intervals[i][0]\n                    return start\n                elif newInterval[0]>intervals[-1][1]:\n                    start = newInterval[0]\n                    return start\n            # For some edge cases\n            if intervals[0][0]<=newInterval[0]:\n                start = intervals[0][0]\n                return start\n\n        start = findStart(intervals,newInterval)\n\n\n    # Checking for end element of overlapping\n        def findEnd(intervals,newInterval):\n            for i in range(len(intervals)):\n                if newInterval[1]<intervals[i][1]:\n                    if newInterval[1]<intervals[i][0]:\n                        end = newInterval[1]\n                    else:\n                        end = intervals[i][1]\n                    return end \n                else:\n                    end = newInterval[1]\n                    return end\n\n        end = findEnd(intervals,newInterval)\n\n        # only appending those items in the result list who are not involved in overlapping\n        res=[]\n        for i in intervals:\n            if start<=min(i)<=end or start<=max(i)<=end:\n                pass\n            else:\n                res.append(i)\n# appending our parent sublist\n        res.append([start,end])\n        res.sort()\n        return res\n            "
            }
        ]
    },
    "57": {
        "question_id": 58,
        "title": "Length of Last Word",
        "difficulty": 1,
        "description": "Given a string s consisting of words and spaces, return the length of the last word in the string.A word is a maximal substring consisting of non-space characters only. ",
        "examples": [
            {
                "input": "s = \"Hello World\"",
                "output": "5",
                "explanation": "The last word is \"World\" with length 5."
            },
            {
                "input": "s = \"   fly me   to   the moon  \"",
                "output": "4",
                "explanation": "The last word is \"moon\" with length 4."
            },
            {
                "input": "s = \"luffy is still joyboy\"",
                "output": "6",
                "explanation": "The last word is \"joyboy\" with length 6."
            }
        ],
        "constraints": [
            "1 <= s.length <= 104",
            "s consists of only English letters and spaces ' '.",
            "There will be at least one word in s."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\nint lengthOfLastWord(string s) {\n    int count = 0;\n    int i = s.length() - 1;\n    while (i >= 0 && s[i] == ' ') {\n        i--;\n    }\n    while (i >= 0 && s[i] != ' ') {\n        count++;\n        i--;\n    }\n    return count;\n\n}\n};"
            },
            {
                "language": "java",
                "code": "import java.util.StringTokenizer;\nclass Solution {//PLEASE UPVOTE\n    public int lengthOfLastWord(String s) {\n       String str[]=s.split(\" \");\n       return str[str.length-1].length();\n    }//PLEASE UPVOTE\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        int ans=0;\n        for(int i=s.length()-1;i>=0;i--){\n            if(s[i]==' ' && ans>0) return ans;\n            if(s[i]!=' ') ans++;\n        }\n\n        return ans;\n\n        \n    }\n};"
            },
            {
                "language": "cpp",
                "code": "public int lengthOfLastWord(String s) {\n    int sLength = s.length(), wordLength = 0;\n\n    for (int index = sLength - 1; index >= 0; index--) {\n        char c = s.charAt(index);\n        \n        if ( c == ' ' && wordLength != 0) {\n            return wordLength;\n        }\n        \n        if (c != ' ') {\n            wordLength++;\n        }\n    }\n\n    return wordLength;\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int lengthOfLastWord(String s) {\n      int ans = 0;\n      for(int i = s.length()-1 ; i>=0; i--){\n        if(s.charAt(i) !=' ' ){\n          ans++;\n        }\n        if( i == 0 ||  s.charAt(i-1) == ' '  &&  s.charAt(i)!= ' ' ){\n          return ans;\n        }\n      }\n      return ans;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int lengthOfLastWord(String s) {\n        int word_length = 0;\n        if (s.length() == 1){\n            return 1;\n        }\n        for (int i = s.length() - 1; i >= 0; i--){\n            if (s.charAt(i) != ' '){\n                word_length++;\n            }else if (word_length != 0 && s.charAt(i) == ' '){\n                return word_length;\n            }\n            \n        }\n        return word_length;\n    }\n}"
            },
            {
                "language": "python",
                "code": "int lengthOfLastWord(char * s){\n    int len = 0;\n    int i = strlen(s) - 1;\n    \n    while (s[i] == ' ' && i >= 0) i--;\n    while (i >= 0 && s[i--] != ' ') len++;\n\n    return len;\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        // need to find length of LAST word. So, we use stack \n        stack<char> st ; \n        int cnt = 0 ; \n        // store the string into the stack\n        for (int i = 0 ; i < s.length() ; i ++)\n        {\n            st.push(s[i]) ; \n        }\n\n        // pop the string till the top element of stack is a space ' '\n        // remove all the spaces in the end \n        while (st.top() == ' ')\n        {\n            st.pop() ; \n        }\n\n        // increase cnt of characters till you find another space ' ' or stack gets empty \n        while (!st.empty() && st.top() != ' ')\n        {\n            cnt ++ ; \n            st.pop() ; \n        }\n\n        return cnt ; \n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int lengthOfLastWord(string s) {\n      stack<char> s1;\n      int count=0;\n      for(int i=0;i<s.size();i++){\n          s1.push(s[i]);\n      }\n//here we push all the element of the string to stack\n\n/*\nnow we will pop() all the blank spaces from the top of stack so \nthat we reach the last later of the last word.\n*/\n\n    while(s1.top()==' ')s1.pop();\n\n/*\nnow we run the while loop util the stack is empty in the case of \nonly one word is there or the blank space comes which seperate the two words.\n\n*/\n\n      while(!s1.empty()&&s1.top()!=' '){\n        count++;\n        s1.pop();\n          \n    }\n// now we itterate the count to count the length of the last word and return  it.\n\n    return count;\n\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "    int lengthOfLastWord(string s) {\n        size_t s_len {s.length()};\n        int length{0};\n        if(s_len == 1){\n            return ++length;\n        }\n        for(size_t i{s_len -1}; i >= 0; --i){\n            if(isalpha(s[i])){"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int lengthOfLastWord(String s) {\n        int length = 0;\n\n        for(int i=s.length()-1 ; i>=0 ; i--)\n        {\n            if(s.charAt(i)!= ' ')\n                length++;\n            else\n                if(length>0) return length;\n        }\n        return length;\n    }\n}"
            }
        ]
    },
    "58": {
        "question_id": 59,
        "title": "Spiral Matrix II",
        "difficulty": 2,
        "description": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order. ",
        "examples": [
            {
                "input": "n = 3",
                "output": "[[1,2,3],[8,9,4],[7,6,5]]",
                "explanation": null
            },
            {
                "input": "n = 1",
                "output": "[[1]]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= n <= 20"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int>> ans(n,vector<int>(n,0));\n        int x = 1,sr=0,sc=0,er=n-1,ec=n-1,i;\n        while(sr<=er&&sc<=ec){\n            for(i=sc;i<=ec;i++){\n                ans[sr][i]  = x++;\n            }sr++;\n            for(i = sr; i<= er; i++){\n                ans[i][ec] = x++;\n            }\n            ec--;\n            for(i = ec; i>=sc; i--){\n                ans[er][i] = x++;\n            }\n            er--;\n            for(i = er; i>= sr; i--){\n                ans[i][sc] = x++;\n            }\n            sc++;\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        int e= n*n, count=0,value=1;\n        int end= e-1;\n        vector<vector<int>>nums(n, vector<int>(n,0));\n        int startingRow=0, startingCol=0,endingRow= n-1, endingCol= n-1;\n\n        while(count<= end)\n        {\n            //first row\n            for(int i= startingCol;count <= end && i<= endingCol;i++)\n            {\n                nums[startingRow][i]=value;\n                count++;\n                value++;\n            }\n            startingRow++;\n\n            // last col\n            for(int i= startingRow;count <= end && i<= endingRow;i++)\n            {\n                nums[i][endingCol]= value;\n                count++;\n                value++;\n            }\n            endingCol--;\n\n            // last row\n            for(int i= endingCol;count <= end && i>=startingCol;i--)\n            {\n                nums[endingRow][i]= value;\n                count++;\n                value++;\n            }\n            endingRow--;\n\n            //first col\n            for(int i= endingRow;count <= end && i>= startingRow;i--)\n            {\n                nums[i][startingCol]=value;\n                count++;\n                value++;\n            }\n            startingCol++;\n        }\n        return nums;   \n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        M = [[0 for j in range(n)] for i in range(n)]\n        if n == 1:\n            return [[1]]\n        a=0\n        b=n-1\n        r = 1\n        while 2*r <= n:\n            for i in range(r-1, n-r):\n                a += 1\n                b += 1\n                M[r-1][i]=a\n                M[i][n-r]=b\n            a = b\n            b = a + n -2*r+1\n            for j in range(n-r,r-1,-1):\n                a +=1\n                b += 1\n                M[n-r][j]=a\n                M[j][r-1]=b\n            r += 1\n            a = b\n            b = a + n -2*r+1\n            \n            #print(r)\n        if 2*r == n+1:\n            M[r-1][r-1]=b+1\n        return M\n        "
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int[][] generateMatrix(int n) \n    {\n        int[][] arr=new int[n][n];\n  boolean a=true;\n  boolean b=false;\n  int i=0;\n  int j=0;\n  int q=0;\n  int p=-1;\n  int r=n;\n  int s=n;\n  int count=0;\n  while(i<n&&j<n&&count<n*n)\n  {\n   count++;\n   \n   if(a==true&&b==false)\n   {\n    arr[i][j]=count;\n    j++;\n    if(j==r)\n    {\n     j--;\n     i++;\n     a=false;\n     r--;\n    }\n   }\n   else if(a==false&&b==false)\n   {\n    arr[i][j]=count;\n    i++;\n    if(i==s)\n    {\n     j--;\n     i--;\n     b=true;\n     s--;\n    }\n   }\n   else if(b==true&&a==false)\n   {\n    arr[i][j]=count;\n    //System.out.print(\"(i:\"+i+\" j:\"+j+\") \");\n    j--;\n    if(j==p)\n    {\n     i--;\n     j++;\n     a=true;\n     p++;\n     \n    }\n   }\n   else if(b==true&&a==true)\n   {\n    arr[i][j]=count;\n    i--;\n    if(i==q)\n    {\n     i++;\n     j++;\n     b=false;\n     q++;\n    }\n    \n   }\n  }\n        return arr;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        \n        vector<vector<int>> arr(n,vector<int>(n));\n        int curr=1, i=0, j=0, left= 0, right= n-1,top=0,bot= n-1;\n        \n        while(curr<= (n*n)){\n            \n            //left -> right\n            while(curr<= (n*n) && j<= right) arr[i][j++]= curr++;\n            j--, i++, top++;\n            \n            //top -> bottom\n            while(curr<= (n*n) && i<= bot) arr[i++][j]= curr++;\n            i--, j--, right--;\n            \n            //right -> left\n            while(curr<= (n*n) && j>= left) arr[i][j--]= curr++;\n            j++, i--, bot--;\n            \n            //bottom -> top\n            while(curr<= (n*n) && i>= top) arr[i--][j]= curr++;\n            i++, j++, left++;\n        }\n        \n        return arr;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        matrix = [[0] * n for _ in range(n)]\n        \n        count = 1\n        rowStart = 0\n        rowEnd = n-1\n        colStart = 0\n        colEnd = n-1\n    \n        while(rowStart <= rowEnd and colStart <= colEnd):\n            for i in range(colStart, colEnd+1):\n                matrix[rowStart][i] = count\n                count += 1\n            rowStart += 1\n        \n            if rowStart > rowEnd:\n                break\n        \n            for i in range(rowStart, rowEnd+1):\n                matrix[i][colEnd] = count\n                count += 1\n            colEnd -= 1\n        \n            if colStart > colEnd:\n                break\n        \n            for i in range(colEnd, colStart-1, -1):\n                matrix[rowEnd][i] = count\n                count += 1\n            rowEnd -= 1\n        \n            if rowStart > rowEnd:\n                break\n        \n            for i in range(rowEnd, rowStart-1, -1):\n                matrix[i][colStart] = count\n                count += 1\n            colStart += 1\n        return matrix"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int r=1;\n    vector<vector<int>> generateMatrix(int n) {\n    vector<vector<int>> v(n,vector<int>(n,0));\n    pair<int,int> p(-1,n);\n    pair<int,int> m(-1,n);\n    while(r<=n*n){\n        p.first+=1;\n        p.second-=1;\n        m.first+=1;\n        m.second-=1;\n        help(v,p,m);\n    }\n    // cout<<v.size()<<\",\"<<v[0].size();\n    return v;\n    }\n    \n    void help(vector<vector<int>>& v,pair<int,int> n,pair<int,int> m){\n        int x,y;\n        y=m.first;\n        while(y<=m.second){\n            v[n.first][y]=r++;\n            y+=1;\n        }\n        x=n.first+1;\n        while(x<=n.second){\n            v[x][m.second]=r++;\n            x+=1;\n        }\n        y=m.second-1;\n        while(y>=m.first){\n            v[n.second][y]=r++;\n            y-=1;\n        }\n        x=n.second-1;\n        while(x>n.first){\n            v[x][m.first]=r++;\n            x-=1;\n        }\n        return;\n    }\n\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int>>mat(n,vector<int>(n));\n        int val=0;\n        int top=0,right=n-1,left=0,bottom=n-1;\n        while(top<=bottom && left<=right){\n            for(int i=left;i<=right;i++){\n                mat[top][i]=++val;\n\n            }\n            top++;\n            for(int i=top;i<=bottom;i++){\n                mat[i][right]=++val;\n\n            }\n            right--;\n            if(top<bottom){\n                for(int i=right;i>=left;i--){\n                    mat[bottom][i]=++val;\n\n                }\n                bottom--;\n            }\n            if(left<right){\n                for(int i=bottom;i>=top;i--){\n                    mat[i][left]=++val;\n                }\n                left++;\n            }\n        }\n        return mat;\n        \n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n      vector<vector<int>> matrix(n,vector<int>(n,1) );\n       \n        int count = 0 ;\n        int total = n*n;\n        // indexes\n        int left = 0 ; \n        int right = n-1;\n        int top=0;\n        int down=n-1;\n        int value = 1;\n\n        while(count<total){\n  \n            for(int i=left; count<total && i<=right ;i++){\n              matrix[top][i]= value;\n              count++;\n              value++;\n            }\n            top++;\n\n             for(int i=top; count<total &&i<=down ;i++){\n              matrix[i][right]=value;\n            count++;\n              value++;\n            }\n            right--;\n            for(int i=right;count<total && i>=left ;i--){\n              matrix[down][i]=value;\n          count++;\n              value++;\n            }\n            down--;\n             for(int i=down;count<total && i>=top ;i--){\n              matrix[i][left]=value;\n        count++;\n              value++;\n            }\n            left++;\n    }\n    return matrix;}\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int>> ans(n , vector<int> (n , 0));\n        int tracker  = 1;\n        int rowStart = 0 , rowEnd = n-1 , colStart = 0 , colEnd = n-1;\n        while(rowStart <= rowEnd && colStart <= colEnd){\n            for(int j=colStart ; rowStart <= rowEnd && colStart <= colEnd && j<=colEnd ; j++){\n                ans[rowStart][j] = tracker++;\n            }\n            rowStart++;\n            for(int i=rowStart ; rowStart <= rowEnd && colStart <= colEnd && i<=rowEnd ; i++){\n                ans[i][colEnd] = tracker++;\n            }\n            colEnd--;\n            for(int j=colEnd ; rowStart <= rowEnd && colStart <= colEnd && j>=colStart ; j--){\n                ans[rowEnd][j] = tracker++;\n            }\n            rowEnd--;\n            for(int i=rowEnd ; rowStart <= rowEnd && colStart <= colEnd && i>=rowStart ; i--){\n                ans[i][colStart] = tracker++;\n            }\n            colStart++;\n        }\n        return ans;\n    }\n};"
            }
        ]
    },
    "59": {
        "question_id": 60,
        "title": "Permutation Sequence",
        "difficulty": 3,
        "description": "The set [1, 2, 3, ..., n] contains a total of n! unique permutations.By listing and labeling all of the permutations in order, we get the following sequence for n = 3:\"123\"\"132\"\"213\"\"231\"\"312\"\"321\"Given n and k, return the kth permutation sequence. ",
        "examples": [
            {
                "input": "n = 3, k = 3",
                "output": "\"213\"",
                "explanation": null
            },
            {
                "input": "n = 3, k = 1",
                "output": "\"123\"",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= n <= 9",
            "1 <= k <= n!"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    string getPermutation(int n, int k) {\n        vector<int> v(n+1,false);\n        vector<int> fact(n+1,1);\n        for(int i = 2; i <= n; i++){\n            fact[i] = fact[i-1]*i;\n        }\n        string ans = \"\";\n        k--;\n        for(int i = 1; i <= n; i++){\n            int x = k/fact[n-i],j,y=k;\n            k -= x*fact[n-i];\n            for(j = 1; j <= n; j++){\n                if(v[j]==false&&x==0){\n                    break;\n                }else if(v[j]==false){\n                    x--;\n                }\n            }\n            if(j<=n)\n            v[j] = true;\n            ans = ans + to_string(j);\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public String getPermutation(int n, int k) {\n        int[] fact = new int[]{1,1,2,6,24,120,720,5040,40320};\n        ArrayList<Integer> list = new ArrayList<>();\n        for(int i=1;i<=n;i++){\n            list.add(i);\n        }\n        return calc(fact,n,k-1,list,0)+\"\";\n    }\n\n    private int calc(int[] fact,int n,int k,ArrayList<Integer> list,int res){\n        if(n==0)\n           return res;\n        res=res*10+list.remove(k/fact[n-1]);\n        return calc(fact,n-1,k%fact[n-1],list,res);\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public String getPermutation(int n, int k) {\n        List<Integer>list=new ArrayList<>();\n        int fact=1;\n        for(int i=1;i<n;i++){\n            fact=fact*i;\n            list.add(i);\n        }\n        list.add(n);\n        k=k-1;\n        String ans=\"\";\n        while(true){\n            ans+=list.get(k/fact);\n            list.remove(k/fact);\n            if(list.size()==0){\n                break;\n            }\n            k=k%fact;\n            fact=fact/list.size();\n        }\n        return ans;\n    }\n}"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        return ''.join([str(i) for i in sorted(list(permutations([i for i in range(1, n+1)], n)))[k-1]])\n        \n\n\n        "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    string getPermutation(int n, int k) {\n        int fact =1;\n        vector<int>numbers;\n        for(int i =1 ;i<n;i++){\n            fact = fact*i;\n            numbers.push_back(i);\n        }\n        numbers.push_back(n);\n        string ans =\"\";\n        k = k-1;\n\n        while(true){\n            ans = ans+ to_string(numbers[k/fact]);\n            numbers.erase(numbers.begin() + k/fact);\n            if(numbers.size()==0){\n                break;\n            }\n            k = k%fact;\n            fact = fact/numbers.size();\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    void recur(string s, string temp, vector<bool> &vis, vector<string> &ans, int &cnt, int k){\n      if(temp.size() == s.size()){\n        ans.emplace_back(temp);\n        cnt++;\n        if(cnt == k) return;\n      }\n      for(int i = 0; i < s.size(); i++){\n        if(!vis[i]){\n          vis[i] = true;\n          temp += s[i];\n          recur(s, temp, vis, ans, cnt, k);\n          temp.pop_back();\n          vis[i] = false;\n        }\n        if(cnt == k) return;\n      }\n    }\n    string getPermutation(int n, int k) {\n      vector<string> ans;\n      string s = \"\", temp = \"\";\n      for(int i = 1; i < n + 1; i++)\n        s += to_string(i);\n      vector<bool> vis(n, false);\n      int cnt = 0;\n      recur(s, temp, vis, ans, cnt, k);\n      return ans.back();\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\npublic:\n    string getPermutation(int n, int k) {\n        string s = \"\" ;\n        vector<int>ds ;\n        for(int i = 1 ; i <= n ; i++){\n            ds.push_back(i) ;\n        }\n        int i = n ;\n        while(k!= 0 && i >= 1){\n            int r = fact(i-1) ;\n            int c = check(r,k) ;\n            s += to_string(ds[c]) ;\n            ds.erase(ds.begin()+c) ;\n            k = k -r*c ;\n            i-- ;\n        }\n        return s ;\n    }\n    int check(int a ,int k){\n        if(k%a == 0)return (k/a) - 1 ;\n        return k/a ;\n    }\n    int fact(int n){\n        if(n == 0)return 1 ;\n        return n*fact(n-1) ;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    string getPermutation(int n, int k) {\n        vector<int> v={0};\n        int tmp=1;\n        for(int i=1;i<=n;i++){\n            v.push_back(i);\n            tmp*=i;\n        }\n        string s;\n        cout<<tmp<<\" \";\n        for(int i=n;i>=2;i--){\n            tmp/=i;\n            int fl=(k+tmp-1)/tmp;\n            s.push_back(v[fl]+'0');\n            k-=(fl-1)*tmp;\n            for(int j=fl;j<v.size()-1;j++){\n                v[j]=v[j+1];\n            }\n        }\n        s.push_back(v[1]+'0');   \n        return s;\n    }\n};"
            },
            {
                "language": "java",
                "code": "public class Solution {\npublic String getPermutation(int n, int k) {\n    int pos = 0;\n    List<Integer> numbers = new ArrayList<>();\n    int[] factorial = new int[n+1];\n    StringBuilder sb = new StringBuilder();\n    \n    // create an array of factorial lookup\n    int sum = 1;\n    factorial[0] = 1;\n    for(int i=1; i<=n; i++){\n        sum *= i;\n        factorial[i] = sum;\n    }\n    // factorial[] = {1, 1, 2, 6, 24, ... n!}\n    \n    // create a list of numbers to get indices\n    for(int i=1; i<=n; i++){\n        numbers.add(i);\n    }\n    // numbers = {1, 2, 3, 4}\n    \n    k--;\n    \n    for(int i = 1; i <= n; i++){\n        int index = k/factorial[n-i];\n        sb.append(String.valueOf(numbers.get(index)));\n        numbers.remove(index);\n        k-=index*factorial[n-i];\n    }\n    \n    return String.valueOf(sb);\n}"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public String getPermutation(int n, int k) {\n        StringBuilder sb = new StringBuilder();\n        ArrayList<Integer> num = new ArrayList<Integer>();\n        int fact = 1;\n        for (int i = 1; i <= n; i++) {\n            fact *= i;\n            num.add(i);"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public String getPermutation(int n, int k) {\n        int fact = 1;\n        List<Integer> al = new ArrayList<>();\n        for(int i = 1;i < n; i++){\n            fact *= i;\n            al.add(i);\n        }\n        al.add(n);\n        String ans = \"\";\n        k--;\n        while(true){\n            ans += al.get(k / fact); //finding the index where the value should start (MSB)\n            al.remove(k / fact); // after finding that value we need to delete that from list\n            if(al.size() == 0)\n                break; // if list is empty then done;\n            k %= fact;  //again decrease k value and apply for other values.\n            fact /= al.size();\n        }\n        return ans;\n    }   \n}"
            }
        ]
    },
    "60": {
        "question_id": 61,
        "title": "Rotate List",
        "difficulty": 2,
        "description": "Given the head of a linked list, rotate the list to the right by k places. ",
        "examples": [
            {
                "input": "head = [1,2,3,4,5], k = 2",
                "output": "[4,5,1,2,3]",
                "explanation": null
            },
            {
                "input": "head = [0,1,2], k = 4",
                "output": "[2,0,1]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is in the range [0, 500].",
            "-100 <= Node.val <= 100",
            "0 <= k <= 2 * 109"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n\n        if(head==null || head.next==null ||k==0) return head;\n        \n        ListNode cur=head;\n        int len=1;\n        while(cur.next!=null){\n            len++;\n            cur=cur.next;\n        }\n\n        cur.next=head;\n        k=k%len;\n        k=len-k;\n        while(k!=0){\n            cur=cur.next;\n            k--;\n        } \n\n        head=cur.next;\n        cur.next=null;\n        return head;\n    }\n}"
            },
            {
                "language": "python",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || head.next==null ||k==0){\n            return head;\n        }\n        //count the length\n        ListNode cur=head;\n        int len=1;\n        while(cur.next!=null){\n            len++;\n            cur=cur.next;\n        }\n        //go till that node\n        cur.next=head;\n        k=k%len;\n        k=len-k;\n        while(k-- >0){\n            cur=cur.next;\n        }\n        //make the node head and break connection\n        head=cur.next;\n        cur.next=null;\n        return head;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n       if(!head)return head;\n       ListNode*ptr=head;\n        int n=1;\n        while(ptr->next){\n            ptr=ptr->next;\n            n++;\n         }\n        k=k%n;\n        if( k==0 || n==1)return head;\n        int s=n-k;//where the list is cut it out\n        ListNode*ptr1=NULL;\n        ListNode*ptr2=head;\n        while(s--){\n            ptr1=ptr2;\n            ptr2=ptr2->next;\n        }\n        ptr->next=head;\n        ptr1->next=NULL;\n      return ptr2;\n    }    \n};"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n     if(!head || k==0)\n     {\n         return head;\n     }\n       int c=0;\n       ListNode* temp=head;\n       while(temp)\n       {\n           c++;\n           temp=temp->next;\n       }\n\n       int z=k%c;\n    //    cout<<c<<\" \"<<z<<\"\\n\";\n    //   cout<<temp->val<<\"\\n\";\n       while(z--)\n       {\n           ListNode* curr=head;\n           while(curr->next->next)\n           {\n               \n               curr=curr->next;\n           }\n            ListNode* next=curr->next;\n           curr->next=next->next;\n           next->next=head;\n           head=next;\n\n       }\n        return head;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        ListNode*l1=head,*l2=head,*curr;\n        if(head == NULL || head->next == NULL)return head;\n        int n=0;\n        while(l1!=NULL){\n            l1=l1->next;\n            n++;\n        }\n        if(n==k || k==0 || k%n == 0)return head;\n        int val=n-k;\n        if(k>n)val = n-k%n;\n        for(int i=0;i<val-1;i++){\n            l2=l2->next;\n        }\n        if(l2->next!=NULL)curr=l2->next;\n        l2->next = NULL;\n        ListNode *newhead = curr;\n        while(curr->next!=NULL)curr=curr->next;\n        curr->next = head;\n        return newhead;\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not k:\n            return head\n        \n        res = []\n        cur = head\n        while cur:\n            res.append(cur.val)\n            cur = cur.next\n            \n        \n        n = len(res)\n        k = k % n  # handle cases where k > n\n        res = res[-k:] + res[:-k] # rotate the array k times\n\n        dum = ListNode(0)\n        cur = dum\n        for i in range(len(res)):\n            cur.next = ListNode(res[i])\n            cur = cur.next\n        return dum.next        "
            },
            {
                "language": "python",
                "code": "        int i = 0;\n        k %= count;\n        while(i < count - k - 1){\n            i++;\n            start = start.next;\n        }"
            },
            {
                "language": "ruby",
                "code": "class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        ListNode start = head, end = head, curr = head;\n        int count = 0;\n        if(head == null || head.next == null)\n            return head;\n        while(curr != null){\n            curr = curr.next;\n            count++;\n        }\n        while(end.next != null){\n            end = end.next;\n        }\n        end.next = head; //ending point\n        int i = 0;\n        k %= count;\n        while(i < count - k - 1){\n            i++;\n            start = start.next;\n        }\n        ListNode newhead = start.next;\n        start.next = null;\n        return newhead;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n       if(!head)\n           return NULL;\n        int n = 1;\n        ListNode* tail = head;\n        while(tail->next){\n            n++;\n            tail = tail->next;\n        }\n        tail->next = head;\n        int sz = n - k % n;\n        for(int i = 0; i < sz; i++){\n            tail = tail->next;\n        }  \n        head = tail->next;\n        tail->next = NULL;\n        return head;\n    }\n};"
            },
            {
                "language": "python",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k==0 || head==null) return head;\n        int count = 1;\n        ListNode temp = head;\n        while (temp.next!=null) {\n            count++;\n            temp = temp.next;\n        }\n        if (k>count) k = k%count;\n        if (k==count) return head;\n        k = count-k-1;\n        temp.next = head;\n        temp = head;\n        while (k>0) {\n            k--;\n            temp = temp.next;\n        }\n        head = temp.next;\n        temp.next = null;\n        return head;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (head ==NULL)return NULL;\n        vector<int> nums;\n        ListNode* p = head;\n        while(p){\n            nums.push_back(p->val);\n            p = p->next;\n        }\n        k = k%nums.size();\n        reverse(nums.begin(), nums.end());\n        reverse(nums.begin(), nums.begin()+k);\n        reverse(nums.begin()+k, nums.end());\n        ListNode* a = new ListNode(nums[0]);\n        ListNode* b = a;\n        for(int i =1; i<nums.size(); i++){\n            b->next = new ListNode(nums[i]);\n            b = b->next;\n        }\n        return a;\n        \n        \n    }\n};"
            }
        ]
    },
    "61": {
        "question_id": 62,
        "title": "Unique Paths",
        "difficulty": 2,
        "description": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.The test cases are generated so that the answer will be less than or equal to 2 * 109. ",
        "examples": [
            {
                "input": "m = 3, n = 7",
                "output": "28",
                "explanation": null
            },
            {
                "input": "m = 3, n = 2",
                "output": "3",
                "explanation": "From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down"
            }
        ],
        "constraints": [
            "1 <= m, n <= 100"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "//using dynamic programming - O(mn) time and O(mn) space\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>>grid(m, vector<int>(n));\n        for (int row = 0; row < m; row++) {\n            for (int col = 0; col < n; col++) {\n                if (row == 0 || col == 0) {\n                    grid[row][col] = 1;\n                }\n                else {\n                    grid[row][col] = grid[row-1][col] + grid[row][col-1];\n                }\n            }\n        }\n        return grid[m-1][n-1];\n    }\n};"
            },
            {
                "language": "",
                "code": "grid[r][c] = grid[r+1][c] + grid[r][c+1]"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int uniquePaths(int m, int n) {\n        int grid[][] = new int[m][n];\n        grid[m-1][n-1] = 1;\n        for(int r = m-1; r >= 0; r--){\n            for(int c = n-1; c >= 0; c--){\n                if(r+1 < m){\n                    grid[r][c] += grid[r+1][c];\n                }\n                if(c+1 < n){\n                    grid[r][c] += grid[r][c+1];\n                }\n            }\n        }\n        return grid[0][0];\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n, int i = 0, int j = 0) {\n        if(i >= m || j >= n) return 0;                                    // reached out of bounds - invalid\n        if(i == m-1 && j == n-1) return 1;                                // reached the destination - valid solution\n        return uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);     // try both down and right\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def uniquePaths(self, m, n, i=0, j=0):\n        if i >= m or j >= n:      return 0\n        if i == m-1 and j == n-1: return 1\n        return self.uniquePaths(m, n, i+1, j) + self.uniquePaths(m, n, i, j+1)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int dp[101][101]{};\n    int uniquePaths(int m, int n, int i = 0, int j = 0) {\n        if(i >= m || j >= n) return 0;\n        if(i == m-1 && j == n-1) return 1;\n        if(dp[i][j]) return dp[i][j];\n        return dp[i][j] = uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m, vector<int>(n));\n        return dfs(dp, 0, 0);\n    }\n    int dfs(vector<vector<int>>& dp, int i, int j) {\n        if(i >= size(dp)   || j >= size(dp[0]))   return 0;     // out of bounds - invalid\n        if(i == size(dp)-1 && j == size(dp[0])-1) return 1;     // reached end - valid path\n        if(dp[i][j]) return dp[i][j];                           // directly return if already calculated\n        return dp[i][j] = dfs(dp, i+1, j) + dfs(dp, i, j+1);    // store the result in dp[i][j] and then return\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def uniquePaths(self, m, n):\n        @cache\n        def dfs(i, j):\n            if i >= m or j >= n:      return 0\n            if i == m-1 and j == n-1: return 1\n            return dfs(i+1, j) + dfs(i, j+1)\n        return dfs(0, 0)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m, vector<int>(n, 1));\n        for(int i = 1; i < m; i++)\n            for(int j = 1; j < n; j++)\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];   // sum of unique paths ending at adjacent top and left cells\n        return dp[m-1][n-1];         // return unique paths ending at cell (m-1, n-1)\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def uniquePaths(self, m, n):\n        dp = [[1]*n for i in range(m)]\n        for i, j in product(range(1, m), range(1, n)):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[-1][-1]"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(2, vector<int>(n,1));\n        for(int i = 1; i < m; i++)\n            for(int j = 1; j < n; j++)\n                dp[i & 1][j] = dp[(i-1) & 1][j] + dp[i & 1][j-1];   // <- &  used to alternate between rows\n        return dp[(m-1) & 1][n-1];\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def uniquePaths(self, m, n):\n        dp = [[1]*n for i in range(2)]\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i&1][j] = dp[(i-1)&1][j] + dp[i&1][j-1]\n        return dp[(m-1)&1][-1]"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<int> dp(n, 1);\n        for(int i = 1; i < m; i++)\n            for(int j = 1; j < n; j++)\n                dp[j] += dp[j-1];   \n        return dp[n-1];\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def uniquePaths(self, m, n):\n        dp = [1]*n\n        for _, j in product(range(1, m), range(1, n)):\n            dp[j] += dp[j-1]\n        return dp[-1]"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        long ans = 1;\n        for(int i = m+n-2, j = 1; i >= max(m, n); i--, j++) \n            ans = (ans * i) / j;\n        return ans;\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def uniquePaths(self, m, n):\n        return factorial(m+n-2) // factorial(m-1) // factorial(n-1)"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def uniquePaths(self,m,n):\n        ans = 1\n        for i, j in enumerate(range(m + n - 2, max(m,n) - 1, -1)):\n            ans = (ans * j) // (i+1)\n        return ans"
            },
            {
                "language": "recursion",
                "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        if (m < 1 || n < 1){\n            return 0;\n        }\n\n        if (m == 1 && n == 1){\n            return 1;\n        }\n\n        return  uniquePaths(m-1, n) + uniquePaths(m, n-1);\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        if m == 1 and n == 1:\n            return 1\n        L_n=[0]\n        for t in range(n-1):\n            L_n.append(1)\n        \n        for i in range(m-1):\n            L_o=L_n\n            L_n=[1]\n            for j in range(1,n):\n                L_n.append(L_n[j-1]+L_o[j])\n        return L_n[-1]\n                "
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    //DP solution.\n\n    public int uniquePaths(int m, int n) {\n        int dp[][]=new int[m][n];\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                dp[i][j]=-1;\n            }\n        }\n        return solve(0,0,m,n,dp);\n    }\n    public int solve(int i,int j,int m,int n,int dp[][]){\n        if(i>=m || j>=n) return 0;\n        if(i==m-1 && j==n-1) return 1;\n        if(dp[i][j]!=-1) return dp[i][j];\n        else return dp[i][j]=solve(i+1,j,m,n,dp)+solve(i,j+1,m,n,dp);\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m][n];\n        return findPath(0, 0, m, n, dp);\n    }\n    int findPath(int path1, int path2, int m, int n, int[][] dp) {\n        if (path1+1==m && path2+1==n) return 1;\n        if (path1==m) return 0;\n        if (path2==n) return 0;\n        if (dp[path1][path2]!=0) return dp[path1][path2];\n        dp[path1][path2] = findPath(path1+1, path2, m, n, dp) + findPath(path1, path2+1, m ,n, dp);\n        return dp[path1][path2];\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n\n    int uniquePaths(int m, int n) {\n         vector<vector<int>> dp(m,vector<int>(n,0));\n         dp[0][0]=1;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(i==0&&j==0) continue;\n                else{\n                    int up=0;\n                    int left=0;\n                     if(i>0) up=dp[i-1][j];\n                     if(j>0) left=dp[i][j-1];\n                    dp[i][j]=left+up;\n                }\n            }\n        }\n        return dp[m-1][n-1];\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n   \n    int path(int x, int y, int m, int n, vector<vector<int>> &dp){\n        if(x == m-1 && y == n-1){\n            return 1;\n        }\n        if(x >= m || y >= n){\n            return 0;\n        }\n        if(dp[x][y] != -1){\n            return dp[x][y];\n        }\n        else\n        return dp[x][y] = path(x+1, y, m, n, dp) + path(x, y+1, m, n, dp);\n        \n    }\n\n    int uniquePaths(int m, int n) {\n     vector<vector<int>> dp(m, vector<int>(n, -1));\n    return path(0, 0, m, n, dp);\n        \n    }\n};\n\n// TLE while exectution of larger input cases.\n\n// class Solution {\n// public:\n\n//     int path(int x, int y, int m, int n){\n//         if(x == m-1 && y == n-1){\n//             return 1;\n//         }\n//         if(x >= m || y >= n){\n//             return 0;\n//         }\n//         return path(x+1, y, m, n) + path(x, y+1, m, n);\n//     }\n\n//     int uniquePaths(int m, int n) {\n//     // vector<vector<int>> dp(m, vector<int>(n, -1));\n//     return path(0, 0, m, n);\n        \n//     }\n// };"
            },
            {
                "language": "cpp",
                "code": "  int uniquePaths(const int& m, const int& n) {\n    std::vector<std::vector<int>> vec{{1}};\n    int top, left;\n    for (int i = 0; i < m; ++i) {\n      vec.emplace_back();\n      for (int j = 0; j < n; ++j) {\n        if (i == 0 && j == 0)\n          continue;\n\n        top = i < 1 ? 0 : vec[i - 1][j];\n        left = j < 1 ? 0 : vec[i][j - 1];\n\n        vec[i].push_back(top + left);\n      }\n    }\n\n    return vec[m - 1][n - 1];\n  }"
            }
        ]
    },
    "62": {
        "question_id": 63,
        "title": "Unique Paths II",
        "difficulty": 2,
        "description": "You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.Return the number of possible unique paths that the robot can take to reach the bottom-right corner.The testcases are generated so that the answer will be less than or equal to 2 * 109. ",
        "examples": [
            {
                "input": "obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]",
                "output": "2",
                "explanation": "There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right"
            },
            {
                "input": "obstacleGrid = [[0,1],[0,0]]",
                "output": "1",
                "explanation": null
            }
        ],
        "constraints": [
            "m == obstacleGrid.length",
            "n == obstacleGrid[i].length",
            "1 <= m, n <= 100",
            "obstacleGrid[i][j] is 0 or 1."
        ],
        "solutions": [
            {
                "language": "",
                "code": "Recursive DP"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int nl, ml, a[105][105], dp[105][105];\n\n    bool valid(int x, int y) {\n        if(x < nl and y < ml and a[x][y] == 0) return true;\n        else return false;\n    }\n\n    int solve(int i, int j) {\n        if(!valid(i, j)) return 0;\n        if(i >= nl-1 and j >= ml-1) return 1;\n        if(dp[i][j] != -1) return dp[i][j];\n        int ans = solve(i+1, j) + solve(i, j+1);\n        return dp[i][j] = ans;\n    }\n\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        memset(dp, -1, sizeof(dp));\n        nl = obstacleGrid.size(), ml = obstacleGrid[0].size();\n        for(int i=0; i<nl; i++) for(int j=0; j<ml; j++) a[i][j] = obstacleGrid[i][j];\n        int ans = solve(0, 0);\n        return ans;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0\n        for i in range(1, m):\n            if obstacleGrid[i][0] == 0:\n                dp[i][0] = dp[i-1][0]\n        for j in range(1, n):\n            if obstacleGrid[0][j] == 0:\n                dp[0][j] = dp[0][j-1]\n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[m-1][n-1]"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    \n    int solve(int i, int j, vector<vector<int>> &obs,vector<vector<int>> &dp, int m, int n)\n    {\n        \n        \n        if(i>=n || j>=m || obs[i][j]==1 || i<0 ||j<0)\n            return 0;\n        \n         if(i>=n-1 && j>=m-1)\n            return 1;\n       \n        \n        if(dp[i][j]!=-1)\n            return dp[i][j];\n        int ans = solve(i,j+1,obs,dp,m,n) + solve(i+1,j,obs,dp,m,n);\n        dp[i][j] = ans;\n        return ans;\n    }\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\n        \n        int n = obs.size();\n        int m = obs[0].size();\n        \n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\n        int ans = solve(0,0,obs,dp,m,n);\n        return ans;\n        \n        \n        \n        \n        \n    }\n};"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        m=len(obstacleGrid)\n        n=len(obstacleGrid[0])\n\n        if m == 1 or n == 1:\n            if any(1 in row for row in obstacleGrid):\n                return 0\n            else:\n                return 1\n\n        L=[[0 for _ in range(n)] for _ in range(m)]\n        \n        temp_x=obstacleGrid[0]\n        if temp_x[0] == 1:   \n           return 0\n        else:\n            for t in range(0,n):\n                if temp_x[t] == 0:\n                    L[0][t]=1\n                if temp_x[t] == 1:\n                    for i in range (t,n):\n                        L[0][t]=0\n                    break\n        \n       \n        temp_y=[]\n        for i in range(1,m):\n            temp_y.append(obstacleGrid[i][0])\n        \n        for t in range(0,m-1):\n            if temp_y[t] == 0:\n                L[t+1][0]=1\n            elif temp_y[t] == 1:\n                for i in range (t,m-1):\n                    L[i+1][0]=0\n                break\n       # print(L)\n\n        for i in range(1,m):\n            for j in range(1,n):\n                if obstacleGrid[i][j]==1:\n                    L[i][j] =0\n                elif obstacleGrid[i][j]==0:\n                    L[i][j]= L[i][j-1]+L[i-1][j]\n      # print(L)    \n        return L[-1][-1]"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        dp = [[-1]*101 for i in range(101)]\n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        def count(i, j):\n            if i >= m or j >= n or obstacleGrid[i][j] == 1:\n               dp[i][j] = 0\n            if i == m - 1 and j == n - 1:\n                if obstacleGrid[i][j]==1:\n                    return 0\n                dp[i][j] = 1\n            if dp[i][j] != -1:\n                return dp[i][j]\n            dp[i][j] = count(i+1,j) + count(i,j+1)\n            return dp[i][j]\n        return count(0,0)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    //checking if the cell is inside of the boundary\n    bool isSafe(vector<vector<int>> &obstacleGrid, int i, int j)\n    {\n        if(i>=0 && i<obstacleGrid.size() && j>=0 && j<obstacleGrid[0].size())\n        {\n            return true;\n        }\n        return false;\n    }\n\n    int dfs(vector<vector<int>> &obstacleGrid, int i, int j, vector<vector<int>> &dp)\n    {\n        //checking if the cell is out of boundary\n        if(isSafe(obstacleGrid, i, j))\n        {\n            // Returning 0 if it's an obstacle\n            if(obstacleGrid[i][j]==1)\n            {\n                dp[i][j] = 0;\n                return 0;\n            }\n            //checking if the cell already visited then the path exists and the no. of possible paths from here on is the value of the cell.\n            if(dp[i][j]!=-1)\n            {\n                return dp[i][j];\n            }\n            //if we have reached last cell then return 1\n            if(i==obstacleGrid.size()-1 && j==obstacleGrid[0].size()-1)\n            {\n                dp[i][j]= 1;\n                return dp[i][j];\n            }\n            //making dfs call to the right then down\n            int right = dfs(obstacleGrid, i, j+1, dp);\n            int down = dfs(obstacleGrid, i+1, j, dp);\n            //Backtracking with the values we got from the right and down and adding them as the no. of paths from here on is the sum of both of them\n            dp[i][j] = right+down;\nreturning the same\n            return dp[i][j];\n        }\n        //if cell is out of boundary no path possible\n        return 0;\n    }\n\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        //Initialising the dp(memoization)\n        int m = obstacleGrid.size();\n        int n = obstacleGrid[0].size();\n        vector<vector<int>> dp(m, vector<int>(n, -1));\n        //calling the dfs recursive function\n        dfs(obstacleGrid, 0, 0, dp);\n        //returning the first cell's count\n        return dp[0][0];\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "/**\n * @param {number[][]} obstacleGrid\n * @return {number}\n */\nvar uniquePathsWithObstacles = function(obstacleGrid) {\n let m = obstacleGrid.length;\n  let n = obstacleGrid[0].length;\n  let memo = new Map();\nif (m === 1 && n === 1) {\n    if (obstacleGrid[0][0] === 1) {\n      return 0;\n    }\n    return 1;\n  }\n\n  const getAllPaths = (row, column) => {\n    if (row === 0 && column === 0) {\n     if (obstacleGrid[0][0] === 1) {\n       return 0;\n     }\n     return 1;\n    }\n    if (row < 0 || column < 0 || obstacleGrid[row][column] === 1) {\n      return 0;\n    }\n    if (memo.has(row + \"_\" + column)) {\n      return memo.get(row + \"_\" + column);\n    }\n\n    let up = getAllPaths(row - 1, column);\n    let left = getAllPaths(row, column - 1);\n    memo.set(row + \"_\" + column, up + left);\n    return up + left;\n  };\n\n  return getAllPaths(m - 1, n - 1);\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    int dfs(int i, int j, vector<vector<int>> &obstacleGrid, vector<vector<int>> &dp) {\n        if(!i && !j) return 1;\n        if(i < 0 || j < 0 || obstacleGrid[i][j]) return 0;\n        if(dp[i][j] != -1) return dp[i][j];\n\n        int u = dfs(i - 1, j, obstacleGrid, dp);\n        int l = dfs(i, j - 1, obstacleGrid, dp);\n\n        return dp[i][j] = u + l;\n    }\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        if(obstacleGrid[0][0]) return 0;\n\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\n        vector<vector<int>> dp(m, vector<int>(n, -1));\n        return dfs(m - 1, n - 1, obstacleGrid, dp);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\n        int n = grid.size() , m = grid[0].size();\n        long long mod = 2e9+7;\n        vector<int>prev(m,0);\n        for(int i=0;i<n;i++){\n            vector<int>curr(m,0);\n            for(int j=0;j<m;j++){\n                \n                if(i>=0 && j>=0 && grid[i][j] == 1){\n                   curr[j] = 0;\n                    // continue;\n                } \n                else if(i==0 && j==0){\n                    curr[j] = 1;\n                    // continue;\n                } \n                else{\n                int up=0,left =0;\n               if(i>0){\n                   up = prev[j];\n               }\n               if(j>0){\n                   left =curr[j-1];\n               } \n                curr[j] = ( up + left) % mod ;\n                }\n            }\n            prev = curr;\n        }\n        \n        return prev[m-1];\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    int[][] ans;\n    int[][] g;\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        int m = obstacleGrid.length;\n        int n = obstacleGrid[0].length;\n        ans = new int[m][n];\n        for(int[] a:ans)\n        Arrays.fill(a,-1);\n        this.g=obstacleGrid;\n        \n        return rec(m-1,n-1);\n    }\n    int rec(int i, int j)\n    {\n        \n        if(i<0 || j<0 || g[i][j]==1) return 0;\n        if(i==0 && j==0) return 1;\n        if(ans[i][j]!=-1) return ans[i][j];\n        else\n        {\n            int up= rec(i,j-1);\n            int left = rec(i-1,j);\n            ans[i][j]= up+left;\n            return ans[i][j];\n        }\n    }\n}"
            }
        ]
    },
    "63": {
        "question_id": 64,
        "title": "Minimum Path Sum",
        "difficulty": 2,
        "description": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.Note: You can only move either down or right at any point in time. ",
        "examples": [
            {
                "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
                "output": "7",
                "explanation": "Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum."
            },
            {
                "input": "grid = [[1,2,3],[4,5,6]]",
                "output": "12",
                "explanation": null
            }
        ],
        "constraints": [
            "m == grid.length",
            "n == grid[i].length",
            "1 <= m, n <= 200",
            "0 <= grid[i][j] <= 100"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n            \n        \n        m, n = len(grid), len(grid[0])\n        \n        for i in range(1, m):\n            grid[i][0] += grid[i-1][0]\n        \n        for i in range(1, n):\n            grid[0][i] += grid[0][i-1]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n        \n        return grid[-1][-1]\n    \n        # An Upvote will be encouraging"
            },
            {
                "language": "rust",
                "code": "Thanks for visiting my solution.\ud83d\ude0a Keep Learning\nPlease give my solution an upvote! \ud83d\udc4d\nIt's a simple way to show your appreciation and\nkeep me motivated. Thank you! \ud83d\ude0a"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        n=len(grid)\n        m=len(grid[0])\n        for i in range(n):\n            for j in range(m):\n                if i==0:\n                    if j!=0:\n                        grid[i][j]+=grid[i][j-1]\n                elif j==0:\n                    if i!=0:\n                        grid[i][j]+=grid[i-1][j]\n                else:\n                    grid[i][j]+=min(grid[i-1][j],grid[i][j-1])\n        return grid[n-1][m-1]"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int n=grid.size(),m=grid[0].size();\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(i==0 and j!=0) grid[i][j]+=grid[i][j-1];\n                if(j==0 and i!=0) grid[i][j]+=grid[i-1][j];\n                if(i!=0 and j!=0) grid[i][j]+=min(grid[i-1][j],grid[i][j-1]);\n            }\n        }\n        return grid[n-1][m-1];\n    }\n};"
            },
            {
                "language": "java",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int minPathSum(int[][] grid) {\n            int height = grid.length;\n            int width = grid[0].length;\n            for (int row = 0; row < height; row++) {\n                for (int col = 0; col < width; col++) {\n                    if(row == 0 && col == 0) grid[row][col] = grid[row][col];\n                    else if(row == 0 && col != 0) grid[row][col] = grid[row][col] + grid[row][col - 1];\n1][col];\n][col - 1]);"
            },
            {
                "language": "python",
                "code": "    for (int i = 1; i < m; i++) {\n        grid[i][0] += grid[i-1][0];\n    }\n    "
            },
            {
                "language": "cpp",
                "code": "    int n=grid.size();\n    int m=grid[0].size();\n    priority_queue<pair<int,pair<int,int>>,\n    vector<pair<int,pair<int,int>>>,\n    greater<pair<int,pair<int,int>>>> pq;\n    int rowA[]={0,1};\n    int colA[]={1,0};\n    pq.push({grid[0][0],{0,0}});"
            },
            {
                "language": "kotlin",
                "code": ""
            },
            {
                "language": "java",
                "code": "class Solution {\n   int[] row = {0, 1};"
            },
            {
                "language": "java",
                "code": "//  DP - Tabulation\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        for (int i = grid.length - 1; i >= 0; i--) {\n            for (int j = grid[0].length - 1; j >= 0; j--) {\n                if (i == grid.length - 1 && j == grid[0].length - 1) {\n                    grid[i][j] = grid[i][j];\n                } else if (i == grid.length - 1) {"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        \n        for (int i = 1; i < m; i++) grid[i][0] += grid[i-1][0];\n        \n        for (int j = 1; j < n; j++) grid[0][j] += grid[0][j-1];\n        \n        for (int i = 1; i < m; i++)\n            for (int j = 1; j < n; j++)\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\n        \n        return grid[m-1][n-1];\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        //we will modify the same array and return the last index grid[row-1][col-1]\n        int row = grid.size();\n        int col = grid[0].size();\n        for (int i = 1; i < row; i++) {\n            grid[i][0] += grid[i-1][0];\n        }\n        for (int j = 1; j < col; j++) {\n            grid[0][j] += grid[0][j-1];\n        }\n        for (int i = 1; i < row; i++) {\n            for (int j = 1; j < col; j++) {\n                grid[i][j] = grid[i][j] + min(grid[i-1][j], grid[i][j-1]);\n            }\n        }\n        return grid[row-1][col-1];\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int m, n;\n    int solve(vector<vector<int>>&grid, int currRow, int currCol)\n    {\n        if (currRow >= m || currCol >= n) return INT_MAX; //when cell is out of bounds\n        if (currRow == m - 1 && currCol == n - 1) return grid[m - 1][n - 1]; //reached the target\n        \n        int rightMin = solve(grid, currRow, currCol + 1);\n        int downMin = solve(grid, currRow + 1, currCol);\n        int bestChoice = min(rightMin, downMin);\n        \n        return (grid[currRow][currCol] + bestChoice);\n    }\n    int minPathSum(vector<vector<int>>& grid) \n    {\n        m = grid.size(); n = grid[0].size();\n        return solve(grid, 0, 0);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int m, n;\n    int solve(vector<vector<int>>&grid, vector<vector<int>>&dp, int currRow, int currCol)\n    {\n        if (currRow >= m || currCol >= n) return INT_MAX; //when cell is out of bounds\n        if (currRow == m - 1 && currCol == n - 1) return grid[m - 1][n - 1]; //reached the target\n        \n        if (dp[currRow][currCol] !=  -1) return dp[currRow][currCol]; //use the already computed result\n        int rightMin = solve(grid, dp, currRow, currCol + 1);\n        int downMin = solve(grid, dp, currRow + 1, currCol);\n        int bestChoice = min(rightMin, downMin);\n        \n        return dp[currRow][currCol] = (grid[currRow][currCol] + bestChoice); //store the result \n    }\n    int minPathSum(vector<vector<int>>& grid) \n    {\n        m = grid.size(); n = grid[0].size();\n        vector<vector<int>>dp(m, vector<int>(n, -1)); \n        //'-1' to denote that subproblem result for that cell is not computed and not stored\n        return solve(grid, dp, 0, 0);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) \n    {\n        int m = grid.size(), n = grid[0].size();\n        //traverse from 'bottom->top' and 'right->left'\n        //as for any cell we need computed result from 'down' and 'right'\n        for (int i = m - 1; i >= 0; i--)\n        {\n            for (int j = n - 1; j >= 0; j--)\n            {\n                if (i == m - 1 && j == n - 1) continue;\n                \n                //grid[i][j + 1] and grid[i + 1][j] will already have stored the result of subproblem\n                int rightMin = (j + 1 >= n)? INT_MAX : grid[i][j + 1]; //\n                int downMin = (i + 1 >= m)? INT_MAX : grid[i + 1][j];\n                grid[i][j] = grid[i][j] + (min(rightMin, downMin)); \n                //rather than making a new 'DP' grid store results of subproblems in the same grid\n            }\n        }\n        return grid[0][0];\n        \n    }\n};"
            },
            {
                "language": "java",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& g) {\n        int n=g.size();\n        int m=g[0].size();\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\n        for(int i=1;i<=n;i++){\n         dp[i][1] =g[i-1][0] + dp[i-1][1];\n        }\n        for(int j=1;j<=m;j++){\n         dp[1][j] = g[0][j-1] + dp[1][j-1];   \n        }\n        for(int i=2;i<=n;i++){\n            for(int j=2;j<=m;j++){\n                dp[i][j] = g[i-1][j-1] + min(dp[i-1][j] , dp[i][j-1]);\n            }\n        }\n        return dp[n][m];\n    }\n};"
            },
            {
                "language": "php",
                "code": "public class Solution {\n    /**\n     * Space Complexity O(m*n) -- for dp matrix\n     * Time Complexity O(m*n)\n     * @param grid\n     * @return\n     */\n    public int minPathSum(int[][] grid) {\n        //initialise a dp with size same as original array\n        int m = grid.length, n = grid[0].length;\n        int[][] dp = new int[m][n];\n\n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                //start counting the cost from the bottom right cell(bottom up approach) this is base condition\n                //Cost of going to destination from destination is the lowest subset problem\n                //then expand with the computed value to other cells gradually\n                //when solving bigger subsets other than base condition, remember we can only go right or bottom\n                if (i + 1 > m - 1 && j + 1 > n - 1) //base condition\n                    dp[i][j] = grid[i][j];\n\n                else if (i + 1 > m - 1)//boundary condition: handles the bottom most row\n                    dp[i][j] = dp[i][j + 1] + grid[i][j];\n\n                else if (j + 1 > n - 1)//boundary condition: handles the right most column\n                    dp[i][j] = dp[i + 1][j] + grid[i][j];\n                else {// normal cells : get the min of 1 horizontal  right travel and 1 vertical bottom travel\n                    dp[i][j] = Math.min(dp[i][j + 1] + grid[i][j], dp[i + 1][j] + grid[i][j]);\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}"
            },
            {
                "language": "java",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int minPathSum(int[][] grid) {\n        return minPathSum(grid, grid.length-1, grid[0].length-1);\n    }\n    private int minPathSum(int[][] grid, int n, int m){\n        if(n == 0 && m == 0) return grid[n][m];\n        if(n < 0 || m < 0) return Integer.MAX_VALUE;\n        return grid[n][m] + Math.min(minPathSum(grid, n-1, m), minPathSum(grid, n, m-1));\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int minPathSum(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int dp[][] = new int[grid.length][grid[0].length];\n        for(int i = 0; i<n; i++){\n            for(int j = 0; j<m; j++){\n                if(i == 0 && j == 0) dp[i][j] = grid[i][j];\n                else if(i == 0) dp[i][j] = dp[i][j-1] + grid[i][j];\n                else if(j == 0) dp[i][j] = dp[i-1][j] + grid[i][j];\n                else {\n                    dp[i][j] = grid[i][j] + Math.min(dp[i][j-1], dp[i-1][j]);\n                }\n            }\n        }\n        return dp[n-1][m-1];\n    }\n}"
            },
            {
                "language": "java",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            }
        ]
    },
    "64": {
        "question_id": 65,
        "title": "Valid Number",
        "difficulty": 3,
        "description": "A valid number can be split up into these components (in order):A decimal number or an integer.(Optional) An 'e' or 'E', followed by an integer.A decimal number can be split up into these components (in order):(Optional) A sign character (either '+' or '-').One of the following formats:\tOne or more digits, followed by a dot '.'.One or more digits, followed by a dot '.', followed by one or more digits.A dot '.', followed by one or more digits.An integer can be split up into these components (in order):(Optional) A sign character (either '+' or '-').One or more digits.For example, all the following are valid numbers: [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"].Given a string s, return true if s is a valid number. ",
        "examples": [
            {
                "input": "s = \"0\"",
                "output": "true",
                "explanation": null
            },
            {
                "input": "s = \"e\"",
                "output": "false",
                "explanation": null
            },
            {
                "input": "s = \".\"",
                "output": "false",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= s.length <= 20",
            "s consists of only English letters (both uppercase and lowercase), digits (0-9), plus '+', minus '-', or dot '.'."
        ],
        "solutions": [
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    bool isNumber(string s) {\n        int i=0, n=s.size();\n\n        // iterate over sign\n        if(s[i]=='+' || s[i]=='-') i++;\n\n        // checking ending condition\n        if(i>=n) return false;\n        \n        bool beforeInt = false;\n\n        // iterating digits\n        while(s[i]>='0' && s[i]<='9' && i<n){\n            i++;\n            beforeInt = true;\n        }\n\n        // checking ending condition\n        if(i>=n) return true;\n\n        // Passing dot\n        bool dot = false;\n        if(s[i] == '.') {i++; dot = true;}\n\n        // check dot ending condition\n        if(i>=n)\n            if(dot==true && beforeInt==false) return false;\n            else return true;\n        \n        // bool afterInt = false;\n\n        // check digit after dot\n        if(dot) \n        if(beforeInt) {if((s[i]<'0' || s[i]>'9') && (s[i]!='e' && s[i]!='E') ) return false; }\n        else {if(s[i]<'0' || s[i]>'9') return false; }\n\n        // iterate decimals until we reach last indext or e\n        while(i<n && s[i]!='e' && s[i]!='E'){\n            if(s[i]<'0' || s[i]>'9') return false;\n            i++;\n        }\n        if(!dot)\n        if((s[i]=='e' || s[i]=='E') && beforeInt==false) return false;\n        // checking ending condition\n        if(i>=n) return true;\n        \n        i++; // next ot e\n        \n        // iterate sign\n        if(s[i]=='+' || s[i]=='-') i++;\n\n        // checking ending condition\n        if(i>=n) return false;\n\n        bool lastInt = false;\n        // iterate over digits\n        while(s[i]>='0' && s[i]<='9' && i<n){\n            i++;\n            lastInt = true;\n        }\n\n        if(!lastInt) return false;\n\n        if(i>=n) return true;\n        return false;\n    }\n};"
            },
            {
                "language": "java",
                "code": "import java.math.BigDecimal;\nimport java.math.BigInteger;\n\npublic class Solution {\n        public boolean isNumber(String s) {\n     s = s.trim();\n     if(s.length() == 0) {\n      return false;\n     }\n     boolean result = true;\n        try{\n         new BigDecimal(s);\n        } catch(Exception e) {\n         result = false;\n        }\n        if(s.contains(\"e\")) {\n         int firstIndex = s.indexOf(\"e\");\n         int lastIndex = s.lastIndexOf(\"e\");\n         if(lastIndex != firstIndex) {\n          return false;\n         }\n         try{\n          new BigDecimal(s.substring(0, firstIndex));\n          new BigInteger(s.substring(firstIndex + 1));\n          result = true;\n         } catch(Exception e) {\n             result = false;\n            }\n        }\n        return result;\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public boolean isNumber(String s) {\n        try{\n            int l=s.length();\n            if(s.equals(\"Infinity\")||s.equals(\"-Infinity\")||s.equals(\"+Infinity\")||s.charAt(l-1)=='f'||s.charAt(l-1)=='d'||s.charAt(l-1)=='D'||s.charAt(l-1)=='F')\n            return false;\n            double x=Double.parseDouble(s);\n            return true;\n        }\n        catch(Exception e){\n            return false;\n        }\n        \n    }\n}"
            },
            {
                "language": "javascript",
                "code": "function isNumber(s) {\n  return !/\\d/.test(s) && isNaN(+s[0]) ? false : !isNaN(+s);\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isNumber(string s) {\n        return is_valid_number(s);\n    }\n\nbool is_valid_number(const std::string& s) {\n    if (s.empty()) return false;\n\n    size_t i = 0;\n    if (s[i] == '+' || s[i] == '-') i++;\n\n    bool has_integer_part = false;\n    while (i < s.size() && isdigit(s[i])) {\n        has_integer_part = true;\n        i++;\n    }\n\n    bool has_decimal_part = false;\n    if (i < s.size() && s[i] == '.') {\n        i++;\n        while (i < s.size() && isdigit(s[i])) {\n            has_decimal_part = true;\n            i++;\n        }\n    }\n\n    if (i < s.size() && (s[i] == 'e' || s[i] == 'E')) {\n        i++;\n\n        if (i < s.size() && (s[i] == '+' || s[i] == '-')) i++;\n\n        if (i == s.size() || !isdigit(s[i])) {\n            return false;\n        }\n        while (i < s.size() && isdigit(s[i])) {\n            i++;\n        }\n    }\n    return i == s.size() && (has_integer_part || has_decimal_part);\n}\n};"
            },
            {
                "language": "typescript",
                "code": "public boolean isNumber(String s) {\n    s = s.trim();\n    \n    boolean pointSeen = false;\n    boolean eSeen = false;\n    boolean numberSeen = false;\n    boolean numberAfterE = true;\n    for(int i=0; i<s.length(); i++) {\n        if('0' <= s.charAt(i) && s.charAt(i) <= '9') {\n            numberSeen = true;\n            numberAfterE = true;\n        } else if(s.charAt(i) == '.') {\n            if(eSeen || pointSeen) {\n                return false;\n            }\n            pointSeen = true;\n        } else if(s.charAt(i) == 'e') {\n            if(eSeen || !numberSeen) {\n                return false;\n            }\n            numberAfterE = false;\n            eSeen = true;\n        } else if(s.charAt(i) == '-' || s.charAt(i) == '+') {\n            if(i != 0 && s.charAt(i-1) != 'e') {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n    \n    return numberSeen && numberAfterE;\n}"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public boolean isNumber(String s) {\n        s = s.trim();\n        boolean pointSeen = false;\n        boolean eSeen = false;\n        boolean numberSeen = false;\n        for(int i=0; i<s.length(); i++) {"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public boolean isNumber(String s) {\n        s = s.toLowerCase().trim();\n        boolean dotSeen = false;\n        boolean eSeen   = false;\n        boolean numberBeforeE = false;\n        boolean numberAfterE  = false;\n        for (int i = 0; i < s.length(); i++) {"
            },
            {
                "language": "java",
                "code": "public boolean isNumber(String s) {\n        \n        if (s == null || s.trim().length() == 0) return false;\n        \n        boolean seenNum = false;\n        boolean seenE = false;\n        boolean seenD = false;\n        "
            },
            {
                "language": "swift",
                "code": "class Solution {\n    public boolean isNumber(String s) {\n        return s.trim().matches(\"[-+]?(\\\\d+\\\\.?|\\\\.\\\\d+)\\\\d*(e[-+]?\\\\d+)?\");\n    }\n}"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        s = s.strip()\n        has_point, has_e, has_number = False, False, False\n        for i in range(len(s)):\n            if s[i].isdigit(): has_number = True\n            elif s[i] == '.':\n                if has_point or has_e: return False"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    bool isNumber(string s) {\n        bool dot = false, e = false, numBeforeE = false, numAfterE = false;\n        s = trim(s);\n        for(int i = 0; i < s.size(); i++) {\n            char c = s[i];\n            if(c >= '0' && c <= '9') {"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public boolean isNumber(String s) {\n        s = s.trim();\n\n        boolean pointSeen = false;\n        boolean eSeen = false;\n        boolean numberSeen = false;\n        boolean numberAfterE = false;"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n  def isNumber(self, s):\n      \"\"\"\n      :type s: str\n      :rtype: bool\n      \"\"\"\n      #define a DFA\n      state = [{}, \n              {'blank': 1, 'sign': 2, 'digit':3, '.':4}, \n              {'digit':3, '.':4},\n              {'digit':3, '.':5, 'e':6, 'blank':9},\n              {'digit':5},\n              {'digit':5, 'e':6, 'blank':9},\n              {'sign':7, 'digit':8},\n              {'digit':8},\n              {'digit':8, 'blank':9},\n              {'blank':9}]\n      currentState = 1\n      for c in s:\n          if c >= '0' and c <= '9':\n              c = 'digit'\n          if c == ' ':\n              c = 'blank'\n          if c in ['+', '-']:\n              c = 'sign'\n          if c not in state[currentState].keys():\n              return False\n          currentState = state[currentState][c]\n      if currentState not in [3,5,8,9]:\n          return False\n      return True"
            },
            {
                "language": "",
                "code": "if c not in stat[curretState].keys()"
            },
            {
                "language": "",
                "code": "if c not in state[currentState]"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        #define DFA state transition tables\n        states = [{},"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public boolean isNumber(String s) {\n        Map<Integer,Map<Character,Integer>> state = new HashMap<>();\n        for(int i=0;i<=10;i++) state.put(i,new HashMap<>());        \n        state.get(0).put('-',1); state.get(0).put('+',2); state.get(0).put('d',3); state.get(0).put('.',4); state.get(0).put('.',10);        \n        state.get(1).put('d',3); state.get(1).put('.',10);        \n        state.get(2).put('d',3); state.get(2).put('.',10);        \n        state.get(3).put('d',3); state.get(3).put('.',4); state.get(3).put('e',5);         "
            },
            {
                "language": "cpp",
                "code": "// States\n// 0: initial\n// 1: only dot\n// 2: number\n// 3: sign\n// 4: dot number\n// 5: e\n// 6: e sign"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        currState = 0\n        dfa = [\n            { 'digit': 1, 'dot': 5, 'sign': 6 },\n            { 'digit': 1, 'dot': 2, 'eE': 3 },\n            { 'digit': 2, 'eE': 3 },\n            { 'sign': 7, 'digit': 8 },\n            { 'digit': 4, 'eE': 3 },\n            { 'digit': 4 },\n            { 'dot': 5, 'digit': 1 },\n            { 'digit': 8 },\n            { 'digit': 8 }\n        ]\n\n        for c in s:\n            # print(c)\n            if c <= \"9\" and c >= \"0\":\n                c = 'digit'\n            elif c == \"e\" or c == \"E\":\n                c = 'eE'\n            elif c == \".\":\n                c = 'dot'\n            elif c == \"-\" or c == \"+\":\n                c = 'sign'\n            # print(c)\n            # print(currState)\n            if c in dfa[currState]:\n                # print(currState)\n                currState = dfa[currState][c]\n                # print(currState)\n            else:\n                return False\n\n        # print(currState)\n        return currState in (1,2,4,8)"
            },
            {
                "language": "swift",
                "code": "Patter maching concept:\n**Number Validation:**\n Pattern:[+-]?((\\\\d+)|((\\\\d+\\\\.)|(\\\\d+\\\\.\\\\d+)|(\\\\.\\\\d+)))(e[+-]?\\\\d+)?\n \n Program:\n import java.util.*;\nimport java.util.regex.*;\nclass Solution {\n    public boolean isNumber(String s) {\n    s=s.toLowerCase();\n     Pattern p=Pattern.compile(\"[+-]?((\\\\d+)|((\\\\d+\\\\.)|(\\\\d+\\\\.\\\\d+)|(\\\\.\\\\d+)))(e[+-]?\\\\d+)?\");\n     Matcher m=p.matcher(s);\n     boolean b=m.matches();\n     if(b)\n        {\n            return true;\n        }\n        return false;\n    }\n}\n "
            }
        ]
    },
    "65": {
        "question_id": 66,
        "title": "Plus One",
        "difficulty": 1,
        "description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.Increment the large integer by one and return the resulting array of digits. ",
        "examples": [
            {
                "input": "digits = [1,2,3]",
                "output": "[1,2,4]",
                "explanation": "The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4]."
            },
            {
                "input": "digits = [4,3,2,1]",
                "output": "[4,3,2,2]",
                "explanation": "The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2]."
            },
            {
                "input": "digits = [9]",
                "output": "[1,0]",
                "explanation": "The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0]."
            }
        ],
        "constraints": [
            "1 <= digits.length <= 100",
            "0 <= digits[i] <= 9",
            "digits does not contain any leading 0's."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& v) {\n        int n = v.size();\n        for(int i = n-1; i >= 0; i--){\n            if(i == n-1)\n                v[i]++;\n            if(v[i] == 10){\n                v[i] = 0;\n                if(i != 0){\n                    v[i-1]++;\n                }\n                else{\n                    v.push_back(0);\n                    v[i] = 1;\n                }\n            }\n        }\n        return v;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "for (int i = digits.length - 1; i >= 0; i--) {\n if (digits[i] < 9) {\n  digits[i]++;\n  return digits;\n }\n digits[i] = 0;\n}\n\ndigits = new int[digits.length + 1];\ndigits[0] = 1;\nreturn digits;"
            },
            {
                "language": "cpp",
                "code": "for (int i = digits.length - 1; i >= 0; i--) {\n if (digits[i] < 9) {\n  digits[i]++;\n  return digits;\n  // starting from extreme right--> if array[i] is less than 9 means can be added with 1\n  // i.e. [ 5,8 ]-->[ 5,9 ] or\n  //      [ 9,4 ]-->[ 9,5 ] or\n  //      [ 6,0 ]-->[ 6,1 ]\n  // and will directly return array\n }\n digits[i] = 0;\n // if array[i] is not less than 9, means it have to be 9 only then digit is changed to 0,\n // and we again revolve around loop to check for number if less than 9 or not\n // i.e. [ 5,9 ]-->[ 5,0 ]-loop->[ 6,0 ] or\n //      [ 1,9,9 ]-->[ 1,9,0 ]-loop->[ 1,0,0 ]-loop->[ 2,0,0 ]\n // and will directly return array\n}\n\n// if all number inside array are 9\n// i.e. [ 9,9,9,9 ] than according to above loop it will become [ 0,0,0,0 ]\n// but we have to make it like this [ 9,9,9,9 ]-->[ 1,0,0,0,0 ]\n\n\n// to make like above we need to make new array of length--> n+1\n// by default new array values are set to -->0 only\n// thus just changed first value of array to 1 and return the array\n\ndigits = new int[digits.length + 1];\ndigits[0] = 1;\nreturn digits;"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public int[] PlusOne(int[] digits) {\n        List<int> ans=new();\n        // start from least significant\n        int i=digits.Length-1;\n        bool easy=false;\n        while(i>-1){\n            if(digits[i]<9){\n                int x=i+1;\n                while(x<digits.Length){\n                    digits[x]=0;\n                    x++;\n                }\n                easy=true;\n                digits[i]++;\n                break;\n            }\n            i--;\n        }\n        if(easy)\n            return digits;\n        ans.Add(1);\n        foreach(var n in digits)\n            ans.Add(0);\n        return ans.ToArray();\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        vector<int> ans;\n        int n=digits.size();\n        int c=0;\n        \n        if(digits[n-1]==9){\n            c=1;\n            ans.push_back(0);\n        }\n        else{\n            ans.push_back(digits[n-1]+1);\n        }\n        for(int i=n-2;i>=0;i--){\n            if(c==1 && digits[i]==9){\n                ans.push_back(0);\n                c=1;\n            }\n            else if(c==1 && digits[i]<9){\n                ans.push_back(digits[i]+1);\n                c=0;\n            }\n            \n            else{\n                ans.push_back(digits[i]);\n            }\n        }\n        if(c==1 && digits[0]==9){\n            ans.push_back(1);\n        }\n        reverse(ans.begin(),ans.end());\n        return ans;\n        \n    }\n};"
            },
            {
                "language": "csharp",
                "code": "public int[] plusOne(int[] digits) {\n        \n    int n = digits.length;\n    for(int i=n-1; i>=0; i--) {\n        if(digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        }\n        \n        digits[i] = 0;\n    }\n    \n    int[] newNumber = new int [n+1];\n    newNumber[0] = 1;\n    \n    return newNumber;\n}"
            },
            {
                "language": "csharp",
                "code": "    public int[] PlusOne(int[] digits) \n    {\n        int carry = 1;\n        int index = digits.Length - 1;\n        while (index >= 0 && carry > 0)\n        {\n            digits[index] = (digits[index] + carry) % 10;\n            carry = digits[index] == 0 ? 1 : 0;"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n       int n = digits.size() - 1;\n      \n      for (int i = n; i >= 0; --i)\n      { \n        if (digits[i] == 9)\n            digits[i] = 0;\n      else\n      {  \n          digits[i] += 1;\n          return digits;\n        }\n      }\n      digits.push_back(0);\n      digits[0] = 1;\n      return digits;\n    } \n    \n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int[] plusOne(int[] digits) {\n        for (int i = digits.length - 1; i >= 0; i--) {\n if (digits[i] < 9) {\n  digits[i]++;\n  return digits;\n }\n digits[i] = 0;\n}\n\ndigits = new int[digits.length + 1];\ndigits[0] = 1;\nreturn digits;\n        \n    }\n}"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        s=int(\"\".join(str(i) for i in digits))+1\n        l=[]\n        while s!=0:\n            l.append(s%10)\n            s//=10\n        return reversed(l)"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        carry = 0\n        n = len(digits)\n        for i in reversed(range(n)):\n            val = digits[i] + carry + 1 if i == n-1 else digits[i] + carry\n            if val <= 9:\n                digits[i] = val\n                carry = 0\n            else:\n                carry = val // 10\n                val -= 10\n                digits[i] = val\n        if carry:\n            digits.insert(0, carry)\n        return digits"
            }
        ]
    },
    "66": {
        "question_id": 67,
        "title": "Add Binary",
        "difficulty": 1,
        "description": "Given two binary strings a and b, return their sum as a binary string. ",
        "examples": [
            {
                "input": "a = \"11\", b = \"1\"",
                "output": "\"100\"",
                "explanation": null
            }
        ],
        "constraints": [],
        "solutions": [
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n\n    string addBinary(string a, string b) {\n        \n        \n        if(b.size() > a.size()) swap(a,b);\n        \n        \n        while(b.size() < a.size()) b = \"0\" + b;\n\n        int carry = 0;\n\n        string res = \"\";\n\n        for(int i = b.size()-1; i >= 0 ; --i)\n        {\n             \n             if(b[i] == '1' && a[i]=='1')\n             {\n\n                if(carry == 0) res = \"0\" + res;\n                \n                else res = \"1\" + res;\n                    \n                carry = 1;\n             }\n\n             else if(b[i] =='0' && a[i] =='0')\n             {\n\n                if(carry == 0) res = \"0\" + res;\n                 \n                else\n                {\n                    res = \"1\" + res;\n                    carry = 0;\n                }\n             }\n\n             else if((b[i]=='0' && a[i]=='1') || (b[i]=='1' && a[i] == '0'))\n             {\n                 \n                if(carry == 0) res = \"1\" + res;\n                 \n                else res = \"0\" + res;\n                 \n             }\n             \n        }\n        \n        if(carry == 1) res = \"1\" + res;\n        \n        return res;\n    }\n};"
            },
            {
                "language": "java",
                "code": "StringBuilder sb = new StringBuilder();\nint carry = 0;\nint i = a.length() - 1;\nint j = b.length() - 1;"
            },
            {
                "language": "python",
                "code": "             # IMPORTANT INFO FOR YOU"
            },
            {
                "language": "java",
                "code": "{\n// First, create result name string and intially it is empty & in the end we gonna return it as our aswer\n        StringBuilder res = new StringBuilder(); \n        int i = a.length() - 1; // we crete i pointer for string a and we have to start adding from right to left \n        int j = b.length() - 1; // similar pointer j for string b\n        int carry = 0; // we create a carry, as we have to consider it as well"
            },
            {
                "language": "cpp",
                "code": "// iterate over the loop until the both condition become false\n        while(i >= 0 || j >= 0){ \n            int sum = carry; // intialise our sum with carry;\n            \n            // Now, we subtract by '0' to convert the numbers from a char type into an int, so we can perform operations on the numbers\n            if(i >= 0) sum += a.charAt(i--) - '0';\n            if(j >= 0) sum += b.charAt(j--) - '0';\n            // taking carry;\n            carry = sum > 1 ? 1 : 0; // getting carry depend on the quotient we get by dividing sum / 2 that will be our carry. Carry could be either 1 or 0 \n   // if sum is 0 res is 1 & then carry would be 0;\n            // if sum is 1 res is 1 & carry would be 0\n            // if sum is 2 res is 0 & carry would be 1\n            // if sum is 3 res is 1 & carry would be 1\n            res.append(sum % 2); // just moduling the sum so, we can get remainder and add it into our result\n        }"
            },
            {
                "language": "go",
                "code": "if(carry != 0) res.append(carry); // we gonna add it into res until carry becomes 0;\n        return res.reverse().toString(); // revese the answer we get & convt to string and return by the help of result;"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public String addBinary(String a, String b) {\n        StringBuilder res = new StringBuilder();\n        int i = a.length() - 1;\n        int j = b.length() - 1;\n        int carry = 0;\n        while(i >= 0 || j >= 0){\n            int sum = carry;\n            if(i >= 0) sum += a.charAt(i--) - '0';\n            if(j >= 0) sum += b.charAt(j--) - '0';\n            carry = sum > 1 ? 1 : 0;\n            res.append(sum % 2);\n        }\n        if(carry != 0) res.append(carry);\n        return res.reverse().toString();\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string res;\n        int i = a.length() - 1;\n        int j = b.length() - 1;\n        int carry = 0;\n        while(i >= 0 || j >= 0){\n            int sum = carry;\n            if(i >= 0) sum += a[i--] - '0';\n            if(j >= 0) sum += b[j--] - '0';\n            carry = sum > 1 ? 1 : 0;\n            res += to_string(sum % 2);\n        }\n        if(carry) res += to_string(carry);\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        res = \"\"\n        i, j, carry = len(a) - 1, len(b) - 1, 0\n        while i >= 0 or j >= 0:\n            sum = carry;\n            if i >= 0 : sum += ord(a[i]) - ord('0') # ord is use to get value of ASCII character\n            if j >= 0 : sum += ord(b[j]) - ord('0')\n            i, j = i - 1, j - 1\n            carry = 1 if sum > 1 else 0;\n            res += str(sum % 2)\n\n        if carry != 0 : res += str(carry);\n        return res[::-1]"
            },
            {
                "language": "go",
                "code": "def addBinary(self, a: str, b: str) -> str:\n    # Make a and b in equal length by appding 0 to the start of small string so traversing will be easier\n    diff = abs(len(a)-len(b))\n    a = \"0\"*diff*(len(a)<len(b)) + a\n    b = \"0\"*diff*(len(b)<len(a)) + b\n    \n    n = len(a)\n    res = []"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public String addBinary(String a, String b) {\n         int i = a.length() - 1, j = b.length() - 1, c = 0;\n StringBuilder sb = new StringBuilder();\n\n while (i >= 0 || j >= 0 || c == 1) {"
            },
            {
                "language": "",
                "code": "                    Please Upvote If You Find It Helpful"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string addBinary(string a, string b) {\n        int m = size(a), n = size(b);\n        int mn = max(m, n); // get the maximum length of a and b\n        string ans = string(mn+1, '0'); // create a string to store the sum, initialized with mn+1 zeroes\n        for(int i = m-1, j = n-1, k = mn; k > 0; i--, j--, k--) {\n            // loop through a, b, and ans starting from the rightmost digit\n            int sum = (i >= 0 ? a[i]-'0' : 0) + (j >= 0 ? b[j]-'0' : 0) + (ans[k]-'0'); \n            // get the sum of the current digits in a, b, and ans (converted from chars to ints)\n            ans[k] = (sum % 2) + '0'; // set the current digit in ans as 0 or 1\n            ans[k-1] = (sum / 2) + '0'; // set the next digit in ans for any carry\n        }\n        if(ans[0] == '0') ans.erase(ans.begin()); // Remove leading zero if present\n        return ans; // return the final sum as a string\n    }\n};"
            },
            {
                "language": "python",
                "code": "  class Solution {\npublic:\n string addBinary(string a, string b) {\n    int i=a.size()-1,j=b.size()-1,carry=0,sum=0;\n    string ans;\n    while(i>=0||j>=0){\n     sum=carry;\n     if(i>=0){\n      sum+=(a[i]-'0');\n      i--;\n     }\n     if(j>=0){\n      sum+=(b[j]-'0');\n      j--;\n     }\n     if(sum>1){\n      ans+=to_string(sum%2);\n      carry=1;\n     }\n     else{\n      carry=0;\n      ans+=to_string(sum);\n     }\n    }\n    if(carry==1)\n    {\n    ans+=(\"1\");\n    }\n    reverse(ans.begin(),ans.end());\n    return ans;\n }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string addBinary(string a, string b) {\n        if(a.size() > b.size()){\n            string zeros(a.size()-b.size(), '0');\n            b = zeros + b;\n        }\n        else{\n            string zeros(b.size()-a.size(), '0');\n            a = zeros + a;\n        }\n        string ans(a.size(),'0');\n        int carry=0;\n        for(int i=a.size()-1; i>=0; i--){\n            if((a[i]=='1' && b[i]=='1')){\n                if(carry==1){\n                    ans[i] = '1';\n                }\n                carry=1;\n            }\n            else if(a[i]=='0' && b[i]=='0'){\n                if(carry==1){\n                    ans[i] ='1';\n                }\n                carry=0;\n            }\n            else{\n                if(carry==1){\n                    ans[i] = '0';\n                    carry=1;\n                }\n                else{\n                    ans[i] = '1';\n                    carry=0;\n                }\n            }\n        }\n        if(carry==1){\n            ans = '1' + ans;\n        }\n        \n\n        return ans;\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string addBinary(string a, string b) {\n        int c=0;\n        string s=\"\";\n        int i=0;\n        while(i<a.length() || i<b.length() || c!=0){\n            int x=0;\n            if(i<a.length() && a[a.length()-i-1]=='1')\n                x=1;\n            int y=0;\n            if(i<b.length() && b[b.length()-1-i]=='1')\n                y=1;\n            s=to_string((x+y+c)%2)+s;\n            c=(x+y+c)/2;\n            i++;\n        }\n        return s;\n    }\n};"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public String addBinary(String a, String b) {\n        StringBuilder sb=new StringBuilder();\n        int i=a.length()-1,j=b.length()-1,c=0;\n        while(i>-1 || j>-1){\n            int sum=((i>-1)?a.charAt(i--)-'0':0)+((j>-1)?b.charAt(j--)-'0':0);\n            sb.append((sum+c)%2);\n            c=(sum+c<2)?0:1;\n        }\n        if(c==1)   sb.append(1);\n        return sb.reverse().toString();\n    }\n}"
            }
        ]
    },
    "67": {
        "question_id": 68,
        "title": "Text Justification",
        "difficulty": 3,
        "description": "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.For the last line of text, it should be left-justified, and no extra space is inserted between words.Note:A word is defined as a character sequence consisting of non-space characters only.Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.The input array words contains at least one word. ",
        "examples": [
            {
                "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\nOutput:\n[\n\u00a0 \u00a0\"This \u00a0 \u00a0is \u00a0 \u00a0an\",\n\u00a0 \u00a0\"example \u00a0of text\",\n\u00a0 \u00a0\"justification. \u00a0\"\n",
                "output": "ords = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\nOutput:\n[\n\u00a0 \u00a0\"This \u00a0 \u00a0is \u00a0 \u00a0an\",\n\u00a0 \u00a0\"example \u00a0of text\",\n\u00a0 \u00a0\"justification. \u00a0\"\n",
                "explanation": null
            },
            {
                "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\nOutput:\n[\n\u00a0 \"What \u00a0 must \u00a0 be\",\n\u00a0 \"acknowledgment \u00a0\",\n\u00a0 \"shall be \u00a0 \u00a0 \u00a0 \u00a0\"\n]\nExplanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word",
                "output": "ords = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\nOutput:\n[\n\u00a0 \"What \u00a0 must \u00a0 be\",\n\u00a0 \"acknowledgment \u00a0\",\n\u00a0 \"shall be \u00a0 \u00a0 \u00a0 \u00a0\"\n]",
                "explanation": "Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word"
            },
            {
                "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\nOutput:\n[\n\u00a0 \"Science \u00a0is \u00a0what we\",\n  \"understand \u00a0 \u00a0 \u00a0well\",\n\u00a0 \"enough to explain to\",\n\u00a0 \"a \u00a0computer. \u00a0Art is\",\n\u00a0 \"everything \u00a0else \u00a0we\",\n\u00a0 \"do \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"\n",
                "output": "ords = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\nOutput:\n[\n\u00a0 \"Science \u00a0is \u00a0what we\",\n  \"understand \u00a0 \u00a0 \u00a0well\",\n\u00a0 \"enough to explain to\",\n\u00a0 \"a \u00a0computer. \u00a0Art is\",\n\u00a0 \"everything \u00a0else \u00a0we\",\n\u00a0 \"do \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"\n",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= words.length <= 300",
            "1 <= words[i].length <= 20",
            "words[i] consists of only English letters and symbols.",
            "1 <= maxWidth <= 100",
            "words[i].length <= maxWidth"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\n        vector<string> res;\n        const int n = words.size();\n        int begin = 0, len = 0;\n        for (int i = 0; i < n; ++i) {\n            if (len + words[i].size() + (i - begin) > maxWidth) {\n                res.emplace_back(connect(words, maxWidth, begin, i, len, false));\n                begin = i;\n                len = 0;\n            }\n            len += words[i].size();\n        }\n        res.emplace_back(connect(words, maxWidth, begin, n, len, true));\n        return res;\n    }\nprivate:\n    string connect(const vector<string>& words, int maxWidth,\n                   int begin, int end, int len,\n                   bool is_last) {\n        string s;\n        int n = end - begin;\n        for (int i = 0; i < n; ++i) {\n            s += words[begin + i];\n            addSpaces(i, n - 1, maxWidth - len, is_last, &s);\n        }\n        if (s.size() < maxWidth) {\n            s.append(maxWidth - s.size(), ' ');\n        }\n        return s;\n    }\n    void addSpaces(int i, int spaceCnt, int maxWidth, bool is_last, string *s) {\n        if (i < spaceCnt) {\n            int spaces = is_last ? 1 : maxWidth / spaceCnt + (i < maxWidth % spaceCnt);\n            s->append(spaces, ' ');\n        }\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "string justify(const vector<string>& words, int start, int end, int space, bool isLast) {\n    string line;\n    if (!isLast) {\n        // eg: \"Science  is  what we\" maxwidth = 20\n        // characters: 7 + 2 + 4 + 2 = 15\n        // left = 20 - 15 = 5\n        // 5/3 => 5 % 3 != 0? => space 1 = 5/3 + 1 = 2\n        // 3/2 -> 3 % 2 != 0? => space 2 = 3/2 + 1 = 2\n        // 1 => space 3 = 1\n  int count = end - start - 1;  // number of space slots = number of words - 1\n        for (int i = start; i < end; ++i) {\n            line += words[i];\n            if (count > 0) {\n                int cur = space % count != 0? space/count + 1: space/count;\n                line.insert(line.end(), cur, ' ');\n                space -= cur;\n                --count;\n            }\n        }\n    } else {\n        for (int i = start; i < end; ++i) {\n            line += words[i];\n            if (space-- > 0) line.push_back(' ');\n        }\n\n    }\n    if (space > 0) line.insert(line.end(), space, ' ');\n    return line;\n}"
            },
            {
                "language": "java",
                "code": "    public List<String> fullJustify(String[] words, int maxWidth) {\n        int left = 0; List<String> result = new ArrayList<>();\n        \n        while (left < words.length) {\n            int right = findRight(left, words, maxWidth);\n            result.add(justify(left, right, words, maxWidth));\n            left = right + 1;\n        }\n        \n        return result;\n    }\n    \n    private int findRight(int left, String[] words, int maxWidth) {\n        int right = left;\n        int sum = words[right++].length();\n        \n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\n            sum += 1 + words[right++].length();\n            \n        return right - 1;\n    }\n    \n    private String justify(int left, int right, String[] words, int maxWidth) {\n        if (right - left == 0) return padResult(words[left], maxWidth);\n        \n        boolean isLastLine = right == words.length - 1;\n        int numSpaces = right - left;\n        int totalSpace = maxWidth - wordsLength(left, right, words);\n        \n        String space = isLastLine ? \" \" : blank(totalSpace / numSpaces);\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\n        \n        StringBuilder result = new StringBuilder();\n        for (int i = left; i <= right; i++)\n            result.append(words[i])\n                .append(space)\n                .append(remainder-- > 0 ? \" \" : \"\");\n        \n        return padResult(result.toString().trim(), maxWidth);\n    }\n    \n    private int wordsLength(int left, int right, String[] words) {\n        int wordsLength = 0;\n        for (int i = left; i <= right; i++) wordsLength += words[i].length();\n        return wordsLength;\n    }\n    \n    private String padResult(String result, int maxWidth) {\n        return result + blank(maxWidth - result.length());\n    }\n    \n    private String blank(int length) {\n        return new String(new char[length]).replace('\\0', ' ');\n    }"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        int left = 0; List<String> result = new ArrayList<>();\n        \n        while (left < words.length) {\n            int right = findRight(left, words, maxWidth);"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> ans = new ArrayList<>();\n        int begin = 0;\n        while(begin < words.length){\n            int end = findWordsForLine(begin, maxWidth, words);\n            ans.add(justifyLine(begin, end, maxWidth, words));\n();\n();"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> result = new ArrayList<>();\n        \n        int start = 0;\n        int end = 0;\n        while (start < words.length) {\n            end = findLastWordIndex(words, start, maxWidth);"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\n        int n=words.size(), left=0, right=0, size=0;\n        vector<string> result;\n        \n        while(left<n){\n            right=findRight(words, maxWidth, left, size);"
            },
            {
                "language": "python",
                "code": "def fullJustify(self, words, maxWidth):\n    res, cur, num_of_letters = [], [], 0\n    for w in words:\n        if num_of_letters + len(w) + len(cur) > maxWidth:\n            for i in range(maxWidth - num_of_letters):\n                cur[i%(len(cur)-1 or 1)] += ' '\n            res.append(''.join(cur))\n            cur, num_of_letters = [], 0\n        cur += [w]\n        num_of_letters += len(w)\n    return res + [' '.join(cur).ljust(maxWidth)]"
            },
            {
                "language": "python",
                "code": "for i in range(maxWidth - num_of_letters):\n                cur[i%(len(cur)-1 or 1)] += ' '"
            },
            {
                "language": "python",
                "code": "def fullJustify(self, words, maxWidth):\n    res, cur, num_of_letters = [], [], 0\n    for w in words:\n        if num_of_letters + len(w) + len(cur) > maxWidth:\n            if len(cur) == 1:\n                res.append( cur[0] + ' '*(maxWidth - num_of_letters) )\n            else:\n                num_spaces = maxWidth - num_of_letters\n                space_between_words, num_extra_spaces = divmod( num_spaces, len(cur)-1)\n                for i in range(num_extra_spaces):\n                    cur[i] += ' '\n                res.append( (' '*space_between_words).join(cur) )\n            cur, num_of_letters = [], 0\n        cur += [w]\n        num_of_letters += len(w)\n    res.append( ' '.join(cur) + ' '*(maxWidth - num_of_letters - len(cur) + 1) )\n    return res"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n            \n        result, current_list, num_of_letters = [],[], 0\n        # result -> stores final result output\n        # current_list -> stores list of words which are traversed but not yet added to result\n        # num_of_letters -> stores number of chars corresponding to words in current_list"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> result = new ArrayList();\n        List<StringBuilder> current = new ArrayList();\n        int numOfLetters = 0;\n        \n        for(String word : words) {\n            StringBuilder w = new StringBuilder(word);"
            },
            {
                "language": "python",
                "code": "# can put spaces only between letters\nidx = 0 if len(curr_line) == 1 else i % (len(curr_line)-1)\ncurr_line[idx] += ' '"
            },
            {
                "language": "python",
                "code": "    def fullJustify(self, words, max_wid: int):\n        res, tmp = [], []\n        char_len = 0\n        for word in words:\n            len_word = len(word)\n            if char_len + len_word + len(tmp) - 1 >= max_wid:\n                st_res = self.make_str(tmp, char_len, max_wid)\n                res.append(st_res)"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    # round robin for distributing spaces\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        res, cur = [], []\n        num_letters = 0\n        for w in words:\n            # if there isn't enough space this word\n            # num_letters + num_spaces + len_w"
            },
            {
                "language": "python",
                "code": "if num_of_letters + len(w) + len(cur) > maxWidth:"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        if (words == null || words.length == 0 || maxWidth <= 0) {\n            return new ArrayList<String>();\n        }\n\n        List<String> result = new ArrayList<String>();\n        List<String> row = new ArrayList<String>();\n        int index = 0, len = 0;\n        while (index < words.length) {\n            String word = words[index];\n            if ((row.size() == 0 && len + word.length() > maxWidth) \n                || (row.size() > 0 && len + word.length() + 1 > maxWidth)) {\n                result.add(formatHelper(row, len, maxWidth, false));\n                row = new ArrayList<String>();\n                len = 0;\n            } else {\n                row.add(word);\n                if (len == 0) {\n                    len += word.length();\n                } else {\n                    len += (word.length() + 1);\n                }\n                index++;\n            }\n        }\n        if (!row.isEmpty()) {\n            result.add(formatHelper(row, len, maxWidth, true));\n        }\n        return result;\n    }\n\n    private String formatHelper(List<String> row, int len, int maxWidth, boolean isLastRow) {\n        StringBuilder result = new StringBuilder();\n        int diff = maxWidth - len;\n        int interLen = (row.size() > 1) ? (diff / (row.size() - 1)) : diff;\n        StringBuilder interString = new StringBuilder();\n        for (int i = 0; i < interLen; i++) {\n            interString.append(\" \");\n        }\n        int largerInterCount = diff - interLen * (row.size() == 1 ? 1 : (row.size() - 1));\n        for (int i = 0; i < row.size(); i++) {\n            result.append(row.get(i));\n            if (isLastRow) {\n                if (i < row.size() - 1) {\n                    result.append(\" \");\n                }\n            } else if (i < row.size() - 1 || row.size() == 1) {\n                if (i < row.size() - 1) {\n                    result.append(\" \");\n                }\n                result.append(interString);\n                if (largerInterCount-- > 0) {\n                    result.append(\" \");\n                }\n            }\n        }\n        if (isLastRow) {\n            while (result.length() < maxWidth) {\n                result.append(\" \");\n            }\n        }\n        return result.toString();\n    }\n}"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n # Why slots: https://docs.python.org/3/reference/datamodel.html#slots\n    # TLDR: 1. faster attribute access. 2. space savings in memory.\n    # For letcode problems this can save ~ 0.1MB of memory <insert is something meme>\n    __slots__ = ()\n \n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n     # Init return array in which, we'll store justified lines\n        lines = []\n  # current line width\n        width = 0\n  # current line words\n        line = []\n        \n        for word in words:\n   # Gather as many words that will fit under maxWidth restrictions.\n   # Line length is a sum of:\n   # 1) Current word length\n   # 2) Sum of words already in the current line\n   # 3) Number of spaces (each word needs to be separated by at least one space)\n            if (len(word) + width + len(line)) <= maxWidth:\n                width += len(word)\n                line.append(word)\n                continue\n            \n   # If the current line only contains one word, fill the remaining string with spaces.\n            if len(line) == 1:\n    # Use the format function to fill the remaining string with spaces easily and readable.\n    # For letcode police, yes you could do something like:\n    #     line = \" \".join(line)\n    #     line += \" \" * (maxWidth - len(line))\n    #     lines.append(line)\n    # to be more \"raw\", but I see no point in that.\n                lines.append(\n                    \"{0: <{width}}\".format( \" \".join(line), width=maxWidth)\n                )\n            else:\n       # Else calculate how many common spaces and extra spaces are there for the current line.\n    # Example:\n                #  line = ['a', 'computer.', 'Art', 'is']\n    # width left in line equals to: maxWidth - width: 20 - 15 = 5\n    # len(line) - 1 because to the last word, we aren't adding any spaces\n    # Now divmod will give us how many spaces are for all words and how many extra to distribute.\n    # divmod(5, 3) = 1, 2\n    # This means there should be one common space for each word, and for the first two, add one extra space.\n                space, extra = divmod(\n                    maxWidth - width,\n                    len(line) - 1\n                )\n                \n                i = 0\n    # Distribute extra spaces first\n    # There cannot be a case where extra spaces count is greater or equal to number words in the current line.\n                while extra > 0:\n                    line[i] += \" \"\n                    extra -= 1\n                    i += 1\n                \n    # Join line array into a string by common spaces, and append to justified lines.\n                lines.append(\n                    (\" \" * space).join(line)\n                )\n            \n   # Create new line array with the current word in iteration, and reset current line width as well.\n            line = [word]\n            width = len(word)\n        \n  # Last but not least format last line to be left-justified with no extra space inserted between words.\n  # No matter the input, there always be the last line at the end of for loop, which makes things even easier considering the requirement.\n        lines.append(\n            \"{0: <{width}}\".format(\" \".join(line), width=maxWidth)\n        )\n        \n        return lines"
            },
            {
                "language": "python",
                "code": "if len(words) == 1:\n      return [words[0].ljust(maxWidth)]"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        res = []\n        i = 0\n        while i < len(words):\n            j, total_len = i, 0\n            while j < len(words) and total_len + len(words[j]) + j - i <= maxWidth:\n                total_len += len(words[j])\n                j += 1\n            if j == len(words):\n                res.append(\" \".join(words[i:j]) + \" \" * (maxWidth - total_len - (j - i - 1)))\n            else:\n                spaces = maxWidth - total_len\n                slots = j - i - 1\n                if slots == 0:\n                    res.append(words[i] + \" \" * spaces)\n                else:\n                    spaces_per_slot = spaces // slots\n                    extra_spaces = spaces % slots\n                    line = words[i]\n                    for k in range(i + 1, j):\n                        line += \" \" * (spaces_per_slot + (1 if extra_spaces > 0 else 0))\n                        extra_spaces -= 1\n                        line += words[k]\n                    res.append(line)\n            i = j\n        return res"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        # list to store the justified lines\n        justified_lines = []\n        # list to store the current line of words\n        line = []\n        # length of the current line\n        line_length = 0\n        # loop through all words\n        for word in words:\n            # if adding the current word to the line and a space would exceed the maxWidth\n            if line_length + len(word) + len(line) > maxWidth:\n                # calculate the number of spaces needed to be added to the line\n                spaces = maxWidth - line_length\n                # distribute the spaces as evenly as possible between the words\n                for i in range(spaces):\n                    line[i % (len(line) - 1 or 1)] += ' '\n                # add the line to the justified_lines list\n                justified_lines.append(''.join(line))\n                # reset line and line_length for the next line\n                line = []\n                line_length = 0\n            # add the current word to the line\n            line.append(word)\n            line_length += len(word)\n        # handle the last line, which is left-justified\n        last_line = ' '.join(line)\n        last_line += ' ' * (maxWidth - len(last_line))\n        justified_lines.append(last_line)\n        return justified_lines"
            },
            {
                "language": "",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "    vector<string> fullJustify(vector<string>& words, int maxWidth) {\n        vector<string> result; //result vector which will store each line\n        string output = words[0]; //add first word to output string\n        for (int i = 1; i<words.size(); i++){\n            if(output.length() + words[i].length() + 1 <= maxWidth) //+1 for space \n   \n     output += \" \"+words[i]; //add space before adding word\n            \n            else{ \n      //this else will be executed when current line can't add current words \n                output = spaceJustifier(output, maxWidth, 0); //formatting space before adding it to result \n                result.push_back(output);\n                //now we added output to result vector now we can start a new line \n                output = words[i]; //add current word to output(start of new line)\n            }\n        }\n        //the above loop will not add last line to result because last line to will always satify (output.length()+words[i].length()+1<=maxWidth) condition\n        output = spaceJustifier(output, maxWidth, 1); //justifying spaces in last line\n        result.push_back(output); //adding last line to result array\n        return result;\n    }"
            },
            {
                "language": "java",
                "code": "string spaceJustifier(string str, int maxWidth, int isLast){\n    //condition if line length is equal to maxWidth so return line as it is.\n    if(str.length() == maxWidth)\n        return str;\n    \n    int spacesInString = 0; //count total spaces in the line \n    for(int i = 0; i<str.length(); i++){\n        if(str[i] == ' ')\n            spacesInString++;\n    }\n    int spacesToBeInserted = maxWidth - str.length(); //spaces to be inserted will be maxWidth - line length\n    //Left Justifier \n    //if line has only 1 word(number of spaces in one word is 0 ex \"hi\") || it's last line then left justify the line\n    if(spacesInString == 0 || isLast == 1){ \n        str.insert(str.length(), spacesToBeInserted,' '); //insert required spaces in right of line ex \"do                  \"\n        return str;\n    }\n    int eachSlot = spacesToBeInserted / spacesInString; \n    int leftOverSpace = spacesToBeInserted % spacesInString; \n    //EXPLANATION FOR EACH SLOT\n    //(spacesToBeInserted / spacesInString) will tell us how much space should we insert at eachSlot\n    //ex - (spacesToBeInserted = 6)/(spaces in string = 2) then each slot will get 3 extra spaces ex - \"hi_hi\" => \"hi_ _ _ _hi_ _ _ _\" will be output\n    \n    //EXPLANATION FOR LEFT OVER SPACE\n    //when the spacesToBeInserted is not divisibe by spacesInString \n    //EX if we spacesToBeInserted = 5 and spaces in string = 2.\n    //since 5/2 is not fully Divisble we will find remainder 5%2 to get left overspace.\n    \n    \n    //EX - so_fine_That_all_the. and maxWidth is 25\n    //      in above case spacesToBeInserted = 5 and spaces in stirng = 4.\n    //      eachSlot will be 5/4 is 1. ie increase spaces by 1 \n    \n    //output will be -> so_ _fine_ _That_ _all_ _the\n    \n    //      since 5/4 is not fully divisible. we will find leftOverSpaces = 5%4 = 1;\n    //      this leftOverSpace will be distributed from left to right ie each slot will get 1,1,1 from left to right\n    \n    //output will be -> so_ _ _fine_ _That_ _all_ _the\n    //                        \u2191\n    //                    leftOverSpace added \n    \n    //if we had more leftoverspaces then it will be added to next slot.\n    \n    for(int i = 0; i<str.length(); i++){\n        if(str[i] == ' ' && (eachSlot > 0 || leftOverSpace >0 )){ //we add spaces till (eachSlot > 0 || leftOverSpace >0)\n            //required noOfSpaces = eachSlot + (leftOverSpace-- > 0 ? 1:0)\n            //((leftOverSpace--) > 0 ? 1:0) will return 1 if leftoverspace>0.\n            //(leftOverSpace--) post decrement\n            int noOfSpaces = eachSlot + ((leftOverSpace--) > 0 ? 1:0);\n            str.insert(i, noOfSpaces , ' '); //inserting spaces\n            i+=noOfSpaces;   //increament count with no of spaces inserted each time \n        }\n        \n    }\n    return str;\n}"
            },
            {
                "language": "",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n vector<string> fullJustify(vector<string>& words, int maxWidth) {\n  int n = words.size();\n  vector<string> ans;\n  int i = 0;\n  while (i < n) {\n   int j = i, numOfWord = 0, spaceBetween = 0;\n   while (j < n && maxWidth >= (numOfWord + spaceBetween + words[j].size())) {\n    numOfWord += words[j].size();\n    spaceBetween++;\n    j++;\n   }\n   spaceBetween--;\n   string res = \"\";\n   int rem = maxWidth - numOfWord;\n   int numOfSpace = spaceBetween <= 0 ? 0 : rem / spaceBetween;\n   int extraSpace = spaceBetween <= 0 ? 0 : rem % spaceBetween;\n   if (j == n) {\n    numOfSpace = 1;\n    extraSpace = 0;\n   }\n   while (i < n && i < j) {\n    res += words[i];\n    int k = 0;\n    while (spaceBetween > 0 && k < numOfSpace) {\n     res += \" \";\n     k++;\n    }\n    spaceBetween--;\n    if (extraSpace > 0) {\n     res += \" \";\n     extraSpace--;\n    }\n    i++;\n   }\n   while (res.size() != maxWidth) res += \" \";\n   ans.push_back(res);\n  }\n  return ans;\n }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> result=new ArrayList<>();\n        int n = words.length;\n        int i=0,j,lineLength;\n        while(i<n){\n            j=i+1;\n            lineLength=words[i].length();\n          while(j<n&&(lineLength+words[j].length()+(j-i-1)<maxWidth))\n            {\n              lineLength+=words[j].length();\n              j++;\n            }\n          int diff =maxWidth-lineLength;\n          int noOfWords=j-i;\n            if(noOfWords==1||j>=n)\n                result.add(leftJustify(diff,noOfWords,words,i,j));\n            else\n                result.add(middleJustify(diff,noOfWords,words,i,j));\n            i=j;\n        }\n        return result;\n    }\n    public static String leftJustify(int diff,int noOfWords,String[] words,int i,int j)\n    {\n        StringBuilder  leftJustifyAns = new StringBuilder(words[i]);\n        int spacesOnRight=diff-(j-i-1);\n        for(int k=i+1;k<j;k++){\n           leftJustifyAns.append(\" \"+words[k]);\n        }\n       leftJustifyAns.append(\" \".repeat(spacesOnRight));\n        return  leftJustifyAns.toString();\n    }\n    public static String middleJustify(int diff,int noOfWords,String[] words,int i,int j)\n    {\n         StringBuilder  middleJustifyAns = new StringBuilder(words[i]);\n       \n        int spacesNeeded= j-i-1;\n        int spaces =diff/spacesNeeded;\n        int extraSpaces = diff%spaces;\n        for(int k=i+1;k<j;++k){\n            int spacesToApply=spaces+(extraSpaces-- > 0 ? 1 : 0);\n            middleJustifyAns.append(\" \".repeat(spacesToApply)+words[k]);\n        }\n        return  middleJustifyAns.toString();\n    }\n    \n}"
            }
        ]
    },
    "68": {
        "question_id": 69,
        "title": "Sqrt(x)",
        "difficulty": 1,
        "description": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.You must not use any built-in exponent function or operator.For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python. ",
        "examples": [
            {
                "input": "x = 4",
                "output": "2",
                "explanation": "The square root of 4 is 2, so we return 2."
            },
            {
                "input": "x = 8",
                "output": "2",
                "explanation": "The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned."
            }
        ],
        "constraints": [
            "0 <= x <= 231 - 1"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int mySqrt(int x) {\n        if (x == 0)\n            return x;\n        int first = 1, last = x;\n        while (first <= last) {\n            int mid = first + (last - first) / 2;\n            // mid * mid == x gives runtime error\n            if (mid  == x / mid)\n                return mid;\n            else if (mid > x / mid) {\n                last = mid - 1;\n            }\n            else {\n                first = mid + 1;\n            }\n        }\n        return last;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    long long int mySqrt(long long int x) {\n        \n        long long int low = 0, high = x;\n\n        int ans;\n        while(low<=high){\n            if(x==0) ans = 0;\n\n            long long int mid = low + (high-low)/2;\n            long long int sq = mid*mid;\n\n            if(sq==x) return mid;\n\n            else if(sq>x) high = mid-1;\n\n            else {\n                low = mid+1;\n                ans = mid;\n            }\n\n\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n\n    int mySqrt(int x) {\n         int l=0,h=x;\n         int ans;\n        while(l<=h){\n\n           long long int mid=l+(h-l)/2;\n           long long int sq=mid*mid;\n\n           if(sq==x){\n               ans=mid;\n               break;\n            }\n            else if(sq<x){\n                //mid=ans;\n                l=mid+1;\n            }\n            else{\n                h=mid-1;\n            }\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int mySqrt(int x) {\n        if(x==0) return 0;\n        int i=1;\n        for(;i<=x/i;i++) //using division instead of multiplication to avoid integer overflow\n            if(x/i==i)  return i;\n        return i-1; //returning (i-1) because at some point (i*i) became greater than x and loop stopped!!!\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int mySqrt(int x) {\n        if(x==0) return 0;\n        int low = 1,high = x,ans =0;\n        while(low<=high){\n            int mid =low + (high-low)/2;\n            if(x/mid==mid)  return mid;\n            else if(x/mid<mid)   high=mid-1;\n            else {low = mid+1; ans = mid;}\n        }\n        return ans;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "int mySqrt(int x){\nif(x<=pow(2,31)-1)\n{\n    return sqrt(x);\n}\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int mySqrt(int x) {\n        int low = 1;\n        int high = x;\n        while(low <= high){\n            long long int mid = low +(high-low)/2;\n            if(mid * mid == x){\n                return mid;\n            }if(mid * mid < x){\n                low = mid +1;\n            }else{\n                high = mid-1;\n            }\n        }\n    return high;}\n};"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        if x < 2:\n            return x;\n        low, high = 1, x\n        while low <= high:\n            mid = (low + high) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return high"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int mySqrt(int num) {\n        int high=num,low=0;\n        while(high>low){\n            long int mid = low + ((long int)high - low + 1) / 2;\n            if(mid<=sqrt(num))\n                low = mid;\n            else\n                high = mid -1;\n        }\n        return low;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\n    public int MySqrt(int x) {\n        double i=0;\n        while(i*i<=x)\n        {\n            \n            if( (i*i) <= x && (i+1)*(i+1) > x)\n                return (int)i;\n                i++;\n        }\n        return 0;\n    }\n}"
            },
            {
                "language": "typescript",
                "code": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        number=1\n        while number*number<=x:\n            number+=1\n        return number"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        left,right=1,x\n        while left<=right:\n            mid=(left+right)//2\n            if mid*mid==x:\n                return mid\n            if mid*mid>x:\n                right=mid-1\n            else:\n                left=mid+1\n        return right\n    "
            }
        ]
    },
    "69": {
        "question_id": 70,
        "title": "Climbing Stairs",
        "difficulty": 1,
        "description": "You are climbing a staircase. It takes n steps to reach the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? ",
        "examples": [
            {
                "input": "n = 2",
                "output": "2",
                "explanation": "There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps"
            },
            {
                "input": "n = 3",
                "output": "3",
                "explanation": "There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step"
            }
        ],
        "constraints": [
            "1 <= n <= 45"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void solve(int n,vector<int> &dp){\n        //base case\n        if(n<=2)\n          return n;\n        \n        if(dp[n]!=-1) \n          return dp[n]; \n        \n        dp[n]=solve(n-1)+solve(n-2);\n        return dp[n];\n    }\n    int climbStairs(int n) {\n        if(n<=2)\n         return n;\n        vector<int> dp(n+1);\n        for(int i=0;i<=n;i++)\n         dp[i]=-1;\n        \n        return solve(n,dp);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int climbStairs(int n) {\n        if(n<=2)\n         return n;\n        vector<int> dp(n+1);\n        dp[0]=0;\n        dp[1]=1;\n        dp[2]=2;\n        for(int i=3;i<=n;i++)\n         dp[i]=dp[i-1]+dp[i-2];\n        \n        return dp[n];\n    }\n};"
            },
            {
                "language": "java",
                "code": "def climbStairs(self, n):\n        prev = 1\n        prev2 = 0\n        for i in range(1, n+1):\n            curi = prev + prev2\n            prev2 = prev\n            prev = curi\n        return prev "
            },
            {
                "language": "java",
                "code": "    def climbStairs(self, n):\n        prev = 1\n        prev2 = 0\n        for i in range(1, n+1):\n            curi = prev + prev2\n            prev2 = prev\n            prev = curi"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        one,two=1,1\n        for i in range(n-1):\n            temp=one+two\n            one=two\n            two=temp\n        return two\n    #please upvote me it would encourage me alot"
            },
            {
                "language": "kotlin",
                "code": "if(n==0 or n==1) {\n    return 1\n}\nreturn f(n-1)+f(n-2)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int findWays(int n){\n        if(n<=1) return 1; //base case\n        return findWays(n-1)+findWays(n-2);\n    }\n\n    int climbStairs(int n) {\n        return findWays(n);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int findWays(int n, vector<int> &dp)\n    {\n        if (n <= 1) return 1;\n        if (dp[n] != -1) return dp[n];//already solved subproblems\n        return dp[n]=findWays(n - 1, dp) + findWays(n - 2, dp); //store the result of subproblem in dp array\n    }\n    int climbStairs(int n) {\n        vector<int>dp(n+1,-1); //fill all values with -1\n        return findWays(n,dp);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int climbStairs(int n) {\n         vector<int>dp(n+1,-1);\n         dp[0]=1,dp[1]=1; //base cases\n         for(int i=2;i<=n;++i){\n             dp[i]=dp[i-1]+dp[i-2];\n         }\n        return dp[n];\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int climbStairs(int n) {\n        int prev2=1,prev1=1; //initally at 0th and 1st index\n        \n        for(int i=2;i<=n;i++){\n            int curr=prev1+prev2;\n            prev2=prev1; //update pointers\n            prev1=curr;\n        }\n        return prev1;\n    }\n};"
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function(n) {\n\n    if (n < 2) {\n\n        return 1;\n    }\n\n    let firstStep = 1;\n\n    let secondStep = 1;\n\n    let thirdStep = 0;\n\n    for (let i=2; i<=n; i++) {\n\n        thirdStep = firstStep + secondStep;\n\n        firstStep = secondStep;\n\n        secondStep = thirdStep;\n    }\n\n    return thirdStep;\n};"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        k1=0\n        k2=1\n        while n>0:\n            k1,k2=k2,k1+k2\n            n-=1\n\n        return k2"
            },
            {
                "language": "go",
                "code": "func climbStairs(n int) int {\n    \n    array := []int{}\n    array = append(array, 1)\n    array = append(array, 1)\n    \n    for i := 2; i < n + 1; i++{\n        array = append(array, (array[i-1] + array[i-2])) \n    }\n    \n    return array[n]\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int climbStairs(int n) {\n        if(n==1){\n            return 1;\n        }\n        if(n==2){\n            return 2;\n        }\n        int a=1;\n        int b=2;\n        for(int i=3;i<=n;i++){\n            b=a+b;\n            a=b-a;\n        }\n        return b;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "int climbStairs(int n){\n    int* dp = calloc(n + 2, sizeof(int));\n    dp[1] = 1;\n    dp[2] = 2;\n    \n    for (int i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n\n    int result = dp[n];\n    free(dp);\n\n    return result;\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    int climbStairs(int n) \n    {\n        vector <int> dp(n+1, 0);\n        dp[0] = 1;\n        dp[1] = 1;\n\n        for(int i = 2; i <= n; i++)\n            dp[i] = dp[i-1] + dp[i-2];\n\n        return dp[n];\n    }  \n};"
            }
        ]
    },
    "70": {
        "question_id": 71,
        "title": "Simplify Path",
        "difficulty": 2,
        "description": "Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.The canonical path should have the following format:The path starts with a single slash '/'.Any two directories are separated by a single slash '/'.The path does not end with a trailing '/'.The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')Return the simplified canonical path. ",
        "examples": [
            {
                "input": "path = \"/home/\"",
                "output": "\"/home\"",
                "explanation": "Note that there is no trailing slash after the last directory name."
            },
            {
                "input": "path = \"/../\"",
                "output": "\"/\"",
                "explanation": "Going one level up from the root directory is a no-op, as the root level is the highest level you can go."
            },
            {
                "input": "path = \"/home//foo/\"",
                "output": "\"/home/foo\"",
                "explanation": "In the canonical path, multiple consecutive slashes are replaced by a single one."
            }
        ],
        "constraints": [
            "1 <= path.length <= 3000",
            "path consists of English letters, digits, period '.', slash '/' or '_'.",
            "path is a valid absolute Unix path."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "class Solution {\n    public String simplifyPath(String path) {\n        Stack<String> s = new Stack<>();\n        StringBuilder res = new StringBuilder();\n        String[] p =path.split(\"/\");\n        \n        for(int i=0;i<p.length;i++){\n            if(!s.isEmpty()  && p[i].equals(\"..\")) s.pop();\n            else if(!p[i].equals(\"\") && !p[i].equals(\".\") && !p[i].equals(\"..\"))\n                s.push(p[i]);\n        }\n        \n        \n        if(s.isEmpty()) return \"/\";\n        while(!s.isEmpty()){\n            res.insert(0,s.pop()).insert(0,\"/\");\n        }\n        \n        return res.toString();\n    }\n}"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public String simplifyPath(String path) {\n        Deque<String> q = new ArrayDeque<>();\n        // iterate over string and add path to q\n        for(String in : path.split(\"/\")) {"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public String simplifyPath(String path) {\n        Stack<String>  stack=new Stack<>();\n        \n        for(int i=0;i<path.length();i++){\n            if(path.charAt(i)!='/'){\n                int a=i;\n                while(i<path.length() && path.charAt(i)!='/') i++;                        "
            },
            {
                "language": "csharp",
                "code": "1. Easy C++\n2. Line by Line Explanation with Comments.\n3. Detailed Explanation \u2705\n4. Stack Problem with Initution.\n5. Please Upvote if it helps\u2b06\ufe0f\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \u2b07\ufe0f\n // \ud83d\ude09If you Like the repository don't foget to star & fork the repository\ud83d\ude09"
            },
            {
                "language": "javascript",
                "code": "Input: path = \"/../\"\nOutput: \"/\"\nInput: path = \"/home//foo/\"\nOutput: \"/home/foo\""
            },
            {
                "language": "php",
                "code": "     // \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09Please upvote if it helps \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        \n        stack<string> st;\n        string res;\n        \n        for(int i = 0;  i<path.size(); ++i)\n        {\n            if(path[i] == '/')    \n                continue;\n            string temp;\n   // iterate till we doesn't traverse the whole string and doesn't encounter the last /\n            while(i < path.size() && path[i] != '/')\n            {\n    // add path to temp string\n                temp += path[i];\n                ++i;\n            }\n            if(temp == \".\")\n                continue;\n   // pop the top element from stack if exists\n            else if(temp == \"..\")\n            {\n                if(!st.empty())\n                    st.pop();\n            }\n            else\n   // push the directory file name to stack\n                st.push(temp);\n        }\n        \n  // adding all the stack elements to res\n        while(!st.empty())\n        {\n            res = \"/\" + st.top() + res;\n            st.pop();\n        }\n        \n  // if no directory or file is present\n        if(res.size() == 0)\n            return \"/\";\n        \n        return res;\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        levels, stack = path.split(\"/\"), []\n\n        for l in levels:\n            if len(l)>0 and l != '.':\n                if l == '..' and stack:\n                    stack.pop()\n                else if != '..':\n                    stack.append(l)\n        \n        return \"/\"+\"/\".join(stack)"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        stack = []\n        for directory in path.split(\"/\"):\n            if directory == \"\" or directory == \".\":\n                continue\n            elif directory == \"..\":\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(directory)\n        return \"/\" + \"/\".join(stack)"
            },
            {
                "language": "php",
                "code": "//TIME : O(N)\n//SPACE: O(N)\n\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        vector<string> arr;\n        int N = path.size();\n        int i = 1;\n        int j = 1;\n        while(j < N){\n            if(path[j] == '/'){\n                arr.push_back(path.substr(i,j-i));\n                //now point j to a non /\n                while(path[j]=='/'){\n                    j++;\n                }\n                i = j;\n            }\n            //else its not / \n            j++;\n        }\n        \n        if(i<N){\n            //Edge case = when there is no last back slash\n            arr.push_back(path.substr(i,j-i));\n        }\n        \n        stack<string> stk;\n        \n        for(auto s : arr){\n            if(stk.size()>0 && s==\"..\") stk.pop(); // as we move one step back in directory\n            else if(s != \"\" && s!= \".\" && s!=\"..\") stk.push(s);\n        }\n        \n        //edge case = when \"\" path is given\n        if(stk.empty()) return \"/\";\n        \n        //PATH FORMATION\n        string res=\"\";\n        while(!stk.empty()){\n           \n            res = '/' + stk.top() + res;\n            stk.pop();\n        }\n        \n        return res;\n    }\n};"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public String simplifyPath(String path) {\n        String[] split = path.trim().split(\"/\");\n        StringBuilder sb = new StringBuilder();\n        List<String> pathRes = new ArrayList<>();\n        for (String s : split) {\n            if (s.isEmpty()) continue;\n            if (s.equals(\"..\")) {\n                if (pathRes.size() > 0)\n                    pathRes.remove(pathRes.size() - 1);\n                if (pathRes.size() > 0)\n                    pathRes.remove(pathRes.size() - 1);\n            } else if (!s.equals(\".\")) {\n                pathRes.add(\"/\");\n                pathRes.add(s);\n            }\n        }\n        for (String s : pathRes)\n            sb.append(s);\n        return sb.length() == 0 ? \"/\" : sb.toString();\n    }\n}"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        a=[]\n        cur=''\n        for i in path + '/':\n            if i=='/' :\n                if cur == '..':\n                    if a: a.pop()\n                elif cur!='' and cur!='.':\n                    a.append(cur)\n                cur=''\n            else:\n                cur+=i\n        return '/'+'/'.join(a)"
            },
            {
                "language": "cpp",
                "code": "class Solution:\n    def simplifyPath(self, path):\n        stack = []\n        for elem in path.split(\"/\"):\n            if stack and elem == \"..\":\n                stack.pop()\n            elif elem not in [\".\", \"\", \"..\"]:\n                stack.append(elem)\n                \n        return \"/\" + \"/\".join(stack)"
            },
            {
                "language": "typescript",
                "code": "public String simplifyPath(String path) {\n    Deque<String> stack = new LinkedList<>();\n    Set<String> skip = new HashSet<>(Arrays.asList(\"..\",\".\",\"\"));\n    for (String dir : path.split(\"/\")) {\n        if (dir.equals(\"..\") && !stack.isEmpty()) stack.pop();\n        else if (!skip.contains(dir)) stack.push(dir);\n    }\n    String res = \"\";\n    for (String dir : stack) res = \"/\" + dir + res;\n    return res.isEmpty() ? \"/\" : res;\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public String simplifyPath(String path) {"
            },
            {
                "language": "typescript",
                "code": "public class Solution {\npublic String simplifyPath(String path) {\n StringBuilder sb = new StringBuilder(\"/\");\n    LinkedList<String> stack = new LinkedList<String>();\n for(String s: path.split(\"/\")){\n  if(s.equals(\"..\")){\n      if(!stack.isEmpty())\n       stack.removeLast();"
            },
            {
                "language": "typescript",
                "code": "public String simplifyPath(String path) {\n    Stack<String> stack = new Stack();\n    for(String cur: path.split(\"/\")){\n        if(cur.equals(\"..\")) {\n            if(!stack.empty()) stack.pop();\n        }\n        else if(cur.length()>0 && !cur.equals(\".\")) stack.push(cur);\n    }"
            },
            {
                "language": "java",
                "code": "StringBuilder sb = new StringBuilder();\n        while (path.peekLast() != null) {\n            sb.append('/');\n            sb.append(path.pollLast());\n        }"
            },
            {
                "language": "typescript",
                "code": "    public String simplifyPath(String path) {\n        Stack<String> s = new Stack<>();\n        for (String p : path.split(\"/\")) {\n            if (p.isEmpty() || \".\".equals(p)) continue;"
            },
            {
                "language": "cpp",
                "code": "string simplifyPath(string path) {\n    string res, tmp;\n    vector<string> stk;\n    stringstream ss(path);\n    while(getline(ss,tmp,'/')) {\n        if (tmp == \"\" or tmp == \".\") continue;\n        if (tmp == \"..\" and !stk.empty()) stk.pop_back();\n        else if (tmp != \"..\") stk.push_back(tmp);\n    }\n    for(auto str : stk) res += \"/\"+str;\n    return res.empty() ? \"/\" : res;\n}"
            },
            {
                "language": "php",
                "code": "if (tmp == \"..\" and !stk.empty()) stk.pop_back();\nelse if (tmp != \"..\") stk.push_back(tmp);"
            },
            {
                "language": "php",
                "code": "if (tmp != \"..\") stk.push_back(tmp);\nelse if (!stk.empty()) stk.pop_back();"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string simplifyPath(string path) {\n        string result=\"\", token;\n        stringstream ss(path);\n        vector<string> tokens;\n        while(getline(ss, token, '/')){\n            if(token==\".\" || token==\"\") continue;"
            },
            {
                "language": "php",
                "code": "string simplifyPath(string path) {\n        istringstream ss(path);\n        deque<string>sub_path_stack;\n        string sub_path;\n        string result;\n        while (getline(ss, sub_path, '/')) {\n            if (sub_path == \".\" || sub_path == \"\") {"
            },
            {
                "language": "cpp",
                "code": "public String simplifyPath(String path) {\n    Deque<String> stack = new ArrayDeque<String>();\n   \n    for(String token : path.split(\"/\")) {\n        if(token.equals(\"..\")) {\n           if(!stack.isEmpty()) stack.pop();\n       \n        } else if(!token.isEmpty() && !token.equals(\".\")) {"
            }
        ]
    },
    "71": {
        "question_id": 72,
        "title": "Edit Distance",
        "difficulty": 3,
        "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.You have the following three operations permitted on a word:Insert a characterDelete a characterReplace a character ",
        "examples": [
            {
                "input": "word1 = \"horse\", word2 = \"ros\"",
                "output": "3",
                "explanation": "\nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')"
            },
            {
                "input": "word1 = \"intention\", word2 = \"execution\"",
                "output": "5",
                "explanation": "\nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')"
            }
        ],
        "constraints": [
            "0 <= word1.length, word2.length <= 500",
            "word1 and word2 consist of lowercase English letters."
        ],
        "solutions": [
            {
                "language": "ruby",
                "code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n\n        w1, w2 = len(word1), len(word2)\n        \n        @lru_cache(None)\n        def dp(i, j):\n\n            if i >= w1             : return w2-j                # word1 used up, so all inserts\n            if j >= w2             : return w1-i                # word2 used up, so all deletes\n            if word1[i] == word2[j]: return dp(i+1, j+1)        # letters match, so no operation\n\n            return min(dp(i,j+1), dp(i+1,j), dp(i+1,j+1)) + 1   # insert, delete, replace\n\n        return dp(0,0)"
            },
            {
                "language": "javascript",
                "code": "var minDistance = function(word1, word2) {\n    let len1 = word1.length, len2 = word2.length;\n    let dp = _.memoize((idx1, idx2) => {\n        if (idx1 >= len1) return len2 - idx2;\n        if (idx2 >= len2) return len1 - idx1;"
            },
            {
                "language": "typescript",
                "code": ""
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        # base case - i steps away\n        for i in range(1, m + 1):"
            },
            {
                "language": "java",
                "code": "class Solution {\n    private int memoizationUtil(String X, String Y, int m, int n, int[][] dp) {\n  if (m == 0) {\n   return n;\n  }\n  if (n == 0) {\n   return m;\n  }\nY, m - 1, n - 1, dp)/*Replace*/));\n1]));"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        lst = []\n        for i in range(len(word1)+1):\n            lst.append([])\n            for j in range(len(word2)+1):\n1"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int m = word1.length();\n        int n = word2.length();\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\n    \n        for(int i = 0; i <= m; i++) {"
            },
            {
                "language": "rust",
                "code": "Thanks for visiting my solution.\ud83d\ude0a"
            },
            {
                "language": "kotlin",
                "code": "//Memoisation\nclass Solution {\npublic:\n    int fun(int i,int j,string& word1,string& word2,vector<vector<int>> &dp)\n    {\n        if(j<0){\n            return i+1;\n        }\n        if(i<0){\n            return j+1;\n        }\n        if(dp[i][j]!=-1) return dp[i][j];\n        if(word1[i]==word2[j]){\n            return dp[i][j]=fun(i-1,j-1,word1,word2,dp);\n        }\n        int ins=1+fun(i,j-1,word1,word2,dp);\n        int del=1+fun(i-1,j,word1,word2,dp);\n        int rep=1+fun(i-1,j-1,word1,word2,dp);\n        return dp[i][j]=min(ins,min(del,rep));\n    }\n    int minDistance(string word1, string word2) {\n        int m=word1.size();\n        int n=word2.size();\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return fun(m-1,n-1,word1,word2,dp);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "//Tabulation\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int m=word1.size();\n        int n=word2.size();\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\n        for(int j=0;j<=n;j++){\n            dp[0][j]=j;\n        }\n        for(int i=0;i<=m;i++){\n            dp[i][0]=i;\n        }\n        for(int i=1;i<=m;i++)\n        {\n            for(int j=1;j<=n;j++){\n                if(word1[i-1]==word2[j-1]){\n                    dp[i][j]=dp[i-1][j-1];\n                    continue;\n                }\n                int ins=1+dp[i][j-1];\n                int del=1+dp[i-1][j];\n                int rep=1+dp[i-1][j-1];\n                dp[i][j]=min(ins,min(del,rep));        \n            }\n        }\n        return dp[m][n];\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int minDistance(String word1, String word2) {\n        int m = word1.length();\n        int n = word2.length();\n        if(m==0)\n            return n;\n        if(n==0)"
            },
            {
                "language": "",
                "code": "                    Please Upvote If You Find It Helpful"
            },
            {
                "language": "javascript",
                "code": "In this question we have to find the **Minimum Operations** to convert `word1` to `word2`.\nSo, what are the posibilities : \n    If both letters are equal then simply decrease index\n    Otherwise there are three posibilities:\n        We can `Insert` a letter\n        We can `Delete` a letter\n        We can `Replace` a letter"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    // Space Optimization - TC: O(n * m), SC: O(m)\n    int minDistance(string word1, string word2) {\n    int n = word1.size(), m = word2.size();\n    // We make dp array 1 indexed\n    // Initialize two vectors to store the values of the previous and current rows of the dp array\n    vector<int> prev(m+1, 0), curr(m+1, 0);\n    // Initialize the first row of the dp array to the numbers 0, 1, 2, ..., m\n    for(int j=0;j<=m;j++) prev[j] = j;\n    // Iterate through each row of the dp array\n    for(int i=1;i<=n;i++){\n        // Set the first element of the current row to i\n        curr[0] = i;\n        // Iterate through each column of the dp array\n        for(int j=1;j<=m;j++){\n            // If the two characters are equal, no operation is needed\n            if(word1[i-1] == word2[j-1])\n                curr[j] = prev[j-1];\n            else {\n                // If the two characters are different, consider three possible operations:\n                // Insertion: add 1 to the minimum value among prev[j], curr[j-1], and prev[j-1]\n                curr[j] = 1 + min(prev[j], min(curr[j-1], prev[j-1]));\n            }\n        }\n        // Update the previous row to be equal to the current row\n        prev = curr;\n    }\n    // Return the value of the last element of the dp array, which represents the minimum edit distance\n    return prev[m];\n}\n};"
            },
            {
                "language": "cpp",
                "code": "// Tabulation - TC: O(n * m), SC: O(n * m)\n    int minDistance(string word1, string word2) {\n        int n = word1.size(), m = word2.size();\n        // We make dp array 1 indexed\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\n        for(int i=0;i<=n;i++) dp[i][0] = i;\n        for(int j=0;j<=m;j++) dp[0][j] = j;\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=m;j++){\n                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1];\n                else\n// Delete - dp[i-1][j], Insert - dp[i][j-1], Replace - dp[i-1][j-1]\n                    dp[i][j] = 1 + min(dp[i-1][j], \n        min(dp[i][j-1], dp[i-1][j-1]));\n            }\n        }\n        return dp[n][m];\n    }"
            },
            {
                "language": "cpp",
                "code": "//Memoization - TC: O(n * m), SC: O(n * m) + O(n + m)\n    int find(string word1, string word2, int i, int j, vector<vector<int>>& dp){\n        if(j < 0) return i+1;\n        if(i < 0) return j+1;\n        if(dp[i][j] != -1) return dp[i][j];\n        if(word1[i] == word2[j]) return find(word1, word2, i-1, j-1, dp);\n        return dp[i][j] = 1 + min(find(word1, word2, i-1, j, dp), \n        min(find(word1, word2, i, j-1, dp), find(word1, word2, i-1, j-1, dp)));\n    }\n    int minDistance(string word1, string word2) {\n        int n = word1.size(), m = word2.size();\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\n        return find(word1, word2, n-1, m-1, dp);\n    }"
            },
            {
                "language": "",
                "code": "            Give a \ud83d\udc4d. It motivates me alot"
            },
            {
                "language": "cpp",
                "code": "// Note the & operator!\nint find(string word1, string word2, int i, int j, vector<vector<int>> &dp)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int minDistance(string s1, string s2) {\n        int m = s1.length(),n=s2.length(),i,j;\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\n        for(i = 0; i <= m; i++){\n            for(j = 0; j <= n; j++){\n                if(i==0&&j==0){\n                    dp[i][j] = 0;\n                }else if(i==0){\n                    dp[i][j] = j;\n                }else if(j==0){\n                    dp[i][j] = i;\n                }\n                else if(s1[i-1]==s2[j-1]){\n                    dp[i][j] = dp[i-1][j-1];\n                }else{\n                    dp[i][j] = min({dp[i-1][j],dp[i][j-1],dp[i-1][j-1]})+1;\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int solve(int i,int j,int& m,int& n,string s1,string s2,vector<vector<int>> &dp){\n        if(i==m){\n            return n-j;\n        }\n        if(j==n){\n            return m-i;\n        }\n        if(dp[i][j] != -1)return dp[i][j];\n        if(s1[i]==s2[j]){\n            return dp[i][j] = solve(i+1,j+1,m,n,s1,s2,dp);\n        }else{\n            // #deletion\n            // #insertion\n            // #replace\n            return dp[i][j] = min({solve(i+1,j,m,n,s1,s2,dp)+1,solve(i,j+1,m,n,s1,s2,dp)+1,solve(i+1,j+1,m,n,s1,s2,dp)+1});\n        }\n    }\n    int minDistance(string s1, string s2) {\n        int m = s1.length(),n=s2.length();\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return solve(0,0,m,n,s1,s2,dp);\n    }\n};"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        if word1 == word2:\n            return 0\n        if len(word1) == 0 or len(word2) == 0:\n            return max(len(word1), len(word2))            \n        w1 = list(word1)\n        w2 = list(word2)        \n        num = 0\n        queue = deque()\n        queue.append((0, 0))\n        visited = set()\n        while len(queue) > 0:\n            for _ in range(len(queue)):\n                i, j = queue.popleft()\n                if (i, j) in visited:\n                    continue\n                visited.add((i, j))\n                while i < len(w1) and j < len(w2) and w1[i] == w2[j]:\n                    i += 1\n                    j += 1\n                if i == len(w1) and j == len(w2):\n                    return num\n                queue.append((i, j + 1))\n                queue.append((i + 1, j + 1))\n                queue.append((i + 1, j))\n            num += 1"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int m=word1.size();\n        int n=word2.size();\n        int dp[m+1][n+1];\n        for(int i=0;i<=m;i++)\n        {\n            dp[i][0]=i;\n        }\n        for(int j=0;j<=n;j++)\n        {\n            dp[0][j]=j;\n\n        }\n        \n        for(int i=1;i<=m;i++)\n        {\n            for(int j=1;j<=n;j++)\n            {\n                if(word1[i-1]==word2[j-1])\n                {\n                    dp[i][j]=dp[i-1][j-1];\n                    \n                }\n                else \n                {   int mini=min(dp[i-1][j],dp[i][j-1]);\n                    dp[i][j]=1+ min(dp[i-1][j-1],mini);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public int MinDistance(string word1, string word2) {\n        var m = word1.Length;\n        var n = word2.Length;\n        var dp = new int[m+1, n+1];\n\n        for(var i = 0; i <= m; i++)\n        {\n            dp[i, 0] = i;\n        }\n\n        for(var j = 0; j <= n; j++)\n        {\n            dp[0, j] = j;    \n        }\n\n        for(var i = 0; i < m; i++)\n        {\n            for(var j = 0; j < n; j++)\n            {\n                if(word1[i] == word2[j])\n                {\n                    dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1] + 1, dp[i+1, j] + 1);\n                }\n                else\n                {\n                    dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1], dp[i+1, j]) + 1;\n                }\n            }\n        }\n\n        return dp[m, n];\n\n        int Min(params int[] arr)\n        {\n            return arr.Min();\n        }\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public int MinDistance(string word1, string word2) {\n        var m = word1.Length;\n        var n = word2.Length;\n        // var dp = new int[m+1, n+1];\n        var prevRow = new int[n+1];\n\n        // for(var i = 0; i <= m; i++)\n        // {\n        //     dp[i, 0] = i;\n        // }\n\n        for(var j = 0; j <= n; j++)\n        {\n            // dp[0, j] = j;    \n            prevRow[j] = j;\n        }\n\n        for(var i = 0; i < m; i++)\n        {\n            var curRow = new int[n+1];\n            curRow[0] = i + 1;\n\n            for(var j = 0; j < n; j++)\n            {\n                if(word1[i] == word2[j])\n                {\n                    // dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1] + 1, dp[i+1, j] + 1);\n                    curRow[j+1] = Min(prevRow[j], prevRow[j+1] + 1, curRow[j] + 1);\n                }\n                else\n                {\n                    // dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1], dp[i+1, j]) + 1;\n                    curRow[j+1] = Min(prevRow[j], prevRow[j+1], curRow[j]) + 1;\n                }\n            }\n            prevRow = curRow;\n        }\n\n        // return dp[m, n];\n        return prevRow[n];\n\n        int Min(params int[] arr)\n        {\n            return arr.Min();\n        }\n    }\n}"
            }
        ]
    },
    "72": {
        "question_id": 73,
        "title": "Set Matrix Zeroes",
        "difficulty": 2,
        "description": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.You must do it in place. ",
        "examples": [
            {
                "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
                "output": "[[1,0,1],[0,0,0],[1,0,1]]",
                "explanation": null
            },
            {
                "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
                "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
                "explanation": null
            }
        ],
        "constraints": [
            "m == matrix.length",
            "n == matrix[0].length",
            "1 <= m, n <= 200",
            "-231 <= matrix[i][j] <= 231 - 1"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "class Solution:\n  def setZeroes(self, matrix):\n    zero_rows, zero_cols = set(), set()\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 0:\n                zero_rows.add(i)\n                zero_cols.add(j)\n    for i in zero_rows:\n        matrix[i] = [0] * len(matrix[0])\n    for j in zero_cols:\n        for i in range(len(matrix)):\n            matrix[i][j] = 0"
            },
            {
                "language": "python",
                "code": "zero_rows, zero_cols = set(), set()"
            },
            {
                "language": "python",
                "code": "for i in range(len(matrix)):\n    for j in range(len(matrix[0])):\n        if matrix[i][j] == 0:\n            zero_rows.add(i)\n            zero_cols.add(j)"
            },
            {
                "language": "python",
                "code": "for i in zero_rows:\n    matrix[i] = [0] * len(matrix[0])"
            },
            {
                "language": "python",
                "code": "for j in zero_cols:\n    for i in range(len(matrix)):\n        matrix[i][j] = 0"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O((N*M)*(N+M)), Where N is the number of row and M is number of column of matrix. Here\n    nested loops creates the time complexity. O(N*M) for traversing through each element and (N+M) for traversing\n    to row and column of elements having value 0.\n\n    Space Complexity : O(N*M), visited matrix space.\n\n    Solved using Matrix with Extra space.\n\n*/\n\n\n/***************************************** Approach 1 Code *****************************************/\n\nclass Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        vector<vector<int>> visited = matrix;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(matrix[i][j] == 0){\n                    for(int k=0; k<m; k++){\n                        visited[i][k] = 0;\n                    }\n                }\n            }\n        }\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(matrix[i][j] == 0){\n                    for(int k=0; k<n; k++){\n                        visited[k][j] = 0;\n                    }\n                }\n            }\n        }\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                matrix[i][j] = visited[i][j];\n            }\n        }\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O((N*M)*(N+M)), Where N is the number of row and M is number of column of matrix. Here\n    nested loops creates the time complexity. O(N*M) for traversing through each element and (N+M)for traversing\n    to row and column of elements having value 0.\n\n    Space Complexity : O(1), Constant space.\n\n    Solved using Matrix.\n\n*/\n\n\n/***************************************** Approach 2 Code *****************************************/\n\nclass Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(matrix[i][j] == 0){\n                    for(int k=0; k<m; k++){\n                        if(matrix[i][k] != 0){\n                            matrix[i][k] = -9999;\n                        }\n                    }\n                }\n            }\n        }\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(matrix[i][j] == 0){\n                    for(int k=0; k<n; k++){\n                        if(matrix[k][j] != 0){\n                            matrix[k][j] = -9999;\n                        }\n                    }\n                }\n            }\n        }\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(matrix[i][j] == -9999){\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here two nested \n    loops creates the time complexity.\n\n    Space Complexity : O(N+M), Here Unordered set(setRows and setColumn) creates the space complexity. O(N) for\n    storing the row indexs and O(M) for storing the column indexs.\n\n    Solved using Matrix + Hash Table.\n\n*/\n\n\n/***************************************** Approach 3 Code *****************************************/\n\nclass Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        unordered_set<int> setRows; \n        unordered_set<int> setColumns; \n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(matrix[i][j] == 0){\n                    setRows.insert(i);\n                    setColumns.insert(j);\n                }\n            }\n        }\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(setRows.count(i) > 0 || setColumns.count(j) > 0){\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here two nested \n    loops creates the time complexity.\n\n    Space Complexity : O(1), Constant space.\n\n    Solved using Matrix.\n\n*/\n\n\n/***************************************** Approach 4 Code *****************************************/\n\nclass Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        bool flag1 = false, flag2 = false;\n        for(int i=0; i<n; i++){\n            if(matrix[i][0] == 0){\n                flag1 = true;\n            }\n        }\n        for(int j=0; j<m; j++){\n            if(matrix[0][j] == 0){\n                flag2 = true;\n            }\n        }\n        for(int i=1; i<n; i++){\n            for(int j=1; j<m; j++){\n                if(matrix[i][j] == 0){\n                    matrix[i][0] = matrix[0][j] = 0;\n                }\n            }\n        }\n        for(int i=1; i<n; i++){\n            for(int j=1; j<m; j++){\n                if(matrix[i][0] == 0 || matrix[0][j] == 0){\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        if(flag1 == true){\n            for(int i=0; i<n; i++){\n                matrix[i][0] = 0;\n            }\n        }\n        if(flag2 == true){\n            for(int j=0; j<m; j++){\n                matrix[0][j] = 0;\n            }\n        }\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        map<int,bool> m1;\n        map<int,bool> m2;\n        for(int i=0;i<matrix.size();i++)\n        {\n            for(int j=0;j<matrix[0].size();j++)\n            {\n                if(matrix[i][j]==0)\n                {\n                    m1[i]=true;\n                    m2[j]=true;\n                }\n            }\n        }\n        for(auto it:m1)\n        {\n            for(int j=0;j<matrix[0].size();j++)\n            {\n                matrix[it.first][j]=0;\n            }\n        }\n        for(auto it:m2)\n        {\n            for(int j=0;j<matrix.size();j++)\n            {\n                matrix[j][it.first]=0;\n            }\n        }\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Pair\n{\n    int i,j;\n    Pair(int i, int j)\n    {\n        this.i = i;\n        this.j = j;\n    }\n}\nclass Solution {\n    public void setZeroes(int[][] matrix) \n    {\n       Queue<Pair> p = new LinkedList<>();\n       int n = matrix.length;\n       int m = matrix[0].length;\n       for(int i=0; i<n; i++)\n       {\n           for(int j=0; j<m; j++)\n           {\n               if(matrix[i][j]==0)\n               {\n                   p.add(new Pair(i,j));\n               }\n           }\n       } \n       while(!p.isEmpty())\n       {\n           Pair a = p.poll();\n           int i1 = a.i;\n           int j1 = a.j;\n           for(int k=0;k<m;k++)\n           {\n               matrix[i1][k]=0;\n           }\n           for(int k=0;k<n;k++)\n           {\n               matrix[k][j1]=0;\n           }\n       }\n\n    }\n}"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        row = set()\n        col = set()\n        for i in range(0, len(matrix)):\n            for j in range(0, len(matrix[0])):\n                if matrix[i][j] == 0:\n                    row.add(i)\n                    col.add(j)\n        for i in range(0, len(matrix)):\n            for j in range(0, len(matrix[0])):\n                if i in row or j in col:\n                    matrix[i][j] = 0\n            "
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows=matrix.length;\n        int cols=matrix[0].length;\n        int []dummy1=new int[rows];\n        int []dummy2=new int[cols];\n        Arrays.fill(dummy1,-1);\n        Arrays.fill(dummy2,-1);\n        for(int i=0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(matrix[i][j]==0)\n                    {dummy1[i]=0;\n                   dummy2[j]=0;\n            }\n            }\n        }\n        for(int i=0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1[i]==0 || dummy2[j]==0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        bool isRow = false, isCol = 0;\n        for(int i = 0; i < matrix[0].size(); i++){\n            if(matrix[0][i] == 0) isRow = true;\n        }\n\n        for(int i = 0; i < matrix.size(); i++){\n                if(matrix[i][0] == 0) isCol = true;\n            }\n\n        for(int i = 1; i < matrix.size(); ++i) {\n            for(int j = 1; j < matrix[0].size(); ++j) {\n                if(matrix[i][j] == 0) { \n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        // Setting each cell to zero if its 1st col or row is zero\n        for(int i = 1; i < matrix.size(); i++) {\n            for(int j = 1; j < matrix[0].size(); ++j) {\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\n                    matrix[i][j] = 0;\n            }\n        }\n\n        if(isRow) {\n            for(int i = 0; i < matrix[0].size(); i++) matrix[0][i] = 0;\n        }\n        if(isCol) {\n            for(int i = 0; i < matrix.size(); i++) matrix[i][0] = 0;\n        }\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public void setZeroes(int[][] m) {\n        int r = m.length, c = m[0].length;\n        boolean[][] zeros = new boolean[r][c];\n        for (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n                if (m[i][j] == 0) zeros[i][j] = true;\n            }\n        }\n        for (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n                if (zeros[i][j] == true) {\n                    fillRowWithZeros(i, m);\n                    fillColumnWithZeros(j, m);\n                }\n            }\n        }\n    }\n\n    private void fillRowWithZeros(int row, int[][] m) {\n        for (int i = 0; i < m[row].length; i++) {\n            m[row][i] = 0;\n        }\n    }\n\n    private void fillColumnWithZeros(int col, int[][] m) {\n        for (int i = 0; i < m.length; i++) {\n            m[i][col] = 0;\n        }\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "public void setZeroes(int[][] matrix){\n\n  int m= matrix.length, n= matrix[0].length;\n        int matrix2[][]= new int[m][n];\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++)\n                matrix2[i][j]=matrix[i][j];\n        }\n        \n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(matrix[i][j]==0){\n                    for(int k=0;k<n;k++)\n                        matrix2[i][k]=0;\n\n                    for(int k=0;k<m;k++)\n                        matrix2[k][j]=0;\n                }\n            }\n        }\n    \n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++)\n                matrix[i][j]=matrix2[i][j];\n        }\n    }"
            },
            {
                "language": "cpp",
                "code": "public void setZeroes(int[][] matrix){\n\n  int m=matrix.length, n=matrix[0].length;\n        int rowsArray[]= new int[m];\n        int colsArray[]= new int[n];\n        \n        Arrays.fill(rowsArray,1);\n        Arrays.fill(colsArray,1);\n        \n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(matrix[i][j]==0){\n                    rowsArray[i]=0;\n                    colsArray[j]=0;\n                }\n            }\n        }\n        \n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(rowsArray[i]==0 || colsArray[j]==0)\n                    matrix[i][j]=0;\n            }\n        }\n    }"
            },
            {
                "language": "java",
                "code": "public void setZeroes(int[][] matrix){\n\n  int m=matrix.length, n=matrix[0].length;\n        boolean isRow0=false, isCol0=false;\n        \n        for(int j=0;j<n;j++){\n            if(matrix[0][j]==0)\n                isRow0=true;\n        }\n        \n        for(int i=0;i<m;i++){\n            if(matrix[i][0]==0)\n                isCol0=true;\n        }\n        \n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                if(matrix[i][j]==0){\n                    matrix[i][0]=0;\n                    matrix[0][j]=0;\n                }\n            }\n        }\n        \n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                if(matrix[0][j]==0 || matrix[i][0]==0)\n                    matrix[i][j]=0;\n            }\n        }\n        \n        if(isRow0){\n            for(int j=0;j<n;j++)\n                matrix[0][j]=0;\n        }\n        \n        if(isCol0){\n            for(int i=0;i<m;i++)\n                matrix[i][0]=0;\n        }\n    }"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public void setZeroes(int[][] arr) {\n        int n = arr.length;\n        int m = arr[0].length;\n\n        int row[] = new int[n];\n        int col[] = new int[m];\n\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < m; j++)\n            {\n                if( arr[i][j] ==0 )\n                {\n                   row[i]=1;\n                   col[j]=1;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if( row[i]==1 )\n            {\n                for (int j = 0; j < m; j++) {\n                    arr[i][j] = 0;\n                }\n            }\n        }\n\n        for (int j = 0; j < m; j++) {\n            if( col[j]==1 )\n            {\n                for (int i = 0; i < n; i++) {\n                    arr[i][j] = 0 ;\n                }\n            }\n        }\n    }\n}"
            }
        ]
    },
    "73": {
        "question_id": 74,
        "title": "Search a 2D Matrix",
        "difficulty": 2,
        "description": "You are given an m x n integer matrix matrix with the following two properties:Each row is sorted in non-decreasing order.The first integer of each row is greater than the last integer of the previous row.Given an integer target, return true if target is in matrix or false otherwise.You must write a solution in O(log(m * n)) time complexity. ",
        "examples": [
            {
                "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3",
                "output": "true",
                "explanation": null
            },
            {
                "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13",
                "output": "false",
                "explanation": null
            }
        ],
        "constraints": [
            "m == matrix.length",
            "n == matrix[i].length",
            "1 <= m, n <= 100",
            "-104 <= matrix[i][j], target <= 104"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int rows = matrix.size(),\n   cols = matrix[0].size(),\n            row = 0, col = cols - 1;\n   \n        while (row < rows && col > -1) {\n            int cur = matrix[row][col];\n            if (cur == target) return true;\n            if (target > cur) row++;\n            else col--;\n        }\n        \n        return false;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n   int m=matrix.size();\n   int n=matrix[0].size();\n   int i=0;\n   int j=n-1;\n   while(i<m && j>=0){\n    int p=matrix[i][j];\n    if(p==target)\n    return true;\n    else if(p>target)\n    j--;\n    else \n    i++;\n   }\n   return false;\n   \n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> \n      row,col=len(matrix),len(matrix[0])\n        left,right=0,row*col-1\n        while left<=right:\n            mid=(left+right)//2\n            num=matrix[mid//col][mid%col]\n            if num==target:\n                return True\n            if num>target:\n                right=mid-1\n            else:\n                left=mid+1\n        return False"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        list1=[]\n        for row in matrix:\n            if row[-1]>=target:\n                list1=row\n                break\n        left,right=0,len(list1)-1\n        while left<=right:\n            mid=(right+left)//2\n            if list1[mid]==target:\n                return True\n            elif list1[mid]>target:\n                right=mid-1\n            else:\n                left=mid+1\n        return False\n    //please upvote me it would encourage me alot\n                "
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        for row in matrix:\n            if row[-1] >= target:\n                return target in row\n\n# please upvote me it would encourage me alot"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int i=0;\n        int j=matrix[0].length-1;\n        while(i<matrix.length && j>=0)\n        {\n            if(matrix[i][j]==target)\n                return true;\n            else if(matrix[i][j]>target)\n                j--;\n            else \n                i++;\n        }\n        return false;\n    }\n}"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int i=0;\n        for(i=0;i<matrix.length;i++){\n            if(target>matrix[i][matrix[0].length-1])\n            continue;\n            else {\n                for(int j=0;j<matrix[0].length;j++){\n                    if(matrix[i][j]==target)\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size(), n = matrix[0].size();\n        vector<int> start(m);\n        for (int i = 0; i < m; i++) {\n            start[i] = matrix[i][0];\n        }\n        int row = upper_bound(start.begin(), start.end(), target) - start.begin() - 1;\n        if (row < 0) { return false; }\n        return binary_search(matrix[row].begin(), matrix[row].end(), target);\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        final int m = matrix.length, n = matrix[0].length;\n        int i = 0, j = n - 1;\n        while (i >= 0 && i < m && j >= 0 && j < n) {\n            if (matrix[i][j] == target)\n                return true;\n            else if (matrix[i][j] > target)\n                j--;\n            else if (matrix[i][j] < target)\n                i++;\n        }\n        return false;\n    }\n}"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        final int m = matrix.length, n = matrix[0].length;\n        int rowIndex = m - 1;\n        int start = 0, end = m - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (matrix[mid][0] == target)\n                return true;\n            else if (matrix[mid][0] < target && mid + 1 < m\n             && matrix[mid + 1][0] > target) {\n                rowIndex = mid;\n                break;\n            } else if (matrix[mid][0] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        start = 0;\n        end = n - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (matrix[rowIndex][mid] == target)\n                return true;\n            else if (matrix[rowIndex][mid] > target)\n                end = mid - 1;\n            else\n                start = mid + 1;\n        }\n        return false;\n    }\n}"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int count = Integer.MAX_VALUE;\n        for(int i=matrix.length-1; i>=0; i--){\n            if(matrix[i][0]==target){\n                return true;\n            }else if(matrix[i][0]>target){\n                if(count>i){\n                    count = i;\n                }\n            }else{\n                count = i;\n                break;\n            }\n        }\n        int start = 0;\n        int end = matrix[0].length-1; \n        while(start<=end){\n            int mid = (start+end)/2;\n            if(matrix[count][mid]>target){\n                end = mid-1;\n            }else if(matrix[count][mid]<target){\n                start = mid+1;\n            }else{\n                return true;\n            }\n        }\n        return false;\n    }\n}"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n         int rowPointer = 0;\n        int colPointer = matrix[0].length-1;\n        while(rowPointer < matrix.length && colPointer >= 0){\n            if(matrix[rowPointer][colPointer] == target) return true;\n            else if(matrix[rowPointer][colPointer] > target) colPointer--;\n            else rowPointer++;\n        }\n        return false;\n    }\n    }"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int search=matrix[0].size();\n        int n=matrix.size();\n        int i=0,j=search-1;\n        while(i<n && j>=0)\n        {\n          if(matrix[i][j]==target)\n          {\n              return true;\n          }\n          if(matrix[i][j]>target)\n          {\n              j--;\n          }\n          else\n          {\n              i++;\n          }\n        }\n        return false;\n    }\n};"
            }
        ]
    },
    "74": {
        "question_id": 75,
        "title": "Sort Colors",
        "difficulty": 2,
        "description": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.You must solve this problem without using the library's sort function. ",
        "examples": [
            {
                "input": "nums = [2,0,2,1,1,0]",
                "output": "[0,0,1,1,2,2]",
                "explanation": null
            },
            {
                "input": "nums = [2,0,1]",
                "output": "[0,1,2]",
                "explanation": null
            }
        ],
        "constraints": [
            "n == nums.length",
            "1 <= n <= 300",
            "nums[i] is either 0, 1, or 2."
        ],
        "solutions": [
            {
                "language": "rust",
                "code": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        size = len(nums)\n        cnt_arr = [0] * 3\n        temp = [0] * size\n        print(temp)\n              \n        for i in range(0,size):\n            cnt_arr[nums[i]] += 1\n        print(cnt_arr)\n        for i in range(1,3):\n            cnt_arr[i] += cnt_arr[i-1]\n        print(cnt_arr)\n        i = size - 1\n        while i >= 0:           \n            temp[cnt_arr[nums[i]] - 1] = nums[i]\n            cnt_arr[nums[i]] -= 1\n            print(temp[i])\n            i -= 1\n        for i in range(0, size):\n            nums[i] =temp[i]\n\n       \n\n       \n        \n\n        "
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # nums.sort()\n        n=len(nums)\n        \n        for i in range(1,n):\n            key=nums[i]\n            j=i-1\n            while j>=0 and key<nums[j]:\n                nums[j+1]=nums[j]\n                j-=1\n                \n            nums[j+1]=key"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public void sortColors(int[] nums) \n    {\n        Arrays.sort(nums);\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n\n        //  Dutch National flag algorithm\n        int low = 0 , mid = 0 , high = nums.size() -1 ;\n        while( mid <= high   )\n        {\n            if( nums[mid] == 1)\n            {\n                mid++;\n                continue;\n            }\n            if(nums[mid] == 0 )\n            {\n                swap( nums[mid] , nums[low]);\n                mid++ , low++;\n                continue;\n            }\n            if(nums[mid] == 2)\n            {\n                swap( nums[mid] , nums[high]);\n                high-- ;\n            }\n        }\n        \n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        //using counting sort\n        int maxm = *max_element(nums.begin(),nums.end());//o(n)\n        vector<int>frequency(maxm+1 , 0);\n        for(int i = 0 ; i < nums.size() ; i++){      //O(n)\n            frequency[nums[i]]++;\n        }\n        int i = 0 ; int j = 0;\n        while( i < maxm+1) {                 //O(m) m=n in this case\n            if(frequency[i]>0){\n                nums[j++]=i;\n                frequency[i]--;\n            }\n            else\n            i++;\n        }\n    }\n};"
            },
            {
                "language": "python",
                "code": "def sortColors(self, nums):\n    red, white, blue = 0, 0, len(nums)-1\n    \n    while white <= blue:\n        if nums[white] == 0:\n            nums[red], nums[white] = nums[white], nums[red]\n            white += 1\n            red += 1\n        elif nums[white] == 1:\n            white += 1\n        else:\n            nums[white], nums[blue] = nums[blue], nums[white]\n            blue -= 1\n            \n            "
            },
            {
                "language": "python",
                "code": "class Solution:\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        p1, p2 = 0, len(nums) - 1"
            },
            {
                "language": "",
                "code": "nums[red], nums[white] = nums[white], nums[red]"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public void sortColors(int[] nums) {\n        int n = nums.length;\n        int i = 0; // to the left of i, the objects with red color\n        int k = n - 1; // to the right of k, the objects with blue color\n        int j = 0; // between i and j are the object with white color\n        // between j and k are the objects with unknown colors, we have to check\n        "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int low = 0;\n        int mid = 0;\n        int high = nums.size() - 1;\n\n        while(mid <= high){\n            switch(nums[mid]){\n\n                //if the element is 0\n                case 0:\n                    swap(nums[low++], nums[mid++]);\n                    break;\n                \n                // if the element is 1\n                case 1:\n                    mid++;\n                    break;\n                \n                // if the element is 2\n                case 2:\n                    swap(nums[mid], nums[high--]);\n                    break;\n            }\n        }\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int low = 0;\n        int mid = 0;\n        int high = nums.size() - 1;\n\n        while(mid <= high){\n            if(nums[mid] == 0){\n                swap(nums[low++], nums[mid++]);\n            } else if(nums[mid] == 1){\n                mid++;\n            } else if(nums[mid] == 2){\n                swap(nums[mid], nums[high--]);\n            }\n        }\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int n = nums.size();\n        int ptr0 = 0, ptr1 = 0, ptr2 = n-1;\n\n        while(ptr1<=ptr2){\n            if(nums[ptr1]==0){\n                swap(nums[ptr0],nums[ptr1]);\n                ptr0++,ptr1++;\n            }\n            else if(nums[ptr1] == 1){\n                ptr1++;\n            }\n            else{\n                swap(nums[ptr1],nums[ptr2]);\n                ptr2--;\n            }\n        }\n    }\n};"
            },
            {
                "language": "rust",
                "code": " O(n)[for loop] +O(n)[while loop 1] +O(n)[while loop 2]+ \n O(n)[while loop 3]\n TOTAL=O(n)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        stack<int>s0;\n        s0.push(-1);\n\n        stack<int>s1;\n        s1.push(-1);\n\n        stack<int>s2;\n        s2.push(-1);\n\n\n        //copying elements from nums into their respective stacks\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]==0) s0.push(0);\n            else if(nums[i]==1) s1.push(1);\n            else if(nums[i]==2) s2.push(2);\n        }\n\n        //as we know stack is first in last out \n        //so we first push 1 into stack 2\n        while(s1.top()!=-1){\n            s2.push(s1.top());\n            s1.pop();\n        }\n       \n        //now we push 0 into stack 2\n        while(s0.top()!=-1){\n            s2.push(s0.top());\n            s0.pop();\n        }\n \n        //copying elements from stack 2 to 'nums' array   \n        int i=0;\n        while(s2.top()!=-1){\n            nums[i]=s2.top();\n            s2.pop();\n            i++;\n        }\n        \n    }\n};"
            },
            {
                "language": "cpp",
                "code": "    void sortColors(vector<int>& nums) {\n        \n        // initialize variables:\n        int low = 0, mid = 0, high = nums.size() - 1;\n        \n        // logic:\n        while(mid <= high)\n        {\n            switch(nums[mid])\n            {\n                case 0: swap(nums[low++], nums[mid++]); break;\n                \n                case 1: mid++; break;\n                \n                case 2: swap(nums[mid], nums[high--]); break;\n            }\n        }\n    }"
            }
        ]
    },
    "75": {
        "question_id": 76,
        "title": "Minimum Window Substring",
        "difficulty": 3,
        "description": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".The testcases will be generated such that the answer is unique. ",
        "examples": [
            {
                "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
                "output": "\"BANC\"",
                "explanation": "The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t."
            },
            {
                "input": "s = \"a\", t = \"a\"",
                "output": "\"a\"",
                "explanation": "The entire string s is the minimum window."
            },
            {
                "input": "s = \"a\", t = \"aa\"",
                "output": "\"\"",
                "explanation": "Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string."
            }
        ],
        "constraints": [
            "m == s.length",
            "n == t.length",
            "1 <= m, n <= 105",
            "s and t consist of uppercase and lowercase English letters."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool ok(vector<int> &A, vector<int> &B) {\n        for(int i=0;i<128;i++) {\n            if(A[i]<B[i]) return 0;\n        }\n        return 1;\n    }\n    string minWindow(string s, string t) {"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        tCounter = Counter(t)\n        tCount = len(tCounter)\n        l, r = 0, 0\n        curWindowCount = 0\n        maxl, maxr = 0, float(\"inf\")\n        curWindow = {}\n        "
            },
            {
                "language": "java",
                "code": "    // Sliding Window Better time: O(Cs + t) space: O(n)\n    public String minWindow(String s, String t) {\n        if (s.equals(t)) {\n            return t;\n        }"
            },
            {
                "language": "cpp",
                "code": "#define MAP_SIZE 60 //(65-90) + (97-122)\n\nclass Solution {\npublic:\n    string minWindow(string s, string t) \n    {\n        vector<int> tCount(MAP_SIZE,0); //IMP: We can have unordered_map or just take a single array again! (this time start from 'A' & end at 'z'"
            },
            {
                "language": "csharp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    string minWindow(string s, string t) {"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public string MinWindow(string s, string t) {\n        if (t.Length > s.Length) return \"\";\n            if (s.Length == t.Length)\n            {\n                string sb = s;\n                sb = String.Concat(sb.OrderBy(x => x));\n                t = String.Concat(t.OrderBy(x => x));"
            },
            {
                "language": "ruby",
                "code": "from collections import Counter\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if len(t) > len(s): return \"\"\n        \n        matched, start, smallest = 0, 0, \"\"\n        tCounter = Counter(t)\n        \n smallest"
            },
            {
                "language": "ruby",
                "code": "string minWindow(string s, string t) {\n        vector<int> map(128,0);\n        for(auto c: t) map[c]++;\n        int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0;\n        while(end<s.size()){\n            if(map[s[end++]]-->0) counter--; //in t\n            while(counter==0){ //valid\n                if(end-begin<d)  d=end-(head=begin);\n                if(map[s[begin++]]++==0) counter++;  //make it invalid\n            }  \n        }\n        return d==INT_MAX? \"\":s.substr(head, d);\n    }"
            },
            {
                "language": "cpp",
                "code": "int findSubstring(string s){\n        vector<int> map(128,0);\n        int counter; // check whether the substring is valid\n        int begin=0, end=0; //two pointers, one point to tail and one  head\n        int d; //the length of substring\n\n        for() { /* initialize the hash map here */ }\n\n        while(end<s.size()){\n\n            if(map[s[end++]]-- ?){  /* modify counter here */ }\n\n            while(/* counter condition */){ \n                 \n                 /* update d here if finding minimum*/\n\n                //increase begin to make it invalid/valid again\n                \n                if(map[s[begin++]]++ ?){ /*modify counter here*/ }\n            }  \n\n            /* update d here if finding maximum*/\n        }\n        return d;\n  }"
            },
            {
                "language": "python",
                "code": "int lengthOfLongestSubstringTwoDistinct(string s) {\n        vector<int> map(128, 0);\n        int counter=0, begin=0, end=0, d=0; \n        while(end<s.size()){\n            if(map[s[end++]]++==0) counter++;\n            while(counter>2) if(map[s[begin++]]--==1) counter--;\n            d=max(d, end-begin);\n        }\n        return d;\n    }"
            },
            {
                "language": "ruby",
                "code": "int lengthOfLongestSubstring(string s) {\n        vector<int> map(128,0);\n        int counter=0, begin=0, end=0, d=0; \n        while(end<s.size()){\n            if(map[s[end++]]++>0) counter++; \n            while(counter>0) if(map[s[begin++]]-->1) counter--;\n            d=max(d, end-begin); //while valid, update d\n        }\n        return d;\n    }"
            },
            {
                "language": "erlang",
                "code": "1. Use two pointers: start and end to represent a window.\n2. Move end to find a valid window.\n3. When a valid window is found, move start to find a smaller window."
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "  public String minWindow(String s, String t) {\n    int [] map = new int[128];\n    for (char c : t.toCharArray()) {\n      map[c]++;\n    }"
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def min_window(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        # Struggled with this problem for a long while."
            },
            {
                "language": "csharp",
                "code": "public String minWindow(String s, String t) {\n    HashMap<Character,Integer> map = new HashMap();\n    for(char c : s.toCharArray())\n        map.put(c,0);\n    for(char c : t.toCharArray())\n    {\n        if(map.containsKey(c))\n            map.put(c,map.get(c)+1);"
            },
            {
                "language": "ruby",
                "code": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\""
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public string MinWindow(string s, string t) {\n        if (t.Length > s.Length)\n        return \"\";\n        if(s.Length==1){\n            if(s[0]==t[0])\n                return Char.ToString(s[0]);\n            return \"\";\n        }\n        Dictionary<char, int> d = new();\n        foreach (var c in t)\n        {\n            if(!d.ContainsKey(c))\n                d.Add(c, 0);\n        }\n        foreach (var c in t)\n        {\n            d[c]++;\n        }\n        //if lengths are equal\n        if(t.Length==s.Length){\n            foreach(var c in s){\n                decrement(d,c);\n            }\n            if(!covered(d))\n                return \"\";\n            return s;\n        }\n        // Use two pointers to create a window of letters in s, which would have all the characters from t.\n        int lp = 0, rp = 0, anslp = 0, ansrp = 0, minWin = Int32.MaxValue;\n        decrement(d, s[lp]);\n        List<char> list = new();\n        while (rp < s.Length-1)\n        {\n            // Expand the right pointer until all the characters of t are covered.\n            while (!covered(d) && rp < s.Length-1)\n            {\n                rp++;\n                decrement(d, s[rp]);\n            }\n            // Once all the characters are covered, move the left pointer and ensure that all the characters\n            // are still covered to minimize the subarray size.\n            while (covered(d) && lp <= rp)\n            {\n                increment(d, s[lp]);\n                lp++;\n            }\n            if (lp > 0) { \n                lp--;\n                decrement(d, s[lp]);\n            }\n            // Continue expanding the right and left pointers until you reach the end of s.\n            if ((rp - lp) < minWin)\n            {\n                minWin = rp - lp;\n                anslp = lp;\n                ansrp = rp;\n            }\n            increment(d, s[lp]);\n            lp++;\n        }\n        lp--;\n        decrement(d,s[lp]);\n        if(!covered(d))\n            return \"\";\n        return s.Substring(anslp, ansrp - anslp + 1);\n    }\n    public bool covered(Dictionary<char,int> d){\n        foreach(var kvp in d){\n            if(kvp.Value>0)\n                return false;\n        }\n        return true;\n    }\n    public void increment(Dictionary<char,int> d, char c){\n        if(d.ContainsKey(c)){\n            d[c]++;\n        }\n    }\n    public void decrement(Dictionary<char,int> d,char c){\n        if(d.ContainsKey(c)){\n            d[c]--;\n        }\n    }\n}"
            },
            {
                "language": "javascript",
                "code": "class Solution {\n    func minWindow(_ s: String, _ t: String) -> String {\n        let s = Array(s)\n        var counters = [Character:Int](t.map {($0, 1)}, uniquingKeysWith: +)\n        var left = 0, missingCount = t.count, minLeft = 0, minRight = Int.max\n\n        for (right,ch) in s.enumerated() {\n            if let value = counters[ch] {\n                counters[ch] = value - 1\n                missingCount -= value > 0 ? 1 : 0\n            }\n\n            for ch in s[left...] {\n                guard missingCount == 0 else { break }\n                if minRight - minLeft > right - left {\n                    (minLeft, minRight) = (left, right)\n                }\n                if let value = counters[ch] {\n                    counters[ch] = value + 1\n                    missingCount += value >= 0 ? 1 : 0\n                }\n                left += 1\n            }\n        }\n        return minRight == Int.max ? \"\" : String(s[minLeft...minRight])\n    }\n}"
            },
            {
                "language": "swift",
                "code": "class Solution {\n func minWindow(_ s: String, _ t: String) -> String {"
            },
            {
                "language": "javascript",
                "code": "  // `counters` is a dictionary where the key is a unique character in `t`, \n  // and the value is the number of times the unique character appears in `t`\n  var counters = [Character:Int](t.map {($0, 1)}, uniquingKeysWith: +)"
            },
            {
                "language": "javascript",
                "code": " var ...\n \n  // `missingCount` accounts for how many characters in `t` are missing from the current `left`...`right` window.\n  // initially, all are missing.\n  missingCount = t.count, \n  \n  // Tip for speed: keep track of start and end of current minimum window, do not \n  // construct substrings over and over in a loop, just once at end.\n  minLeft = 0,  minRight = Int.max \n\n        for (right,ch) in s.enumerated() {\n            if let value = counters[ch] {\n                counters[ch] = value - 1\n    // `value > 0` accounts for the case where there are more instances of a unique character\n    // in a sliding window that in `t`.\n                missingCount -= value > 0 ? 1 : 0\n            }\n\n            for ch in s[left...] { // iterates the entire rest of the substring, but due to our logic, will break early when `missingCount` increases\n                guard missingCount == 0 else { break }\n                if minRight - minLeft > right - left {\n                    (minLeft, minRight) = (left, right)\n                }\n                if let value = counters[ch] {\n                    counters[ch] = value + 1\n     \n     // again, `value >= 0` accounts for the case where there are more instances of a unique character\n     // in a sliding window that in `t`.\n                    missingCount += value >= 0 ? 1 : 0\n                }\n                left += 1\n            }\n        }\n        return minRight == Int.max ? \"\" : String(s[minLeft...minRight])\n    }\n}"
            },
            {
                "language": "go",
                "code": "func minWindow(s string, t string) string {\n    m := len(s)\n    n := len(t)\n    \n    if m == 0 || n == 0 || m < n {\n        return \"\"\n    }\n\n    dict := make(map[byte]int)\n    for i := 0; i < n; i++ {\n        dict[t[i]]++\n    }\n    \n    // required unique chars\n    required := len(dict)\n    actual := 0\n    window := make(map[byte]int)\n    minSize := math.MaxInt64\n    start := 0\n    left, right := 0, 0\n    \n    for end := 0; end < m; end++ {\n        c := s[end]\n        window[c]++\n        \n        if value, ok := dict[c]; ok {\n            if value == window[c] {\n                actual++\n            }\n        }\n        \n        for start <= end && actual == required {\n            size := end-start+1\n            if size < minSize {\n                minSize = size\n                left = start\n                right = end\n            }\n            \n            rc := s[start]\n            window[rc]--\n            if value, ok := dict[rc]; ok {\n                if value > window[rc] {\n                    actual--\n                }\n            }\n            start++\n        }\n    }\n    \n    if minSize == math.MaxInt64 {\n        return \"\"\n    }\n    return s[left:right+1]\n}"
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nconst minWindow = function (s, t) {\n  if (!s || !t || s.length < t.length) return \"\";\n\n  let l = 0, r = 0;\n  let count = 0, minI = s.length + 1, minL = s.length + 1;\n\n  const freqMap = {};\n  for (const ch of t) freqMap[ch] = (freqMap[ch] || 0) + 1;\n\n  while (r < s.length) {\n    if (freqMap[s[r]]-- >= 1) count += 1;\n    r += 1;\n\n    while (count == t.length) {\n      if (r - l < minL) {\n        minL = r - l;\n        minI = l;\n      }\n      if (freqMap[s[l]]++ >= 0) count -= 1;\n      l += 1;\n    }\n  }\n  return s.slice(minI, minI + minL);\n};"
            },
            {
                "language": "lisp",
                "code": "if (freqMap[s[l]]++ >= 0) count -= 1;"
            },
            {
                "language": "dart",
                "code": "class Solution {\n// Runtime: 529 ms, faster than 50.00% of Dart online submissions for Minimum Window Substring.\n// Memory Usage: 149.5 MB, less than 100.00% of Dart online submissions for Minimum Window Substring.\n  String minWindow(String s, String t) {\n    List<int> ht = List.filled(100, 0);\n    int i = 0, j = 0;\n    List<int> cht = List.filled(100, 0);\n    int m = s.length,\n        n = t.length,\n        cnt = 0,\n        reqcnt = 0,\n        min = double.maxFinite.toInt();\n    String res = \"\";\n    List<String> ss = s.split(\"\");\n    List<String> tt = t.split(\"\");\n    for (String ch in tt) cht[ch.codeUnitAt(0) - 'A'.codeUnitAt(0)]++;\n    for (int num in cht) if (num > 0) reqcnt++;\n    while (j <= m) {\n      if (cnt == reqcnt) {\n        if (min > (j - i + 1)) {\n          min = j - i + 1;\n          res = s.substring(i, j);\n        }\n        if (cht[ss[i].codeUnitAt(0) - 'A'.codeUnitAt(0)] > 0) {\n          ht[ss[i].codeUnitAt(0) - 'A'.codeUnitAt(0)]--;\n          if (ht[ss[i].codeUnitAt(0) - 'A'.codeUnitAt(0)] <\n              cht[ss[i].codeUnitAt(0) - 'A'.codeUnitAt(0)]) cnt--;\n        }\n        i++;\n      } else {\n        if (j == m) break;\n        if (cht[ss[j].codeUnitAt(0) - 'A'.codeUnitAt(0)] > 0) {\n          ht[ss[j].codeUnitAt(0) - 'A'.codeUnitAt(0)]++;\n          if (ht[ss[j].codeUnitAt(0) - 'A'.codeUnitAt(0)] ==\n              cht[ss[j].codeUnitAt(0) - 'A'.codeUnitAt(0)]) cnt++;\n        }\n        j++;\n      }\n    }\n    return res;\n  }\n}"
            },
            {
                "language": "dart",
                "code": "class Solution {\n// Runtime: 555 ms, faster than 50.00% of Dart online submissions for Minimum Window Substring.\n// Memory Usage: 142.8 MB, less than 100.00% of Dart online submissions for Minimum Window Substring.\n  String minWindow(String s, String t) {\n    if (s == \"\" || t == \"\") return \"\";\n    if (s.isEmpty || t.isEmpty) return \"\";\n\n    int n = s.length;\n    int m = t.length;\n\n    List<int> freq = List.filled(128, 0);\n    int characters = 0;\n\n    for (int i = 0; i < m; i++) {\n      freq[t.codeUnitAt(i)]++;\n      characters++;\n    }\n\n    int start = 0, end = 0;\n    int min_length = double.maxFinite.toInt();\n    int start_index = 0;\n\n    while (end < n) {\n      if (freq[s.codeUnitAt(end)] > 0) characters--;\n      freq[s.codeUnitAt(end)]--;\n      end++;\n\n      while (characters == 0) {\n        if (min_length > end - start) {\n          min_length = end - start;\n          start_index = start;\n        }\n        freq[s.codeUnitAt(start)]++;\n        if (freq[s.codeUnitAt(start)] > 0) {\n          characters++;\n        }\n        start++;\n      }\n    }\n\n    return min_length == double.maxFinite.toInt()\n        ? \"\"\n        : s.substring(start_index, start_index + min_length);\n  }\n}"
            },
            {
                "language": "dart",
                "code": "class Solution {\n// Runtime: 309 ms, faster than 100.00% of Dart online submissions for Minimum Window Substring.\n// Memory Usage: 158.3 MB, less than 50.00% of Dart online submissions for Minimum Window Substring.\n  String minWindow(String s, String t) {\n    int m = s.length, n = t.length;\n    List<int> map = List.filled(128, 0);\n    for (int i = 0; i < n; i++) map[t.codeUnitAt(i)]++;\n\n    int count = 0, i = 0, j = 0, min = double.maxFinite.toInt(), si = -1;\n    while (j < m) {\n      if (map[s.codeUnitAt(j++)]-- > 0) count++;\n      while (count == n) {\n        if (j - i < min) {\n          min = j - i;\n          si = i;\n        }\n        if (++map[s.codeUnitAt(i++)] > 0) count--;\n      }\n    }\n    return si == -1 ? \"\" : s.substring(si, si + min);\n  }\n}"
            },
            {
                "language": "python",
                "code": "var minWindow = function (s, t) {\n  let cnt = {}, len = t.length, res = [], min = Infinity;\n  for (let char of t) {\n    cnt[char] = (cnt[char] || 0) + 1;\n  }\n  for (let r = 0, l = 0; r < s.length; r++) {\n    if (cnt[s[r]] > 0) len--;\n    cnt[s[r]]--;\n    while (!len) {\n      if (r - l < min) {\n        min = r - l;\n        res = [l, r];\n      }\n      if (cnt[s[l]] >= 0) len++;\n      cnt[s[l]]++;\n      l++;\n    }\n  }\n  return s.slice(res[0], res[1] + 1);\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string minWindow(string s, string t) {\n        unordered_map<char, int> mp;\n        for(auto it:t){\n            mp[it]++;\n        }\n        int cnt=mp.size();\n\n        string ans=\"\";\n        int len=INT_MAX;\n        int i=0, j=0;\n        int n=s.size();\n        while(j<n){\n            if(mp.count(s[j])>0){\n                mp[s[j]]--;\n                if(mp[s[j]]==0){\n                    cnt--;\n                }\n            }\n            if(cnt==0){\n                if(len>j-i+1){\n                    ans = s.substr(i, j-i+1);\n                    len = ans.size();\n                }\n                while(cnt==0){\n                    if(mp.count(s[i])>0){\n                        mp[s[i]]++;\n                        if(mp[s[i]]==1){\n                            cnt++;\n                            if(len>j-i+1){\n                    ans = s.substr(i, j-i+1);\n                    len = ans.size();\n                }\n                        }\n                    }\n                    i++;\n                }\n                \n                j++;\n            }\n            else{\n                j++;\n            }\n\n        }\n       \n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    string minWindow(string s, string t) {\n        if (s.size() < t.size() or s.empty()) {\n            return \"\";\n        }\n        \n        int i = 0, j = 0;\n        int start = -1, len = INT_MAX;\n        std::vector<int> m(128, 0);\n        \n        // Push elements of t into hash table.\n        for (auto c : t) {\n            m[c]++;\n        }\n        \n        while (j < s.size()) {\n            if (isFound(m)) {\n                // Current string contains all characters of t,\n                // then we start to shrink it from left.\n                if (j - i < len) {\n                    start = i;\n                    len = j - i;\n                }\n                m[s[i++]]++;\n                continue;\n            }\n            // Current string doesn't contain all characters of t,\n            // so we need to extend it and do checking in the next iteration.\n            m[s[j++]]--;\n        }\n        \n        // Try to shrink the last found string.\n        while (isFound(m)) {\n            if (j - i < len) {\n                start = i;\n                len = j - i;\n            }\n            m[s[i++]]++;\n        }\n        \n        if (start != -1) {\n            return s.substr(start, len);\n        }\n        return \"\";\n    }\n\nprivate:\n    // If all values of hash table are <= 0,\n    // it means all characters of t are included in current string\n    bool isFound(const std::vector<int>& m) {\n        return std::all_of(m.begin(), m.end(), [](int i) { return i <= 0; });\n    }\n};"
            }
        ]
    },
    "76": {
        "question_id": 77,
        "title": "Combinations",
        "difficulty": 2,
        "description": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].You may return the answer in any order. ",
        "examples": [
            {
                "input": "n = 4, k = 2",
                "output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
                "explanation": "There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination."
            },
            {
                "input": "n = 1, k = 1",
                "output": "[[1]]",
                "explanation": "There is 1 choose 1 = 1 total combination."
            }
        ],
        "constraints": [
            "1 <= n <= 20",
            "1 <= k <= n"
        ],
        "solutions": [
            {
                "language": "typescript",
                "code": "function combine(n: number, k: number): number[][] {\n  const result = [];\n\n  function dfs(cur) {\n    if (cur.length === k) {\n      result.push([...cur]);\n      return;\n    }\n\n    for (let i = (cur[cur.length - 1] || 0) + 1; i <= n; i++) {\n      cur.push(i);\n      dfs(cur);\n      cur.pop();\n    }\n  }\n\n  dfs([]);\n\n  return result;\n};"
            },
            {
                "language": "typescript",
                "code": "function combine(n: number, k: number): number[][] {\n  const result = [];\n\n  function dfs(cur: number[]) {\n    if (cur.length === k) {\n      result.push(cur);\n      return;\n    }"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(k*nCk), here nCk means the binomial coefficient of picking k elements out of n elements.\n    where nCk = C(n,k) = n!/(n\u2212k)!\u00d7k!.\n\n    Space Complexity : O(nCk), as stated above the nCk here refers to the binomial coefficient.\n\n    Solved using Array + Backtracking.\n\n*/\n\nclass Solution { \nprivate: \n    void combine(int n, int k, vector<vector<int>> &output, vector<int> &temp, int start){\n        if(temp.size() == k){\n            output.push_back(temp);\n            return;\n        }\n        for(int i=start; i<=n; i++){\n            temp.push_back(i);\n            combine(n, k, output, temp, i+1);\n            temp.pop_back();\n        }\n    }     \npublic:\n    vector<vector<int>> combine(int n, int k) {\n        vector<vector<int>> output;\n        vector<int> temp;\n        combine(n, k, output, temp, 1);\n        return output;\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        Set<List<Integer>> set = new HashSet<>();\n        for (int i = 1; i <= n; i++) {\n            List<Integer> list = new ArrayList<>();\n            findUsingBackTracking(i, k, n, list, set);\n        }\n        return new ArrayList<>(set);\n    }\n\n    private void findUsingBackTracking(int curr, int k, int n, List<Integer> list, Set<List<Integer>> set) {\n        if (list.size() > k) {\n            return;\n        }\n\n        list.add(curr);\n\n        if (list.size() == k) {\n            set.add(new ArrayList<>(list));\n        }\n\n        for (int i = curr + 1; i <= n; i++) {\n            findUsingBackTracking(i, k, n, list, set);\n        }\n        list.remove(list.size() - 1);\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> res=new ArrayList<>();\n        List<Integer> l=new ArrayList<>();\n        int arr[]=new int[n];\n        for(int i=0;i<n;i++){\n            arr[i]=i+1;\n        }\n        bt(0,res,l,k,arr);\n        return res;\n    }\n    void bt(int i,List<List<Integer>> res,List<Integer> l,int k,int arr[]){\n        if(i==arr.length){\n            if(l.size()==k){\n                res.add(new ArrayList<>(l));\n            }\n            return;\n        }\n        l.add(arr[i]);\n        bt(i+1,res,l,k,arr);\n        l.remove(l.size()-1);\n        bt(i+1,res,l,k,arr);\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void helper(vector<int>& nums, int k, int index, vector<int>& temp, vector<vector<int>>& ans)\n    {\n          if(index==nums.size())\n          {\n              if(temp.size()==k)\n              {\n                  ans.push_back(temp);\n              }\n              return ;\n          }\n          helper(nums, k, index+1, temp, ans);\n          temp.push_back(nums[index]);\n          helper(nums, k, index+1, temp, ans);\n          temp.pop_back();\n    }\n    vector<vector<int>> combine(int n, int k)\n     {\n        vector<vector<int>> ans;\n        vector<int> temp;\n        vector<int> nums;\n        for(int i = 1;i<=n;i++)\n        {\n            nums.push_back(i);\n        }\n        helper(nums,k,0,temp,ans);\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>>ans;\n    void backtrack(int n,int start,vector<int>&temp,int k){\n        if(temp.size()>k)return;\n        if(temp.size()==k)ans.push_back(temp);\n\n          for(int i=start;i<=n;i++){\n              temp.push_back(i);\n              backtrack(n,i+1,temp,k);\n              temp.pop_back();\n          }\n    }\n    vector<vector<int>> combine(int n, int k) {\n        vector<int>temp;\n         backtrack(n,1,temp,k);\n         return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void helper(vector<int>& nums, int k, int index, vector<int>& temp, vector<vector<int>>& ans){\n\n        \n          if(index==nums.size()){\n\n              if(temp.size()==k){\n                  ans.push_back(temp);\n              }\n              return ;\n          }\n\n          helper(nums, k, index+1, temp, ans);\n          temp.push_back(nums[index]);\n          helper(nums, k, index+1, temp, ans);\n          temp.pop_back();\n        \n\n\n\n    }\n    vector<vector<int>> combine(int n, int k) {\n        vector<vector<int>> ans;\n        vector<int> temp;\n        vector<int> nums;\n\n        for(int i = 1;i<=n;i++){\n            nums.push_back(i);\n        }\n\n        helper(nums,k,0,temp,ans);\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void helper(vector<int>& nums, int k, int index, vector<int>& temp, vector<vector<int>>& ans){\n\n        \n            if(k==0){\n                ans.push_back(temp);\n                return;\n            }\n          \n\n            if(index==nums.size()) return ;\n\n            for(int i = index;i<nums.size();i++){\n                temp.push_back(nums[i]);\n                helper(nums,k-1,i+1,temp,ans);\n                temp.pop_back();\n            }\n\n\n\n    }\n    vector<vector<int>> combine(int n, int k) {\n        vector<vector<int>> ans;\n        vector<int> temp;\n        vector<int> nums;\n\n        for(int i = 1;i<=n;i++){\n            nums.push_back(i);\n        }\n\n        helper(nums,k,0,temp,ans);\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> ans;\n    \n    void helper(int idx, int k,vector<int>&current,int n)\n    {\n        if(current.size()==k)    // base case\n        {\n            ans.push_back(current);\n            return;\n        }\n        \n        for(int i=idx;i<n+1;i++)\n        {\n            current.push_back(i);  //consider the current element i\n            helper(i+1,k,current,n); // generate combinations\n            current.pop_back(); //proceed to next element\n        }\n    }\n    \n    vector<vector<int>> combine(int n, int k) {\n        vector<int>current;\n        helper(1,k,current,n);\n        return ans; //return answer\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "void getSubsets(int n,int k, int idx, vector<int>res){\n    if(idx >= n && res.size() < k)\n        return;\n    if(res.size()==k){\n        result.push_back(res);\n        return;"
            },
            {
                "language": "cpp",
                "code": "vector<vector<int>> ans; \nvoid solve(int n,int k,int i,vector<int> &v)\n{\n    if(v.size() == k)\n    {\n        ans.push_back(v);\n        return;\n    }\n    "
            },
            {
                "language": "go",
                "code": "func combine(n int, k int) [][]int {\n var ans [][]int\n dfs(&ans, n, k-1, make([]int, k))\n return ans\n}\n\nfunc dfs(ans *[][]int, n int, k int, current []int) {\n if k == -1 {\n  dest := make([]int, len(current))\n  copy(dest, current)\n  *ans = append(*ans, dest)\n  return\n }\n\n for i := n; i > 0; i-- {\n  current[k] = i\n  dfs(ans, i-1, k-1, current)\n }\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n //declaring new list of list for storing results\n        List<List<Integer>> res = new ArrayList<>();\n  //calling the helper function\n        helper(n, k, 1,  res, new ArrayList<>());\n        return res;\n    }\n    private void helper(int n, int k, int idex, List<List<Integer>> res, List<Integer> temp){\n //when size of the temp list equals to k it is added to the final list 'res'\n        if(temp.size()==k){\n            res.add(new ArrayList<>(temp));\n   //after adding the temp to res just return \n            return;\n        }\n  //for loop for iterating over the range [1,n]\n        for(int i = idex; i<=n;i++){\n            temp.add(i);\n            helper(n, k, i+1, res, temp);\n   //backtracking to the previous numeber\n            temp.remove(temp.size()-1);\n        }\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n \n        List<List<Integer>> res = new ArrayList<>();\n        helper(n, k, 1,  res, new ArrayList<>());\n        return res;\n    }\n    private void helper(int n, int k, int idex, List<List<Integer>> res, List<Integer> temp){\n \n        if(temp.size()==k){\n            res.add(new ArrayList<>(temp));\n            return;\n        }\n  \n        for(int i = idex; i<=n;i++){\n            temp.add(i);\n            helper(n, k, i+1, res, temp);\n            temp.remove(temp.size()-1);\n        }\n    }\n}"
            }
        ]
    },
    "77": {
        "question_id": 78,
        "title": "Subsets",
        "difficulty": 2,
        "description": "Given an integer array nums of unique elements, return all possible subsets (the power set).The solution set must not contain duplicate subsets. Return the solution in any order. ",
        "examples": [
            {
                "input": "nums = [1,2,3]",
                "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
                "explanation": null
            },
            {
                "input": "nums = [0]",
                "output": "[[],[0]]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 10",
            "-10 <= nums[i] <= 10",
            "All the numbers of\u00a0nums are unique."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "public List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n        if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n} "
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> permute(int[] nums) {\n   List<List<Integer>> list = new ArrayList<>();\n   // Arrays.sort(nums); // not necessary\n   backtrack(list, new ArrayList<>(), nums);\n   return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n   if(tempList.size() == nums.length){\n      list.add(new ArrayList<>(tempList));\n   } else{\n      for(int i = 0; i < nums.length; i++){ \n         if(tempList.contains(nums[i])) continue; // element already exists, skip\n         tempList.add(nums[i]);\n         backtrack(list, tempList, nums);\n         tempList.remove(tempList.size() - 1);\n      }\n   }\n} "
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> permuteUnique(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\n    if(tempList.size() == nums.length){\n        list.add(new ArrayList<>(tempList));\n    } else{\n        for(int i = 0; i < nums.length; i++){\n            if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\n            used[i] = true; \n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, used);\n            used[i] = false; \n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> combinationSum(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\n    if(remain < 0) return;\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\n    else{ \n        for(int i = start; i < nums.length; i++){\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> combinationSum2(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n    \n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\n    if(remain < 0) return;\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\n    else{\n        for(int i = start; i < nums.length; i++){\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i + 1);\n            tempList.remove(tempList.size() - 1); \n        }\n    }\n} "
            },
            {
                "language": "typescript",
                "code": "public List<List<String>> partition(String s) {\n   List<List<String>> list = new ArrayList<>();\n   backtrack(list, new ArrayList<>(), s, 0);\n   return list;\n}\n\npublic void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\n   if(start == s.length())\n      list.add(new ArrayList<>(tempList));\n   else{\n      for(int i = start; i < s.length(); i++){\n         if(isPalindrome(s, start, i)){\n            tempList.add(s.substring(start, i + 1));\n            backtrack(list, tempList, s, i + 1);\n            tempList.remove(tempList.size() - 1);\n         }\n      }\n   }\n}\n\npublic boolean isPalindrome(String s, int low, int high){\n   while(low < high)\n      if(s.charAt(low++) != s.charAt(high--)) return false;\n   return true;\n} "
            },
            {
                "language": "csharp",
                "code": "Pick a starting point.\nwhile(Problem is not solved)\n    For each path from the starting point.\n        check if selected path is safe, if yes select it\n        and make recursive call to rest of the problem\n        before which undo the current move.\n    End For\nIf none of the move works out, return false, NO SOLUTON."
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrack(result, new ArrayList<Integer>(), nums, 0);\n        return result;\n    }\n    void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums, int start){\n        if(nums.length == start){"
            },
            {
                "language": "lisp",
                "code": "    for(int i = start; i < nums.length; i++){\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }"
            },
            {
                "language": "java",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        int n=nums.size();\n        for(int i=0;i<(1<<n);i++){\n            vector<int>v;\n            for(int j=0;j<n;j++){\n                if((1<<j)&i){\n                    v.push_back(nums[j]);\n                }\n            }\n            ans.push_back(v);\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic: \n    vector<vector<int>> ans;\n    void help(int i,vector<int>&temp,vector<int>& nums){\n    if(i==nums.size()){\n        ans.push_back(temp); // No need to return anything because the return type of this function is \"void\"\n        return;\n    }\n    temp.push_back(nums[i]);\n    help(i+1,temp,nums);\n    temp.pop_back();\n    help(i+1,temp,nums);\n}\n    vector<vector<int>> subsets(vector<int>& nums) {\n        //vector<vector<int>> ans;\n        vector<int>temp;\n        help(0,temp,nums);\n        return ans;\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\ndef subsets(self, nums: List[int]) -> List[List[int]]:\n    self.ans = []\n    self.length = len(nums)\n    self.helper([],nums,0)\n    return self.ans\n\ndef helper(self,arr,nums,ind):\n    if ind < self.length:\n        for i in range(ind,self.length):\n            self.helper(arr+[nums[i]],nums,i+1)\n    self.ans.append(arr)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void pS(int ind,vector<int> &nums,vector<int> &v,vector<vector<int>> &ans){\n        if(ind==nums.size()){\n            ans.push_back(v);\n            return;\n        }\n        v.push_back(nums[ind]);\n        pS(ind+1,nums,v,ans);\n        v.pop_back();\n        pS(ind+1,nums,v,ans);\n    }\n   \n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        vector<int> v;\n        pS(0,nums,v,ans);\n        return ans;\n    }\n};"
            },
            {
                "language": "",
                "code": "solve(temp,ans,s+1,nums);\n\ntemp.push_back(nums[s]);"
            },
            {
                "language": "cpp",
                "code": "class Solution {  \n  public:\n   vector<vector<int>>ans;\nvoid helpsub(vector<int>&nums,vector<int>subset,int i) {\n    if (i==nums.size()) {\n        ans.push_back(subset);\n        return;\n    }\n    subset.push_back(nums[i]);\n    helpsub(nums,subset,i+1);\n\n    subset.pop_back();\n    helpsub(nums,subset,i+1);\n}\n\nvector<vector<int>>subsets(vector<int>&nums) {\n    vector<int>subset;\n    helpsub(nums,subset,0);\n    return ans;\n}"
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function(nums) {\n    const output = [[]];\n    const hashmap = new Map();\n    \n    const backtracking = (curr, remaining, target) => {\n        if (!target) {\n            const key = curr.sort((a, b) => a - b).toString();\n            if (!hashmap.has(key)) {\n                output.push(curr);\n                hashmap.set(key, 1);\n            }\n            return;\n        }\n\n        for (let i = 0; i < remaining.length; i++) {\n            const item = remaining[i];\n            const newCurr = [...curr];\n            const newRemaining = [...remaining];\n\n            newCurr.push(item);\n            newRemaining.splice(0, i + 1)\n\n            backtracking(newCurr, newRemaining, target - 1);\n        }\n    }\n\n    for (let i = 1; i <= nums.length; i++) {\n        backtracking([], nums, i);\n    }\n\n    return output;\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    static void subsequence(int i,int[] arr, List<Integer> lst, List<List<Integer>> res){\n        if(res.contains(lst)) return;\n        if(i==arr.length){\n            res.add(new ArrayList<>(lst));\n            return;\n        }\n        lst.add(arr[i]);\n        subsequence(i+1, arr, lst, res);\n        lst.remove(lst.size()-1);\n        subsequence(i+1, arr, lst, res);\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> res=new ArrayList<>();\n        subsequence(0, nums, new ArrayList<>(), res);\n        return res;\n    }\n}"
            },
            {
                "language": "python",
                "code": "result = [[]]\ndef helper(res,list1):\n result.append(res)\n if not list1:\n  return\n for j in range(len(list1)):\n  helper(res+[list1[j]],list1[j+1:])\nfor i in range(len(nums)):\n helper([nums[i]],nums[i+1:])\nreturn result"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void backtrack(vector <vector <int>> & ans, vector <int> v, vector <int> nums, int i) {\n        if (i == nums.size()) {\n            ans.push_back(v);\n            return ;\n        }\n        v.push_back(nums[i]);\n        backtrack(ans, v, nums, i+1);\n        v.pop_back();\n        backtrack(ans, v, nums, i+1);\n    }\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector <vector <int>> ans;\n        vector <int> v;\n        // ans.push_back({});\n        int i=0;\n        backtrack(ans, v, nums, i);\n        return ans;\n    }\n};"
            }
        ]
    },
    "78": {
        "question_id": 79,
        "title": "Word Search",
        "difficulty": 2,
        "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. ",
        "examples": [
            {
                "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
                "output": "true",
                "explanation": null
            },
            {
                "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"",
                "output": "true",
                "explanation": null
            },
            {
                "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"",
                "output": "false",
                "explanation": null
            }
        ],
        "constraints": [
            "m == board.length",
            "n = board[i].length",
            "1 <= m, n <= 6",
            "1 <= word.length <= 15",
            "board and word consists of only lowercase and uppercase English letters."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\nprivate:\nint m, n;\nbool search_at(vector<vector<char>>& board, const string word, int char_idx, int x, int y){\n    char curr = board[x][y];\n    bool result = false;\n    if (curr != word[char_idx]) return result;\n    if (word.size() == char_idx+1) return true;\n    "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        for (size_t y = 0; y < board.size(); y++) {\n            for (size_t x = 0; x < board[y].size(); x++) {\n                if (dfs(board, x, y, word)) {\n                    return true;\n                }"
            },
            {
                "language": "java",
                "code": "class Solution {\n    private boolean dfs(int r, int c, int i, boolean[][] visited, char[][] board, String word){\n        if(i == word.length()){\n            return true;\n        }\n        if(r < 0 || c < 0 || r >= board.length || c >= board[0].length){\n            return false;\n        }"
            },
            {
                "language": "python",
                "code": "    n=len(board)\n    m = len(board[0])\n    lenword = len(word)\n    def backtrack(i,j,curr):\n        if curr == lenword:\n            return True\n        if i<0 or i>=n or j<0 or j>=m or board[i][j]!=word[curr]:\n            return False\n(i,j+1,curr+1) "
            },
            {
                "language": "python",
                "code": "        dic = {}\n        for row in range(len(board)):\n            for col in range(len(board[0])):\n                dic.setdefault(board[row][col], 0)\n                dic[board[row][col]]+=1"
            },
            {
                "language": "kotlin",
                "code": ""
            },
            {
                "language": "java",
                "code": "// We can take this array to move all 4 directions\nint[][] dir = new int[][]{ {1,0}, {-1,0}, {0,1}, {0,-1}};\n\npublic boolean exist(char[][] board, String word) {\n    int n = board.length;\n    int m = board[0].length;\n, String word){"
            },
            {
                "language": "ruby",
                "code": "def exist(board, word)\n    m, n = board.length, board[0].length\n    word = word.chars\n    tally = word.tally\n    word.reverse! if tally[word.first] > tally[word.last]\n    pos = 1\n    len_word = word.length.freeze # freeze is dumbish here. Thanks to @user9697N\n\n    dfs = proc do |i, j|\n        return true if pos == len_word\n        letter = word[pos]\n        [ [1,0], [-1, 0], [0, 1], [0, -1] ].each do |(a, b)|\n            ii, jj = i + a, j + b\n            next unless ii.between?(0, m - 1) && jj.between?(0, n - 1) && board[ii][jj] == letter\n            pos += 1\n            board[ii][jj] = nil\n            dfs.call(ii, jj)\n            pos -= 1\n            board[ii][jj] = letter\n        end\n    end\n\n    f = word.first.freeze # freeze is dumbish here. Thanks to @user9697N\n    m.times do |i|\n        n.times do |j|\n            letter = board[i][j]\n            next unless letter == f\n            board[i][j] = nil\n            dfs.call(i, j)\n            board[i][j] = letter\n        end\n    end\n    false\nend"
            },
            {
                "language": "ruby",
                "code": "require 'test/unit'\nclass Test_exist < Test::Unit::TestCase\n    def test_\n        assert_equal true, exist([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\")\n        assert_equal true, exist([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\")\n        assert_equal false, exist([[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\")\n    end\nend"
            },
            {
                "language": "",
                "code": "word.reverse! if tally[word.first] > tally[word.last]"
            },
            {
                "language": "java",
                "code": "class Solution {\n    boolean[][] visited;\n    int n,m;\n    public boolean exist(char[][] board, String word) {\n        //Approach: Using Backtracking \n        n = board.length;\n        m = board[0].length;\n\n        visited = new boolean[n][m];\n\n        //traverse through the boadrd and math with word\n        for(int i=0;i<board.length;i++){\n            for(int j=0;j<board[0].length;j++){\n                //if char at 0 of word is equa to board of [i][j]\n                if(board[i][j]==word.charAt(0)){\n                    //check for validation\n                    if(valid(i, j, 0, board, word)){\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    //backtrack function\n    public boolean valid(int i, int j, int count, char[][] board, String word){\n        //base case: out of bond condition\n        if(i<0 || i>=n || j<0 || j>=m) return false;\n\n        //if already visited\n        if(visited[i][j]) return false;\n\n        //if not match\n        if(board[i][j] != word.charAt(count)) return false;\n\n        //if the word is found in the bord, that means count will be equal to the size of the word-1\n        if(count == word.length()-1){\n            return true;\n        }\n\n        //calculation and recursive calls\n        //mark the visited array\n        visited[i][j] = true;\n\n        //increment the count \n        count++;\n\n        //call recursion for top, down, left, and right\n        if(valid(i+1, j, count, board, word) ||\n           valid(i, j+1, count, board, word) ||\n           valid(i-1, j, count, board, word) ||\n           valid(i, j-1, count, board, word)\n           ){\n               return true;\n           }\n        \n        //mark the curr than unvisited\n        visited[i][j] = false;\n\n        return false;\n\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\nbool search(vector<vector<char>> &b, string w,int r,int c){\n    \n    if(w.empty()){\n        return true;\n    }\n    \n    char val=b[r][c];\n    b[r][c]='*';\n    char ch=w[0];\n    bool dis=false;\n    if(r>0){\n        if(b[r-1][c]==ch){\n           \n            dis=dis||search(b,w.substr(1),r-1,c);\n    \n          \n        }\n    }\n    if(c>0){\n        if(b[r][c-1]==ch){\n            \n            dis=dis||search(b,w.substr(1),r,c-1);\n           \n        }\n    }\n    if(r<b.size()-1){\n        if(b[r+1][c]==ch){\n            dis=dis||search(b,w.substr(1),r+1,c);\n            \n        }\n    }\n    if(c<b[0].size()-1){\n        if(b[r][c+1]==ch){\n            dis=dis||search(b,w.substr(1),r,c+1);\n          \n        }\n    }\n   b[r][c]=val;\n    return dis;\n}\n    bool exist(vector<vector<char>>& b, string w) {\n        vector<vector<int>> start;\n        \n        vector<vector<int>> cord;\n       \n        for(int i=0;i<b.size();i++){\n            for(int j=0;j<b[i].size();j++){\n                if(b[i][j]==w[0]){\n                    cord.push_back({i,j});\n\n                }\n                \n                \n            }\n        }\n        \n        for(auto v:cord){\n            if(search(b,w.substr(1),v[0],v[1]))return true;\n            \n        }\n\n        return false;}\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution \n{\npublic:\n    bool searchNext(vector<vector<char>> &board, string word, int row, int col, \n    int index, int m, int n) \n    {\n        // if index reaches at the end that means we have found the word\n        if (index == word.length())\n            return true;\n\n        // Checking the boundaries if the character at which we are placed is not \n        //the required character\n        if (row < 0 || col < 0 || row == m || col == n || board[row][col] != \n        word[index] or board[row][col] == '*')\n            return false;\n\n        // this is to prevent reusing of the same character again and again\n        char c = board[row][col];\n        board[row][col] = '*';\n\n        // top direction\n        bool top = searchNext(board, word, row - 1, col, index + 1, m, n);\n       \n        // right direction\n        bool right = searchNext(board, word, row, col + 1, index + 1, m, n);\n       \n        // bottom direction\n        bool bottom = searchNext(board, word, row + 1, col, index + 1, m, n);\n        \n        // left direction\n        bool left = searchNext(board, word, row, col - 1, index + 1, m, n);\n\n        board[row][col] = c; // undo change\n\n        return top || right || bottom || left;\n    }\n    bool exist(vector<vector<char>> board, string word) \n    {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        int index = 0;\n\n        // First search the first character\n        for (int i = 0; i < m; i++) \n        {\n            for (int j = 0; j < n; j++)\n             {\n                 if (board[i][j] == word[index]) \n                 {\n                    if (searchNext(board, word, i, j, index, m, n))\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    bool[,] visited;\n    public bool Exist(char[][] board, string word) {\n        int m = board.Length, n = board[0].Length;\n        visited = new bool[m, n];\n        \n        for(int i = 0; i < m; i++)\n        {\n            for(int j = 0; j < n; j++)\n            {\n                if(word[0] == board[i][j] && DFS(board, new StringBuilder(word), 0, i, j))\n                   return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private bool DFS(char[][] b, \n                     StringBuilder word,\n                     int index, \n                     int i, \n                     int j)\n    {\n        if(word.Length == index)\n            return true;\n        if(i < 0 || i >= b.Length || j < 0 || j >= b[0].Length || b[i][j] != word[index] || visited[i, j])\n            return false;\n        \n        visited[i, j] = true;\n        \n        if(DFS(b, word, index + 1, i - 1, j) ||\n           DFS(b, word, index + 1, i + 1, j) ||\n           DFS(b, word, index + 1, i, j - 1) ||\n           DFS(b, word, index + 1, i, j + 1))\n            return true;\n        \n        visited[i, j] = false;\n        return false;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void getStartIdx(vector<vector<char>>& board,char ch,vector<pair<int,int>>& start){\n        for(int i=0;i<board.size();i++){\n            for(int j=0;j<board[0].size();j++){\n                if(board[i][j]==ch) start.push_back({i,j});\n            }\n        }\n    }\n    bool checkIfWordExist(vector<vector<char>>& board,string &word,int idx,int row,int col){\n        bool ans;\n        if(idx==word.size()) return true;\n        if(row>=board.size()||col>=board[0].size()||row<0||col<0||board[row][col]!=word[idx]) return false;\n        board[row][col] = '-';\n        ans = checkIfWordExist(board,word,idx+1,row+1,col) || checkIfWordExist(board,word,idx+1,row-1,col) ||checkIfWordExist(board,word,idx+1,row,col+1) || checkIfWordExist(board,word,idx+1,row,col-1);\n        board[row][col] = word[idx];\n        return ans;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        vector<pair<int,int>> start;\n        getStartIdx(board,word[0],start);\n        for(pair<int,int> startIdx:start){\n            int row = startIdx.first;\n            int col = startIdx.second;\n            if(checkIfWordExist(board,word,0,row,col)) return true;\n        }\n        return false;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool exist(vector<vector<char>>& b, string w) {\n        int n = b.size();\n        \n        int m = b[0].size();\n        \n        int i,j;\n        \n        for(i=0;i<n;i++){\n            for(j=0;j<m;j++){\n                if(b[i][j] == w[0]){\n                    char t = b[i][j];\n                    b[i][j] = '1';\n                    \n                    if(solve(i,j,n,m,1,w,b))\n                        return true;\n                    \n                    b[i][j] = t;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    bool solve(int i, int j, int n, int m, int in, string w, vector<vector<char>>& b){\n        if(in == w.size())\n            return true;\n        \n        int a[] = {0,0,1,-1};\n        int x[] = {1,-1,0,0};\n        \n        for(int k=0;k<4;k++){\n            int r = i+a[k];\n            int c = j+x[k];\n            \n            if(r<0 || c<0 || r>=n || c>=m || b[r][c]=='1' || b[r][c]!=w[in])\n                continue;\n            \n            char t = b[r][c];\n            b[r][c] = '1';\n            if(solve(r,c,n,m,in+1,w,b))\n                return true;\n            \n            b[r][c] = t;\n        }\n            \n        return false;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "//YouTube Link : https://www.youtube.com/watch?v=whyax_vB8xY\nclass Solution {\npublic:\n    int l, m, n;\n    vector<vector<int>> directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    bool find(vector<vector<char>>& board, int i, int j, string &word, int idx) {\n        if(idx >= l)\n            return true;\n        \n        if(i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[idx])\n            return false;\n        \n        char temp = board[i][j];\n        board[i][j] = '$';\n        \n        for(auto& dir : directions) {\n            int i_ = i + dir[0];\n            int j_ = j + dir[1];\n            \n            if(find(board, i_, j_, word, idx+1))\n                return true;\n        }\n        \n        board[i][j] = temp;\n        return false;\n    }\n    \n    bool exist(vector<vector<char>>& board, string word) {\n        m = board.size();\n        n = board[0].size();\n        l = word.length();\n        if(m*n < l)\n            return false;\n        \n        for(int i = 0; i<m; i++) {\n            for(int j = 0; j<n; j++) {\n                if(board[i][j] == word[0] && find(board, i, j, word, 0)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n};"
            },
            {
                "language": "go",
                "code": "type State struct {\n    r, c int\n}\n\nfunc exist(board [][]byte, word string) bool {\n    m, n := len(board), len(board[0])\n    v := make(map[State]struct{})\n    \n    for r := 0; r < m; r++ {\n        for c := 0; c < n; c++ {\n            if dfs(r, c, board, 0, word, v) {\n                return true\n            }\n        }\n    }\n    return false\n}\n\n\nfunc dfs(r int, c int, board [][]byte, i int, word string, v map[State]struct{}) bool {\n    s := State{r, c}\n    if _, ok := v[s]; ok {\n        return false\n    }\n    v[s] = struct{}{}\n    defer delete(v, s)\n    \n    if board[r][c] != word[i] {\n        return false\n    }\n    \n    if i+1 == len(word) {\n        return true\n    }\n    \n    m, n := len(board), len(board[0])\n    for _, d := range [][]int{{1,0}, {-1,0}, {0,1}, {0,-1}} {\n        rr, cc := r + d[0], c + d[1]\n        if rr >= 0 && rr < m && cc >= 0 && cc < n {\n            if dfs(rr, cc, board, i+1, word, v) {\n                return true\n            }\n        }\n    }\n    \n    return false\n}"
            }
        ]
    },
    "79": {
        "question_id": 80,
        "title": "Remove Duplicates from Sorted Array II",
        "difficulty": 2,
        "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.Return k after placing the final result in the first k slots of nums.Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.Custom Judge:The judge will test your solution with the following code:int[] nums = [...]; // Input arrayint[] expectedNums = [...]; // The expected answer with correct lengthint k = removeDuplicates(nums); // Calls your implementationassert k == expectedNums.length;for (int i = 0; i < k; i++) {    assert nums[i] == expectedNums[i];}If all assertions pass, then your solution will be accepted. ",
        "examples": [
            {
                "input": "nums = [1,1,1,2,2,3]",
                "output": "5, nums = [1,1,2,2,3,_]",
                "explanation": "Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            },
            {
                "input": "nums = [0,0,1,1,1,1,2,3,3]",
                "output": "7, nums = [0,0,1,1,2,3,3,_,_]",
                "explanation": "Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            }
        ],
        "constraints": [
            "1 <= nums.length <= 3 * 104",
            "-104 <= nums[i] <= 104",
            "nums is sorted in non-decreasing order."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\n    public int removeDuplicates(int[] arr) {\n      int prev = arr[0],k = 1,c=0;\n     for(int i=1;i<arr.length;i++){\n         if(prev==arr[i]) c++;\n         else if(prev!=arr[i]) c = 0;\n         if(c<=1) arr[k++] = arr[i];\n         prev = arr[i];\n     }\n     return k;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "int removeDuplicates(vector<int>& nums) {\n    int i = 0;\n    for (int n : nums)\n        if (i < 2 || n > nums[i-2])\n            nums[i++] = n;\n    return i;\n}"
            },
            {
                "language": "cpp",
                "code": "public int removeDuplicates(int[] nums) {\n    int i = 0;\n    for (int n : nums)\n        if (i < 2 || n > nums[i-2])\n            nums[i++] = n;\n    return i;\n}"
            },
            {
                "language": "ruby",
                "code": "def removeDuplicates(self, nums):\n    i = 0\n    for n in nums:\n        if i < 2 or n > nums[i-2]:\n            nums[i] = n\n            i += 1\n    return i"
            },
            {
                "language": "ruby",
                "code": "def remove_duplicates(nums)\n    i = 0\n    nums.each { |n| nums[(i+=1)-1] = n if i < 2 || n > nums[i-2] }\n    i\nend"
            },
            {
                "language": "cpp",
                "code": "int removeDuplicates(vector<int>& nums, int k) {\n    int i = 0;\n    for (int n : nums)\n        if (i < k || n > nums[i-k])\n            nums[i++] = n;\n    return i;\n}"
            },
            {
                "language": "cpp",
                "code": "int removeDuplicates(vector<int>& nums) {\n    if(nums.size()<3)\n        return nums.size();\n        \n    int idx = 2;\n    for(int i=2;i<nums.size();++i)\n    {"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        \n        int index = 1;  // Index of the next unique element to add to the array\n        int count = 1;  // Count of the current element\n    \n        // Loop through the array starting from the second element\n        for(int i = 1; i < nums.length; i++){\n        \n            // If the current element is the same as the previous element, increment the count\n            if(nums[i] == nums[i-1]){\n                count++;\n            } \n            // If the current element is different from the previous element, reset the count\n            else {\n                count = 1;\n            }\n        \n            // If the count is less than or equal to 2, add the current element to the array\n            if(count <= 2){\n                nums[index] = nums[i];\n                index++;\n            }\n        }\n    // Return the index, which represents the number of unique elements in the array after removing duplicates\n    return index;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        map<int, int>m;\n        for(int i=0; i<nums.size(); i++){\n            if(m[nums[i]]==2){\n                nums.erase(nums.begin()+i);\n                i--;\n            }\n            else{\n                m[nums[i]]++;\n            }\n        }\n        return nums.size();\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        // the intution behind this ->  go through all the elements, along with that check if the \n  // current element has been included previously or not\n  // if included skip it, else add it\n    int ind = 0;\n    for (auto it : nums) \n    {\n        if (ind < 2 or it > nums[ind-2]) \n        {\n            nums[ind++] = it;\n        }\n    }\n    return ind; // this will contain the no of unique elements in the array\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution\n{\npublic:\n    int removeDuplicates(vector<int> &nums)\n    {\n        int prev = nums[0], count = 1, pos = 1;\n        for (int i = 1; i < nums.size(); i++)\n            if (prev != nums[i])"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def removeDuplicates(self, nums):\n  if len(nums) < 2: return len(nums)\n        slow, fast = 2, 2\n\n        while fast < len(nums):\n            if nums[slow - 2] != nums[fast]:\n                nums[slow] = nums[fast]\n                slow += 1\n            fast += 1\n        return slow"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n       \"\"\"\n        [1,1,1,1,1,2,2,2,3]\n             sf                : nums[f] == nums[s-2] ; f is at a dupe ; s is at first dupe >2 \n             s f               : nums[f] == nums[s-2] ; f is at a dupe ; s is at first dupe >2\n             s   f             : nums[f] == nums[s-2] ; f is at a dupe ; s is at first dupe >2\n             s    f            : nums[f] != nums[s-2] ; f is at next val; swap and move s ahead"
            },
            {
                "language": "go",
                "code": "    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) <= 2:\n            return len(nums)\n        \n        pointer = 1\n        for i in range(2,len(nums)):\n            if nums[i] != nums[pointer-1]:\n                pointer += 1"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        low, i = 0, 0\n        for curr, num in enumerate(nums):\n            if num != nums[low]:\n                low = curr\n            if curr - low < 2:\n                nums[i] = num"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        # each unique element appears at most x times, nums[:k+1] is the array without duplicates\n        k = x = 2\n        for i in range(x, len(nums)):\n            if nums[i] != nums[k-x]:\n                nums[k] = nums[i]\n                k += 1"
            },
            {
                "language": "",
                "code": "----------------- ||  Please leave a like  || --------------"
            },
            {
                "language": "cpp",
                "code": "//---------------- BEST SOLUTION ------------------\n\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int k = 0;\n        for(int i : nums){\n            if(k==0 || k == 1 || i != nums[k-2] ){\n                nums[k++] = i;\n            }\n        }\n        return k;\n\n    }\n}"
            },
            {
                "language": "",
                "code": "----------------- ||  Please leave a like  || --------------"
            },
            {
                "language": "cpp",
                "code": "//------------Brute Force solution------------------\n\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int k = 0;\n        for(int i = 0 ; i<nums.length; i++){\n            int count = 1;\n            for (int j = i+1; j<nums.length ; j++){\n                if(nums[i] == nums[j]){\n                    count = count + 1;\n                }\n            }\n            if(count > 2){\n                nums[i] = Integer.MAX_VALUE;\n                k++;\n            }\n        }\n        Arrays.sort(nums);\n        return nums.length-k;\n\n    }\n}"
            },
            {
                "language": "",
                "code": "----------------- ||  Please leave a like  || --------------"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n       int cnt=1; // this will keep track of duplicate element    atmost 2.\n       for(int i=1;i<nums.size();++i)\n       {\n           if(nums[i-1]==nums[i])  \n           {\n               if(cnt==2) // cnt already 2 then..\n               {\n                  int index=i;// keeping track of curr index\n                  while(i<nums.size() && nums[i-1]==nums[i]) i++; // increament till we reach to non-duplicate element.\n                  nums.erase(nums.begin()+index,nums.begin()+i); removing all the duplicate from nums from index to i.\n                  i=index-1;\n                  cnt=1; // making cnt again 1.\n               }\n               else ++cnt;\n           }\n           else cnt=1; // if nums[i]!=nums[i-1] then update cnt to 1.\n       }\n       return nums.size(); // returning size after erasing duplicate from nums.\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int solution_ptr = 0, count = 0, len = nums.size();\n        int ptr = 0;\n        while (ptr < len)\n        {\n            int temp = nums[ptr];"
            },
            {
                "language": "java",
                "code": "public int removeDuplicates(int[] nums) {\n var n = nums.length;\n if (n < 3)\n  return n;\n  \n var i = 2;\n for (var j = i; j < n; j++)\n  if (nums[j] != nums[i - 2])\n   nums[i++] = nums[j];\n   \n return i;\n}"
            },
            {
                "language": "java",
                "code": "public int removeDuplicates(int[] nums, int k) {\n var n = nums.length;\n if (n < k + 1)\n  return n;\n  \n var i = k;\n for (var j = i; j < n; j++)\n  if (nums[i - k] != nums[j])\n   nums[i++] = nums[j];\n   \n return i;\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution\n{\npublic:\n    int removeDuplicates(vector<int> &nums)\n    {\n        int prev = nums[0], count = 1, pos = 1;\n        for (int i = 1; i < nums.size(); i++)\n            if (prev != nums[i])"
            },
            {
                "language": "cpp",
                "code": "public int removeDuplicates(int[] nums) {\n    int i = 0;\n    for(int n : nums)\n        if(i < 1 || n > nums[i - 1]) \n            nums[i++] = n;\n    return i;\n}"
            },
            {
                "language": "cpp",
                "code": "public int removeDuplicates(int[] nums) {\n   int i = 0;\n   for (int n : nums)\n      if (i < 2 || n > nums[i - 2])\n         nums[i++] = n;\n   return i;\n}"
            },
            {
                "language": "cpp",
                "code": "    public int removeDuplicates(int[] A) {\n        int i = 2;\n        for (int j = 2; j < A.length; j++)\n            if (A[j] != A[i-2])\n                A[i++] = A[j];\n        return i;\n    }"
            }
        ]
    },
    "80": {
        "question_id": 81,
        "title": "Search in Rotated Sorted Array II",
        "difficulty": 2,
        "description": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).Before being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.You must decrease the overall operation steps as much as possible. ",
        "examples": [
            {
                "input": "nums = [2,5,6,0,0,1,2], target = 0",
                "output": "true",
                "explanation": null
            }
        ],
        "constraints": [],
        "solutions": [
            {
                "language": "csharp",
                "code": "1. Easy C++\n2. Line by Line Explanation with Comments.\n3. Detailed Explanation \u2705\n4. Initution is to use Binary Search\n5. Please Upvote if it helps\u2b06\ufe0f\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \u2b07\ufe0f\n // \ud83d\ude09If you Like the repository don't foget to star & fork the repository\ud83d\ude09"
            },
            {
                "language": "cpp",
                "code": "   // \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09Please upvote if it helps \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09\nclass Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        int l = 0;\n        int r = nums.size() - 1;\n        \n        while(l <= r)\n        {\n            int mid = l + (r-l) / 2;\n            if (nums[mid] == target)\n                return true;\n   // with duplicates we can have this contdition, just update left & right\n            if((nums[l] == nums[mid]) && (nums[r] == nums[mid]))\n            {\n                l++;\n                r--;\n            }\n   // first half\n   // first half is in order\n            else if(nums[l] <= nums[mid])\n            {\n    // target is in first  half\n                if((nums[l] <= target) && (nums[mid] > target))\n                    r = mid - 1;\n                else\n                    l = mid + 1;\n            }\n   // second half\n   // second half is order\n   // target is in second half\n            else\n            {\n                if((nums[mid] < target) && (nums[r]>= target))\n                    l = mid + 1;\n                else\n                    r = mid - 1;\n            }\n        }\n        return false;\n    }\n // for github repository link go to my profile.\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        for(int i = 0; i < nums.size(); i++)\n            if(nums[i] == target) return true;\n        return false;\n    }\n};"
            },
            {
                "language": "dart",
                "code": ""
            },
            {
                "language": "",
                "code": "if((nums[l] == nums[mid]) && (nums[r] == nums[mid]))\n {\n          l++;\n          r--;"
            },
            {
                "language": "python",
                "code": "# If the length of the given array list is 1, then check the first element and return accordingly\nif len(nums)==1:\n    if nums[0]!=target:\n        return False\n    else:\n        return True\n\nleft=0\nright=len(nums)-1\n# binary search \nwhile(left<=right):\n\n    # shifting to remove duplicate elements\n    while left<right and nums[left] == nums[left+1]:\n        left+=1\n    while left<right and nums[right] == nums[right-1]:\n        right-=1\n\n    # step 1 calculate the mid    \n    mid=(left+right)//2\n\n    #step 2\n    if nums[mid]==target:\n        return True\n\n    #step 3\n    elif nums[left]<=nums[mid]:\n        if nums[mid]>=target and nums[left]<=target:\n            right=mid-1\n        else:\n            left=mid+1\n\n    # step 4\n    else:\n        if target>=nums[mid] and target<=nums[right]:\n            left=mid+1\n        else:\n            right=mid-1\n\n# step 5\nreturn False"
            },
            {
                "language": "cpp",
                "code": "bool search(vector<int>& nums, int target) {\n    int n = nums.size();\n    int min_index = 0;"
            },
            {
                "language": "java",
                "code": "class Solution {\n  int findRotation(int [] nums, int first, int count) {\n    while(count > 0) {\n      int steps = count >> 1;\n      int it = first + steps;\n      if(nums[it] > nums[0]) {\n        first = it+1;\n        count -= (steps+1);"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        \n        if( nums[0] == target or nums.back() == target ) return true; \n        // this line is redundant it reduces only the worst case when all elements are same to O(1)\n        \n        const int n = nums.size();\n        int l = 0 , h = n-1;\n        while( l+1 < n and nums[l] == nums[l+1]) l++;\n\n        // if all elements are same\n        if( l == n-1){\n            if( nums[0] == target ) return true;\n            else return false;\n        }\n        \n        // while last element is equal to 1st element\n        while( h >= 0 and nums[h] == nums[0] ) h--;\n        int start = l , end = h;\n        \n        // find the point of pivot ie from where the rotation starts\n        int pivot = -1;\n        while( l <= h ){\n            int mid = l + (h-l)/2;\n            if( nums[mid] >= nums[0] ) l = mid+1;\n            else {\n                pivot = mid;\n                h = mid-1;\n            }\n        }\n        \n        \n        if( pivot == -1 ) l = start , h = end; // if no pivot exits then search space is from start -e end\n        else {\n            if( target > nums[end] ) l = start , h = pivot-1; // search space second half\n            else l = pivot , h = end; // search space first half\n        }\n        \n        // normal binary search\n        while ( l <= h ){\n            int mid = l + (h-l)/2;\n            if( nums[mid] > target ) h = mid-1;\n            else if( nums[mid] < target ) l = mid+1;\n            else return true;\n        }\n        \n        return false;\n        \n    }\n};"
            },
            {
                "language": "javascript",
                "code": "if( target > nums[end] ) l = start , h = pivot-1; // search space second half\n            else l = pivot , h = end; // search space first half"
            },
            {
                "language": "ruby",
                "code": "for(int i = 1 ; i<n; i++)"
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {boolean}\n */"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool search(vector<int>& nums, int t) {\n        int n= nums.size();\n        int low=0, high=n-1;\n        while(low<=high)\n        {\n           int mid=low+(high-low)/2;\n           if(nums[mid]==t)\n           {return true;}\n    else if((nums[low]==nums[mid]) && (nums[high]==nums[mid])){\n                low++; high--;\n            }\n           else if(nums[low]<=nums[mid])\n           {\n              if(nums[low]<=t and t<nums[mid])\n              {\n                high=mid-1;\n              }\n              else\n              {\n                low=mid+1; \n              }\n           }\n           else\n           {\n              if(nums[mid]<t and t<=nums[high])\n              {\n                low=mid+1;\n              }\n              else\n              {\n                high=mid-1;\n              }\n           }\n        }\n        return false;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool search(vector<int>& nums, int target) \n    {\n        int low = 0;\n        int high = nums.size()-1;\n        while(low <= high)\n        {\n            int mid = (low + high)/2;\n            if(nums[mid] == target)\n            {\n                return true;\n            }\n            if((nums[low] == nums[mid]) && (nums[high] == nums[mid]))\n            {\n               low++;\n               high--;\n            }\n            else if(nums[low] <= nums[mid])\n            {\n                if(target >= nums[low] && target < nums[mid])\n                {\n                    high = mid-1;\n                }\n                else\n                {\n                    low = mid + 1;\n                }\n            }\n            else\n            {\n                if(target > nums[mid] && target <= nums[high])\n                {\n                    low = mid + 1;\n                }\n                else\n                {\n                    high = mid -1;\n                }\n            }\n        }\n        return false;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool search(vector<int>& a, int k) {\n        int l=0;\n       int h=a.size()-1;\n       while(l<=h){\n            int mid=(l+h)/2;\n            \n            if(a[mid]==k) return true;\n            if((a[l]==a[mid]) && (a[h]==a[mid]))\n            {\n                l++;\n                h--;\n            }\n            else if(a[l]<=a[mid]){\n                if(k>=a[l] && k<a[mid]){\n                    h=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }\n            }\n            else{\n                if(k<=a[h] && k>a[mid]){\n                    l=mid+1;\n                }\n                else{\n                    h=mid-1;\n                }\n            }\n        }\n        return false;\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "    }\n    return false;\n}"
            },
            {
                "language": "",
                "code": ""
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n\n        low = 0\n        high = len(nums) - 1\n\n\n        while low <= high:\n            mid = (low + high) // 2\n            \n            if nums[mid] == target:\n                return True\n            \n            if nums[mid] == nums[low]:\n                low += 1\n                continue\n                \n            if nums[mid] > nums[high]:\n                if nums[low] <= target < nums[mid]:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n            elif nums[mid] < nums[high]:\n                if nums[mid] < target <= nums[high]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            else:\n                high -= 1\n                \n\n        return False"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        int s=0,e=nums.size()-1;\n        while(s<=e){\n            int mid=s+(e-s)/2;\n            if(nums[mid]==target){\n                return true;\n            }\n            if(nums[mid]==nums[s]&&nums[mid]==nums[e]){\n                s++;e--;\n            }\n            else if(nums[mid]>=nums[s]){\n                if(nums[s]<=target &&nums[mid]>target) e=mid-1;\n                else s=mid+1;\n            }\n            else{\n            if(nums[mid]<target &&nums[e]>=target) s=mid+1;\n            else e=mid-1;\n            }\n        }\n        return false;\n\n    }\n};"
            }
        ]
    },
    "81": {
        "question_id": 82,
        "title": "Remove Duplicates from Sorted List II",
        "difficulty": 2,
        "description": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well. ",
        "examples": [
            {
                "input": "head = [1,2,3,3,4,4,5]",
                "output": "[1,2,5]",
                "explanation": null
            },
            {
                "input": "head = [1,1,1,2,3]",
                "output": "[2,3]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is in the range [0, 300].",
            "-100 <= Node.val <= 100",
            "The list is guaranteed to be sorted in ascending order."
        ],
        "solutions": [
            {
                "language": "lisp",
                "code": "O(n)"
            },
            {
                "language": "lisp",
                "code": "O(n)"
            },
            {
                "language": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        ArrayList<Integer> list=new ArrayList<Integer>();\n        ListNode temp=head;\n        while(temp!=null){\n                if(map.containsKey(temp.val)){\n                    map.put(temp.val,2);\n                }else{\n                    map.put(temp.val,1);\n                }\n                list.add(temp.val);\n                temp=temp.next;\n        }\n        for(int i=0;i<list.size();i++){\n            if(map.get(list.get(i))>1){\n                list.add(i,-101);\n                list.remove(i+1);\n            }\n        }\n        if(list.isEmpty()){\n            return null;\n        }\n        if(list.get(0)==-101){\n            while(!list.isEmpty() && list.get(0)==-101){\n                list.remove(0);\n            }\n        }\n        if(list.isEmpty()){\n            return null;\n        }\n       ListNode ans=new ListNode(list.get(0));\n       ListNode copy=ans;\n       \n       for(int i=1;i<list.size();i++){\n           if(list.get(i)==-101){\n               continue;\n           }\n           copy.next=new ListNode(list.get(i));\n           copy=copy.next;\n       }\n\n        return ans;\n    }\n}"
            },
            {
                "language": "rust",
                "code": "public:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if(head==0||head->next==0)return head;\n        int flag=0;\n        ListNode*prev=0,*cur=head,*nex=head->next,*dummy=0;\n           prev=new ListNode;\n            dummy=prev;\n        prev->next=head;\n        while(nex!=0)\n        {\n            if(cur->val==nex->val)\n            {\n                prev->next=nex;\n                cur=prev->next;\n                nex=cur->next;\n                flag=1;\n            }\n            else if(flag==1)\n            {\n                 prev->next=nex;\n                cur=prev->next;\n                nex=cur->next;\n                flag=0;\n            }\n            else\n            {\n                prev=prev->next;\n                cur=cur->next;\n              nex=nex->next;      \n            }\n        }\n         if(flag==1)\n            {\n                prev->next=0;\n            }\n        return dummy->next;\n        \n    }\n};```"
            },
            {
                "language": "rust",
                "code": "use std::collections::HashMap;\n\nimpl Solution {\n pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n  let mut map = HashMap::new();\n  Self::delete_build(head, &mut map)\n }\n\n pub fn delete_build(mut node: Option<Box<ListNode>>, map: &mut HashMap<i32, bool>) -> Option<Box<ListNode>> {\n  let mut to_build = false;\n  while let Some(curr_node) = node.take() {\n   if let Some(next_node) = curr_node.next.as_ref() {\n    // if current node's value is not equal to next ndoe's value\n    // and it is not exist in duplicated value's hashmap then proceed to add it\n    if curr_node.val != next_node.val && !map.contains_key(&curr_node.val) {\n     to_build = true;\n    } else {\n     map.insert(curr_node.val, true);\n    }\n   } else {\n    // reach the end here :)\n    // this time the next node is `None`\n    if !map.contains_key(&curr_node.val) {\n     to_build = true;\n    }\n   }\n   if to_build {\n    // recursively build the new list\n    return Some(Box::new(ListNode {\n     val: curr_node.val,\n     next: Self::delete_build(curr_node.next, map)\n    }));\n   } else {\n    // pass to the next node\n    node = curr_node.next;\n   }\n  }\n  None\n }\n}"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def deleteDuplicates(self, head):\n        if head is not None:\n            if head.next is not None:\n                if head.val == head.next.val:\n                    headTemp = self.deleteDuplicates(head.next)\n                    if headTemp is not None:\n                        if head.val == headTemp.val:\n                            if headTemp is not None:\n                                return headTemp.next\n                            return None\n                    return headTemp\n                else:\n                    head.next = self.deleteDuplicates(head.next)\n        return head"
            },
            {
                "language": "rust",
                "code": "    ListNode *dummy=new ListNode(0,head);\n       ListNode *prev=dummy;\n        \n        while(head!=NULL){\n       \n        if(head->next!=NULL && head->val==head->next->val){\n                \nwhile(head->next!=NULL && head->val==head->next->val)head=head->next;\n                     \n                   \n                        prev->next=head->next;\n                }\n                \n                else prev=prev->next;\n                       \n               \n                head=head->next;\n        }\n        \n        return dummy->next;\n            \n    }\n \n \n //if(you_like_and_understand_my_solution)\n //{\n //  please_upvote++;\n // }\n \n /*Guys plz plz plz upvote my solution if you really like and understand it.and if you stuck at any point then feel free to comment*/."
            },
            {
                "language": "ruby",
                "code": "ListNode* deleteDuplicates(ListNode* head) {\n    ListNode dummy(0, head);\n    ListNode *previous = &dummy, *current = head;\n    \n    while(current) {\n        ListNode *next_node = current->next;\n        while(next_node && current->val == next_node->val) {\n            ListNode *temp = next_node->next;"
            },
            {
                "language": "kotlin",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head==null) return null;\n\n        ListNode ans=new ListNode();\n        ans.next=head;\n\n        ListNode ptr=ans;\n\n        while(ptr.next!=null && ptr.next.next!=null){\n\n            if(ptr.next.val == ptr.next.next.val){\n                int value=ptr.next.val;\n                while(ptr.next!=null && ptr.next.val==value){\n                    ptr.next=ptr.next.next;\n                }\n            }\n            else{\n                ptr=ptr.next;\n            }\n        }\n        return ans.next;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* t=head;\n        int c=1;\n        ListNode* dummy=new ListNode(1);\n        ListNode* ans=dummy;\n        int f=1;\n        while(f && t)\n        {\n            ListNode* p=t;\n            int c=0;\n            while(t->next && t->val==t->next->val)\n            {\n                c++;\n                t=t->next;\n            }\n            if(c==0)\n            {\n                ans->next=p;\n                ans=ans->next;\n            }\n            t=t->next;\n        }\n        ans->next=NULL;\n        return dummy->next;\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head == null) { return null; }\n        \n        HashMap<Integer, Integer> map = new HashMap<>();\n        ListNode node = head;\n        \n        // Traversing the LL and making the Map such that we can point duplicates\n        while(node != null){\n            if(map.containsKey(node.val)) { map.put(node.val, 1); }\n            else { map.put(node.val, 0); }\n            node = node.next;\n        }\n        \n        HashSet<Integer> finalNodeVals = new HashSet<>();\n        for(int i : map.keySet()){\n            if(map.get(i) == 0) { finalNodeVals.add(i); }\n        }\n        \n        if(finalNodeVals.size() == 0) { return null; }\n        \n        ListNode node1 = head, finalHead = head;\n        boolean first = true;\n        \n        while(node1 != null){\n            if(finalNodeVals.contains(node1.val) && first == true) { \n                head = node1; finalHead = head; first = false; \n            }\n            else if(finalNodeVals.contains(node1.val) && first == false) { \n                head.next = node1; head = head.next;\n            }\n            node1 = node1.next;\n        }\n        \n        head.next = null;\n        \n        return finalHead;\n    }\n}"
            },
            {
                "language": "ruby",
                "code": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode pre = new ListNode(0);\n        pre.next = head;\n        ListNode curr = head, ans = pre;\n        \n        while(curr != null){\n            while(curr.next != null && curr.val == curr.next.val){\n                curr = curr.next;\n            }\n            if(pre.next != curr){\n                pre.next = curr.next;\n            }\n            else{\n                pre.next = curr; pre = pre.next;\n            }\n            curr = curr.next;\n        }\n        \n        return ans.next;\n    }\n}"
            },
            {
                "language": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {    \n        ListNode result = new ListNode(0, null);\n        ListNode curr = result;\n        boolean isRepeated = false;\n        while (head != null){\n            while (head.next != null && head.val == head.next.val){\n                isRepeated = true;\n                head = head.next;\n            }\n            \n            if (!isRepeated){\n                curr.next = new ListNode(head.val, null);\n                curr = curr.next;\n            }\n            \n            isRepeated = false;\n            head = head.next;\n        }\n        return result.next;\n    }\n}"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n\n        if(head == NULL || head->next == NULL) return head;\n\n        ListNode* dummy = new ListNode(0);\n        dummy->next = head;\n        ListNode* curr = head;\n        ListNode* prev = dummy;\n\n        while(curr != NULL){\n            if(curr->next != NULL && curr->val == curr->next->val){\n                while(curr->next != NULL && curr->val == curr->next->val){\n                    curr= curr->next;\n                }\n                prev->next = curr->next;\n            }\n            else{\n                prev = curr;\n            }\n            curr = curr->next;\n        }\n        return dummy->next;\n    }\n};"
            }
        ]
    },
    "82": {
        "question_id": 83,
        "title": "Remove Duplicates from Sorted List",
        "difficulty": 1,
        "description": "Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. ",
        "examples": [
            {
                "input": "head = [1,1,2]",
                "output": "[1,2]",
                "explanation": null
            },
            {
                "input": "head = [1,1,2,3,3]",
                "output": "[1,2,3]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is in the range [0, 300].",
            "-100 <= Node.val <= 100",
            "The list is guaranteed to be sorted in ascending order."
        ],
        "solutions": [
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* temp=head;\n        while (temp&&temp->next)\n        {\n            if (temp->next->val==temp->val)\n            {\n                temp->next=temp->next->next;\n                continue;\n            }\n            temp=temp->next;\n        }\n        return head;\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution(object):\n    def deleteDuplicates(self, head):\n        temp = head\n        while (temp and temp.next):\n            if (temp.next.val == temp.val):\n                temp.next = temp.next.next\n                continue\n            temp = temp.next\n        return head\n        "
            },
            {
                "language": "rust",
                "code": "struct ListNode* deleteDuplicates(struct ListNode* head) {\n    struct ListNode* temp=head;\n    while (temp&&temp->next)\n    {\n        if (temp->next->val==temp->val)\n        {\n            temp->next=temp->next->next;\n            continue;\n        }\n        temp=temp->next;\n    }\n    return head;\n}"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode temp = head;\n        while (temp != null && temp.next != null)\n        {\n            if (temp.next.val==temp.val)\n            {\n                temp.next=temp.next.next;\n                continue;\n            }\n            temp=temp.next;\n        }\n        return head;\n    }\n}"
            },
            {
                "language": "ruby",
                "code": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode curr = head;\n\n        while(head != null && head.next != null) {\n            if(head.val == head.next.val) head.next = head.next.next;\n            else head = head.next;\n        } \n        return curr;\n    }\n}"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if (head == null)\n            return null;\n        ListNode tmp = head;\n        ListNode tmpT = head;\n        while (tmp.next != null)\n        {\n            if (tmp.next.val == tmp.val) {\n                tmpT = tmp;\n                while (tmpT.next != null && tmpT.next.val == tmpT.val)\n                    tmpT = tmpT.next;\n                tmp.next = tmpT.next;\n            }\n            if (tmp.next != null) tmp = tmp.next;\n        }\n\n        return head;\n    }\n}"
            },
            {
                "language": "scala",
                "code": "if(curr.val == itr.val)\n    curr = curr.next; "
            },
            {
                "language": "python",
                "code": "itr.next = curr;\nitr = itr.next;\ncurr = curr.next;"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n        ListNode curr = head.next, itr = head;\n        while(curr != null){\n            if(curr.val == itr.val)\n                curr = curr.next;\n            else{\n                itr.next = curr;\n                itr = itr.next;\n                curr = curr.next;\n            }\n        }\n        itr.next = null;\n        return head;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        struct ListNode* p=head;\n        if(p==NULL){\n            return head;\n        }\n        struct ListNode* q=p->next;\n       struct ListNode* ans;\n       while(q!=NULL){\n           if(p->val != q->val){\n               p=q;\n               q=q->next;\n           }\n           else{\n               p->next=q->next;\n               delete q;\n               q=p->next;\n           }\n       }\n       return head;\n\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "public class Solution {\n    public ListNode DeleteDuplicates(ListNode head) {\n        \n        if(head == null)\n            return null;\n\n        if(head.next == null)\n            return head;\n\n        ListNode prevNode = head;\n        for(ListNode node = head.next; node != null; node = node.next)\n        {\n            if(node.val == prevNode.val)\n            {\n                prevNode.next = node.next;\n            }\n            else \n            {\n                prevNode = node;\n            }\n        }\n\n        return head;\n\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n//prev\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode *p=head;\n        ListNode *prev=NULL;\n        if(head==NULL||head->next==NULL)\n        return head;\n        else\n        {\n            prev=head;\n            p=prev->next;\n        }\n        while(1)\n        {\n            if(prev->val==p->val)\n            {\n                if(p->next==NULL)\n                {prev->next=NULL;break;}\n                prev->next=p->next;}\n            else\n            {\n                prev=p;\n            if(p->next==NULL)\n            break; }\n            \n\n            \n            p=p->next;\n        }\n     return head;   \n    }\n};"
            },
            {
                "language": "rust",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode *ans = new ListNode(0);\n        ListNode *curr = ans;\n\n        while(head) {\n            while(head->next && head -> val == head -> next -> val) head = head -> next;\n            curr -> next = head;\n            curr = head;\n            head = head -> next;\n        }\n        return ans->next;\n    }\n};"
            },
            {
                "language": "rust",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode *I =head;\n        while(I!=NULL && I->next!=NULL){\n            if(I->val==I->next->val){\n                ListNode* temp = I->next;\n                I->next = I->next->next;\n                delete(temp);\n            }else I = I->next;\n        }\n        return head;   \n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode temp = head;\n        while (temp != null) {\n            while(temp.next != null && temp.next.val == temp.val) \n                temp.next = temp.next.next;\n            temp = temp.next;\n        } return head;   \n    }\n}"
            }
        ]
    },
    "83": {
        "question_id": 84,
        "title": "Largest Rectangle in Histogram",
        "difficulty": 3,
        "description": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram. ",
        "examples": [
            {
                "input": "heights = [2,1,5,6,2,3]",
                "output": "10",
                "explanation": "The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units."
            },
            {
                "input": "heights = [2,4]",
                "output": "4",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= heights.length <= 105",
            "0 <= heights[i] <= 104"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution {\n    public int largestRectangleArea(int[] height) {\n        /*\n        //Brute force approach, TLE\n        int n = height.length;\n        //base case \n        if(n==0) return 0;\n        int maxArea = 0;\n\n        //initialize left and right array,\n         //Main aim is to find the nearest smallest element to the left and the right\n\n         int[] left = new int[n];\n         int[] right = new int[n];\n\n         //add -1 in 0th index of left & n in n-1th index of right\n         left[0] = -1;\n         right[n-1] = n;\n\n         //find and add the less height from the left\n         for(int i=1;i<n;i++){\n             int prev = i-1;\n             while(prev>=0 && height[prev]>=height[i]){\n                 prev = left[prev];\n             }\n             left[i] = prev;\n         }\n\n         //find and add the less height from the right\n         for(int i=1;i<n;i++){\n             int prev = i+1;\n             while(prev<n && height[prev]>=height[i]){\n                 prev = right[prev];\n             }\n             right[i] = prev;\n         }\n         // once we have these two arrays fill we need width & area\n         for(int i=0;i<n;i++){\n             int width = right[i]-left[i]-1;\n             maxArea = Math.max(maxArea, height[i]*width);\n         }\n         return maxArea;\n         */\n\n         //Optimize pproach using stack\n         int n = height.length;\n         int maxArea = 0;\n         Stack<Integer> st = new Stack<>();\n\n         for(int i=0;i<=n;i++){\n             //if our array is empty then take 0 as curr height else currHeight will be the height[i]\n             int currHeight = i==n ? 0 : height[i];\n\n             while(!st.isEmpty() && currHeight<height[st.peek()]){\n                 int top = st.pop();\n                 //finding the width\n                 // width differ, if stack is empty or not empty after we pop the element\n                 int width = st.isEmpty() ? i : i-st.peek()-1;\n\n                 //now update the max area\n                 maxArea = Math.max(maxArea, height[top]*width);\n             }\n             st.push(i);\n         }\n         return maxArea;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "    class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int rs[]=new int[heights.length];\n        int ls[]=new int [heights.length];\n        Stack<Integer>st=new Stack<>();\n        rs[heights.length-1]=heights.length;\n        st.push(heights.length-1);\n        for(int i=heights.length-2;i>=0;i--){\n             while(st.size()>0 && heights[st.peek()]>=heights[i])st.pop();\n             if(st.size()==0)rs[i]=(heights.length);\n             else rs[i]=st.peek();  \n             st.push(i);\n        }\n        st.clear();\n        ls[0]=-1;\n        st.push(0);\n        for(int i=1;i<heights.length;i++){\n             while(st.size()>0 && heights[st.peek()]>=heights[i])st.pop();\n             if(st.size()==0)ls[i]=(-1);\n             else ls[i]=st.peek();           \n             st.push(i);\n        }\n               int maxarea=0;\n     for(int i=0;i<heights.length;i++){\n          maxarea=Math.max(maxarea,(rs[i]-ls[i]-1)*heights[i]);\n\n     }\n     return maxarea;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        stack<pair<int,int>> s;\n        stack<pair<int,int>> ss;\n        vector<int> right;\n         vector<int> left;\n        int index=heights.size();\n        for(int i=heights.size()-1; i>=0; i--){\n            if(s.size()==0){\n                right.push_back(index);\n            }\n            else if(s.size()>0 && s.top().first<heights[i]){\n                right.push_back(s.top().second);\n            }\n            else if(s.size()>0  && s.top().first>=heights[i]){\n                while(s.size()>0  && s.top().first>=heights[i]){\n                    s.pop();\n                }\n                if(s.size()==0){\n                    right.push_back(index);\n                }\n                else{\n                    right.push_back(s.top().second);\n        \n                }\n            }\n            s.push({heights[i],i});\n\n        }\n        reverse(right.begin(),right.end());\n\n       \n\n\n          for(int i=0; i<heights.size(); i++){\n            if(ss.size()==0){\n                left.push_back(-1);\n            }\n            else if(ss.size()>0 && ss.top().first<heights[i]){\n                left.push_back(ss.top().second);\n            }\n            else if(ss.size()>0  && ss.top().first>=heights[i]){\n                while(ss.size()>0  && ss.top().first>=heights[i]){\n                    ss.pop();\n                }\n                if(ss.size()==0){\n                    left.push_back(-1);\n                }\n                else{\n                    left.push_back(ss.top().second);\n        \n                }\n            }\n            ss.push({heights[i],i});\n\n        }\n\n\n       vector<int> ans;\n        \n\n        for(int i=0; i<heights.size(); i++){\n          int z=heights[i]*(right[i]-left[i]-1);\n            ans.push_back(z);\n        }\n        sort(ans.begin(), ans.end());\n        return ans[heights.size()-1];\n\n       //return maxarea;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    vector<int> nextsmall(vector<int>& arr,int n){\n         stack<int> s;\n    s.push(-1);\n        vector<int> ans(n);\n        for(int i=arr.size()-1;i>=0;i--){\n           \n            while(s.top()!=-1&&arr[s.top()]>=arr[i])\n            s.pop();\n            if(s.empty()){\n            ans[i]=arr[i];\n            s.push(arr[i]);\n            }\n            else\n            {\n            ans[i]=s.top();\n            s.push(i);\n            \n            }\n            \n        }\n        return ans;\n    }\n    vector<int> prevsmall(vector<int>& arr,int n){\n         stack<int> s;\n    s.push(-1);\n        vector<int> ans(n);\n        for(int i=0;i<n;i++){\n           \n            while(s.top()!=-1&&arr[s.top()]>=arr[i])\n            s.pop();\n            if(s.empty()){\n            ans[i]=arr[i];\n            s.push(arr[i]);\n            }\n            else\n            {\n            ans[i]=s.top();\n            s.push(i);\n            \n            }\n            \n        }\n        return ans;\n    }\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int area=0;\n        int n =heights.size();\n        vector<int> next(n);\n        vector<int> prev(n);\n        next=nextsmall(heights,n);\n        prev=prevsmall(heights,n);\n        for(int i=0;i<n;i++){\n            int l=heights[i];\n            if(next[i]==-1)\n            next[i]=n;\n             int b=next[i]-prev[i]-1;\n             int newarea=l*b;\n             area=max(newarea,area);\n        }\n        return area;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n=heights.size();\n        stack<int>st;\n        vector<int>nsl, nsr;\n\n        for(int i=0;i<n;i++){\n            if(st.size()==0)nsl.emplace_back(-1);\n            else if(!st.empty() and heights[st.top()]<heights[i])\n                nsl.emplace_back(st.top());\n            else if(!st.empty() and heights[st.top()]>=heights[i]){\n                while(!st.empty() and heights[st.top()]>=heights[i])st.pop();\n                if(st.size()==0)nsl.emplace_back(-1);\n                else nsl.emplace_back(st.top());\n            }\n\n            st.push(i);\n        } \n        stack<int>st1;\n        for(int i=n-1;i>=0;i--){\n            if(st1.size()==0)nsr.emplace_back(n);\n            else if(!st1.empty() and heights[st1.top()]<heights[i]){\n                cout<<\"height \"<<heights[i]<<\" \";\n                cout<<st.top()<<\" \";\n                nsr.emplace_back(st1.top());\n                }\n            else if(!st1.empty() and heights[st1.top()]>=heights[i]){\n                while(!st1.empty() and heights[st1.top()]>=heights[i])st1.pop();\n                if(st1.size()==0)nsr.emplace_back(n);\n                else nsr.emplace_back(st1.top());\n          \n            }\n            // cout<<i<<\" \";\n            st1.push(i);\n            // cout<<st1.top()<<\" \";\n        }\n        reverse(nsr.begin(),nsr.end());\n\n        long long ans=0;\n        // for(int i=0;i<n;i++){\n        //     cout<<nsl[i]<<\" \";\n        // }\n        cout<<endl;\n        for(int i=0;i<n;i++){\n            cout<<nsr[i]<<\" \";\n        }\n        for(int i=0;i<n;i++){\n            int area=(nsr[i]-nsl[i]-1)*heights[i];\n            if(ans<area)ans=area;\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "",
                "code": ""
            },
            {
                "language": "python",
                "code": "int maxArea = 0;\nfor (int i = 0; i < height.length; i++) {\n    maxArea = Math.max(maxArea, height[i] * (lessFromRight[i] - lessFromLeft[i] - 1));\n}"
            },
            {
                "language": "python",
                "code": "for (int i = 1; i < height.length; i++) {              \n    int p = i - 1;\n    while (p >= 0 && height[p] >= height[i]) {\n        p--;\n    }\n    lessFromLeft[i] = p;              \n}"
            },
            {
                "language": "javascript",
                "code": "while (p >= 0 && height[p] >= height[i]) {\n      p = lessFromLeft[p];\n}"
            },
            {
                "language": "java",
                "code": "public static int largestRectangleArea(int[] height) {\n    if (height == null || height.length == 0) {\n        return 0;\n    }\n    int[] lessFromLeft = new int[height.length]; // idx of the first bar the left that is lower than current\n    int[] lessFromRight = new int[height.length]; // idx of the first bar the right that is lower than current\n    lessFromRight[height.length - 1] = height.length;\n    lessFromLeft[0] = -1;\n\n    for (int i = 1; i < height.length; i++) {\n        int p = i - 1;\n\n        while (p >= 0 && height[p] >= height[i]) {\n            p = lessFromLeft[p];\n        }\n        lessFromLeft[i] = p;\n    }\n\n    for (int i = height.length - 2; i >= 0; i--) {\n        int p = i + 1;\n\n        while (p < height.length && height[p] >= height[i]) {\n            p = lessFromRight[p];\n        }\n        lessFromRight[i] = p;\n    }\n\n    int maxArea = 0;\n    for (int i = 0; i < height.length; i++) {\n        maxArea = Math.max(maxArea, height[i] * (lessFromRight[i] - lessFromLeft[i] - 1));\n    }\n\n    return maxArea;\n}"
            },
            {
                "language": "",
                "code": "p = lessFromLeft[p];"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public int largestRectangleArea(int[] h) {\n        int n = h.length;\n        int max = 0;\n        int[] stack = new int[n + 1];\n        int is = -1;\n        for (int i = 0; i <= n; i++) {"
            },
            {
                "language": "cpp",
                "code": "int hgt [100001];\nint pos [100001];\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        ios::sync_with_stdio(false);\n        cin.tie(nullptr);\n        heights.push_back(0);\n        int ans=heights[0], n=heights.size(), m=0;\n        hgt[0]=heights[0];\n        pos[0]=0;\n        for(int i=1; i<n; ++i) {\n            pos[m+1]=i;\n            for(; m>=0 && heights [i]<hgt[m]; --m) {\n                ans=max(ans,hgt[m]*(i-pos[m]));\n            }\n            hgt[++m]=heights[i];\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "swift",
                "code": "What the Question is saying, \nGiven an array of integers heights representing the histogram's bar height where the width of each bar is 1, \nreturn the area of the largest rectangle in the histogram."
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int n = heights.length;\n        if(n == 0) return 0; // Base Condition\n        int maxArea = 0;\n        int left[] = new int[n]; //fill left boundary\n        int right[] = new int[n]; // fill right boundary\n        \n        left[0] = -1;\n        right[n - 1] = n;\n        \n        for(int i = 1; i < n; i++){\n            int prev = i - 1; // previous for comparing the heights\n            while(prev >= 0 && heights[prev] >= heights[i]){\n                prev = left[prev]; // we have done this to minimise the jumps we make to the left\n            }\n            left[i] = prev;\n        }\n        // Similarly we do for right\n        for(int i = n - 2; i >= 0; i--){\n            int prev = i + 1; \n            while(prev < n && heights[prev] >= heights[i]){\n                prev = right[prev]; \n            }\n            right[i] = prev;\n        }\n        // once we have these two arrays fill we need width & area\n        for(int i = 0; i < n; i++){\n            int width = right[i] - left[i] - 1;\n            maxArea = Math.max(maxArea, heights[i] * width);\n        }\n        return maxArea;\n        \n    }\n}"
            },
            {
                "language": "java",
                "code": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        if(n == 0) return 0; // Base Condition\n        int maxArea = 0;\n        vector<int> left(n); //fill left boundary\n        vector<int> right(n); // fill right boundary\n        \n        left[0] = -1;\n        right[n - 1] = n;\n        \n        for(int i = 1; i < n; i++){\n            int prev = i - 1; // previous for comparing the heights\n            while(prev >= 0 && heights[prev] >= heights[i]){\n                prev = left[prev]; // we have done this to minimise the jumps we make to the left\n            }\n            left[i] = prev;\n        }\n        // Similarly we do for right\n        for(int i = n - 2; i >= 0; i--){\n            int prev = i + 1; \n            while(prev < n && heights[prev] >= heights[i]){\n                prev = right[prev]; \n            }\n            right[i] = prev;\n        }\n        // once we have these two arrays fill we need width & area\n        for(int i = 0; i < n; i++){\n            int width = right[i] - left[i] - 1;\n            maxArea = max(maxArea, heights[i] * width);\n        }\n        return maxArea;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int n = heights.length;\n        int maxArea = 0;\n        Stack<Integer> st = new Stack<>();\n        \n        for(int i = 0; i <= n; i++){\n            int currHeight = i == n ? 0 : heights[i];\n            // check if currHeight becomes greater then height[top] element of stack. we do a push because it's an increasing sequence\n            // otherwise we do pop and find area, so for that we write a while loop\n            while(!st.isEmpty() && currHeight < heights[st.peek()]){\n                int top = st.pop(); // current element on which we are working\n                // now we need width & area\n                int width = st.isEmpty() ? i : i - st.peek() - 1; // width differ, if stack is empty or not empty after we pop the element\n                int area = heights[top] * width; // current height * width\n                maxArea = Math.max(area, maxArea);\n            }\n            // if it doesn't enter in while loop, it means it's an increasing sequence & we need to push index\n            st.push(i);\n        }\n        return maxArea;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        int maxArea = 0;\n        stack<int> st;\n        \n        for(int i = 0; i <= n; i++){\n            int currHeight = i == n ? 0 : heights[i];\n            // check if currHeight becomes greater then height[top] element of stack. we do a push because it's an increasing sequence\n            // otherwise we do pop and find area, so for that we write a while loop\n            while(!st.empty() && currHeight < heights[st.top()]){\n                int top = st.top(); st.pop(); // current element on which we are working\n                // now we need width & area\n                int width = st.empty() ? i : i - st.top() - 1; // width differ if we stack is empty or not empty after we pop the element\n                int area = heights[top] * width; // current height * width\n                maxArea = max(area, maxArea);\n            }\n            // if it doesn't enter in while loop, it means it's an increasing sequence & we need to push index\n            st.push(i);\n        }\n        return maxArea;\n    }\n};"
            },
            {
                "language": "php",
                "code": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& hts) {\n        int size=hts.size();\n        int to_right[size];\n        stack<int> st;"
            },
            {
                "language": "cpp",
                "code": "int largestRectangleArea(vector<int> &height) {\n\nint maxArea = 0;\nheight.push_back(0); //why? coz 0 will always be lesser than than previous non zero stack element so we can calculate area of all previous element w.r.t it.\nstack<int> index; //store index of previous smaller index\n\nfor(int i = 0; i < height.size(); i++)\n{"
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} heights\n * @return {number}\n */\nvar largestRectangleArea = function(heights) {\n    let stack = [];\n    stack.push(-1);\n    stack.push(0);\n    let maxarea = heights[0];\n    for(let i = 1; i< heights.length; i++){\n        if(heights[i]>=heights[stack[stack.length-1]])\n            stack.push(i);\n        else {\n            while(stack[stack.length-1] >= 0 && heights[i] <= heights[stack[stack.length-1]]){\n                let ind = stack.pop();\n                maxarea = Math.max(maxarea, (i - stack[stack.length-1] -1)*heights[ind]);\n            }\n            stack.push(i)\n        }\n    }\n\n    while(stack[stack.length-1] >= 0){\n        let ind = stack.pop();\n        maxarea = Math.max(maxarea, (heights.length - stack[stack.length-1] -1)*heights[ind]);\n    }\n    return maxarea;\n};"
            }
        ]
    },
    "84": {
        "question_id": 85,
        "title": "Maximal Rectangle",
        "difficulty": 3,
        "description": "Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. ",
        "examples": [
            {
                "input": "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
                "output": "6",
                "explanation": "The maximal rectangle is shown in the above picture."
            },
            {
                "input": "matrix = [[\"0\"]]",
                "output": "0",
                "explanation": null
            },
            {
                "input": "matrix = [[\"1\"]]",
                "output": "1",
                "explanation": null
            }
        ],
        "constraints": [
            "rows == matrix.length",
            "cols == matrix[i].length",
            "1 <= row, cols <= 200",
            "matrix[i][j] is '0' or '1'."
        ],
        "solutions": [
            {
                "language": "javascript",
                "code": "var maximalRectangle = function (aa) {\n    let m = aa.length,\n        n = aa[0].length;\n\n    let widthOnLeftTillHere = Array.from({ length: m }, () =>\n        new Array(n).fill(0)\n    );\n    for (let r = 0; r < m; r++)\n        for (let c = 0; c < n; c++)\n            if (aa[r][c] === \"1\") {\n                widthOnLeftTillHere[r][c] =\n                    (widthOnLeftTillHere[r][c - 1] || 0) + 1;\n            }\n\n    let maxArea = 0;\n    for (let r = 0; r < m; r++)\n        for (let c = 0; c < n; c++)\n            if (aa[r][c] === \"1\") {\n                let minWidthGoingUp = Infinity;\n                let increasingHeight = 1;\n                for (let r2 = r; r2 >= 0; r2--, increasingHeight++) {\n                    minWidthGoingUp = Math.min(\n                        minWidthGoingUp,\n                        widthOnLeftTillHere[r2][c]\n                    );\n                    maxArea = Math.max(\n                        maxArea,\n                        minWidthGoingUp * increasingHeight\n                    );\n                }\n            }\n    return maxArea;\n};"
            },
            {
                "language": "javascript",
                "code": "function maximalRectangle(aa) {\n    let m = aa.length,\n        n = aa[0].length;\n\n    let heights = new Array(n + 1).fill(0), // this row heights, last col is 0\n        maxArea = 0;\n\n    for (let r = 0; r < m; r++) {\n        let cols = []; // prev increasing columns - stack\n        cols.top = () => cols[cols.length - 1]; // get column left on top of stack\n\n        for (let c = 0; c <= n; c++) {\n            if (c < n) {\n                if (aa[r][c] === \"1\") heights[c]++;\n                else heights[c] = 0;\n            }\n\n            while (cols.length && heights[cols.top()] > heights[c]) {\n                let height = heights[cols.pop()]; // prev column height\n                let width = cols.length ? c - cols.top() - 1 : c; // prev prev column to cur column width\n                maxArea = Math.max(maxArea, width * height);\n            }\n            cols.push(c);\n        }\n    }\n    return maxArea;\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n     vector<int> prev(vector<int> v,int n){\n         vector<int> ans(n);\n         stack<int> s;\n         s.push(-1);\n         for(int i=0;i<n;i++){\n        int curr=v[i];\n        while(s.top()!=-1 && v[s.top()]>=curr){\n            s.pop();\n        }\n        //top me hi ans h;\n         ans[i]=s.top();\n         s.push(i);\n         }\n         return ans;\n     }\n\n     vector<int> next(vector<int> v,int n){\n         vector<int> ans(n);\n         stack<int> s;\n           s.push(-1);\n         for(int i=n-1;i>=0;i--){\n        int curr=v[i];\n        while(s.top()!=-1 && v[s.top()]>=curr){\n            s.pop();\n        }\n        //top me hi ans h;\n         ans[i]=s.top();\n         s.push(i);\n         }\n         return ans;\n     }\n\n    int maxHisto(vector<int> v){\n        int nt=v.size();\n        vector<int> p(nt);\n        p=prev(v,nt);\n        vector<int> n(nt);\n        n=next(v,nt);\n        int sum=INT_MIN;\n        for(int i=0;i<nt;i++){\n          if(n[i]==-1){\n              n[i]=nt;\n          }\n        int a= v[i]*(n[i]-p[i]-1);\n        sum=max(a,sum);\n        }\n        return sum;\n    }\n    int maximalRectangle(vector<vector<char>>& matrix) {\n       vector<vector<int>> v(matrix.size());\n       for(int i=0;i<matrix.size();i++){\n           for(int j=0;j<matrix[i].size();j++){\n               if(matrix[i][j]=='0')\n  v[i].push_back(0);\n  else v[i].push_back(1);\n           }\n       } \n       int first= maxHisto(v[0]);\n     for(int i=1;i<v.size();i++){\n        for(int j=0;j<v[i].size();j++){\n            if(v[i][j]!=0){\n                v[i][j]=v[i-1][j]+v[i][j];\n            }\n            else v[i][j]=0;\n        }\n        int a=  maxHisto(v[i]);\n        first= max(first,a);\n     }\nreturn first;\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maximalRectangle(self, matrix):\n        rows = len(matrix)\n        cols = len(matrix[0])\n        max_area = 0\n        \n        for i in range(rows):\n            for j in range(cols):\n                for width in range(1, cols-j+1):\n                    for height in range(1, rows-i+1):\n                        is_rectangle = True # is composed only of 1's\n                        for k in range(i, i+height):\n                            for l in range(j, j+width):\n                                if matrix[k][l] != \"1\": # If we find a cell that is not 1, rectangle is not valid\n                                    is_rectangle = False\n                                    break\n                                if not is_rectangle:\n                                    break\n                        if is_rectangle:\n                            area = width * height\n                            max_area = max(max_area, area)\n        return max_area"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if not matrix: # Return 0 if the matrix is empty\n            return 0\n\n        m, n = len(matrix), len(matrix[0]) # Get the number of rows and columns in the matrix\n\n        # Initialize three arrays to store the number of consecutive 1's to the left of each cell,\n        # the number of consecutive 1's to the right of each cell, and the height of each cell\n        left, right, height = [0] * n, [n] * n, [0] * n\n\n        # Initialize the maximum possible area to 0\n        max_area = 0\n\n        # Iterate over each row in the matrix\n        for i in range(m):\n            # Initialize the current left and right indices to 0 and n respectively\n            cur_left, cur_right = 0, n\n\n            # Iterate over each column in the matrix to compute the height of each cell\n            for j in range(n):\n                # If the cell is a 1, increment the height of the cell\n                if matrix[i][j] == \"1\":\n                    height[j] += 1\n                else:\n                    height[j] = 0\n\n            # Iterate over each column in the matrix to compute the number of consecutive 1's\n            # to the left of each cell\n            for j in range(n):\n                # If the cell is a 1, update the number of consecutive 1's to the left of the cell\n                # to be the maximum of the current value and the current left index\n                if matrix[i][j] == \"1\":\n                    left[j] = max(left[j], cur_left)\n                else:\n                    # If the cell is a 0, reset the number of consecutive 1's to the left of the cell to 0\n                    # and update the current left index to be the current column index plus 1\n                    left[j] = 0\n                    cur_left = j + 1\n\n            # Iterate over each column in the matrix to compute the number of consecutive 1's\n            # to the right of each cell\n            for j in range(n - 1, -1, -1):\n                # If the cell is a 1, update the number of consecutive 1's to the right of the cell\n                # to be the minimum of the current value and the current right index\n                if matrix[i][j] == \"1\":\n                    right[j] = min(right[j], cur_right)\n                else:\n                    # If the cell is a 0, reset the number of consecutive 1's to the right of the cell to n\n                    # and update\n                    # the current right index to be the current column index\n                    right[j] = n\n                    cur_right = j\n\n            # Iterate over each column in the matrix to compute the maximum possible area of a rectangle\n            # with the given heights\n            for j in range(n):\n                # Update the maximum possible area to be the maximum of the current value and the area of\n                # the rectangle with the given height, left, and right values\n                max_area = max(max_area, (right[j] - left[j]) * height[j])\n\n        # Return the maximum possible area\n        return max_area"
            },
            {
                "language": "cpp",
                "code": "class Solution {\nprivate:\n    vector<int> nextSmaller(vector<int> &arr,int n){\n        stack<int> st;\n        vector<int> ans(n);\n        st.push(-1);\n        for(int i=arr.size()-1;i>=0;i--){\n            while(st.top()!=-1 && arr[st.top()]>=arr[i]){\n                st.pop();\n            }\n            ans[i]=st.top();\n            st.push(i);\n        }\n        return ans;\n    }\n    vector<int> prevSmaller(vector<int> &arr,int n){\n        stack<int> st;\n        vector<int> ans(n);\n        st.push(-1);\n        for(int i=0;i<arr.size();i++){\n            while(st.top()!=-1 && arr[st.top()]>=arr[i]){\n                st.pop();\n            }\n            ans[i]=st.top();\n            st.push(i);\n        }\n        return ans;\n    }\n    int maxAreaHistogram(vector<int> &arr){\n        int n = arr.size();\n        vector<int> next(n);\n        vector<int> prev(n);\n        next = nextSmaller(arr,n);\n        prev = prevSmaller(arr,n);\n        int area = 0;\n        for(int i=0;i<arr.size();i++){\n            int length = arr[i];\n            if(next[i]==-1){\n                next[i]=n;\n            }\n            int width = next[i]-prev[i]-1;\n            area = max(area,(length*width));\n        }\n        return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n        ios_base::sync_with_stdio(false);\n        vector<vector<int>> mat;\n        for(int i=0;i<matrix.size();i++){\n            vector<int> v;\n            for(int j=0;j<matrix[i].size();j++){\n                if(matrix[i][j]=='1'){\n                    v.push_back(1);\n                }\n                else{\n                    v.push_back(0);\n                }\n            }\n            mat.push_back(v);\n        }\n        int n = mat.size();\n        int area = maxAreaHistogram(mat[0]);\n        for(int i=1;i<n;i++){\n            for(int j=0;j<mat[i].size();j++){\n                if(mat[i][j]!=0){\n                    mat[i][j]+=mat[i-1][j];\n                }\n            }\n            area=max(area,maxAreaHistogram(mat[i]));\n        }\n        return area;\n    }\n};"
            },
            {
                "language": "rust",
                "code": "impl Solution {\n    pub fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {\n        let mut histogram = vec![0; matrix[0].len()];\n        let mut max_area = 0;\n        for col in matrix {\n            for (i, c) in col.into_iter().enumerate() {\n                histogram[i] = if c == '0' { 0 } else { histogram[i] + 1 }\n            }\n            max_area = i32::max(max_area, Self::max_rect(&histogram));\n        }\n        max_area\n    }\n\n    fn max_rect(histogram: &Vec<i32>) -> i32 {\n        let (mut max_area, mut width, n) = (0, 0, histogram.len());\n        let mut stack = Vec::with_capacity(n);\n\n        (0..n).for_each(|cur| {\n            while let Some(&last) = stack.last() {\n                if histogram[last] > histogram[cur] {\n                    stack.pop();\n                    width = if let Some(&prev) = stack.last() { cur - prev - 1 } else { cur };\n                    max_area = i32::max(max_area, width as i32 * histogram[last]);\n                } else { break; }\n            }\n            stack.push(cur);\n        });\n\n        while let Some(last) = stack.pop() {\n            width = if let Some(&prev) = stack.last() { n - prev - 1 } else { n };\n            max_area = i32::max(max_area, width as i32 * histogram[last]);\n        }\n\n        max_area\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {public:\nint maximalRectangle(vector<vector<char> > &matrix) {\n    if(matrix.empty()) return 0;\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    int left[n], right[n], height[n];\n    fill_n(left,n,0); fill_n(right,n,n); fill_n(height,n,0);\n    int maxA = 0;\n    for(int i=0; i<m; i++) {\n        int cur_left=0, cur_right=n; \n        for(int j=0; j<n; j++) { // compute height (can do this from either side)\n            if(matrix[i][j]=='1') height[j]++; \n            else height[j]=0;\n        }\n        for(int j=0; j<n; j++) { // compute left (from left to right)\n            if(matrix[i][j]=='1') left[j]=max(left[j],cur_left);\n            else {left[j]=0; cur_left=j+1;}\n        }\n        // compute right (from right to left)\n        for(int j=n-1; j>=0; j--) {\n            if(matrix[i][j]=='1') right[j]=min(right[j],cur_right);\n            else {right[j]=n; cur_right=j;}    \n        }\n        // compute the area of rectangle (can do this from either side)\n        for(int j=0; j<n; j++)\n            maxA = max(maxA,(right[j]-left[j])*height[j]);\n    }\n    return maxA;\n}"
            },
            {
                "language": "",
                "code": "0 0 0 1 0 0 0 \n0 0 1 1 1 0 0 \n0 1 1 1 1 1 0"
            },
            {
                "language": "",
                "code": "l: 0 0 0 3 0 0 0\nr: 7 7 7 4 7 7 7"
            },
            {
                "language": "",
                "code": "l: 0 0 2 3 2 0 0\nr: 7 7 5 4 5 7 7 "
            },
            {
                "language": "",
                "code": "l: 0 1 2 3 2 1 0\nr: 7 6 5 4 5 6 7"
            },
            {
                "language": "java",
                "code": "/* we start from the first row, and move downward;\n * height[i] record the current number of countinous '1' in column i;\n * left[i] record the left most index j which satisfies that for any index k from j to  i, height[k] >= height[i];\n * right[i] record the right most index j which satifies that for any index k from i to  j, height[k] >= height[i];\n * by understanding the definition, we can easily figure out we need to update maxArea with value (height[i] * (right[i] - left[i] + 1));\n * \n * Then the question is how to update the array of height, left, and right\n return 0;"
            },
            {
                "language": "",
                "code": "height: 0 0 0 1 0 0 0\nleft: 0 0 0 3 0 0 0\nright 7 7 7 4 7 7 7"
            },
            {
                "language": "",
                "code": ""
            },
            {
                "language": "",
                "code": ""
            },
            {
                "language": "",
                "code": "matrix\n0 0 0 1 0 0 0\n0 0 1 1 1 0 0\n0 1 1 1 1 1 0"
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "public int maximalRectangle(char[][] matrix) {\n        if(matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0) return 0;\n        int[] heights = new int[matrix[0].length];\n        int ans = 0;\n        for(int i = 0;i<matrix.length;i++){\n            for(int j = 0;j<matrix[0].length;j++){\n                if(matrix[i][j] == '0') heights[j] = 0;\n                else heights[j]++;\n)){"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& M) {\n        if(!size(M)) return 0;\n        int ans = 0, m = size(M), n = size(M[0]);\n        for(int start_i = 0; start_i < m; start_i++) \n            for(int start_j = 0; start_j < n; start_j++) \n                for(int end_i = start_i; end_i < m; end_i++) \n                    for(int end_j = start_j; end_j < n; end_j++) {\n                        bool allOnes = true;\n                        for(int i = start_i; i <= end_i && allOnes; i++) \n                            for(int j = start_j; j <= end_j && allOnes; j++) \n                                if(M[i][j] != '1') allOnes = false;                           \n                        ans = max(ans, allOnes * (end_i - start_i + 1) * (end_j - start_j + 1));\n                    }\n\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& M) {\n        if(!size(M)) return 0;\n        int ans = 0, m = size(M), n = size(M[0]);\n        for(int i = 0; i < m; i++) \n            for(int j = 0; j < n; j++) \n                for(int row = i, colLen = n, col; row < m && M[row][j] == '1'; row++) {\n                    for(col = j; col < n && M[row][col] == '1'; col++);\n                    colLen = min(colLen, col-j);\n                    ans = max(ans, (row-i+1) * colLen);\n                }\n            \n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& M) {\n        if(!size(M)) return 0;\n        int ans = 0, m = size(M), n = size(M[0]);\n        vector<vector<short>> dp(m+1, vector<short>(n+1));\n        for(int i = m-1; ~i; i--) \n            for(int j = n-1; ~j; j--) \n                dp[i][j] = M[i][j] == '1' ? dp[i][j+1] + 1 : 0;\n                    \n        for(int i = 0; i < m; i++) \n            for(int j = 0; j < n; j++) \n                for(int row = i, colLen = n; row < m && M[row][j] == '1'; row++)\n                    ans = max(ans, (row-i+1) * (colLen = min(colLen, dp[row][j]*1)));\n                    \n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& M) {\n        if(!size(M)) return 0;\n        int ans = 0, m = size(M), n = size(M[0]);\n        vector<vector<short>> dp(m+1, vector<short>(n+1)), up(m, vector<short>(n,1)), down(up);\n        for(int i = m-1; ~i; i--) \n            for(int j = n-1; ~j; j--) \n                dp[i][j] = M[i][j] == '1' ? dp[i][j+1] + 1 : 0;\n        \n        stack<int> s;\n        for(int j = 0; j < n; j++) {\n            s = stack<int>();\n            for(int i = 0; i < m; i++) {\n                while(size(s) && dp[s.top()][j] >= dp[i][j]) s.pop();\n                up[i][j] = i - (size(s) ? s.top() : -1);\n                s.push(i);\n            }\n            s = stack<int>();\n            for(int i = m-1; ~i; i--) {\n                while(size(s) && dp[s.top()][j] >= dp[i][j]) s.pop();\n                down[i][j] = (size(s) ? s.top() : m) - i;\n                s.push(i);\n            }            \n        }\n\n        for(int i = 0; i < m; i++) \n            for(int j = 0; j < n; j++) \n                ans = max(ans, dp[i][j] * (up[i][j]+down[i][j]-1));\n                    \n        return ans;\n    }\n};"
            },
            {
                "language": "python",
                "code": "def maximalRectangle(self, matrix):\n    if not matrix or not matrix[0]:\n        return 0\n    n = len(matrix[0])\n    height = [0] * (n + 1)\n    ans = 0\n    for row in matrix:\n        for i in xrange(n):\n            height[i] = height[i] + 1 if row[i] == '1' else 0\n        stack = [-1]\n        for i in xrange(n + 1):\n            while height[i] < height[stack[-1]]:\n                h = height[stack.pop()]\n                w = i - 1 - stack[-1]\n                ans = max(ans, h * w)\n            stack.append(i)\n    return ans\n\n# 65 / 65 test cases passed.\n# Status: Accepted\n# Runtime: 120 ms\n# 100%"
            },
            {
                "language": "cpp",
                "code": "        for i in xrange(n + 1):\n            while height[i] < height[stack[-1]]:\n                h = height[stack.pop()]\n                w = i - 1 - stack[-1]\n                ans = max(ans, h * w)\n            stack.append(i)"
            },
            {
                "language": "java",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public int maximalRectangle(char[][] matrix) {\n        if (matrix==null||matrix.length==0||matrix[0].length==0)\n            return 0;\n        int cLen = matrix[0].length;    // column length\n        int rLen = matrix.length;       // row length\n        // height array \n        int[] h = new int[cLen+1];\n        h[cLen]=0;\n        int max = 0;\n        \n        \n        for (int row=0;row<rLen;row++) {\n            Stack<Integer> s = new Stack<Integer>();\n            for (int i=0;i<cLen+1;i++) {\n                if (i<cLen)\n                    if(matrix[row][i]=='1')\n                        h[i]+=1;\n                    else h[i]=0;\n                \n                if (s.isEmpty()||h[s.peek()]<=h[i])\n                    s.push(i);\n                else {\n                    while(!s.isEmpty()&&h[i]<h[s.peek()]){\n                        int top = s.pop();\n                        int area = h[top]*(s.isEmpty()?i:(i-s.peek()-1));\n                        if (area>max)\n                            max = area;\n                    }\n                    s.push(i);\n                }\n            }\n        }\n        return max;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    \n    public int maximalRectangle(char[][] matrix) {\n        if(matrix.length==0) return 0;\n\n        int[][] dp = new int[matrix.length][matrix[0].length];\n        for (int i = 0; i < dp.length; i++) {\n            for (int j = 0; j < dp[0].length; j++) {"
            },
            {
                "language": "cpp",
                "code": "the same idea, but more concise    \n\nint maximalRectangle(vector<vector<char> > &matrix) {\n    if (matrix.size() <= 0 || matrix[0].size() <= 0)\n        return 0;\n        \n    int m = matrix.size();\n    int n = matrix[0].size() + 1;\n    int h = 0, w = 0, ret = 0;"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int maximalRectangle(char[][] matrix) {\n       int rLen = matrix.length, cLen = rLen == 0 ? 0 : matrix[0].length, max = 0;\n        int[] h = new int[cLen+1];\n   \n        for (int row = 0; row < rLen; row++) {\n            Stack<Integer> s = new Stack<Integer>();\n            s.push(-1);"
            },
            {
                "language": "java",
                "code": "class Solution {\n    //optimized according to the version below\n    public int maximalRectangle(char[][] matrix) {\n        if(matrix.length==0)  return 0;\n        \n        int row = matrix.length;\n        int col = matrix[0].length;\n        "
            },
            {
                "language": "cpp",
                "code": "public int maximalRectangle(char[][] matrix) {\n    if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;\n    int max = Integer.MIN_VALUE;\n    int[] height = new int[matrix[0].length + 1];\n    for(int r = 0; r < matrix.length; r++) {\n        Stack<Integer> stack = new Stack<Integer>();\n        for(int c = 0; c < height.length; c++) {\n            if(c < matrix[0].length) {\n1),"
            },
            {
                "language": "java",
                "code": "public class Solution {\npublic int maximalRectangle(char[][] matrix) {\n    if (matrix==null||matrix.length==0)\n        return 0;\n    if (matrix[0]==null||matrix[0].length==0)\n        return 0;\n        \n    int[] record = new int[matrix[0].length];"
            },
            {
                "language": "cpp",
                "code": "int maximalRectangle(vector<vector<char>>& matrix)\n{\n    int maxRect = 0;\n    vector<int> packed(matrix.empty() ? 0 : matrix[0].size(), 0);\n    for (vector<char>& row : matrix) // given row[i], packed[] = row[0] + row[1] + row[2] + ... + row[i]\n    {\n        for (unsigned j = 0; j < row.size(); packed[j] = row[j] == '1' ? packed[j] + 1 : 0, ++j);"
            },
            {
                "language": "swift",
                "code": "Intuition :\n1) Pick one row\n2) Do summation of each index till that row\n  i) if any index value is 0 then put 0 else previous summation + 1 \n3) Pass this array to get max area (84. Largest Rectangle in Historgram)\n4) Update max area\n\n84. Largest Rectangle in Histogram\nIntuition :\n1) Max area will always have atleast one full bar height on any index\n2) Find largest rectangle including each bar one by one.\n a) For each bar, We have to find it's left limit & right limit (to know the maximum width)\n b) Find it's left limit (where we find any index's value is smaller than current index in left side array of curr index)\n c) Find it's right limit (where we find any index's value is smaller than current index in right side array of curr index\n3) Take the maximum of all the max area found by each bar.\n4) calculate area\n  width * height\nwhere width = right limit - left limit + 1\nheight = curr index's value\n5) Update max area & return it"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int maximalRectangle(char[][] matrix) {\n        if(matrix.length == 0)  return 0;\n        int maxArea = 0;\n        int row = matrix.length;\n        int col = matrix[0].length;\n        int[] dp = new int[col];\n        for(int i=0;i<row;i++){\n            for(int j=0;j<col;j++){\n                dp[j] = matrix[i][j] == '1' ? dp[j]+1 : 0;\n            }\n            //treating dp[j] as histogram, solving max area problem there and updating the max area\n            maxArea = Math.max(maxArea, findMaxAreaInHistogram(dp));\n        }\n        return maxArea;\n    }\n //84. Largest Rectangle in Histogram code\n    public int findMaxAreaInHistogram(int[] dp){\n        int len = dp.length;\n        int maxArea = 0;\n        int[] left = new int[len];\n        int[] right = new int[len];\n        Stack<Integer> stack = new Stack<>();\n        //traversing left to right, finding left limit\n        for(int i=0;i<len;i++){\n            if(stack.isEmpty()){\n                stack.push(i);\n                left[i] = 0;\n            }else{\n                while(!stack.isEmpty() && dp[stack.peek()] >= dp[i])\n                    stack.pop();\n                left[i] = stack.isEmpty() ? 0 : stack.peek()+1;\n                stack.push(i);\n            }\n        }\n        //doing empty to stack\n        while(!stack.isEmpty())\n            stack.pop();\n        \n        //traversing right to left, find right limit\n        for(int i=len-1;i>=0;i--){\n            if(stack.isEmpty()){\n                stack.push(len-1);\n                right[i] = len - 1;\n            }else{\n                while(!stack.isEmpty() && dp[stack.peek()] >= dp[i])\n                    stack.pop();\n                right[i] = stack.isEmpty() ? len-1 : stack.peek()-1;\n                stack.push(i);\n            }\n        }\n        //traversing the array , caculating area\n        int[] area = new int[len];\n        for(int i=0;i<len;i++){\n            area[i] = (right[i] - left[i] + 1) * dp[i];\n            maxArea = Math.max(maxArea, area[i]);\n        }\n        return maxArea;\n    }\n}"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def maximalRectangle(self, mat: List[List[str]]) -> int:\n        # using 84: Largest Rectangle in Histogram solution\n        \n        def LRIH(hist):\n            n = len(hist)\n            left = [0]*n"
            }
        ]
    },
    "85": {
        "question_id": 86,
        "title": "Partition List",
        "difficulty": 2,
        "description": "Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.You should preserve the original relative order of the nodes in each of the two partitions. ",
        "examples": [
            {
                "input": "head = [1,4,3,2,5,2], x = 3",
                "output": "[1,2,2,4,3,5]",
                "explanation": null
            },
            {
                "input": "head = [2,1], x = 2",
                "output": "[1,2]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is in the range [0, 200].",
            "-100 <= Node.val <= 100",
            "-200 <= x <= 200"
        ],
        "solutions": [
            {
                "language": "rust",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        ListNode* left=new ListNode();\n        ListNode* right= new ListNode();\n        ListNode* ptr=right;\n        ListNode* ptr2=left;\n        ListNode*curr=head;\n        while(curr){\n            if(curr->val>=x){\n                //right\n                ptr->next=new ListNode(curr->val);\n                ptr=ptr->next;\n            }\n            else{\n                //left\n                ptr2->next=new ListNode(curr->val);\n                ptr2=ptr2->next;\n            }\n            curr=curr->next;\n        }\n        ptr2->next=right->next;\n        \n        return left->next;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public ListNode partition(ListNode head, int x) {\n        if (head == null || head.next == null) return head;\n        ListNode lessCurr = null, xCurr = null, current = head;\n        ListNode lessHead = null, xHead = null;\n        while (current != null) {\n            if (current.val < x) {\n                if (lessCurr == null) {\n                    lessCurr = current;\n                    lessHead = lessCurr;\n                }\n                else {\n                    lessCurr.next = current;\n                    lessCurr = lessCurr.next;\n                }\n            } else {\n                if (xCurr == null) {\n                    xCurr = current;\n                    xHead = xCurr;\n                }\n                else {\n                    xCurr.next = current;\n                    xCurr = xCurr.next;\n                }\n            }\n            current = current.next;\n        }\n        if (xCurr != null) xCurr.next = null;\n        if (lessCurr != null) lessCurr.next = xHead;\n        return lessHead != null ? lessHead : xHead;\n    }\n}"
            },
            {
                "language": "rust",
                "code": "Anyways, Ladies-N-Gentlemen let's understand this problem"
            },
            {
                "language": "",
                "code": "Input: head = [1,4,3,2,5,2], x = 3\nOutput: [1,2,2,4,3,5]"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public ListNode partition(ListNode head, int x) {\n        ListNode left = new ListNode(0);\n        ListNode right = new ListNode(0);\n        \n        ListNode leftTail = left;\n        ListNode rightTail = right;\n        \n        while(head != null){\n            if(head.val < x){\n                leftTail.next = head;\n                leftTail = leftTail.next;\n            }\n            else{\n                rightTail.next = head;\n                rightTail = rightTail.next;\n            }\n            head = head.next;\n        }\n        \n        leftTail.next = right.next;\n        rightTail.next = null;\n        \n        return left.next;\n    }\n}"
            },
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        ListNode *left = new ListNode(0);\n        ListNode *right = new ListNode(0);\n        \n        ListNode *leftTail = left;\n        ListNode *rightTail = right;\n        \n        while(head != NULL){\n            if(head->val < x){\n                leftTail->next = head;\n                leftTail = leftTail->next;\n            }\n            else{\n                rightTail->next = head;\n                rightTail = rightTail->next;\n            }\n            head = head->next;\n        }\n        \n        leftTail->next = right->next;\n        rightTail->next = NULL;\n        \n        return left->next;\n    }\n};"
            },
            {
                "language": "rust",
                "code": "ListNode* partition(ListNode* head, int x) {\n        ListNode* left=new ListNode(0);\n        ListNode* right=new ListNode(0);\n        ListNode* leftTail = left;\n        ListNode* rightTail = right;\n        while(head!=NULL)\n        {"
            },
            {
                "language": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        less_head = less_tail = ListNode(0)\n        greater_head = greater_tail = ListNode(0)\n    \n        while head:\n            if head.val < x:\n                less_tail.next = head\n                less_tail = less_tail.next\n            else:\n                greater_tail.next = head\n                greater_tail = greater_tail.next\n            head = head.next\n    \n        greater_tail.next = None\n        less_tail.next = greater_head.next\n    \n        return less_head.next"
            },
            {
                "language": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} x\n * @return {ListNode}\n */\nvar partition = function(head, x) {\n    let left = [];\n    let right = [];\n    while(head){\n        if(head.val < x){\n            left.push(head.val);\n        }else{\n            right.push(head.val)\n        }\n        head = head.next;\n    }\n    \n    head = null;\n\n    while(right.length !== 0){\n        let node = new ListNode(right.pop());\n        node.next = head;\n        head = node;\n    }\n    while(left.length !== 0){\n        let node = new ListNode(left.pop());\n        node.next = head;\n        head = node;\n    }\n    return head;\n};"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        if(!head){return NULL;}\n        vector<int>v;\n        while(head){\n            v.push_back(head->val);\n            head=head->next;\n        }\n        vector<int>v1;\n        for(int i=0; i<v.size(); i++){\n            if(v[i]<x){\n                v1.push_back(v[i]);\n                v.erase(v.begin()+i);\n                i--;\n            }\n        }\n        reverse(v.begin(), v.end());\n        for(int i=v1.size()-1; i>=0; i--){\n            v.push_back(v1[i]);\n        }\n        reverse(v.begin(), v.end());\n        ListNode* root=NULL;\n        for(int i=v.size()-1; i>=0; i--){\n            ListNode* temp=new ListNode;\n            temp->val=v[i];\n            temp->next=root;\n            root=temp;\n        }\n        return root;\n    }\n};"
            },
            {
                "language": "erlang",
                "code": "Runtime - 97%\ud83d\udd25 "
            },
            {
                "language": "",
                "code": "* PEACE OUT LUV\u270c\ufe0f*"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        if(head == NULL || head ->next == NULL){\n            return head;\n        }\n        queue<ListNode*>q;\n        ListNode* lar = head;\n        while(lar != NULL){\n            if(lar ->val >= x){\n                break;\n            }\n            lar = lar ->next;\n        }\n        ListNode* temp = head;\n        ListNode* prev = head;\n        ListNode* back = NULL;\n        while(temp != NULL){\n            temp = temp ->next;\n            if(prev ->val >=x){\n                back = prev;\n            }\n            if(prev ->val <x){\n                prev ->next = NULL;\n                if(back != NULL){\n                    back ->next = temp;\n                }\n                q.push(prev);\n            }\n            prev = temp;\n        }\n        ListNode* temp1 = NULL;\n        if(q.empty()==false){\n            ListNode* l = q.front();\n            temp1 = l;\n            q.pop();\n            while(!q.empty()){\n                l ->next = q.front();\n                q.pop();\n                l = l ->next;\n            }\n            if(l != NULL){\n                l ->next = lar;\n            }\n            return temp1;\n        }\n        return head;\n        \n    }\n};"
            },
            {
                "language": "kotlin",
                "code": " public ListNode partition(ListNode head, int x) {\n        if(head==null || head.next==null) return head;\n  \n  //head1  refers to head of another list with elements greater than x and prev1 refers to its previous node\n        ListNode curr=head, prev=null, head1=null, prev1=null;\n        while(curr!=null){\n            if(curr.val<x){\n                if(prev==null) {head=curr;prev=curr;}\n                else{prev.next=curr;\n                prev=curr;}\n            }else{\n                if(head1==null) {head1=curr;prev1=curr;}\n                else{prev1.next=curr;\n                prev1=curr;}\n            }\n          curr=curr.next;\n        }\n        if(prev!=null) prev.next=head1;\n        if(prev1!=null) prev1.next=null;\n        return head;"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    \n    ListNode* partition(ListNode* head, int x) {\n        \n        ListNode* small = new ListNode(-1);\n        ListNode* large = new ListNode(-1);\n        ListNode* small_head = small;\n        ListNode* large_head = large;\n        \n        while (head){\n            if (head->val < x){\n                small->next = head;\n                small = small -> next;\n                head = head -> next;\n                small->next = NULL;\n            }\n            else{\n                large->next = head;\n                large = large -> next;\n                head = head -> next;\n                large -> next = NULL;\n            }\n        }\n        small -> next = large_head -> next;\n\n        return small_head -> next;\n    }\n};"
            },
            {
                "language": "rust",
                "code": "    ListNode* front, *back = head;\n    ListNode* lesser = new ListNode(0), *greater = new ListNode(0);\n    ListNode  *lcurr = lesser, * gcurr = greater;\n    \n    while(back != nullptr){"
            },
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        ListNode *left = new ListNode(0);\n        ListNode *right = new ListNode(0);"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        // Create 2 linked list"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        # left list consists of all the nodes having value less than x\n        # right list consits of all the nodes having values greater than or equal to x\n        # To avoid any edge cases, we will start both the lists a dummy node having value -1"
            },
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        queue<ListNode*>s;\n        ListNode*prev=new ListNode(0),*p=head,*dummy=prev;\n        while(p){"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:"
            },
            {
                "language": "python",
                "code": "dummy1, dummy2 = ListNode(-1), ListNode(-1)\ndummyHead1, dummyHead2 = dummy1, dummy2\n\ncurr = head\nwhile curr:\n    tmp = curr.next\n    if curr.val < x:\n        dummyHead1.next = curr\n        dummyHead1 = dummyHead1.next "
            },
            {
                "language": "java",
                "code": "class Solution {\n    public ListNode partition(ListNode head, int x) {\n        if(head==null||head.next==null)return head;\n        ListNode s=new ListNode();\n        ListNode l=new ListNode();\n        ListNode temp=head;\n        ListNode ls=null;\n        ListNode z=s;"
            },
            {
                "language": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        "
            }
        ]
    },
    "86": {
        "question_id": 87,
        "title": "Scramble String",
        "difficulty": 3,
        "description": "We can scramble a string s to get a string t using the following algorithm:If the length of the string is 1, stop.If the length of the string is > 1, do the following:\tSplit the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.Apply step 1 recursively on each of the two substrings x and y.Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false. ",
        "examples": [
            {
                "input": "s1 = \"great\", s2 = \"rgeat\"",
                "output": "true",
                "explanation": "One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true."
            },
            {
                "input": "s1 = \"abcde\", s2 = \"caebd\"",
                "output": "false",
                "explanation": null
            },
            {
                "input": "s1 = \"a\", s2 = \"a\"",
                "output": "true",
                "explanation": null
            }
        ],
        "constraints": [
            "s1.length == s2.length",
            "1 <= s1.length <= 30",
            "s1 and s2 consist of lowercase English letters."
        ],
        "solutions": [
            {
                "language": "rust",
                "code": "Thanks for visiting my solution.\ud83d\ude0a Keep Learning\nPlease give my solution an upvote! \ud83d\udc4d\nIt's a simple way to show your appreciation and\nkeep me motivated. Thank you! \ud83d\ude0a"
            },
            {
                "language": "javascript",
                "code": "isScramble(\"great\", \"rgeat\")\n           /           |           |           |           \\\nisScramble(\"g\", \"r\")  isScramble(\"g\", \"at\")  isScramble(\"gr\", \"ra\")  isScramble(\"gr\", \"eat\")  isScramble(\"gre\", \"rge\")\n           |           /           |           |           |           \\           |           /           |\nisScramble(\"\", \"\")  isScramble(\"g\", \"a\")  isScramble(\"g\", \"r\")  isScramble(\"g\", \"e\")  isScramble(\"g\", \"r\")  isScramble(\"g\", \"r\")  isScramble(\"gr\", \"e\")  isScramble(\"gr\", \"g\")  isScramble(\"gr\", \"er\")  isScramble(\"gr\", \"gea\")  isScramble(\"gre\", \"rg\")  isScramble(\"gre\", \"er\")\n      /      \\           /      \\           /      \\           /      \\           /      \\           /      \\           /      \\           /      \\           /      \\           /      \\           /      \\\nfalse  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  true"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    unordered_map<string,bool> mp;\n    \n    bool isScramble(string s1, string s2) {\n        int n = s1.size();\n        if(s1==s2) return true;   \n        if(n==1) return false;\n        \n        string key = s1+\" \"+s2;\n        \n        if(mp.find(key)!=mp.end()) return mp[key];\n\n        for(int i=1;i<n;i++)\n        {\n            if(isScramble(s1.substr(0,i),s2.substr(0,i)) && \n                            isScramble(s1.substr(i),s2.substr(i)))\n                return mp[key] = true;\n            \n            if(isScramble(s1.substr(0,i),s2.substr(n-i)) &&\n                        isScramble(s1.substr(i),s2.substr(0,n-i)))\n                return mp[key] = true;\n        }\n        \n        return mp[key] = false;\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def isScramble(self,s1, s2):\n        m ={}\n        def func(s1, s2):\n            if (s1, s2) in m:\n                return m[(s1, s2)]\n            if not sorted(s1) == sorted(s2):\n                return False\n            if len(s1) == 1:\n                return True\n            \n\n            for i in range(1, len(s1)):\n                if func(s1[:i], s2[-i:]) and func(s1[i:], s2[:-i]) or func(s1[:i], s2[:i]) and func(s1[i:], s2[i:]):\n                    m[(s1, s2)] = True\n                    return True\n            m[(s1, s2)] = False\n            return False\n        return func(s1, s2)"
            },
            {
                "language": "javascript",
                "code": ""
            },
            {
                "language": "java",
                "code": ""
            },
            {
                "language": "python",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "python",
                "code": "@cache\ndef func(s1, s2):"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if s1 == s2:\n            return True\n        if sorted(s1) != sorted(s2):\n            return False\n        \n        n = len(s1)\n        dp = [[[False] * (n+1) for _ in range(n)] for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(n):\n                dp[i][j][1] = (s1[i] == s2[j])\n        \n        for length in range(2, n+1):\n            for i in range(n-length+1):\n                for j in range(n-length+1):\n                    for k in range(1, length):\n                        if (dp[i][j][k] and dp[i+k][j+k][length-k]) or (dp[i][j+length-k][k] and dp[i+k][j][length-k]):\n                            dp[i][j][length] = True\n                            break\n        \n        return dp[0][0][n]\n\n    \n        # An Upvote will be encouraging"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    bool isScramble(string s1, string s2) {\n        int n = (int) s1.size();\n        bool vis[n][n][n][n];\n        bool dp[n][n][n][n];\n        memset(vis, false, sizeof(vis));\n        memset(dp, false, sizeof(dp));\n\n        // we are always calling the function such that, the substring we are checking on both the\n        // substrings are of same length, i.e. (r1 - l1 + 1 == r2 - l2 + 1)\n\n        // helper takes in two substrings of both string\n        // and returns whether they are scamble of each other\n        function<bool(int, int, int, int)> helper = [&] (int l1, int r1, int l2, int r2) {\n            if (vis[l1][r1][l2][r2]) return dp[l1][r1][l2][r2];\n            vis[l1][r1][l2][r2] = true;\n\n            bool isSame = true;\n            for (int i = l1, j = l2; i <= r1 && j <= r2; i++, j++)\n                if (s1[i] != s2[j]) isSame = false;\n            \n            // is already same, simply return true\n            if (isSame) {\n                dp[l1][r1][l2][r2] = true;\n                return true;\n            }\n\n            bool res = false;\n            for (int i = l1; i < r1; i++) {\n                // opt1: prefix1 matches to prefix2 and suffix1 matches to suffix2\n                res |= (helper(l1, i, l2, l2 + (i - l1)) && helper(i + 1, r1, l2 + (i - l1) + 1, r2));\n\n                // opt2: prefix1 matches to suffix2 and prefix2 matches to suffix1\n                res |= (helper(l1, i, r2 - (i - l1), r2) && helper(i + 1, r1, l2, r2 - (i - l1) - 1));\n            }\n\n            dp[l1][r1][l2][r2] = res;\n            return res;\n        };\n\n        return helper(0, n - 1, 0, n - 1);\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isScramble(self, first: str, second: str) -> bool:\n        @cache\n        def dp(a: str, b: str) -> bool:\n            if a == b:\n                return True\n\n            if Counter(a) != Counter(b):\n                return False\n\n            return any(\n                dp(a[:i], b[:i]) and dp(a[i:], b[i:]) or \\\n                dp(a[:i], b[-i:]) and dp(a[i:], b[:-i])\n                for i in range(1, len(a))\n            )\n\n        return dp(first, second)"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    Map<String, Boolean> mp = new HashMap<>();\n    \n    public boolean helper(String a, String b)\n    {\n        if(a.equals(b) == true) return true;\n        \n        if(a.length() <= 1) return false;\n        \n        int n = a.length();\n        boolean check = false;\n        \n        String key = a;\n        \n        key += ' ' + b;\n        \n        if(mp.containsKey(key))\n             return mp.get(key);\n        \n        for(int i = 1; i < n; i++)\n        {\n            boolean swap = helper(a.substring(0, i), b.substring(n - i)) && helper(a.substring(i), b.substring(0, n - i));\n            boolean unswap = helper(a.substring(0,i), b.substring(0,i)) && helper(a.substring(i), b.substring(i));\n            \n            if(swap || unswap){\n                check = true;\n                break;\n            }\n        }\n        \n        mp.put(key, check);\n        \n        return check;\n    }\n    \n    public boolean isScramble(String a, String b)\n    {\n        if(a.equals(b) == true) return true;\n        \n        if(a.length() != b.length()) return false;\n        \n        if(a.isEmpty() == true) return true;\n        \n        return helper(a, b);\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isScramble(string s1, string s2) {\n        int n = s1.length(); // Get the length of the strings\n        if (n != s2.length()) { // If the lengths are not equal, return false\n            return false;\n        }\n        bool dp[n + 1][n][n]; // Define a 3D boolean array to store the results\n        memset(dp, false, sizeof(dp)); // Initialize all values to false\n        for (int i = 0; i < n; i++) { // Base case: length 1\n            for (int j = 0; j < n; j++) {\n                if (s1[i] == s2[j]) { // If the characters are equal, set dp[1][i][j] to true\n                    dp[1][i][j] = true;\n                }\n            }\n        }\n        for (int l = 2; l <= n; l++) { // General case: length > 1\n            for (int i = 0; i <= n - l; i++) {\n                for (int j = 0; j <= n - l; j++) {\n                    for (int k = 1; k < l; k++) { // Divide the strings into two substrings at all possible positions\n                        if ((dp[k][i][j] && dp[l - k][i + k][j + k]) || // Check if the two substrings are scrambled strings of each other in swapped order\n                            (dp[k][i][j + l - k] && dp[l - k][i + k][j])) { // Check if the two substrings are scrambled strings of each other in same order\n                            dp[l][i][j] = true; // If any one of these checks returns true, set dp[l][i][j] to true\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return dp[n][0][0]; // Return dp[n][0][0], which is the final result\n    }\n};"
            }
        ]
    },
    "87": {
        "question_id": 88,
        "title": "Merge Sorted Array",
        "difficulty": 1,
        "description": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.Merge nums1 and nums2 into a single array sorted in non-decreasing order.The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. ",
        "examples": [
            {
                "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
                "output": "[1,2,2,3,5,6]",
                "explanation": "The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1."
            },
            {
                "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
                "output": "[1]",
                "explanation": "The arrays we are merging are [1] and [].\nThe result of the merge is [1]."
            },
            {
                "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
                "output": "[1]",
                "explanation": "The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1."
            }
        ],
        "constraints": [
            "nums1.length == m + n",
            "nums2.length == n",
            "0 <= m, n <= 200",
            "1 <= m + n <= 200",
            "-109 <= nums1[i], nums2[j] <= 109"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(MlogM), Sorting the array(nums1) costs O(MlogM). Where M is the size of the\n    Array(nums1).\n\n    Space Complexity : O(1), Constant Space. \n\n    Solved using Array + Sorting.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        for(int i=0; i<n; i++){\n            nums1[m+i] = nums2[i];\n        }\n        sort(nums1.begin(), nums1.end());\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N+M), Because we iterate N+M times for both the Array(nums1 and nums2). Where\n    M is the number of elements in Array(nums1) and N is the number of elements in Array(nums2).\n\n    Space Complexity : O(1), Constant Space. \n\n    Solved using Array + Two Pointers. \n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int i = m-1;\n        int j = n-1;\n        int k = m+n-1;\n        while(i>=0 && j>=0){\n            if(nums1[i] > nums2[j]){\n                nums1[k] = nums1[i];\n                i--; k--;\n            }\n            else{\n                nums1[k] = nums2[j];\n                j--; k--;\n            }\n        }\n        while(j>=0){\n            nums1[k] = nums2[j];\n            j--; k--;\n        }\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        //variables to work as pointers\n        int i=m-1; // will point at m-1 index of nums1 array\n        int j=n-1; // will point at n-1 index of nums2 array\n        int k=nums1.length-1; //will point at the last position of the nums1 array\n\n        // Now traversing the nums2 array\n        while(j>=0){\n            // If element at i index of nums1 > element at j index of nums2\n            // then it is largest among two arrays and will be stored at k position of nums1\n            // using i>=0 to make sure we have elements to compare in nums1 array\n            if(i>=0 && nums1[i]>nums2[j]){\n                nums1[k]=nums1[i];\n                k--; \n                i--; //updating pointer for further comparisons\n            }else{\n                // element at j index of nums2 array is greater than the element at i index of nums1 array \n                // or there is no element left to compare with the nums1 array \n                // and we just have to push the elements of nums2 array in the nums1 array.\n                nums1[k] = nums2[j];\n                k--; \n                j--; //updating pointer for further comparisons\n            }\n        }\n    }\n}"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        for i in range(m,m+n):\n            nums1[i]=nums2[i-m]\n        nums1.sort()\n    #please upvote me it would encourage me alot"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i=m-1 , j=n-1 ;\n        while(i>=0 && j>=0 ){\n            if(nums1[i]>=nums2[j]){\n                nums1[i+j+1]=nums1[i] ;\n                i-- ;\n                }else{\n                    nums1[i+j+1]=nums2[j];\n                    j-- ;\n                }\n        }\n        while(j>=0){\n                    nums1[j]=nums2[j];\n                    j-- ;\n                }\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        \n    int i = m - 1;\n    int j = n - 1;\n    int k = m + n - 1;\n    while (i >= 0 && j >= 0)\n    {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (i >= 0)\n        nums1[k--] = nums1[i--];\n    while (j >= 0)\n        nums1[k--] = nums2[j--];\n\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n       int[] arr=new int[n+m];\n       int i =0 ,j =0 , k = 0;\n       while(i<m && j<n)          \n    {\n        if(nums1[i]<=nums2[j])\n        {\n            arr[k++]=nums1[i++];\n        }\n        else if(nums1[i]>nums2[j]){\n            arr[k++]=nums2[j++];\n        }\n    }\n      while(i<m)\n      {\n         arr[k++]=nums1[i++];\n      }\n       while(j<n)\n      {\n         arr[k++]=nums2[j++];\n      }\n      for(int a=0;a<arr.length;a++)\n   {\n       nums1[a]=arr[a];\n   }\n    }\n   \n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int[] ans = new int[m+n];\n        int k=0,i=0,j=0;\n        while(i<m && j<n){\n            if(nums1[i]>=nums2[j]){\n                ans[k] = nums2[j];\n                j++;\n                k++;\n            }\n            else{\n                ans[k] = nums1[i];\n                i++;\n                k++;\n            }\n        }\n        while(i<m){\n            ans[k]=nums1[i];\n                 k++;\n                 i++;\n\n        }\n        while(j<n){\n            ans[k]=nums2[j];\n                 k++;\n                 j++;\n\n        }\n        for(int l=0;l<m+n;l++)\n      {\n          nums1[l]=ans[l];\n      }\n       \n        \n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        vector<int>ans(m+n);\n        int k=0,i=0,j=0;\n        while(i<m && j<n){\n            if(nums1[i]>=nums2[j]){\n                ans[k] = nums2[j];\n                j++;\n                k++;\n            }\n            else{\n                ans[k] = nums1[i];\n                i++;\n                k++;\n            }\n        }\n        while(i<m){\n            ans[k]=nums1[i];\n                 k++;\n                 i++;\n\n        }\n        while(j<n){\n            ans[k]=nums2[j];\n                 k++;\n                 j++;\n\n        }\n        for(int l=0;l<m+n;l++)\n      {\n          nums1[l]=ans[l];\n      }\n        \n    }\n};"
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nvar merge = function(num1, m, num2, n) {\n    let j=0\n         for(let i=m;i<m+n;i++){\n                 num1[i]=num2[j]\n                 j++\n         }\nconsole.log(num1.sort((a,b)=>a-b))\n};"
            },
            {
                "language": "ruby",
                "code": "def merge(nums1, m, nums2, n)\n  i = nums1.length - 1\n  m -= 1 \n  n -= 1\n\n  while i >= 0 && n >= 0 \n    if m >= 0 && nums1[m] > nums2[n]\n      nums1[i] = nums1[m]\n      m -= 1\n    else\n      nums1[i] = nums2[n]\n      n -= 1\n    end\n    i -= 1 \n  end\nend"
            }
        ]
    },
    "88": {
        "question_id": 89,
        "title": "Gray Code",
        "difficulty": 2,
        "description": "An n-bit gray code sequence is a sequence of 2n integers where:Every integer is in the inclusive range [0, 2n - 1],The first integer is 0,An integer appears no more than once in the sequence,The binary representation of every pair of adjacent integers differs by exactly one bit, andThe binary representation of the first and last integers differs by exactly one bit.Given an integer n, return any valid n-bit gray code sequence. ",
        "examples": [
            {
                "input": "n = 2",
                "output": "[0,1,3,2]\nExplanation:\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit",
                "explanation": null
            },
            {
                "input": "n = 1",
                "output": "[0,1]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= n <= 16"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution:\n    def grayCode(self, n: int) -> List[int]:\n        oldArr = [0,1]\n        i = 1\n        while i< n:\n            Arr = list(oldArr)\n            for j in range(len(oldArr)-1,-1,-1):\n                Arr.append((2**i)+oldArr[j])\n            oldArr = Arr\n            i+=1\n        return oldArr"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def grayCode(self, n: int) -> List[int]:\n        res = [0]\n        for i in range(n):\n            for j in range(len(res) - 1, -1, -1):\n                res.append(res[j] | (1 << i))\n        return res"
            },
            {
                "language": "csharp",
                "code": "public List<Integer> grayCode(int n) {\n    List<Integer> rs=new ArrayList<Integer>();\n    rs.add(0);\n    for(int i=0;i<n;i++){\n        int size=rs.size();\n        for(int k=size-1;k>=0;k--)\n            rs.add(rs.get(k) | 1<<i);\n    }\n    return rs;\n}"
            },
            {
                "language": "cpp",
                "code": "    vector<int> grayCode(int n) {\n        vector<int>res(1,0);\n        for(int i=0;i<n;i++){\n            int size=res.size();\n            for(int j=size-1;j>=0;j--){\n                res.push_back(res[j]|1<<i);\n            }\n        }"
            },
            {
                "language": "csharp",
                "code": "public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        if(n == 0) return list;\n        list.add(1);\n        int curr = 1;"
            },
            {
                "language": "csharp",
                "code": ""
            },
            {
                "language": "python",
                "code": "class Solution1:\n    def grayCode(self, n): \n        \"\"\" \n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        res = [0] \n        for i in range(n):"
            },
            {
                "language": "java",
                "code": "def grayCode(self, n: int) -> List[int]:\n        s=[0]\n        for k in range(n):\n            ns=[]\n            for x in s:\n                ns.append(x+(1<<k))\n            s=s+ns[::-1]\n        return s"
            },
            {
                "language": "go",
                "code": "    s=[0, 1]\n    m = 1\n    for k in range(1, n):\n        ns=[]\n        m = m << 1\n        for x in s:\n            ns.append(x+m)\n        s += ns[::-1]"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> grayCode(int n) {\n        int cnt=1;\n        vector<int>v;\n        v.push_back(0);\n        v.push_back(1);\n        for(int i=1; i<n; i++){\n            cnt*=2;\n            int l=v.size();\n            for(int j=l-1; j>=0; j--){\n                v.push_back(v[j]+cnt);\n            }\n        }\n        return v;\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "public List<Integer> grayCode(int n) {\n    List<Integer> result = new LinkedList<>();\n    for (int i = 0; i < 1<<n; i++) result.add(i ^ i>>1);\n    return result;\n}"
            },
            {
                "language": "csharp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "/*\n        The purpose of this function is to convert an unsigned\n        binary number to reflected binary Gray code.\n \n        The operator >> is shift right. The operator ^ is exclusive or.\n*/\nunsigned int binaryToGray(unsigned int num)\n{"
            },
            {
                "language": "csharp",
                "code": "public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);                                //n=0 {0}\n        if(n == 0) return list;\n        int increase = 1;\n        for(int i = 0;i<n;i++){                     //              n=2\n            int len = list.size();                  //              len = 2"
            },
            {
                "language": "cpp",
                "code": "public List<Integer> grayCode(int n) {\n        List<Integer> result = new LinkedList<>();\n        for (int i = 0; i < Math.pow(2,n); i++) \n            result.add(i ^ i/2);\n        return result;\n    }"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def grayCode(self, n):\n        if n == 0: return [0]\n        t = self.grayCode(n-1)\n        return t + [i+(1<<(n-1)) for i in t][::-1]"
            },
            {
                "language": "java",
                "code": "def grayCode(self, n: int) -> List[int]:\n    ans = [0]\n    for i in range(n):\n        ans += [(1<<i) ^ c for c in reversed(ans)]\n    return ans"
            },
            {
                "language": "go",
                "code": "import collections\nfrom collections import defaultdict\n\ndef func(n):\n    if dp[n]!=[]:\n        return dp[n]\n    if n==1:\n        return ['0','1']"
            },
            {
                "language": "ruby",
                "code": "def grayCode(self, n: int) -> List[int]:\n        if n==1:\n            return [0,1]\n        if n==2:\n            return [0,1,3,2]\n        base = [0,1,3,2]\n        for i in range(3,n+1):\n            multiplier = pow(2,i-1)\n            temp = []"
            },
            {
                "language": "python",
                "code": "# logic is:\n# for 1- [0,1]\n# for 2 - [0,1,3,2] - not that first half of array is same as for n=1 addition for i=2 is (2**1)+1 => 3, (2**1)+0 => 2\n# that is [0,1,1,0] => first half of array + concatenate reverse part of array and add powers of 2 to it  \noldArr = [0,1]\ni = 1\nwhile i< n:\n # add old array\n newArr = list(oldArr)\n # now add bit value to old reversed values\n for j in range(len(oldArr)-1,-1,-1):\n  newArr.append((2**i)+oldArr[j])\n oldArr = newArr\n i+=1\nreturn oldArr"
            },
            {
                "language": "python",
                "code": "class Solution:\n    # @return a list of integers\n    '''\n    from up to down, then left to right\n    \n    0   1   11  110\n            10  111\n                101\n                100\n                \n    start:      [0]\n    i = 0:      [0, 1]\n    i = 1:      [0, 1, 3, 2]\n    i = 2:      [0, 1, 3, 2, 6, 7, 5, 4]\n    '''\n    def grayCode(self, n):\n        results = [0]\n        for i in range(n):\n            results += [x + pow(2, i) for x in reversed(results)]\n        return results"
            },
            {
                "language": "elixir",
                "code": "start: [0]\ni = 0:          [0]\ni = 1:          [0, 1]\n                  nums[1] = nums[0] + 1\ni = 2:          [0, 1, 3, 2]\n                  nums[2:4] = nums[1: : -1] + 2"
            },
            {
                "language": "python",
                "code": "results += [x | (1 << i) for x in reversed(results)]"
            },
            {
                "language": "cpp",
                "code": "class Solution(object):\n    def grayCode(self, n):\n        res = [0]\n        for i in range(n):\n            res += [x|(1<<i) for x in res[::-1]]\n        return res"
            },
            {
                "language": "swift",
                "code": "class Solution {\n    func grayCode(_ n: Int) -> [Int] {\n        var arr: [Int] = [0]\n        var e = -1\n        \n        func povv(_ n: Int, _ e: Int) -> Int { return Int(pow(Double(n), Double(e))) }\n        \n        for i in 1..<povv(2, n) {\n            if i == povv(2, e + 1) { e += 1 }\n            \n            let index = povv(2, e + 1) - i - 1\n            let num = povv(2, e) + arr[index]\n            arr.append(num)\n        }\n        \n        return arr\n    }\n    \n}"
            }
        ]
    },
    "89": {
        "question_id": 90,
        "title": "Subsets II",
        "difficulty": 2,
        "description": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set).The solution set must not contain duplicate subsets. Return the solution in any order. ",
        "examples": [
            {
                "input": "nums = [1,2,2]",
                "output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
                "explanation": null
            }
        ],
        "constraints": [],
        "solutions": [
            {
                "language": "javascript",
                "code": "while(i+1 <nums.size() && nums[i]==nums[i+1]){\n            i++;\n        }"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>>ans;\n    void help(int i,vector<int>&nums,vector<int>&temp){\n        if(i==nums.size()){\n            ans.push_back(temp);\n            return;\n        }\n        temp.push_back(nums[i]);\n        help(i+1,nums,temp);\n        \n        temp.pop_back();\n        while(i+1 <nums.size() && nums[i]==nums[i+1]){\n            i++;\n        }\n        help(i+1,nums,temp);\n        \n    }\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        vector<int>temp;\n        sort(nums.begin(),nums.end());\n        help(0,nums,temp);\n        //sort(ans.begin(),ans.end());\n        return ans;\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>>ans=new ArrayList<>();\n        solve(0,nums,new ArrayList<>(),ans);\n        return ans;\n    }\n    public void solve(int ind,int[]nums,ArrayList<Integer>temp,List<List<Integer>>ans){\n        ans.add(new ArrayList<>(temp));\n        for(int i=ind;i<nums.length;i++){\n            if(i!=ind && nums[i]==nums[i-1]) continue;//for duplicate checking\n            temp.add(nums[i]);\n            solve(i+1,nums,temp,ans);\n            temp.remove(temp.size()-1);\n        }\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        Arrays.sort(nums); \n        List<List<Integer>> ans = new ArrayList<>(); \n        findSubsets(0, nums, new ArrayList<>(), ans); \n        return ans; \n    }\n    public static void findSubsets(int index, int[] nums, List<Integer> ds, List<List<Integer>> ans) {\n        ans.add(new ArrayList<>(ds)); \n        for(int i = index;i<nums.length;i++) {\n            if(i!=index && nums[i] == nums[i-1]) continue; \n            ds.add(nums[i]); \n            findSubsets(i+1, nums, ds, ans); \n            ds.remove(ds.size() - 1);\n        }\n        \n    }\n}"
            },
            {
                "language": "swift",
                "code": "class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        List<List<Integer>> arr = new ArrayList<>();\n        Arrays.sort(nums);\n        func (arr, new ArrayList<>(), nums);\n        return arr;\n    }\n    void func (List<List<Integer>> arr, List<Integer> pro, int[] unpro) {\n        if (unpro.length==0) {\n            for (List<Integer> i : arr) {\n                if (pro.equals(i)==true) return;\n            }\n            arr.add(new ArrayList<>(pro));\n            return;\n        }\n        pro.add(unpro[0]);\n        func (arr, pro, Arrays.copyOfRange(unpro, 1, unpro.length));\n        pro.remove(pro.size()-1);\n        func (arr, pro, Arrays.copyOfRange(unpro, 1, unpro.length));\n    }\n}"
            },
            {
                "language": "go",
                "code": "    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        powerset =[[]]\n        hmap = Counter(nums);\n        for key in hmap.keys():\n            l = len(powerset)\n            for i in range(0,len(powerset)):\n                k = 0\n                while( k < hmap[key] ):\n                    k+=1\n                    powerset.append(list(powerset[i]+k*[key]));\n        return powerset ;"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void solve(vector <int> nums, vector<int> temp, int index, vector<vector<int>>& ans)\n    {\n        if(index >= nums.size())\n        {\n            ans.push_back(temp);\n            return ;\n        }\n        \n        solve(nums, temp, index+1, ans);\n        \n        int key = nums[index];\n        temp.push_back(key);\n        solve( nums, temp, index+1, ans);\n    }\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> ans;\n        vector <int> temp;\n        solve(nums, temp, 0, ans);\n        sort(ans.begin(), ans.end());\n        \n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\n        \n        return ans;\n        \n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        Set<List<Integer>> set = new HashSet<>();\n        set.add(new ArrayList<>());\n        for (int i = 0; i < nums.length; i++) {\n            goBacktracking(i, nums, new ArrayList<>(), set);\n        }\n        return new ArrayList<>(set);\n    }\n\n    private void goBacktracking(int i, int[] nums, ArrayList<Integer> list, Set<List<Integer>> set) {\n        if (i >= nums.length) {\n            List<Integer> templist = new ArrayList<>(list);\n            Collections.sort(templist);\n            set.add(templist);\n            return;\n        }\n\n        list.add(nums[i]);\n        \n        for (int j = i + 1; j <= nums.length; j++) {\n            goBacktracking(j, nums, list, set);\n        }\n        list.remove(list.size() - 1);\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>>ans;\n    void subsequence(int ind,int n,vector<int>&arr,vector<int>&ds){\n    if(ind==n){\n        ans.push_back(ds);\n        return;\n    }\n // Since in this question we can change the order of the array elements unlike question(https://leetcode.com/problems/non-decreasing-subsequences/description/).\n    //  Therefore we sorted the nums vector initially.\n    //  Therefore condition , if(ds.size()==0 || nums[index] >= ds[ds.size()-1]) is not required .\n    ds.push_back(arr[ind]);\n    subsequence(ind+1,n,arr,ds);\n    ds.pop_back();\n    if(ds.size()==0 || arr[ind]!=ds[ds.size()-1])subsequence(ind+1,n,arr,ds);\n}\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        vector<int>ds;\n        subsequence(0,nums.size(),nums,ds);\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time complexity : O(2^N*2^N), For every index, we make 2 recursion calls and there are N elements and for\n    every subset we are checking duplicates in output and in worst case it can contain 2^N-1 subset. so total time\n    complexity is O(2^N*2^N).\n\n    Space complexity : O(2^N*N), In worst case there can be 2^N-1 subsets and for every subset, we need O(N) \n    space on average so total space complexity is O(2^N*N).\n\n    Solved using Array + Backtracking.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\nprivate: \n    void subsetsWithDup(vector<int>& nums, vector<vector<int>> &output, vector<int> temp, int index) {\n        if(nums.size() == index){\n            bool isPresent = find(output.begin(), output.end(), temp) != output.end();\n            if(!isPresent){\n                output.push_back(temp);\n            }\n            return;\n        }\n        subsetsWithDup(nums, output, temp, index+1);\n        temp.push_back(nums[index]);\n        subsetsWithDup(nums, output, temp, index+1);\n    }\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<int> temp;\n        vector<vector<int>> output;\n        subsetsWithDup(nums, output, temp, 0);\n        return output;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time complexity : O(2^N).\n\n    Space complexity : O(2^N*N), In worst case there can be 2^N-1 subsets and for every subset, we need O(N) \n    space on average so total space complexity is O(2^N*N).\n\n    Solved using Array + Backtracking.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    void solve(vector<int> &nums, vector<int> &ds, vector<vector<int>> &ans, int ind){\n        ans.push_back(ds);\n        for(int i=ind;i<nums.size();i++)\n        {\n            if(i>ind && nums[i] == nums[i-1]){\n                continue;\n            }\n            ds.push_back(nums[i]);\n            solve(nums,ds,ans,i+1);\n            ds.pop_back();\n        }\n    }\n    vector<vector<int>> subsetsWithDup(vector<int>& nums){\n        vector<vector<int>> ans;\n        sort(nums.begin(),nums.end());\n        vector<int> ds;\n        solve(nums,ds,ans,0);\n        return ans;\n    }\n};"
            },
            {
                "language": "go",
                "code": "func subsetsWithDup(nums []int) [][]int {\n    sort.Ints(nums)\n    res := [][]int{}\n\n    for i := 0; i <= len(nums); i++ {\n        findSubset(nums, 0, i, []int{}, &res)\n    }\n    return res\n}\n\nfunc findSubset(nums []int, idx, l int, list []int, res *[][]int) {\n    if len(list) == l {\n        temp := make([]int, l)\n        copy(temp, list)\n        (*res) = append(*res, temp)\n        return\n    }\n\n    for i := idx; i < len(nums); i++ {\n        if i == idx || nums[i] != nums[i-1] {\n            findSubset(nums, i+1, l, append(list, nums[i]), res)\n        }\n    }\n}"
            }
        ]
    },
    "90": {
        "question_id": 91,
        "title": "Decode Ways",
        "difficulty": 2,
        "description": "A message containing letters from A-Z can be encoded into numbers using the following mapping:'A' -> \"1\"'B' -> \"2\"...'Z' -> \"26\"To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into:\"AAJF\" with the grouping (1 1 10 6)\"KJF\" with the grouping (11 10 6)Note that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\".Given a string s containing only digits, return the number of ways to decode it.The test cases are generated so that the answer fits in a 32-bit integer. ",
        "examples": [
            {
                "input": "s = \"12\"",
                "output": "2",
                "explanation": "\"12\" could be decoded as \"AB\" (1 2) or \"L\" (12)."
            },
            {
                "input": "s = \"226\"",
                "output": "3",
                "explanation": "\"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6)."
            },
            {
                "input": "s = \"06\"",
                "output": "0",
                "explanation": "\"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\")."
            }
        ],
        "constraints": [
            "1 <= s.length <= 100",
            "s contains only digits and may contain leading zero(s)."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\n    public int numDecodings(String s) {\n        char lastDigit = s.charAt(0);\n        if (lastDigit == '0') return 0;\n        int independentCount = 1, totalNum = 1;\n        for (int i = 1; i < s.length(); i++) {\n            char digit = s.charAt(i);\n            int tempIndependentCount = digit == '0' ? 0 : totalNum, tempTotalNum = tempIndependentCount;"
            },
            {
                "language": "csharp",
                "code": "    int n = s.size();\n    this->records = vector<int>(n, -1);\n    long result = helper(s, n, 0);\n    if (result == INT_MAX) "
            },
            {
                "language": "typescript",
                "code": "function numDecodings(s: string, memo = new Map()): number {    \n    if (s[0] === '0') return 0\n    else if (s === '' || s.length === 1) return 1\n    else if (memo.has(s)) return memo.get(s) \n    const answer = (s[0] === '1' || (s[0] === '2' && parseInt(s[1]) < 7)) ? numDecodings(s.slice(1), memo) + numDecodings(s.slice(2), memo) : numDecodings(s.slice(1), memo)\n    memo.set(s, answer)\n    return answer        "
            },
            {
                "language": "kotlin",
                "code": "dp[i] = \n  dp[i-2], if s[i-1]+s[i] between [10, 26], and s[i] ==0\n  dp[i-1] + dp[i-2], if s[i-1]+s[i] between [10, 26], and s[i] !=0\n  return 0, if s[i]==s[i-1]==0, or s[i-1]+s[i]>26 and s[i]==0\n  dp[i-1], other cases"
            },
            {
                "language": "go",
                "code": ""
            },
            {
                "language": "go",
                "code": "class Solution {\npublic:\n    int func(int i,string &s,vector<int>&dp){\n        if(i==s.length())return 1;\n        if(i==s.length()-1){\n            if(s[i]>='1' && s[i]<='9')return 1;\n            return 0;\n        }\n        if(s[i]=='0')return 0;\n        if(dp[i]!=-1)return dp[i];\n        int p1=0,p2=0;\n        if(s[i]>='1' && s[i]<='9')\n            p1 = func(i+1,s,dp);\n        int x=0;\n        x = (s[i]-'0')*10 + (s[i+1]-'0');\n        if(x>=1 && x<=26)\n            p2 = func(i+2,s,dp);\n        return dp[i]=p1+p2;\n        \n        \n    }\n    int numDecodings(string s) {\n        vector<int>dp(101,-1);\n        return func(0,s,dp);\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "    int numDecodings(string s) {\n        return s.empty() ? 0: numDecodings(0,s);    \n    }\n    int numDecodings(int p, string& s) {\n        int n = s.size();\n        if(p == n) return 1;\n        if(s[p] == '0') return 0; // sub string starting with 0 is not a valid encoding\n        int res = numDecodings(p+1,s);\n        if( p < n-1 && (s[p]=='1'|| (s[p]=='2'&& s[p+1]<'7'))) res += numDecodings(p+2,s);\n        return res;\n    }"
            },
            {
                "language": "cpp",
                "code": " public int numDecodings(String s) {\n        return s.length()==0?0:numDecodings(0,s);      \n    }\n    private int numDecodings(int p, String s) {\n        int n=s.length();\n        if(p==n) return 1;\n        if(s.charAt(p)=='0') return 0;\n        int res=numDecodings(p+1,s);\n        if(p<n-1&&(s.charAt(p)=='1'||s.charAt(p)=='2'&&s.charAt(p+1)<'7')) \n   res+=numDecodings(p+2,s);\n        return res;\n    }"
            },
            {
                "language": "cpp",
                "code": "    int numDecodings(string s) {\n        int n = s.size();\n        vector<int> mem(n+1,-1);\n        mem[n]=1;\n        return s.empty()? 0 : num(0,s,mem);   \n    }\n    int num(int i, string &s, vector<int> &mem) {\n        if(mem[i]>-1) return mem[i];\n        if(s[i]=='0') return mem[i] = 0;\n        int res = num(i+1,s,mem);\n        if(i<s.size()-1 && (s[i]=='1'||s[i]=='2'&&s[i+1]<'7')) res+=num(i+2,s,mem);\n        return mem[i] = res;\n    }"
            },
            {
                "language": "java",
                "code": " public int numDecodings(String s) {\n        int n=s.length();\n        Integer[] mem=new Integer[n];\n        return s.length()==0?0:numDecodings(0,s,mem);      \n    }\n    private int numDecodings(int p, String s, Integer[] mem) {\n        int n=s.length();\n        if(p==n) return 1;\n        if(s.charAt(p)=='0') return 0;\n        if(mem[p]!=null) return mem[p];\n        int res=numDecodings(p+1,s,mem);\n        if(p<n-1&&(s.charAt(p)=='1'||s.charAt(p)=='2'&&s.charAt(p+1)<'7')) \n   res+=numDecodings(p+2,s,mem);\n        return mem[p]=res;\n    }"
            },
            {
                "language": "cpp",
                "code": "    int numDecodings(string s) {\n        int n = s.size();\n        vector<int> dp(n+1);\n        dp[n] = 1;\n        for(int i=n-1;i>=0;i--) {\n            if(s[i]=='0') dp[i]=0;\n            else {\n                dp[i] = dp[i+1];\n                if(i<n-1 && (s[i]=='1'||s[i]=='2'&&s[i+1]<'7')) dp[i]+=dp[i+2];\n            }\n        }\n        return s.empty()? 0 : dp[0];   \n    }"
            },
            {
                "language": "cpp",
                "code": " public int numDecodings(String s) {\n        int n=s.length();\n        int[] dp=new int[n+1];\n        dp[n]=1;\n        for(int i=n-1;i>=0;i--)\n            if(s.charAt(i)!='0') {\n                dp[i]=dp[i+1];\n                if(i<n-1&&(s.charAt(i)=='1'||s.charAt(i)=='2'&&s.charAt(i+1)<'7')) \n     dp[i]+=dp[i+2];\n            }\n        return dp[0];   \n    }"
            },
            {
                "language": "csharp",
                "code": "    int numDecodings(string s) {\n        int p = 1, pp, n = s.size();\n        for(int i=n-1;i>=0;i--) {\n            int cur = s[i]=='0' ? 0 : p;\n            if(i<n-1 && (s[i]=='1'||s[i]=='2'&&s[i+1]<'7')) cur+=pp;\n            pp = p;\n            p = cur;\n        }\n        return s.empty()? 0 : p;   \n    }"
            },
            {
                "language": "cpp",
                "code": " public int numDecodings(String s) {\n        int dp1=1, dp2=0, n=s.length();\n        for(int i=n-1;i>=0;i--) {\n            int dp=s.charAt(i)=='0'?0:dp1;\n            if(i<n-1&&(s.charAt(i)=='1'||s.charAt(i)=='2'&&s.charAt(i+1)<'7'))\n                dp+=dp2;\n            dp2=dp1;\n            dp1=dp;\n        }\n        return dp1;\n    }"
            },
            {
                "language": "python",
                "code": "public int numDecodings(String s) {\n        if(s == null || s.length() == 0) return 0;\n        HashMap<Integer, Integer> map = new HashMap<>();\n        return dfs(s, map, 0);\n    }\n& str.charAt(index + 1) < '7'))){"
            },
            {
                "language": "csharp",
                "code": ""
            },
            {
                "language": "java",
                "code": ""
            },
            {
                "language": "csharp",
                "code": "int numDecodings(string s) {\n        if(s[0] == '0')return 0;\n        if(s.size() == 1)return 1;\n        int last = 1, secondlast = 1;\n        for(int i = 1; i<s.size(); i++){\n            if(s[i] == '0')last = 0;\n            if(s[i-1] == '1' || s[i-1] == '2' && s[i] <= '6'){\n                last = last + secondlast;"
            },
            {
                "language": "python",
                "code": "map.put(index, res);"
            },
            {
                "language": "csharp",
                "code": "public int numDecodings(String s) {\n        if(s == null || s.length() == 0 || s.charAt(0) =='0') return 0;\n        int[] mem = new int[s.length()+1];\n(index+1)<'7')))"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        @cache\n        def dp(i):\n            if i == len(s): return 1\n            if s[i] == '0': return 0\n            \n            return dp(i+1) + (dp(i+2) if 10 <= int(s[i:i+2]) <= 26 else 0)"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    int ans(string s, int len){\n        if(s.length() == 0){\n            return 1;\n        }\n        if(s[0] == '0'){"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        a = [0, 1]\n        for i in range(len(s)):\n            if not i or not 9 < int(s[i - 1:i + 1]) < 27:\n                a[i % 2] = 0\n            if s[i] != \"0\":\n                a[i % 2] += a[i % 2 - 1]"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    int help(int i, string s, int* dp) {\n        if(i >= s.size()) return 1;\n        if(dp[i] != -1) return dp[i];\n        int ans = 0;\n        int op1 = s[i] - '0', op2 = 0;\n        if(i < s.size() - 1) {\n            op2 = op1 * 10 + s[i + 1] - '0';\n        }\n        if(op1 > 0) ans+= help(i + 1, s, dp);\n        if(op1 > 0 && op2 > 0 && op2 <= 26) ans+= help(i + 2, s, dp);\n        return dp[i] = ans;\n    }\n\n    int numDecodings(string s) {\n        int dp[101];\n        memset(dp,-1, sizeof dp);\n        return help(0, s, dp);\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    long long int dp[102];\n    int f(int i, string &s){\n        if(i>=s.size()-1)return 1;\n        if(dp[i]!=-1)return dp[i];\n        int a = s[i]-48;\n        int b = (s[i]-48)*10+s[i+1]-48;\n        if(a==0)return 0;\n        int p1 = 0, p2 = 0;\n        if(1<=a and a<=26)p1 = f(i+1, s);\n        if(1<=b and b<=26)p2 = f(i+2, s);\n        return dp[i] = p1+p2;\n    }\n    int numDecodings(string s) {\n        memset(dp, -1, sizeof dp);\n        s+='z';\n        return f(0, s);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    int dfs(int i, int n, string &s, vector<int> &dp) {\n        if(i == n) return 1;\n        if(dp[i] != -1) return dp[i];\n\n        int pick1 = s[i + 1] == '0' || s[i] == '0' ? 0 : dfs(i + 1, n, s, dp);\n        int pick2 = s[i] != '0' && i + 1 < n && stoi(s.substr(i, 2)) <= 26 ? dfs(i + 2, n, s, dp) : 0;\n\n        return dp[i] = pick1 + pick2;\n    }\npublic:\n    int numDecodings(string s) {\n        int n = s.size();\n        vector<int> dp(n, -1);\n        return dfs(0, n, s, dp);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int numDecodings(string s) {\n        int n = s.size();\n        vector<int> dp(n + 1);\n        dp[n] = 1;\n        for(int i=n-1; i>=0; i--) {\n            int pick1 = s[i + 1] == '0' || s[i] == '0' ? 0 : dp[i + 1];\n            int pick2 = s[i] != '0' && i + 1 < n && stoi(s.substr(i, 2)) <= 26 ? dp[i + 2] : 0;\n            dp[i] = pick1 + pick2;\n        }\n        return dp[0];\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    int numDecodings(string s) {\n        int n = s.size(), a = 1, b = 0;\n        for(int i=n-1; i>=0; i--) {\n            int pick1 = s[i + 1] == '0' || s[i] == '0' ? 0 : a;\n            int pick2 = s[i] != '0' && i + 1 < n && stoi(s.substr(i, 2)) <= 26 ? b : 0;\n            int c = pick1 + pick2;\n            b = a;\n            a = c;\n        }\n        return a;\n    }\n};"
            },
            {
                "language": "python",
                "code": "class Solution {\npublic:\n    int mycoldfun(int ind,string& str,vector<int> &dp){\n        if(dp[ind]!=-1) return dp[ind];\n        if(ind>=str.size()) return 1;\n        int single=0,dub=0;\n        if(str[ind]-'0'>0) single=mycoldfun(ind+1,str,dp);\n        if(ind+1<str.size() && 10<=((str[ind]-'0')*10+str[ind+1]-'0') && ((str[ind]-'0')*10+str[ind+1]-'0') <=26) dub=mycoldfun(ind+2,str,dp);\n        return dp[ind]=single+dub;\n    }\n    int numDecodings(string s) {\n        vector<int> dp(s.size()+2,-1);\n        return mycoldfun(0,s,dp);\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public int numDecodings(String s) {\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        int n = s.length();\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = s.charAt(0) != '0' ? 1 : 0;\n        for (int i = 2; i <= n; i++) {\n            int first = Integer.valueOf(s.substring(i - 1, i));\n            int second = Integer.valueOf(s.substring(i - 2, i));\n            if (first >= 1 && first <= 9) {\n               dp[i] += dp[i-1];  \n            }\n            if (second >= 10 && second <= 26) {\n                dp[i] += dp[i-2];\n            }\n        }\n        return dp[n];\n    }\n}"
            },
            {
                "language": "csharp",
                "code": "public int numDecodings(String s) {\n    if(s == null || s.length() == 0) {\n      return 0;\n    }\n    int n = s.length();\n    int[] dp = new int[n];\n    dp[0] = s.charAt(0) != '0' ? 1 : 0;\n    for(int i = 1; i < n; i++) {"
            },
            {
                "language": "csharp",
                "code": "public int numDecodings(String s) {\n    if (s == null || s.length() == 0) {\n        return 0;\n    }\n    char[] chars = s.toCharArray();\n    int[] dp = new int[chars.length];\n    dp[0] = chars[0] == '0' ? 0 : 1;"
            },
            {
                "language": "csharp",
                "code": " int numDecodings(string s) {\n    int n = s.size();\n    if (n == 0 || s[0] == '0') return 0;\n    if (n == 1) return 1;\n    int pre2 = 1, pre1 = 1;\n    int cur;\n    for (int i = 1; i < n; ++i) {\n        cur = 0;"
            },
            {
                "language": "python",
                "code": "def numDecodings(s): \n if not s:\n  return 0\n\n dp = [0 for x in range(len(s) + 1)] \n \n # base case initialization\n dp[0] = 1 \n dp[1] = 0 if s[0] == \"0\" else 1   #(1)\n\n for i in range(2, len(s) + 1): \n  # One step jump\n  if 0 < int(s[i-1:i]) <= 9:    #(2)\n   dp[i] += dp[i - 1]\n  # Two step jump\n  if 10 <= int(s[i-2:i]) <= 26: #(3)\n   dp[i] += dp[i - 2]\n return dp[len(s)]"
            },
            {
                "language": "ruby",
                "code": "    def numDecodings(self, s: str) -> int:\n        if not s or s[0]=='0':\n            return 0\n\n        dp = [0 for x in range(len(s) + 1)] \n\n        # base case initialization\n        dp[0:2] = [1,1]"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        # Edge case check\n        if s is None or s[0] == '0':\n            return 0\n        dp = [1] * len(s)\n        for i in range(1, len(s)): \n            # One digit check"
            }
        ]
    },
    "91": {
        "question_id": 92,
        "title": "Reverse Linked List II",
        "difficulty": 2,
        "description": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list. ",
        "examples": [
            {
                "input": "head = [1,2,3,4,5], left = 2, right = 4",
                "output": "[1,4,3,2,5]",
                "explanation": null
            },
            {
                "input": "head = [5], left = 1, right = 1",
                "output": "[5]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is n.",
            "1 <= n <= 500",
            "-500 <= Node.val <= 500",
            "1 <= left <= right <= n"
        ],
        "solutions": [
            {
                "language": "",
                "code": "C++ easy solution"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int left, int right)\n    {\n        if(head==NULL || head->next==NULL) return head;    //if list contain only single node or no node\n        ListNode *h1=head;\n        ListNode *x = head;\n        ListNode *x1=head,*x2=head;\n        int n = 0;\n        while(x!=NULL) {\n            n++;\n            x=x->next;\n        }\n        if(left==n) return head;   //if left position is equal to size \n        int i=1;\n        while(i<left) {      //assining left position\n            x1 = h1;\n            h1=h1->next;\n            i++;\n        }\n        ListNode *t1=head;\n        if(right<n) {        //assigning right position\n            i=1;\n            while(i<right){\n                t1=t1->next;\n                i++;\n            }\n            x2=t1->next;\n            t1->next=NULL;\n        }\n        ListNode *t = NULL, *p=NULL;\n        ListNode *temp = h1;\n        while(h1!=NULL)       //reversing from left positin to right position\n        {\n            t=h1->next;\n            h1->next=p;\n            p=h1;\n            h1=t;\n        }\n        h1=p;\n        while(p->next != NULL)\n            p=p->next;\n        if(left!=1)\n        {\n            x1->next=h1;\n            if(right != n)\n                temp->next = x2;\n            return head;\n        }\n        if(right != n)\n                temp->next = x2;\n        return h1;\n    }\n};"
            },
            {
                "language": "",
                "code": "Input: head = [1,2,10,20,30,40,5], left = 3, right = 6\nOutput: [1,2,40,30,20,10,5]"
            },
            {
                "language": "ruby",
                "code": "So, the pre pointer will be assigned on just before left position\nCurr pointer & forw pointer will help in reversing the linkedlist\n\nSo, we gonna perform these steps,\ncurr.next = forw.next\nforw.next = curr.next ? prev.next [\"We are not sure at this point which one forw should have to point, so we gonna find out later\"]\nprev.next = forw\nforw = curr.next"
            },
            {
                "language": "rust",
                "code": "Because, let's say we have given \"left = 1\" then where our prev pointer will be assigned then, \nto handle that case we gonna use one dummy node. So, if left = 1 then our prev will be at dummy node"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        ListNode dummy = new ListNode(0); // created dummy node\n        dummy.next = head;\n        ListNode prev = dummy; // intialising prev pointer on dummy node\n        \n        for(int i = 0; i < left - 1; i++)\n            prev = prev.next; // adjusting the prev pointer on it's actual index\n        \n        ListNode curr = prev.next; // curr pointer will be just after prev\n        // reversing\n        for(int i = 0; i < right - left; i++){\n            ListNode forw = curr.next; // forw pointer will be after curr\n            curr.next = forw.next;\n            forw.next = prev.next;\n            prev.next = forw;\n        }\n        return dummy.next;\n    }\n}"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        ListNode *dummy = new ListNode(0); // created dummy node\n        dummy->next = head;\n        ListNode *prev = dummy; // intialising prev pointer on dummy node\n        \n        for(int i = 0; i < left - 1; i++)\n            prev = prev->next; // adjusting the prev pointer on it's actual index\n        \n        ListNode *curr = prev->next; // curr pointer will be just after prev\n        // reversing\n        for(int i = 0; i < right - left; i++){\n            ListNode *forw = curr->next; // forw pointer will be after curr\n            curr->next = forw->next;\n            forw->next = prev->next;\n            prev->next = forw;\n        }\n        return dummy->next;\n    }\n};"
            },
            {
                "language": "java",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "    public static ListNode reverseBetween(ListNode head, int left, int right) {\n        Queue<ListNode> queue = new LinkedList<>();\n        Stack<ListNode> stack = new Stack<>();\n        int leftCounter=1;\n        ListNode root = head;\n        while (root!=null){\n            if(leftCounter<left){\n                queue.add(root);\n            } else if (left<=leftCounter && leftCounter<=right) {\n                stack.add(root);\n            }else {\n                queue.add(root);\n            }\n            leftCounter++;\n            root=root.next;\n        }\n        ListNode result;\n        ListNode temp;\n        if(left==1){\n            result=stack.pop();\n            temp=result;\n            while(!stack.isEmpty()){\n               temp.next=stack.pop();\n               temp=temp.next;\n            }\n            while (!queue.isEmpty()){\n                temp.next=queue.poll();\n                temp=temp.next;\n            }\n        }else {\n            int counter=2;\n            result=queue.poll();\n            temp=result;\n            while (counter<left){\n                temp.next=queue.poll();\n                temp=temp.next;\n                counter++;\n            }\n            while (!stack.isEmpty()){\n                temp.next=stack.pop();\n                temp=temp.next;\n            }\n            while (!queue.isEmpty()){\n                temp.next=queue.poll();\n                temp=temp.next;\n            }\n\n        }\n        temp.next=null;\n        return result;\n    }"
            },
            {
                "language": "python",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        if(left==right)\n            return head;\n        ListNode head1=head;\n        ListNode finalhead=head;\n        Stack<Integer> st=new Stack<>();\n        int c=1;\n        while(c<left){\n            head=head.next;\n            c++;\n        }\n        int start=c;\n        while(c<=right){\n            st.push(head.val);\n            head=head.next;\n            c++;\n        }\n        int cnt=1;\n        while(cnt<start){\n            head1=head1.next;\n            cnt++;\n        }\n        while(!st.isEmpty()){\n            head1.val=st.pop();\n            head1=head1.next;\n        }\n        return finalhead;\n    }\n}"
            },
            {
                "language": "java",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        int length=right-left+1;\n        if(!head || head->next==NULL || length==1)return head;\n\n        //finding node at left-1\n        ListNode* curr=head;\n        for(int i=1;i<left-1;i++){\n            if(curr)curr=curr->next;\n            else break;\n        }\n        ListNode* left_half=(left==1)?NULL:curr;\n        curr=(left==1)?curr:curr->next;\n\n        //finding node at right+1\n        ListNode* right_half=head;\n        for(int i=1;i<=right;i++){\n            if(right_half)right_half=right_half->next;\n            else break;\n        }\n        ListNode *prev=right_half;\n\n        while(curr && length){\n            ListNode* next=curr->next;\n            curr->next=prev;\n            prev=curr;\n            curr=next;\n            length--;\n        }\n        if(left_half==NULL)return prev;\n        left_half->next=prev;\n        return head;\n\n        \n\n        \n    }\n};"
            },
            {
                "language": "java",
                "code": ""
            },
            {
                "language": "csharp",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        List<Integer> list = new ArrayList<>();\n        if(left == right) return head;\n\n        rec(head,list,left , right , 0);\n        return head;\n    }\n\n    public void rec(ListNode node , List<Integer> list , int left , int right , int curr){\n        if(node == null) return;\n        curr++;\n\n        if(curr >= left && curr <= right){\n            list.add(node.val);\n        }\n        if(curr > right){\n            return;\n        }\n        rec(node.next , list,left , right , curr);\n        if(curr >= left && curr <= right){\n            node.val = list.get(0);\n            list.remove(0);\n        }\n    }\n}"
            },
            {
                "language": "java",
                "code": ""
            },
            {
                "language": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\n        def reverse(head,left,right):\n            if (head and not head.next) or not head:\n                return head,head\n            prev = None\n            curr = tail = head\n            nxt = head.next\n\n            while(left!=right+1):\n                curr.next = prev\n                prev = curr\n                curr = nxt\n                if nxt:\n                    nxt = nxt.next\n\n                left+=1\n\n            return prev,tail\n\n        left_boundary = right_boundary = ListNode(next=head)\n        count_r = count_l = 0\n        while(count_r!=right+1):\n            right_boundary=right_boundary.next\n            if (count_l != left-1):\n                left_boundary=left_boundary.next\n                count_l+=1\n            count_r+=1\n             \n        reverse_head,reverse_tail = reverse(left_boundary.next,left,right)\n        if count_l == 0:\n            head = reverse_head\n        else:\n            left_boundary.next = reverse_head\n        \n        reverse_tail.next = right_boundary\n\n        return head"
            },
            {
                "language": "java",
                "code": ""
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        if (left == right) return head;\n        List<Integer> list = new LinkedList<>();\n        goRecursively(head, list, left, right, 0);\n        return head;\n    }\n\n    private void goRecursively(ListNode node, List<Integer> list, int left, int right, int cur) {\n        if (node == null) return;\n        cur++;\n        if (cur >= left && cur <= right) {\n            list.add(node.val);\n        }\n        if (cur > right) {\n            return;\n        }\n\n        goRecursively(node.next, list, left, right, cur);\n        if (cur >= left && cur <= right) {\n            node.val = list.get(0);\n            list.remove(0);\n        }\n    }\n}"
            },
            {
                "language": "java",
                "code": ""
            },
            {
                "language": "python",
                "code": "def reverseBetween(self, head, left, right):\n    def reverse(head, steps):\n        count = 0\n        curr = head\n        prev = None\n        while count < steps:\n            curr_next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = curr_next\n            count += 1\n    \n    prev_left, left_node, right_node = None, None, None\n    curr = head\n    for index in range(1, right + 1):\n        if index == left - 1:\n            prev_left = curr\n        if index == left:\n            left_node = curr\n        if index == right:\n            right_node = curr\n        curr = curr.next\n            \n    next_right = right_node.next\n    reverse(left_node, right - left + 1)\n    left_node.next = next_right\n\n    if prev_left:\n        prev_left.next = right_node\n        return head\n    else:\n        return right_node\n        "
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* reverseList( ListNode* head , ListNode * rightnext) {\n        if(head == NULL || head -> next == NULL){\n            return head;\n        }\n        ListNode * prev = NULL;\n        ListNode * curr = head;\n        ListNode * forward = NULL;\n        \n        while(curr != rightnext){\n            forward=curr -> next;\n            curr -> next =prev;\n            prev = curr;\n            curr = forward;\n        }\n        return prev;\n    }\n    \n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        \n        if(head==NULL || head->next ==NULL){\n            return head;\n        }\n        int count =1;\n        ListNode* prev = NULL;\n        ListNode* leftNode = head;\n        while(count!=left && leftNode->next !=NULL){\n            prev = leftNode;\n            leftNode = leftNode->next;\n            count++;\n        }\n        ListNode* rightNode = leftNode;\n        while(count!=right && rightNode->next!=NULL){\n            rightNode =rightNode->next;\n            count++;\n        }\n       \n        ListNode* rightnext = rightNode->next;\n        ListNode* newhead = reverseList(leftNode , rightnext);\n        if(prev!=NULL){\n        prev->next =newhead;\n        leftNode->next = rightnext;\n            return head;\n        }\n        leftNode->next = rightnext;\n        return newhead;\n    }\n};"
            }
        ]
    },
    "92": {
        "question_id": 93,
        "title": "Restore IP Addresses",
        "difficulty": 2,
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.For example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order. ",
        "examples": [
            {
                "input": "s = \"25525511135\"",
                "output": "[\"255.255.11.135\",\"255.255.111.35\"]",
                "explanation": null
            },
            {
                "input": "s = \"0000\"",
                "output": "[\"0.0.0.0\"]",
                "explanation": null
            },
            {
                "input": "s = \"101023\"",
                "output": "[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= s.length <= 20",
            "s consists of digits only."
        ],
        "solutions": [
            {
                "language": "go",
                "code": "class Solution {\npublic:  \n \nbool subpart(string s, int i, int j){\n         int len = j-i+1;\n         if(len >3) return false;\n         if(s[i] == '0'){\n             if(len == 1) return true;\n             return false;\n                     }\n         int num = stoi(s.substr(i,j-i+1));\n         if(num>=0 && num<=255) return true;\n         return false;\n                          \n   }\n\n  bool issafe(string s, int len, int i, int j, int k){\n     if(subpart(s,0,i) && subpart(s,i+1,j) && subpart(s,j+1,k) && subpart(s,k+1,len-1))//checking each four part whether all these part is valid or not\n        return true;\n     else{\n         return false;\n         } \n  }\n\n\nvoid addstring(string s, int n, int i, int j, int k,vector<string> &res){//adding substring part along with . in our result string\n    string temp;\n    temp.append(s.substr(0,i+1));\n    temp.push_back('.');\n    temp.append(s.substr(i+1,j-i));\n    temp.push_back('.');\n    temp.append(s.substr(j+1,k-j));\n    temp.push_back('.');\n    temp.append(s.substr(k+1,n-k-1));\n    res.push_back(temp);\n}\n    \n    vector<string> restoreIpAddresses(string s) {\n        int n=s.size();\n        vector<string>res;\n        int i,j,k;\n        for(i=0;i<n-3;++i){//checking position of i,j,k in the string which can produce the required result\n            for(j=i+1;j<n-2;++j){\n                for(k=j+1;k<n-1;++k){\n                    if(issafe(s,n,i,j,k))\n                        addstring(s,n,i,j,k,res);\n                }\n            }\n        }\n          \n        return res;\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    bool isValid(string sub) {\n        if(sub.size()==1)\n            return true;\n        if(sub.size()>1 && sub[0]!='0' && stoi(sub) <=255)\n            return true;\n        \n        return false;\n       \n    }\n    void dfs(vector<string>& ans, string s, string path, int i, int dots) {\n// count number of dots, valid ip cannot have more than 3 dots.\n// when end of string is reached and number of dot is 3 (after popping last one) then it is a valid ip\n        if(dots==4) {\n            if(i == s.length()) {\n                path.pop_back();\n                ans.push_back(path);\n            }\n            return; \n        }\n\n        // iterate over next 1 to 3 substrings\n        for(int k=1; k<=3; k++) {\n            // if substr is >=0 and <=255 \n            if(i+k<=s.length() && isValid(s.substr(i,k)))  {;\n                dfs(ans, s, path+s.substr(i,k)+'.', i+k, dots+1);\n            }\n        }\n        \n    }\n    vector<string> restoreIpAddresses(string s) {\n        vector<string> ans; \n        string path; \n        dfs(ans, s, path, 0, 0);\n        return ans; \n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool check(string s){\n        int n=s.size();\n        //if the size of string is 1 that is always possible so return true\n        if(n==1){\n            return true;\n        }\n        //if we have length >3 or string starts with 0 return false\n        if(n>3||s[0]=='0'){\n            return false;\n        }\n        //we are converting string to integer to check if it is less than equalto 255\n        int val=stoi(s);\n        if(val>255){\n            return false;\n        }\n        //return true at last\n        return true;\n    }\n    vector<string> restoreIpAddresses(string s) {\n        int n=s.size();\n        //we will store our ans in ans vector of strings\n        vector<string>ans;\n        //the max length of the ip address could be 12 as 255.255.255.255 so \n        //all the string s with size greater than 12 can have ans\n        if(n>12){\n            return ans;\n        }\n        //now we have our string of length 12 or less than 12 so now \n            //1. we have to spit the s in parts such that it satisfy the ip address conditions\n            //2. if all 4 strings satisfy the condition we will push into ans vector\n        \n        for(int i=1;i<=3;i++){//for the length before first '.'\n            for(int j=1;j<=3;j++){//for the length between first and second '.'\n                for(int k=1;k<=3;k++){//for the length between second and third '.'\n                    //checking condition if the last segment is of length 3 or less\n                    if(i+j+k<n&&i+j+k+3>=n){\n                        //dividing the s int substrings \n                        string a=s.substr(0,i);\n                        string b=s.substr(i,j);\n                        string c=s.substr(j+i,k);\n                        string d=s.substr(i+j+k);\n                        //if all the substring satisfy the check function condition \n                        //then we will push into ans vector \n                        if(check(a)&&check(b)&&check(c)&&check(d)){\n                            ans.push_back(a+\".\"+b+\".\"+c+\".\"+d);\n                        }\n                    }\n                }\n            }\n        }\n        //return the ans vector\n        return ans;\n    }\n};"
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {string} s\n * @return {string[]}\n */\nvar restoreIpAddresses = function(s) {\n    if(s.length>12 || s.length <4) return []\n\n    let res = []\n\n    let iterate = (arr,temp) =>{\n\n        if(temp.length > 4) return;\n\n        if(arr.length ==0 && temp.length == 4){\n            res.push(temp.join('.'))\n            return;\n        }\n\n        for(let i =1; i<4; i++){\n            if(arr.length < i) break;\n            let value = arr.slice(0,i);\n            if((value.length>1 && value[0]== \"0\") || +value >255) break;\n            iterate(arr.slice(i),[...temp,value])\n        }\n    }\n\n    iterate(s,[])\n    return res;\n}"
            },
            {
                "language": "javascript",
                "code": "var restoreIpAddresses = function(s) {\n    if(s.length>12 || s.length <4) return []\n\n    let res = []\n    let map ={}\n    let iterate = (arr,temp) =>{\n\n        if(temp.length > 4) return;\n\n        if(arr.length ==0 && temp.length == 4){\n            let joined = temp.join('.')\n            if(map[joined] || temp[3] == \"\") return;\n            map[joined] =1\n            res.push(joined)\n            return;\n        }\n\n        for(let i =1; i<4; i++){\n            let value = arr.slice(0,i);\n            if((value.length>1 && value[0]== \"0\") || +value >255) break;\n            iterate(arr.slice(i),[...temp,value])\n        }\n    }\n\n    iterate(s,[])\n    return res;\n}"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    vector<string> ans;\n    void helper(string s, int j, int count){\n        //Hit the Bottom | Base Case\n        if(count == 3)\n        {\n            if((s[0]!= '0' or 0==j) and j+1<=3 and stoi(s.substr(0, j+1))<=255)\n                ans.push_back(s);\n            return;\n        }\n        if(j==0)\n            return;\n\n        for(int i=j; (i>0 and (i>= j-3)); i--){\n            if((s[i]!= '0' or i==j) and stoi(s.substr(i, j-i+1))<=255){\n                //Insert the '.' and call recursively\n                s.insert(i, 1,'.');\n                helper(s, i-1, count+1);\n                //Backtrack\n                s.erase(i, 1);\n            }\n        }\n    }\n    vector<string> restoreIpAddresses(string s) {\n        helper(s, s.length()-1, 0);\n        return ans;\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "    def restoreIpAddresses(self, s: str) -> List[str]:\n        path = []\n        result = []\n        self.dfs(s, path, result)\n        return result\n    \n    def dfs(self,s,path,result):\n        if not s and len(path) == 4:\n            s = '.'.join(path[::-1])\n            result.append(s)\n            return\n        elif len(path) == 4: return \n        else:\n            for i in range(1, min(3, len(s))+1):\n                if int(s[:i]) >= 0 and int(s[:i]) <= 255:\n                    if i > 1 and s[0]=='0': continue\n                    else: self.dfs(s[i:], [s[:i]]+path, result)\n            return"
            },
            {
                "language": "erlang",
                "code": "1. Number of dots should be exactly 3.\n2. When we take 2 or 3 letters make sure first letter shouldn't be zero.\n3. We can only take any number from 0-255.  "
            },
            {
                "language": "rust",
                "code": "Possibility 1: Take 1 number.\nPossibility 2: Take 2 number but also check that first letter shouldn't be '0'.\nPossibility 3: Take 3 number but also check that first letter shouldn't be '0'and number shouldn't exceed 255."
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    unordered_set<string> set;\n    void sol(int i, string s, string temp,int dot)\n    {\n        if(i>=s.size())\n        {\n            if(dot==4)\n            {\n                temp.pop_back();\n                set.insert(temp);\n            }\n            return;\n        }\n        if(dot>=4) return;\n        sol(i+1,s,temp+s.substr(i,1)+'.',dot+1);\n        if(s[i] != '0') sol(i+2,s,temp+s.substr(i,2)+'.',dot+1);\n        if(s[i] !='0' && stoi(s.substr(i,3))<=255)\n            sol(i+3,s,temp+s.substr(i,3)+'.',dot+1);\n\n    }\n    vector<string> restoreIpAddresses(string s) {\n        sol(0,s,\"\",0);\n        vector<string> ans(set.begin(),set.end());\n        return ans;\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\nprivate:\nbool isSafe(string s){\n    int n = s.size();\n    if(n>=4||n<=0)return false;\n    if(n>1&&s[0]=='0')return false;\n    if(n&&stoi(s)>255)return false;\n    return true;\n}\nvoid solve(string s,vector<string>& ans,string st,int idx,int dot){\n    if(dot==3){\n        if(isSafe(s.substr(idx))){\n            ans.push_back(st+s.substr(idx));\n        }\n        return;\n    }\n    for(int i=idx;i<s.size();i++){\n        if(isSafe(s.substr(idx,i-idx+1))){\n            st.push_back(s[i]);\n            st.push_back('.');\n            solve(s,ans,st,i+1,dot+1);\n            st.pop_back();\n        }\n    }\n}\npublic:\n    vector<string> restoreIpAddresses(string s) {\n        int n = s.size();\n        vector<string> ans;\n        string st = \"\";\n        if(n<4)return ans;\n        solve(s,ans,st,0,0);\n        return ans;\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "    bool check(string s){\n        if(s.length() == 1)\n            return true;\n        if(s[0] == '0')\n            return false;\n        if(s.length() == 2)\n            return true;\n        if(s[0] > '2')"
            },
            {
                "language": "typescript",
                "code": "   private List<String> ipes;\n   private int l;\n   public List<String> restoreIpAddresses(String s) {\n       ipes = new ArrayList<>();\n       l = s.length();\n       f(s, 0, \"\", 0);\n       return ipes;\n   }\n   "
            },
            {
                "language": "typescript",
                "code": "function restoreIpAddresses(s: string): string[] {\n    let result:string[] = [];\n    const DFS  = (ip:string,index:number,octet:number) => {\n        if(index >= s.length){\n            return;\n        }\n        // last octet check\n        if(octet == 3){\n            //check if last digit is valid\n            if(s.substring(index, index+1) != \"0\" || index+1 == s.length){\n                if(Number(s.substring(index)) < 256){\n                    ip += '.'\n                    ip += s.substring(index);\n                    result.push(ip)\n                }\n            }\n            return\n        }\n        for(let i = 1; i <= 3 && index+i < s.length; i++){\n            if(Number(s.substring(index, index+i)) < 256){\n                DFS(ip + '.'+ s.substring(index, index+i),index+i, octet + 1);\n            }\n            //check for leading zero\n            if(s.substring(index, index+1) == \"0\"){\n                break;\n            }\n        }\n    }\n    for(let i = 1; i <= 3 && i < s.length ; i++){\n        if(Number(s.substring(0, i)) < 256){\n            DFS(s.substring(0, i), i, 1);\n        }\n        //check for leading zero\n        if(s[0] == \"0\"){\n                break;\n        }\n    }\n    return result\n};"
            }
        ]
    },
    "93": {
        "question_id": 94,
        "title": "Binary Tree Inorder Traversal",
        "difficulty": 1,
        "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values. ",
        "examples": [
            {
                "input": "root = [1,null,2,3]",
                "output": "[1,3,2]",
                "explanation": null
            },
            {
                "input": "root = []",
                "output": "[]",
                "explanation": null
            },
            {
                "input": "root = [1]",
                "output": "[1]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [0, 100].",
            "-100 <= Node.val <= 100"
        ],
        "solutions": [
            {
                "language": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        return self.inorderTraversal(root.left)+ [root.val]+self.inorderTraversal(root.right) if root else []"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    void dfs(TreeNode* root, vector<int>& vec) {\n        if(!root) return;\n        dfs(root -> left, vec);\n        vec.push_back(root -> val);\n        dfs(root -> right, vec);\n    }\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> vec;\n        dfs(root, vec);\n        return vec;\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        lis = []\n        self.dfs(root, lis)\n        return lis\n\n    def dfs(self, root, lis):\n        if(root == None):\n            return\n        self.dfs(root.left, lis)\n        lis.append(root.val)\n        self.dfs(root.right, lis)"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        TreeNode *curr = root;\n        vector<int> vec;\n        while(curr) {\n            if(!curr -> left) {\n                vec.push_back(curr -> val);\n                curr = curr -> right;\n            }\n            else {\n                TreeNode* prev = curr -> left;\n                while(prev -> right && prev -> right != curr) {\n                    prev = prev -> right;\n                }\n                if(!prev -> right) {\n                    prev -> right = curr;\n                    curr = curr -> left;\n                }\n                else{\n                    vec.push_back(curr -> val);\n                    prev -> right = NULL;\n                    curr = curr -> right;\n                }\n            }\n        }\n        return vec;\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        lis = []\n        curr = root\n        while(curr):\n            if curr.left == None:\n                lis.append(curr.val)\n                curr = curr.right\n            else:\n                prev = curr.left\n                while prev.right and prev.right != curr:\n                    prev = prev.right\n                if prev.right == None:\n                    prev.right = curr\n                    curr = curr.left\n                else:\n                    lis.append(curr.val)\n                    curr = curr.right\n                    prev.right = None\n        return lis"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void trav(TreeNode *&root,vector<int> &ans){\n        if(root == NULL)return ;\n        trav(root->left,ans);\n        ans.push_back(root->val);\n        trav(root->right,ans);\n        \n}\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> ans;\n        trav(root,ans);\n        return ans;\n\n\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    List<Integer> arr = new ArrayList<>();\n    public List<Integer> inorderTraversal(TreeNode root) {\n        if (root!=null) {\n            inorderTraversal(root.left);\n            arr.add(root.val);\n            inorderTraversal(root.right);\n        }\n        return arr;\n    }\n}"
            },
            {
                "language": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\n        var result = [Int]()\n        var stack = [TreeNode]()\n        var current = root\n        \n        while !stack.isEmpty || current != nil {\n            while current != nil {\n                stack.append(current!)\n                current = current?.left\n            }\n            \n            current = stack.popLast()\n            result.append(current!.val)\n            current = current?.right\n        }\n        \n        return result\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\n    vector<int> v;\n        void solve(TreeNode* t){\n            if(t == NULL)\n             return ;\n           \n            solve(t->left);\n             v.push_back(t->val);\n            solve(t->right);\n        }\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        solve(root);\n        return v;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        if(root == NULL) return {};\n        vector<int> ans;\n        ans = inorderTraversal(root->left);\n        ans.push_back(root->val);\n        vector<int> temp = inorderTraversal(root->right);\n\n        for(auto i: temp) ans.push_back(i);\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\n\ntypedef struct list {\n    int val;\n    struct list *next;\n} List;\n\nList *append(List *head, int val) {\n    if (head == NULL) {\n        List *new_node = (List *) malloc(sizeof(List));\n        new_node->val = val;\n        new_node->next = NULL;\n        return new_node;\n    }\n    List *cur = head;\n    while (cur->next) {\n        cur = cur->next;\n    }\n    List *new_node = (List *) malloc(sizeof(List));\n    cur->next = new_node;\n    new_node->val = val;\n    new_node->next = NULL;\n    return head;\n}\n\nvoid free_list(List *head){\n    List *tmp = head;\n    while (tmp) {\n        head = tmp;\n        tmp = tmp->next;\n        free(head);\n    }\n}\n\nList *helper(struct TreeNode* root, List *head) {\n    if (root == NULL) {\n        return head;\n    }\n    if (root->left) {\n        head = helper(root->left, head);\n    }\n    head = append(head, root->val);\n    if (root->right) {\n        head = helper(root->right, head);\n    }\n    return head;\n}\n\nint *List_to_array(List *head, int *returnSize) {\n    int n = 0;\n    List *curr = head;\n    while (curr) {\n        ++n;\n        curr = curr->next;\n    }\n    *returnSize = n;\n    int *array = (int *) malloc(sizeof(int) * n);\n    for(int i = 0; i < n; ++i) {\n        array[i] = head->val;\n        head = head->next;\n    }\n    free_list(head);\n    return array;\n}\n\nvoid print_list(List *head) {\n    printf(\"List: \");\n    while (head) {\n        printf(\"%d \", head->val);\n        head = head->next;\n    }\n    printf(\"\\n\");\n}\n\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\n    List *head = helper(root, NULL);\n    int *array = List_to_array(head, returnSize);\n    return array;\n}"
            },
            {
                "language": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        \n        // Check if the root is null\n        if(root == null){\n            // If the root is null, return an empty ArrayList\n            return new ArrayList<Integer>();\n        }\n\n        // Create a new ArrayList to store the values obtained in an in-order traversal\n        ArrayList<Integer> ans = new ArrayList<>();\n\n        // Recursively perform an in-order traversal on the left subtree and add the obtained values to the ArrayList\n        ans.addAll(inorderTraversal(root.left));\n\n        // Add the value of the root to the ArrayList\n        ans.add(root.val);\n\n        // Recursively perform an in-order traversal on the right subtree and add the obtained values to the ArrayList\n        ans.addAll(inorderTraversal(root.right));\n\n        // Return the ArrayList containing all the values obtained in the in-order traversal\n    return ans;\n    }\n}"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []"
            }
        ]
    },
    "94": {
        "question_id": 95,
        "title": "Unique Binary Search Trees II",
        "difficulty": 2,
        "description": "Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order. ",
        "examples": [
            {
                "input": "n = 3",
                "output": "[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]",
                "explanation": null
            },
            {
                "input": "n = 1",
                "output": "[[1]]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= n <= 8"
        ],
        "solutions": [
            {
                "language": "javascript",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number} n\n * @return {TreeNode[]}\n */\nvar generateTrees = function(n) {\n    const generateBacktracking = (fst, lst) => {\n        if (fst > lst)\n            return [undefined];\n        let tree = [];\n        for (let val = fst; val <= lst; val++){\n            for (let left of generateBacktracking(fst, val-1)){\n                for (let right of generateBacktracking(val+1, lst)){\n                    let node = new TreeNode(val, left, right);\n                    tree.push(node);\n                }\n            }\n        }\n        return tree;\n    };\n    return generateBacktracking(1, n);\n};"
            },
            {
                "language": "ruby",
                "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n   def generateTrees(self, n: 'int') -> 'List[TreeNode]':\n    memo = {}\n    \n    def generate_trees_helper(start: int, end: int) -> List[TreeNode]:\n        if start > end:\n            return [None]\n        \n        if (start, end) in memo:\n            return memo[(start, end)]\n        \n        result = []\n        \n        for i in range(start, end+1):\n            left_subtrees = generate_trees_helper(start, i-1)\n            right_subtrees = generate_trees_helper(i+1, end)\n            \n            for left in left_subtrees:\n                for right in right_subtrees:\n                    root = TreeNode(i)\n                    root.left = left\n                    root.right = right\n                    result.append(root)\n        \n        memo[(start, end)] = result\n        \n        return result\n    \n    return generate_trees_helper(1, n)"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\n        @lru_cache(None)\n        def dfs(left, right):\n            if left > right: return [None]\n            if left == right: return [TreeNode(left)]\n            ans = []\n            for root in range(left, right+1):\n                leftNodes = dfs(left, root - 1)\n                rightNodes = dfs(root+1, right)\n                for leftNode in leftNodes:\n                    for rightNode in rightNodes:\n                        rootNode = TreeNode(root, leftNode, rightNode)\n                        ans.append(rootNode)\n            return ans\n        \n        return dfs(1, n)"
            },
            {
                "language": "java",
                "code": "from functools import cache\n\nclass Solution:\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\n        @cache\n        def dfs(left, right):\n            if left<right:\n                return [TreeNode(root, leftNode, rightNode) "
            },
            {
                "language": "rust",
                "code": "class Solution:"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node."
            },
            {
                "language": "cpp",
                "code": "vector<TreeNode*> buildTree(int start, int end) {\n vector<TreeNode*> ans;\n        \n    // If start > end, then subtree will be empty so add NULL in the ans and return it.\n    if(start > end) {\n  ans.push_back(NULL);\n        return ans;\n    }\n\n    // Iterate through all values from start to end to construct left and right subtree recursively\n for(int i = start; i <= end; ++i) {\n  vector<TreeNode*> leftSubTree = buildTree(start, i - 1);    // Construct left subtree\n        vector<TreeNode*> rightSubTree = buildTree(i + 1, end);     // Construct right subtree\n            \n  // loop through all left and right subtrees and connect them to ith root  \n  for(int j = 0; j < leftSubTree.size(); j++) {\n   for(int k = 0; k < rightSubTree.size(); k++) {\n    TreeNode* root = new TreeNode(i);   // Create root with value i\n    root->left = leftSubTree[j];   // Connect left subtree rooted at leftSubTree[j]\n                root->right = rightSubTree[k];   // Connect right subtree rooted at rightSubTree[k]\n    ans.push_back(root);    // Add this tree(rooted at i) to ans data-structure\n   }\n  }\n    }\n        \n return ans;\n}\n    \nvector<TreeNode*> generateTrees(int n) {\n return buildTree(1, n);\n}"
            },
            {
                "language": "",
                "code": "What a masterpiece!!!"
            },
            {
                "language": "csharp",
                "code": "public List<TreeNode> generateTrees(int n) {\n return generateSubtrees(1, n);\n}\n\nprivate List<TreeNode> generateSubtrees(int s, int e) {\n List<TreeNode> res = new LinkedList<TreeNode>();\n if (s > e) {\n  res.add(null); // empty tree\n  return res;\n }\n\n for (int i = s; i <= e; ++i) {\n  List<TreeNode> leftSubtrees = generateSubtrees(s, i - 1);\n  List<TreeNode> rightSubtrees = generateSubtrees(i + 1, e);\n\n  for (TreeNode left : leftSubtrees) {\n   for (TreeNode right : rightSubtrees) {\n    TreeNode root = new TreeNode(i);\n    root.left = left;\n    root.right = right;\n    res.add(root);\n   }\n  }\n }\n return res;\n}"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };"
            },
            {
                "language": "csharp",
                "code": "Map<List<Integer>,List<TreeNode>> hm = new HashMap<>();\n\n\npublic List<TreeNode> generateTrees(int n) {\n    List<TreeNode> res = new LinkedList<TreeNode>();\n    if(n == 0) return res;"
            },
            {
                "language": "ruby",
                "code": "def generateTrees(self, n: int) -> List[TreeNode]:\n    if n==0:\n        return []\n    return self.generate(1,n)\ndef generate(self,start,end):\n    if start>end:\n        return [None]\n    res = []"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n, int s = 1) {\n        vector<TreeNode*> ans;\n        if(n < s)\n            return {nullptr};\n   \n  // Consider every number in range [s,n] as root \n        for(int i=s; i<=n; i++) {\n  \n   // generate all possible trees in range [s,i)\n            for(auto left: generateTrees(i-1, s)) {\n   \n    // generate all possible trees in range (i,e]\n                for(auto right: generateTrees(n, i+1))\n    \n     // make new trees with i as the root\n                    ans.push_back(new TreeNode(i, left, right));\n            }\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "java",
                "code": "public static List<TreeNode> generateTrees(int n) {\n    List<TreeNode>[] result = new List[n + 1];\n    result[0] = new ArrayList<TreeNode>();\n    if (n == 0) {\n        return result[0];\n    }\n\n    result[0].add(null);\n    for (int len = 1; len <= n; len++) {\n        result[len] = new ArrayList<TreeNode>();\n        for (int j = 0; j < len; j++) {\n            for (TreeNode nodeL : result[j]) {\n                for (TreeNode nodeR : result[len - j - 1]) {\n                    TreeNode node = new TreeNode(j + 1);\n                    node.left = nodeL;\n                    node.right = clone(nodeR, j + 1);\n                    result[len].add(node);\n                }\n            }\n        }\n    }\n    return result[n];\n}\n\nprivate static TreeNode clone(TreeNode n, int offset) {\n    if (n == null) {\n        return null;\n    }\n    TreeNode node = new TreeNode(n.val + offset);\n    node.left = clone(n.left, offset);\n    node.right = clone(n.right, offset);\n    return node;\n}"
            },
            {
                "language": "csharp",
                "code": "public List<TreeNode> generateTrees(int n) {\n \n List<TreeNode>[] res = new List[n+1];\n res[0] = new ArrayList();\n if(n == 0) return res[0];"
            },
            {
                "language": "csharp",
                "code": " public class Solution {\n TreeNode deepCopy(TreeNode root){\n  if(root == null) return null;\n  TreeNode tmp = new TreeNode(1);\n  tmp.left = deepCopy(root.left);\n  tmp.right = deepCopy(root.right);"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n, int s = 1) {\n        vector<TreeNode*> ans;\n        if(n < s) return {nullptr};                              \n         for(int i=s; i<=n; i++) {                                  \n            for(auto left: generateTrees(i-1, s)) {                \n                for(auto right: generateTrees(n, i+1))               \n                    ans.push_back(new TreeNode(i, left, right));   \n            }\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n, int s = 1) {\n        vector<TreeNode*> ans;\n        if(n < s) return {nullptr};                              \n         for(int i=s; i<=n; i++) {                                  // Consider every number in range [s,n] as root  \n            for(auto left: generateTrees(i-1, s)) {                  // generate all possible trees in range [s,i)\n                for(auto right: generateTrees(n, i+1))               // generate all possible trees in range (i,e]\n                    ans.push_back(new TreeNode(i, left, right));     // make new trees with i as the root\n            }\n        }\n        return ans;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<TreeNode*> rec(int start, int end) {\n        vector<TreeNode*> res;\n        if (start > end) return {NULL};\n        \n        if (start == end) return {new TreeNode(start)};\n        \n        for (int i = start; i <= end; i++) {\n            vector<TreeNode*> left = rec(start, i-1), right = rec(i+1, end);\n            \n            for (auto l : left)\n                for (auto r : right)\n                    res.push_back(new TreeNode(i, l, r));\n        }\n        return res;\n    }\n    \n    vector<TreeNode*> generateTrees(int n) {\n        vector<TreeNode*> res = rec(1, n);\n        return res;\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def generateTrees(self, n: int) -> List[TreeNode]:\n        def rec(start, end):\n  \n            if start > end:\n                return [None]\n    \n            if start == end:\n                return [TreeNode(start)]\n            ret_list = []\n   \n            for i in range(start, end+1):\n                left = rec(start, i-1)\n                right = rec(i+1, end)\n                for pair in product(left, right):\n                    ret_list.append(TreeNode(i, pair[0], pair[1]))\n        \n            return ret_list\n        \n        res = rec(1,n)\n        return res"
            }
        ]
    },
    "95": {
        "question_id": 96,
        "title": "Unique Binary Search Trees",
        "difficulty": 2,
        "description": "Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n. ",
        "examples": [
            {
                "input": "n = 3",
                "output": "5",
                "explanation": null
            },
            {
                "input": "n = 1",
                "output": "1",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= n <= 19"
        ],
        "solutions": [
            {
                "language": "",
                "code": "G(n) = F(1, n) + F(2, n) + ... + F(n, n). "
            },
            {
                "language": "",
                "code": "G(0)=1, G(1)=1. "
            },
            {
                "language": "lisp",
                "code": "F(i, n) = G(i-1) * G(n-i) 1 <= i <= n "
            },
            {
                "language": "",
                "code": "G(n) = G(0) * G(n-1) + G(1) * G(n-2) + \u2026 + G(n-1) * G(0) "
            },
            {
                "language": "cpp",
                "code": "public int numTrees(int n) {\n  int [] G = new int[n+1];\n  G[0] = G[1] = 1;\n    \n  for(int i=2; i<=n; ++i) {\n    for(int j=1; j<=i; ++j) {\n      G[i] += G[j-1] * G[i-j];\n    }\n  }\n  return G[n];\n}"
            },
            {
                "language": "javascript",
                "code": "/*    \nHope it will help you to understand :\n    \n    n = 0;     null   \n    \n    count[0] = 1\n    \n    \n    n = 1;      1       "
            },
            {
                "language": "cpp",
                "code": "public class Solution {\n    public int numTrees(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= i; j++) {\n                dp[i] += dp[j - 1]*dp[i - j];\n            }"
            },
            {
                "language": "cpp",
                "code": " public int numTrees(int n) {\n        return trees(1, n);\n    }\n\n    int trees(int lo, int hi) {\n        if (lo >= hi) return 1;"
            },
            {
                "language": "cpp",
                "code": "int numTrees(int n) {\n    vector<int> dp(n + 1);\n    dp[0] = 1;\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j < i / 2; j++) {\n            dp[i] += 2 * dp[j] * dp[i - j - 1];\n        }"
            },
            {
                "language": "cpp",
                "code": "int numTrees(int n) {\n         int nums[2000]={1,1,};\n         int i,x;\n         for(x=2;x<=n;x++){\n           for(i=1;i<=x/2;i++)\n             nums[x]=nums[x]+nums[i-1]*nums[x-i];\n           if(x%2==0)nums[x]=2*nums[x];\n           else nums[x]=2*nums[x]+nums[x/2]*nums[x/2];  }"
            },
            {
                "language": "",
                "code": " \n              1            1                   2                    3               3\n            \\            \\                 / \\                  /               /\n             3             2              1   3                2               1\n               /               \\                                 /                 \\\n              2                 3                              1                    2\n                     i = 1                   i = 2                       i = 3           \n(i = root node)"
            },
            {
                "language": "ruby",
                "code": "           3                          2                         1               \n          / \\                        / \\                      /   \\      \nnumTrees(2) numTrees(0)    numTrees(1) numTrees(1)   numTrees(0) numTrees(2)              \n         i = 3                      i = 2                     i = 1           \n   \n                      i\n =>              /   \\ \n         numTrees(i-1) numTrees(n-i)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int numTrees(int n) {\n        if(n <= 1) return 1;\n        int ans = 0;\n        for(int i = 1; i <= n; i++) \n            ans += numTrees(i-1) * numTrees(n-i);\n        return ans;\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def numTrees(self, n: int) -> int:\n        if n <= 1: return 1\n        return sum(self.numTrees(i-1) * self.numTrees(n-i) for i in range(1, n+1))"
            },
            {
                "language": "erlang",
                "code": "f(i) = numTrees(i)\n                                                                 f(5)\n        __________________________________|____________________________________________         \n                     \u2199                            \u2193                \u2193                \u2193                 \u2198\n          (f(0)*           f(4))                 f(1)*f(3)        f(2)*f(2)        f(3)*f(1)          f(4)*f(0)\n         _____________|_____________             \u2b06\ufe0f          \u2b06\ufe0f  \u2b06\ufe0f         \u2b06\ufe0f                 \u2b06\ufe0f\n              \u2199        \u2193        \u2193         \u2198      \n         f(0)f(3)     f(1)f(2)   f(2)f(1)   f(3)f(0)      \n     ______|_____       \u2b06\ufe0f  \u2b06\ufe0f        \u2b06\ufe0f\n          \u2199      \u2193     \u2198\n      f(0)f(2) f(1)f(1) f(2)f(1)\n          __|__          \u2b06\ufe0f \n      \u2199       \u2198\n     f(0)f(1)  f(1)f(0)"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int dp[20]{};\n    int numTrees(int n) {\n        if(n <= 1) return 1;\n        if(dp[n]) return dp[n];\n        for(int i = 1; i <= n; i++) \n            dp[n] += numTrees(i-1) * numTrees(n-i);\n        return dp[n];\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    @cache\n    def numTrees(self, n: int) -> int:\n        if n <= 1: return 1\n        return sum(self.numTrees(i-1) * self.numTrees(n-i) for i in range(1, n+1))"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n+1);\n        dp[0] = dp[1] = 1;\n        for(int i = 2; i <= n; i++) \n            for(int j = 1; j <= i; j++)\n                dp[i] += dp[j-1] * dp[i-j];\n        return dp[n];\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [0]*(n+1)\n        dp[0], dp[1] = 1, 1\n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        return dp[n]"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    long ncr(int n, int r) {\n        long ans = 1;\n        for(int i = 0; i < r; i++) {\n            ans *= n-i;\n            ans /= i+1;\n        }\n        return ans;   \n    }\n    int numTrees(int n) {\n        return ncr(2*n, n) / (n + 1);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "java",
                "code": "class Solution:\n    def numTrees(self, n: int) -> int:\n        return factorial(2*n) // (factorial(n)*factorial(n+1))"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int numTrees(int n) {\n        long ans = 1;\n        for(int i = 0; i < n; i++) \n            ans *= (4*i+2) / (i+2.);\n        return ans;\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def numTrees(self, n: int) -> int:\n        return int(prod((4*i+2) / (i+2) for i in range(n)))"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int numTrees(int n) {\n        int[] sol = new int[n+1];\n        sol[0] = 1;\n        for(int i = 1; i <= n; i++) {\n            for(int j = 0; j < i; j++) {\n                sol[i] += sol[j] * sol[i-j-1];\n            }\n        }\n        return sol[n];\n    }\n}"
            },
            {
                "language": "",
                "code": ""
            },
            {
                "language": "",
                "code": "Recursive DP"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int dp[20];\n\n    int solve(int n) {\n        if(n <= 1) return 1;\n        if(dp[n]) return dp[n];\n        int ans = 0;\n        for(int i=1; i <= n; i++) {\n            ans += solve(i-1) * solve(n-i);\n        }\n        return dp[n] = ans;\n    }\n\n    int numTrees(int n) {\n        memset(dp, 0, sizeof(dp));\n        int ans = solve(n);\n        return ans;\n    }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def numTrees(self, n):\n        return factorial(2*n)//factorial(n)//factorial(n)//(n+1)"
            },
            {
                "language": "kotlin",
                "code": "    return [1,\n        2,\n        5,\n        14,\n        42,\n        132,\n        429,\n        1430,"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int numTrees(int n, int[] dp){\n        if(n == 0 || n == 1) return 1;\n        if(dp[n]!=0) return dp[n];\n        int count = 0;\n        for(int i=1;i<=n;i++){\n            count += numTrees(i-1, dp) * numTrees(n - i, dp);"
            },
            {
                "language": "php",
                "code": "def numTrees(self, n: int) -> int:\n\n    return factorial(2*n)//(factorial(n)*factorial(n+1))"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int numTrees(int n) {\n        int dp[]=new int[n+1];\n         dp[0]=1;\n         dp[1]=1;\n    for(int i=2;i<dp.length;i++)\n    {\n        int l=0; int r=i-1;\n        while(l<=(i-1))\n        {\n            dp[i]+=dp[l]*dp[r];\n            l++;\n            r--;\n        }\n    }\n        return dp[n];\n        \n    }\n}"
            },
            {
                "language": "",
                "code": "   1                                2\n  \\                            /\n    2                        1"
            },
            {
                "language": "",
                "code": "   1                1                2                  3                 3\n \\                \\              / \\                /                 /\n  2                3            1   3              2                 1\n      \\              /                               /                   \\\n    3            2                               1                     2"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int numTrees(int n) {\n        // Checking for Invalid Input\n        if (n < 0) {\n            throw new IllegalArgumentException(\"Invalid Input\");\n        }\n        // For n == 0, empty tree is a valid BST.\n        // For n == 1, valid BST can have only one node.\n        if (n <= 1) {\n            return 1;\n        }\n\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n\n        for (int i = 2; i <= n; i++) {\n            // We only need to do half as dp[i] is symmetrical.\n            // For example, when i = 5:\n            // dp[i] = dp[0]*dp[4] + dp[1]*dp[3] + dp[2]*dp[2] + dp[3]*dp[1] + dp[4]*dp[0]\n            // Here except dp[2]*dp[2] all others are appearing twice.\n            for (int j = 0; j < i / 2; j++) {\n                dp[i] += dp[j] * dp[i - 1 - j];\n            }\n            dp[i] *= 2;\n\n            // Only add i/2 * i/2 for odd numbers.\n            if ((i & 1) == 1) {\n                dp[i] += dp[i / 2] * dp[i / 2];\n            }\n        }\n\n        return dp[n];\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    \n    int dp[20];\n    "
            },
            {
                "language": "cpp",
                "code": "public int numTrees(int n) {\n        int[] dp = new int[n+1];\n        dp[0]=1;\n        dp[1]=1;\n        for(int i = 2; i<=n; i++) {\n            for(int j = 0; j <i; j++) {\n                dp[i] = dp[i] + dp[j] * dp[i-j-1];\n            }\n        }"
            },
            {
                "language": "cpp",
                "code": " public int numTrees(int n) {\n    int [] dp = new int[n+1];\n    dp[0]= 1;\n    dp[1] = 1;\n    for(int level = 2; level <=n; level++)\n        for(int root = 1; root<=level; root++)\n            dp[level] += dp[level-root]*dp[root-1];\n    return dp[n];\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int numTrees(int n) {\n        if (n == 0) return 0;\n        // For convenience: when you say you have N numbers, I denote them 0-based as 0..N-1\n        // The table:   first dimension is SIZE of a tree: 0..N\n        //              second dimension is index, or 0-based value of the number: 0..N-1. +1 because want to use diagonal to store sumf or [..][I]\n        //              entry itself is: number of unique trees of size I, and rooted with number (or index) J = 0..I-1"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int numTrees(int n) {\n        int result=0;\n        if(n==1 || n==0)\n            return 1;\n        for(int i=0;i<n;i++)\n            result+=numTrees(i)*numTrees(n-i-1);\n        return result;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int>result(n+1,0); //Initializing vector with 0\n        result[1]=result[0]=1;\n        for(int i=2;i<=n;i++)\n        {\n            for(int j=0;j<i;j++)\n            {\n                result[i]+=result[j]*result[i-j-1]; //Calculating C(i) to use for C(i+1) and storing it in result\n            }\n        }\n        return result[n]; //return answer\n    }\n};"
            },
            {
                "language": "javascript",
                "code": "     `C(n)=Ci(2n,n)/n+1`"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    long CalculateCoeff(int n,int k) //Function to calculate Ci(n.k)\n    {\n        long res=1;\n        if(k>n-k)\n            k=n-k;                    //Since Ci(n,k)=Ci(n,n-k), property of binomial coefficients\n        for(int i=0;i<k;i++)\n        {\n            res*=(n-i);\n            res/=(i+1);\n        }\n        return res;\n    }\n    int numTrees(int n) {\n        return CalculateCoeff(2*n,n)/(n+1);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": ""
            },
            {
                "language": "kotlin",
                "code": "}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> dp;\n    int solve(int i,int j)\n    {\n        if(i>j) return 1;\n        if(i==j) return dp[i][j]=1;\n        \n        if(dp[i][j]!=-1) return dp[i][j];\n        int sum=0;\n        for(int k=i;k<=j;k++)\n        {\n            if(dp[i][k-1]==-1)\n            dp[i][k-1]=solve(i,k-1);\n            if(dp[k+1][j]==-1)\n            dp[k+1][j]=solve(k+1,j);\n            sum+=dp[i][k-1]* dp[k+1][j];\n        }\n        return dp[i][j]=sum;\n    }\n    int numTrees(int n) \n    {\n        dp.resize(22,vector<int>(22,-1));\n         solve(1,n);\n        return dp[1][n];\n    }\n};```"
            }
        ]
    },
    "96": {
        "question_id": 97,
        "title": "Interleaving String",
        "difficulty": 2,
        "description": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.An interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:s = s1 + s2 + ... + snt = t1 + t2 + ... + tm|n - m| <= 1The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...Note: a + b is the concatenation of strings a and b. ",
        "examples": [
            {
                "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"",
                "output": "true",
                "explanation": "One way to obtain s3 is:\nSplit s1 into s1 = \"aa\" + \"bc\" + \"c\", and s2 into s2 = \"dbbc\" + \"a\".\nInterleaving the two splits, we get \"aa\" + \"dbbc\" + \"bc\" + \"a\" + \"c\" = \"aadbbcbcac\".\nSince s3 can be obtained by interleaving s1 and s2, we return true."
            },
            {
                "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"",
                "output": "false",
                "explanation": "Notice how it is impossible to interleave s2 with any other string to obtain s3."
            },
            {
                "input": "s1 = \"\", s2 = \"\", s3 = \"\"",
                "output": "true",
                "explanation": null
            }
        ],
        "constraints": [
            "0 <= s1.length, s2.length <= 100",
            "0 <= s3.length <= 200",
            "s1, s2, and s3 consist of lowercase English letters."
        ],
        "solutions": [
            {
                "language": "typescript",
                "code": "class Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length() + s2.length() != s3.length()) return false;\n        this.s1 = s1;\n        this.s2 = s2;\n        this.s3 = s3;\n        dp = new int[s1.length() + 1][s2.length() + 1];\n        return helper(0, 0, 0);\n    }\n\n    String s1;\n    String s2;\n    String s3;\n    int[][] dp;\n\n    private boolean helper(int i, int j, int k) {\n        boolean isMatch = false;\n        // base case\n        if(k == s3.length()) return true;\n        \n        // we don't have to calculate it again, just return result\n        if(dp[i][j] != 0) return dp[i][j] == 1;\n\n        // if s1 matches pick s1\n        if(i < s1.length() && s1.charAt(i) == s3.charAt(k)) {\n            isMatch = isMatch || helper(i + 1, j, k + 1);\n        }\n\n        // if s2 matches pick s2\n        if(j < s2.length() && s2.charAt(j) == s3.charAt(k)) {\n            isMatch = isMatch || helper(i, j + 1, k + 1);\n        }\n\n        // memorize the final answer\n        dp[i][j] = isMatch ? 1 : -1;\n\n        return isMatch;\n    }   \n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int rec(int i1,int i2,int i3,string s1, string s2, string s3,vector<vector<vector<int>>>&dp){\n        if(i1==s1.size()&&i2==s2.size()&&i3==s3.size()){\n            return 1;\n        }\n        if(i3==s3.size())return 0;\n        if(dp[i1][i2][i3]!=-1)return dp[i1][i2][i3];\n        int a=0,b=0;\n        if(i1<s1.size() && s1[i1]==s3[i3]){\n            a=rec(i1+1,i2,i3+1,s1,s2,s3,dp);\n        }\n        if(i2<s2.size() && s2[i2]==s3[i3]){\n            b=rec(i1,i2+1,i3+1,s1,s2,s3,dp);\n        }\n        return dp[i1][i2][i3]=a||b;\n    }\n    bool isInterleave(string s1, string s2, string s3) {\n        int n1=s1.size();\n        int n2=s2.size();\n        int n3=s3.size();\n        vector<vector<vector<int>>>dp(n1+1,vector<vector<int>>(n2+1,vector<int>(n3+1,-1)));\n        return rec(0,0,0,s1,s2,s3,dp);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        int n1=s1.size(), n2=s2.size(), n3=s3.size();\n        if(n1+n2 != n3)\n        return false;\n        vector<vector<bool>> dp(n1+1, vector<bool>(n2+1));\n        for(int i=0;i<=n1;i++)\n        {\n            for(int j=0;j<=n2;j++)\n            {\n                if(i==0 && j==0)\n                dp[i][j]=true;\n                else if(i==0)\n                dp[i][j]=(dp[i][j-1] && s2[j-1]==s3[j-1]);\n                else if(j==0)\n                dp[i][j]=(dp[i-1][j] && s1[i-1]==s3[i-1]);\n                else\n                dp[i][j]=(dp[i][j-1] && s2[j-1]==s3[i+j-1]) || \n                         (dp[i-1][j] && s1[i-1]==s3[i+j-1]);\n            }\n        }\n        return dp[n1][n2];\n    }\n};"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        def dfs(i, j):\n            if i == len(s1) and j == len(s2):\n                return True\n            choose_s1, choose_s2 = False, False\n            if i < len(s1) and s1[i] == s3[i + j]:\n                choose_s1 = dfs(i + 1, j)\n            if j < len(s2) and s2[j] == s3[i + j]:\n                choose_s2 = dfs(i, j + 1)\n\n            return choose_s1 or choose_s2\n\n        return dfs(0, 0)"
            },
            {
                "language": "erlang",
                "code": "                                        \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n                  \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2528 0, 0 \u2520\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n                  \u2502                     \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u251b                      \u2502\n              \u250f\u2501\u2501\u2501\u2537\u2501\u2501\u2513                                             \u250f\u2501\u2501\u2537\u2501\u2501\u2501\u2513     \n      \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2528 1, 0 \u2520\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e                         \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2528 0, 1 \u2520\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e                 \n      \u2502       \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u251b         \u2502                         \u2502         \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u251b         \u2502 \n  \u250f\u2501\u2501\u2501\u2537\u2501\u2501\u2513                  \u250f\u2501\u2501\u2537\u2501\u2501\u2501\u2513                 \u250f\u2501\u2501\u2501\u2537\u2501\u2501\u2513                    \u250f\u2501\u2501\u2537\u2501\u2501\u2501\u2513  \n  \u2503 2, 0 \u2503                  \u2503 1, 1 \u2503                 \u2503 1, 1 \u2503                    \u2503 0, 2 \u2503 \n  \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u251b                  \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u251b                 \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u251b                    \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u251b   \n     .                         .                        .                           .\n     .                         .                        .                           .\n     .                         .                        .                           ."
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n        @cache\n        def dfs(i, j):\n            if i == len(s1) and j == len(s2):\n                return True\n            choose_s1, choose_s2 = False, False\n            if i < len(s1) and s1[i] == s3[i + j]:\n                choose_s1 = dfs(i + 1, j)\n            if j < len(s2) and s2[j] == s3[i + j]:\n                choose_s2 = dfs(i, j + 1)\n\n            return choose_s1 or choose_s2\n\n        return dfs(0, 0)"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        m, n = len(s1), len(s2)\n        if m + n != len(s3):\n            return False\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        for i in range(1, m + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        for j in range(1, n + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                choose_s1, choose_s2 = False, False\n                if s1[i - 1] == s3[i + j - 1]:\n                    choose_s1 = dp[i - 1][j]\n                if s2[j - 1] == s3[i + j - 1]:\n                    choose_s2 = dp[i][j - 1]\n                dp[i][j] = choose_s1 or choose_s2\n\n        return dp[m][n]"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        m, n = len(s1), len(s2)\n        if m + n != len(s3):\n            return False\n        if n > m:\n            m, n = n, m\n            s1, s2 = s2, s1\n        dp = [False] * (n + 1)\n        dp[0] = True\n        for j in range(1, n + 1):\n            dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\n        for i in range(1, m + 1):\n            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\n            for j in range(1, n + 1):\n                choose_s1, choose_s2 = False, False\n                if s1[i - 1] == s3[i + j - 1]:\n                    choose_s1 = dp[j]\n                if s2[j - 1] == s3[i + j - 1]:\n                    choose_s2 = dp[j - 1]\n                dp[j] = choose_s1 or choose_s2\n\n        return dp[-1]"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        \n        d={}\n        m=len(s1)\n        n=len(s2)\n        if m==0:\n            return s2==s3"
            },
            {
                "language": "rust",
                "code": "def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m = len(s1)\n    n = len(s2)\n    if m+n != len(s3): return False   \n    dp = [[False for j in range(n+1)] for i in range(m+1)]\n    dp[0][0] = True           \nin one loop\n] == s3[i+j-1]):"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        if(s1.length()+s2.length()!=s3.length())return false;\n        vector<vector<bool>>dp(s1.length()+1,vector<bool>(s2.length()+1,false));\n        dp[0][0]=true;\n        for(int i=1;i<=s1.length();i++){\n            dp[i][0]=dp[i-1][0] && s1[i-1]==s3[i-1];\n        }\n        for(int i=1;i<=s2.length();i++){\n            dp[0][i]=dp[0][i-1] && s2[i-1]==s3[i-1];\n        }\n        for(int i=1;i<=s1.length();i++){\n            for(int j=1;j<=s2.length();j++){\n                dp[i][j]=(dp[i-1][j] && s1[i-1]==s3[i+j-1])|| (dp[i][j-1] && s2[j-1]==s3[i+j-1]);\n            }\n        }\n        return dp[s1.length()][s2.length()];\n    }\n};\n\n\n//Recursive solution\n// class Solution {\n// public:\n//     bool canMake(string s1,string s2,string s3,int i,int j,int k){\n//         if(i==s1.length() && j==s2.length() && k== s3.length())return true;\n//         if(i<s1.length() && s1[i]==s3[k] && canMake(s1,s2,s3,i+1,j,k+1))return true;\n//         if(j<s2.length() && s2[j]==s3[k] && canMake(s1,s2,s3,i,j+1,k+1))return true;\n//         else return false;\n//     }\n//     bool isInterleave(string s1, string s2, string s3) {\n//         if(s1.length()+s2.length()!=s3.length())return false;\n//         return canMake(s1,s2,s3,0,0,0);\n//     }\n// };"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    bool helper(string& s1, string& s2, string &s3, int l1, int l2, int l3) {\n        if(l1<0 && l2<0 && l3<0) {\n            return true;\n        }\n        if(l1>=0 && s1[l1]==s3[l3] && l2>=0 && s2[l2]==s3[l3] ) {\n            return (helper(s1, s2, s3, l1-1, l2, l3-1) || helper(s1, s2, s3, l1, l2-1, l3-1));\n        }\n        else if(l1>=0 && s1[l1]==s3[l3])\n            return helper(s1, s2, s3, l1-1, l2, l3-1);\n        \n        else if(l2>=0 &&s2[l2]==s3[l3])\n            return helper(s1, s2, s3, l1, l2-1, l3-1);\n        \n        else return false;\n    }\n    \n    bool isInterleave(string s1, string s2, string s3) {\n        if(s3.size() != s1.size() + s2.size())\n   return false;\n        return helper(s1, s2, s3,s1.size()-1, s2.size()-1, s3.size()-1);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    // int dp[102][102];\n    bool helper(string& s1, string& s2, string &s3, int l1, int l2, int l3, vector<vector<int>>&dp) {\n        if(l1<0 && l2<0 && l3<0) {\n            return true;\n        }\n        if(l1>=0 && l2>=0 && dp[l1][l2]!=-1) {\n            return dp[l1][l2];\n        }\n        if(l1>=0 && s1[l1]==s3[l3] && l2>=0 && s2[l2]==s3[l3] ) {\n            return dp[l1][l2] = (helper(s1, s2, s3, l1-1, l2, l3-1, dp) || helper(s1, s2, s3, l1, l2-1, l3-1, dp));\n        }\n        else if(l1>=0 && s1[l1]==s3[l3])\n            return helper(s1, s2, s3, l1-1, l2, l3-1, dp);\n        \n        else if(l2>=0 &&s2[l2]==s3[l3])\n            return helper(s1, s2, s3, l1, l2-1, l3-1, dp);\n        \n        else return false;\n    }\n    \n    bool isInterleave(string s1, string s2, string s3) {\n        if(s3.size() != s1.size() + s2.size())\n   return false;\n        vector<vector<int>>dp(s1.size()+1, (vector<int>(s2.size()+1, -1)));\n        // memset(dp, -1, sizeof(dp));\n        return helper(s1, s2, s3,s1.size()-1, s2.size()-1, s3.size()-1, dp);\n    }\n};"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n  if (s1.length() + s2.length() != s3.length()) return false;\n  if (s1.length() < s2.length()) swap(s1, s2);\n  int m = s1.length(), n = s2.length();\n   \n        vector<bool> dp(n + 1, false);\n        dp[0] = true;\n        for (int j = 1; j <= n; j++) {\n            dp[j] = s3[j - 1] == s2[j - 1] && dp[j - 1];\n        }\n\n        for (int i = 1; i <= m; i++) {\n            dp[0] = s3[i - 1] == s1[i - 1] && dp[0];\n            for (int j = 1; j <= n; j++) {\n                dp[j] = (s3[i + j - 1] == s1[i - 1] && dp[j]);\n                dp[j] = dp[j] || (s3[i + j - 1] == s2[j - 1] && dp[j - 1]);\n            }\n        }\n        return dp.back();\n    }\n};"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n        if len(s1) < len(s2):\n            s1, s2 = s2, s1\n        m, n = len(s1), len(s2)\n        \n        dp = [True] + [False] * n\n        for j in range(1, n + 1):\n            dp[j] = s2[j - 1] == s3[j - 1] and dp[j - 1]\n\n        for i in range(1, m + 1):\n            dp[0] = s1[i - 1] == s3[i - 1] and dp[0]\n            for j in range(1, n + 1):\n                dp[j] = (s1[i - 1] == s3[i + j - 1] and dp[j])\n                dp[j] = dp[j] or (s2[j - 1] == s3[i + j - 1] and dp[j - 1])\n        return dp[-1]"
            },
            {
                "language": "csharp",
                "code": " bool isInterleave(string s1, string s2, string s3) {\n    \n    if(s3.length() != s1.length() + s2.length())\n        return false;\n    \n    bool table[s1.length()+1][s2.length()+1];\n    \n    for(int i=0; i<s1.length()+1; i++)\n        for(int j=0; j< s2.length()+1; j++){\n            if(i==0 && j==0)\n                table[i][j] = true;\n            else if(i == 0)\n                table[i][j] = ( table[i][j-1] && s2[j-1] == s3[i+j-1]);\n            else if(j == 0)\n                table[i][j] = ( table[i-1][j] && s1[i-1] == s3[i+j-1]);\n            else\n                table[i][j] = (table[i-1][j] && s1[i-1] == s3[i+j-1] ) || (table[i][j-1] && s2[j-1] == s3[i+j-1] );\n        }\n        \n    return table[s1.length()][s2.length()];\n}"
            },
            {
                "language": "csharp",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    // s1: abc\n    // s2: bcd\n    // good s3: abbccd, abcbcd, abcdbc, etc.. order of characters from s1 and s2 should remain unchanged\n    bool isInterleave(string s1, string s2, string s3) {\n        \n        if((s1.size() + s2.size()) != s3.size())\nj - 1] == s3[i + j - 1]);"
            },
            {
                "language": "csharp",
                "code": "bool isInterleave(string s1, string s2, string s3) {\n    int m = s1.length();\n    int n = s2.length();\n    int p = s3.length();\n    \n    if (m + n != p) return false;\n    "
            },
            {
                "language": "go",
                "code": "bool isInterleave(string s1, string s2, string s3) {\n    if (s3.size() != s1.size() + s2.size()) return false;\n\n    int m = (int) s1.size();\n    int n = (int) s2.size();\n    // dp[i][j] = the first i chars in s1, the first j chars in s2\n    // can or not can construct to the first (i+j) chars in s3\n    vector<vector<bool>> dp(m+1, vector<bool>(n+1, false));"
            },
            {
                "language": "typescript",
                "code": "public class Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if (s1.length() + s2.length() != s3.length()) return false;\n        int n1 = s1.length(), n2 = s2.length();\n        boolean[][] dp = new boolean[n1 + 1][n2 + 1];\n        for (int i = 0; i <= n1; i++) {\n            for (int j = 0; j <= n2; j++) {\n                if (i == 0 && j == 0) { // s1 empty, s2 empty\n1)) || (j > 0 && dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));"
            },
            {
                "language": "csharp",
                "code": "    bool isInterleave(string s1, string s2, string s3) {\n        memset(dp,0,sizeof(dp));\n        if(s1.length()+s2.length()!=s3.length())return false;\n        for(int i=s1.length()+1;i--;){\n            for(int j=s2.length()+1;j--;){\n                if(s1.length()==i && s2.length()==j){\n                    dp[i][j]=1;\n                }\n                else{\n                    "
            },
            {
                "language": "csharp",
                "code": "# code block\nclass Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        bool f[s1.size()+1][s2.size()+1];\n        memset(f,false,sizeof(f));\n        f[0][0]=true;"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n  public:\n    int dp[102][102];\n  bool solve(string s1, string s2, string s3, int x, int y, int z) {\n    if (x < 0 and y < 0 and z < 0) return true;\n    if (x >= 0 and y >= 0 and dp[x][y] != -1) return dp[x][y];\n    if (x >= 0 and s1[x] == s3[z] and y >= 0 and s2[y] == s3[z])\n      return dp[x][y] = solve(s1, s2, s3, x - 1, y, z - 1) or solve(s1, s2, s3, x, y - 1, z - 1);\n    else if (x >= 0 and s1[x] == s3[z])\n      return solve(s1, s2, s3, x - 1, y, z - 1);\n    else if (y >= 0 and s2[y] == s3[z])\n      return solve(s1, s2, s3, x, y - 1, z - 1);\n    else\n      return false;\n  }\n  bool isInterleave(string s1, string s2, string s3) {\n    memset(dp, -1, sizeof(dp));\n    int x = s1.size(), y = s2.size(), z = s3.size();\n    if (x + y != z) return false;\n    return solve(s1, s2, s3, x - 1, y - 1, z - 1);\n  }\n};"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3): return False\n        m, n = len(s1), len(s2)\n        \n        @lru_cache(None)\n        def dp(i, j):\n            if i == m and j == n: return True  # Found a valid match\n            ans = False\n            if i < m and s1[i] == s3[i+j]:  # Case match s1[i] with s3[i+j]\n                ans |= dp(i + 1, j)\n            if j < n and s2[j] == s3[i+j]:  # Case match s2[j] with s3[i+j]\n                ans |= dp(i, j + 1)\n            return ans\n\n        return dp(0, 0)"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3): return False\n\n        m, n = len(s1), len(s2)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[m][n] = True\n        for i in range(m, -1, -1):\n            for j in range(n, -1, -1):\n                if i < m and s1[i] == s3[i + j]:\n                    dp[i][j] |= dp[i + 1][j]\n                if j < n and s2[j] == s3[i + j]:\n                    dp[i][j] |= dp[i][j + 1]\n        return dp[0][0]"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3): return False\n\n        m, n = len(s1), len(s2)\n        dp, dpPrev = [False] * (n + 1), [False] * (n + 1)\n        for i in range(m, -1, -1):\n            for j in range(n, -1, -1):\n                dp[j] = False\n                if i == m and j == n:\n                    dp[n] = True\n                if i < m and s1[i] == s3[i + j]:\n                    dp[j] |= dpPrev[j]\n                if j < n and s2[j] == s3[i + j]:\n                    dp[j] |= dp[j + 1]\n            dp, dpPrev = dpPrev, dp\n        return dpPrev[0]"
            },
            {
                "language": "rust",
                "code": "def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m,n=len(s1),len(s2)\n    if m+n!=len(s3):\n        return False\n    table=[[0 for i in range(n+1)] for j in range(m+1)]\n    def dp(i,j):\n        if table[i][j]!=0:\n            return True if table[i][j]==1 else False\n        if i==m and j==n:"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool dfs(int index, int l, int r, int turn, string &s1, string &s2, string &s3, vector<vector<vector<int>>> &dp){\n        if(index == s3.size()){\n            if(l == s1.size() && r == s2.size()) return true;\n            return false;\n        }\n        //cout << index << \",\" << l << \",\" << r << \" \" << turn << \"\\n\";"
            }
        ]
    },
    "97": {
        "question_id": 98,
        "title": "Validate Binary Search Tree",
        "difficulty": 2,
        "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).A valid BST is defined as follows:The left subtree of a node contains only nodes with keys less than the node's key.The right subtree of a node contains only nodes with keys greater than the node's key.Both the left and right subtrees must also be binary search trees. ",
        "examples": [
            {
                "input": "root = [2,1,3]",
                "output": "true",
                "explanation": null
            },
            {
                "input": "root = [5,1,4,null,null,3,6]",
                "output": "false",
                "explanation": "The root node's value is 5 but its right child's value is 4."
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [1, 104].",
            "-231 <= Node.val <= 231 - 1"
        ],
        "solutions": [
            {
                "language": "kotlin",
                "code": "class Solution {\n    public boolean fullArr(ArrayList<Integer> arr, int val)\n    {\n        if (arr.size() > 0)\n        {\n            if (arr.get(arr.size() - 1) < val)\n                arr.add(val);\n            else\n                return  false;\n        }\n        else\n            arr.add(val);\n        return true;\n    }\n\n    public boolean checkArr(TreeNode root, ArrayList<Integer> arr) {\n        boolean ok = true;\n\n        if (ok && root.left != null)\n        {\n            if ((root.left.val < root.val))\n                ok = checkArr(root.left, arr);\n            else\n                ok = false;\n        }\n        if (ok) ok = fullArr(arr, root.val);\n        if (ok && root.right != null) {\n            if (root.right.val > root.val)\n                ok = checkArr(root.right, arr);\n            else\n                ok = false;\n        }\n        return ok;\n    }\n\n    public boolean isValidBST(TreeNode root) {\n        return checkArr(root, new ArrayList<Integer>());\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "public List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> list = new ArrayList<>();\n    if(root == null) return list;\n    Stack<TreeNode> stack = new Stack<>();\n    while(root != null || !stack.empty()){\n        while(root != null){\n            stack.push(root);\n            root = root.left;\n        }\n        root = stack.pop();\n        list.add(root.val);\n        root = root.right;\n        \n    }\n    return list;\n}"
            },
            {
                "language": "cpp",
                "code": " public int kthSmallest(TreeNode root, int k) {\n     Stack<TreeNode> stack = new Stack<>();\n     while(root != null || !stack.isEmpty()) {\n         while(root != null) {\n             stack.push(root);    \n             root = root.left;   \n         } \n         root = stack.pop();\n         if(--k == 0) break;\n         root = root.right;\n     }\n     return root.val;\n }"
            },
            {
                "language": "kotlin",
                "code": "public boolean isValidBST(TreeNode root) {\n   if (root == null) return true;\n   Stack<TreeNode> stack = new Stack<>();\n   TreeNode pre = null;\n   while (root != null || !stack.isEmpty()) {\n      while (root != null) {\n         stack.push(root);\n         root = root.left;\n      }\n      root = stack.pop();\n      if(pre != null && root.val <= pre.val) return false;\n      pre = root;\n      root = root.right;\n   }\n   return true;\n}"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n   public boolean isValidBST(TreeNode root) {\n        if(root == null) return true;\n        Deque<TreeNode> stack = new LinkedList<>();\n        TreeNode prev = null;\n        boolean onRightSideOfPrev = false;\n        while(root != null || !stack.isEmpty()) {\n&& prev.val >= root.val))) {"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    TreeNode prev;\n        \n    public boolean isValidBST(TreeNode root) {\n        if (root == null)\n            return true;\n        \n        if(!isValidBST(root.left))"
            },
            {
                "language": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    private boolean isValid = true;\n    private TreeNode pre = null;\n    public boolean isValidBST(TreeNode root) {\n        helper(root);\n        return isValid;\n    }\n    "
            },
            {
                "language": "kotlin",
                "code": " bool isValidBST(TreeNode* root, TreeNode* min=NULL, TreeNode* max=NULL) {\n        if (!root) return true;\n        if (min != NULL && root->val <= min->val) return false;\n        if (max != NULL && root->val >= max->val) return false;\n        return isValidBST(root->left, min, root) && isValidBST(root->right, root, max);\n    }"
            },
            {
                "language": "kotlin",
                "code": "    Stack<TreeNode> sTree = new Stack<>();\n    \n    TreeNode curr = null;\n        TreeNode pre = null;\n    curr=root;"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public boolean isValidBST(TreeNode root) {\n        if(root == null) {\n            return true;\n        }\n        Stack<TreeNode> stack = new Stack<>();\n        stack.push(root);\n        while(!stack.isEmpty()) {"
            },
            {
                "language": "kotlin",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public static boolean isValid(TreeNode root,TreeNode min ,TreeNode max){\n        if(root==null){\n            return true;\n        }\n        if(min!=null && root.val<=min.val){\n            return false;\n        }\n        if(max!=null && root.val>=max.val){\n            return false;\n        }\n        return isValid(root.left,min,root)&&isValid(root.right,root,max);\n\n    }\n    public boolean isValidBST(TreeNode root) {\n    if(isValid(root,null,null)){\n          return true;\n      }\n      else{\n           return false;\n    \n      }\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n\n    // Travserse entire tree using inorder, and store each element inside the res.\n    void inorder(TreeNode* root, vector<int>&res) {\n        if(!root) return;\n        inorder(root->left, res);\n        res.push_back(root->val);\n        inorder(root->right, res);\n    }\n\n    bool isValidBST(TreeNode* root) {\n        vector<int> res;\n        inorder(root, res);\n        for(int i=1; i<res.size(); ++i) {\n            // Checking if res[i-1] >= res[i] then return false;\n            // That means the input tree is not a valid BST;\n            if(res[i-1]>=res[i]) return false;\n        }\n        return true;\n        // Follow up: solve this without using any extra space.\n        // Hint: You can use ranges, for each element.\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        return isValidBs(root,Long.MIN_VALUE,Long.MAX_VALUE);\n    }\n\n        public boolean isValidBs(TreeNode root, long min, long max){\n        if(root == null)return true;\n        if(root.val<= min || root.val >= max) return false;\n        boolean left= isValidBs(root.left,min,root.val);\n        boolean right = isValidBs(root.right,root.val,max);\n        return left && right;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\nvector<int> numbers;//declare it globally, it contains the inorder traversal of BST\n\nvoid inorderpush(TreeNode* root){\n    if(root==nullptr){\n        return;\n    }\n    inorderpush(root->left);\n    numbers.push_back(root->val);//inserts the element in array\n    inorderpush(root->right);\n}\n\nbool isValidBST(TreeNode* root) {\n    inorderpush(root);\n\n    for(int i=0;i<numbers.size()-1;i++){\n        if(numbers[i+1]<=numbers[i]){\n            return false;//if array is not strictly increasing\n        }\n    }\n    return true; //if array is strictly increasing   \n    }\n};"
            },
            {
                "language": "",
                "code": "root = [2147483647]\nroot = [2147483647, 2147483647]"
            },
            {
                "language": "",
                "code": "root = [9223372036854775807]\nroot = [9223372036854775807, 9223372036854775807]"
            },
            {
                "language": "kotlin",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        return isValidBST(root, null, null);\n    }\n\n    private boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {\n        if (root == null) {\n            return true;\n        }\n\n        if (min != null && root.val <= min.val) {\n            return false;\n        }\n\n        if (max != null && root.val >= max.val) {\n            return false;\n        }\n        return isValidBST(root.left, min, root) \n                && isValidBST(root.right, root, max);\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        if (root->left == NULL && root->right == NULL)\n            return true;        \n        return checkBST(root, NULL, NULL); \n    }\n\n    bool checkBST(TreeNode* root, TreeNode* min, TreeNode* max) {\n        if (root == NULL)\n            return true;\n        if ((min != NULL && root->val <= min->val) || (max != NULL && root->val >= max->val))\n            return false;\n        return checkBST(root->left, min, root) &&\n               checkBST(root->right, root, max);  \n    }\n};"
            },
            {
                "language": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        output =[]\n        self.inorder(root, output)\n        \n        for i in range(1, len(output)):\n   if output[i-1]>= output[i]:\n    return False\n        \n        return True\n    \n    # Time complexity of inorder traversal is O(n)\n    # Fun fact: Inorder traversal leads to a sorted array if it is \n    # a Valid Binary Search. Tree.\n    def inorder(self, root, output):\n        if root is None:\n            return\n        \n        self.inorder(root.left, output)\n        output.append(root.val)\n        self.inorder(root.right, output)\n        "
            },
            {
                "language": "python",
                "code": "# Recursive: runtime-16ms\n\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        output = []\n        self.inorder(root, output)\n        return output\n        \n    def inorder(self, root, output):\n        if root is None:\n            return\n        \n        self.inorder(root.left, output)\n        output.append(root.val)\n        self.inorder(root.right, output)\n\n\n# Iterative Runtime: 20 ms, faster than 70.13%\n\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        output = []\n        stack=[]\n        \n        while stack or root:\n            \n            if root:\n                stack.append(root)\n                root =root.left\n                \n            else:\n                temp =stack.pop()\n                output.append(temp.val)\n                root= temp.right\n           \n        return output"
            },
            {
                "language": "python",
                "code": "## Recursive Solution: Runtime: 36 ms, faster than 97.16%\n\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\nclass Solution(object):\n    def preorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        \n        output =[]\n        \n        # perform dfs on the root and get the output stack\n        self.dfs(root, output)\n        \n        # return the output of all the nodes.\n        return output\n    \n    def dfs(self, root, output):\n        \n        # If root is none return \n        if root is None:\n            return\n        \n        # for preorder we first add the root val\n        output.append(root.val)\n        \n        # Then add all the children to the output\n        for child in root.children:\n            self.dfs(child, output)\n       \n    \n    \n# Iterative Solution- Runtime: 40 ms, faster than 91.86% \n\n\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution(object):\n    def preorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if root is None:\n            return []\n        \n        stack = [root]\n        output = []\n        \n        # Till there is element in stack the loop runs.\n        while stack:\n            \n            #pop the last element from the stack and store it into temp.\n            temp = stack.pop()\n            \n            # append. the value of temp to output\n            output.append(temp.val)\n            \n            #add the children of the temp into the stack in reverse order.\n            # children of 1 = [3,2,4], if not reveresed then 4 will be popped out first from the stack.\n            # if reversed then stack = [4,2,3]. Here 3 will pop out first.\n            # This continues till the stack is empty.\n            stack.extend(temp.children[::-1])\n        \n        #return the output\n        return output\n        "
            },
            {
                "language": "python",
                "code": "# Recursive solution\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        output =[]\n        self.dfs(root, output)\n        return output\n    \n    def dfs(self, root, output):\n        if root is None:\n            return\n        \n        output.append(root.val)\n        self.dfs(root.left, output)\n        self.dfs(root.right, output)\n       \n    \n# Iterative Solution- Runtime: 12 ms, faster than 97.82%\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        output =[]\n        stack = [root]\n        \n        while stack:\n            temp=stack.pop()\n            if temp:\n                output.append(temp.val)\n                stack.append(temp.right)\n                stack.append(temp.left)\n        \n        return output"
            },
            {
                "language": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        if root is None:\n            return []\n        \n        result = []\n        self.dfs(root, \"\", result)\n        return result\n\n    def dfs(self, root, path, result):\n        if not root.left and not root.right:\n            result.append(path + str(root.val))\n        \n        if root.left:\n            self.dfs(root.left, path + str(root.val) + \"->\" , result)\n        if root.right:\n            self.dfs(root.right, path + str(root.val) + \"->\", result)\n        "
            },
            {
                "language": "python",
                "code": "# Recursive : Runtime: 40 ms, faster than 89.79% \n\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution(object):\n    def postorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        output =[]\n        self.dfs(root, output)\n        return output\n    \n    def dfs(self, root, output):\n        if root is None:\n            return\n        for child in root.children:\n            self.dfs(child, output)\n        \n        output.append(root.val)\n \n \n # Iterative Solution: Runtime: 48 ms, faster than 62.81%\n \n `\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution(object):\n    def postorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        output =[]\n        stack = [root]\n        \n        while stack:\n            root = stack.pop()\n            if root:\n                output.append(root.val)\n                stack += root.children\n                \n        return output[::-1]`\n        "
            },
            {
                "language": "python",
                "code": "# Recursive solution\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        output = []\n        self.dfs(root, output)\n        return output\n    \n    def dfs(self, root, output):\n        if root is None:\n            return\n        self.dfs(root.left, output)\n        self.dfs(root.right, output) \n        output.append(root.val)\n  \n  \n# Iterative solution: Runtime: 12 ms, faster than 98.10%\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        output = []\n        stack =[root]\n        \n        if not root:\n            return None\n        \n        # iterate only when there is elements inside the stack.\n        while stack:\n            \n            # pop the element from stack and stored it into temp\n            temp=stack.pop()\n            \n            #append the value of temp to output\n            output.append(temp.val)\n            \n            #Now traverse through left node and add the node to stack\n            if temp.left:\n                stack.append(temp.left)\n                \n            #else traverse through right node and add to stack\n            if temp.right:\n                stack.append(temp.right)\n         \n        # After iterating through the stack,  print the result in reverse order.  \n        return output[::-1]\n    \n    \n# Example: Iteration 1 : #stack=[1] - first iteration, temp =1, \n                #output[1]\n                #temp.left is Null\n                #temp.right is [2]\n                # stack =[2]"
            },
            {
                "language": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        output =[]\n        self.dfs(root, 0, output)\n        return output\n    \n    def dfs(self, root, level, output):\n        \n        if not root:\n            return\n        \n        if len(output) < level+1:\n            output.append([])\n            \n        output[level].append(root.val)    \n        self.dfs(root.left, level+1, output)\n        self.dfs(root.right, level+1, output)\n        "
            },
            {
                "language": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        output = []\n        self.dfs(root, 0, output)\n        return output[::-1]\n    \n    def dfs(self, root, level, output):\n        if root is None:\n             return\n            \n        if len(output) < level+1:\n            output.append([])\n            \n        output[level].append(root.val)\n        self.dfs(root.left, level+1, output)\n        self.dfs(root.right, level+1, output)"
            },
            {
                "language": "python",
                "code": "\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[List[int]]\n        \"\"\"\n        output=[]\n        self.dfs(root, 0, output)\n        return output\n    \n    def dfs(self, root, level ,output):\n        if root is None:\n            return\n        if len(output)< level+1:\n            output.append([])\n        \n        output[level].append(root.val)\n        for child in root.children:\n            self.dfs(child, level+1, output)\n      "
            },
            {
                "language": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        output=[]\n        self.dfs(root, 0, output)\n        \n        for i in range(len(output)):\n            if i % 2 !=0:\n                output[i].reverse()\n            else:\n                continue\n        return output\n    \n    def dfs(self, root, level, output):\n        if root is None:\n            return\n        \n        if len(output) < level+1:\n            output.append([])\n        \n        output[level].append(root.val)\n        self.dfs(root.left, level+1, output)\n        self.dfs(root.right, level+1, output)\n        "
            },
            {
                "language": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not preorder:\n            return None\n        \n        #pattern is preorder=[root, left, right]\n        #inorder = [left, root, right],  so find index and value using root.\n        \n        root = TreeNode(preorder[0])\n        \n        root_index= 0\n        \n        #iterate through inorder list and find the list index of the root.\n        for i in range(len(inorder)):\n            if inorder[i]== root.val:\n                root_index = i\n            else:\n                continue\n                \n        #slice the inorder list into left and right.     \n        left_inorder = inorder[:root_index]\n        right_inorder = inorder[root_index+1:]\n        \n        #slice the preorder list into left and right.\n        left_preorder = preorder[1:len(left_inorder)+1]\n        right_preorder = preorder[len(left_preorder)+1:]\n        \n        #append by updating preorder and inorder lists\n        root.left = self.buildTree(left_preorder, left_inorder)\n        root.right = self.buildTree(right_preorder, right_inorder)\n        \n        return root"
            },
            {
                "language": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        # PATTERN\n        # inorder: l, root, right\n        # postorder: l,r,root\n        # the last element of postorder is root\n        \n        if not inorder or not postorder:\n            return None\n        \n        root_index=0\n        \n        # Build the data structure based on root value\n        root = TreeNode(postorder.pop())\n        \n        for i in range(len(inorder)):\n            if inorder[i]==root.val:\n                root_index=i\n            else:\n                continue\n        \n        left_in=inorder[:root_index]\n        right_in = inorder[root_index+1:]\n        \n        root.right = self.buildTree(right_in, postorder)\n        root.left = self.buildTree(left_in,  postorder)\n\n        return root\n   "
            },
            {
                "language": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def constructFromPrePost(self, pre, post):\n        \"\"\"\n        :type pre: List[int]\n        :type post: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        if not pre:\n            return None\n        \n        root = TreeNode(post.pop())\n        \n        if len(pre) == 1:\n            return root\n        \n        # Find the index of the root value from pre\n        for i in range(len(pre)):\n            if pre[i]==post[-1]:\n                root_index= i\n            else:\n                continue\n        \n        root.right = self.constructFromPrePost(pre[root_index:], post) \n        root.left = self.constructFromPrePost(pre[1:root_index],post) \n        \n        return root \n   \n# Explanation:   root=1, root_index = 0, root.right=(pre(1,2,3,4,5,6,7))  [1, 2,3,4,5,6,7]                           vii\n         # root = 3, root_index= 4, root.right=(pre(3,6,7))  [3,4,5,6,7]                               v\n           # root=7, root_index=2, root.right= pre(7), now len(pre) == 1, return 7 ---[7]        i\n           # root =6, root_index=1, root.left= pre(6), now len(pre)==1, return 6 -----[6,7]      ii \n\n         # root =2, root_index= 1, root.right= pre(2,4,5)   [2,3,4,5,6,7]                               vi \n           # root = 5, root_index=2, root.right= pre(5)  now len(pre)==1, return 5 ----[5,6,7]   iii\n           # root = 4, root_index=1, root.right= pre(4)  now len(pre)==1, return 4-----[4,5,6,7]  iv"
            }
        ]
    },
    "98": {
        "question_id": 99,
        "title": "Recover Binary Search Tree",
        "difficulty": 2,
        "description": "You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure. ",
        "examples": [
            {
                "input": "root = [1,3,null,null,2]",
                "output": "[3,1,null,null,2]",
                "explanation": "3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid."
            },
            {
                "input": "root = [3,1,4,null,null,2]",
                "output": "[2,1,4,null,null,3]",
                "explanation": "2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid."
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [2, 1000].",
            "-231 <= Node.val <= 231 - 1"
        ],
        "solutions": [
            {
                "language": "kotlin",
                "code": "var recoverTree = function(root) {\n    let small = null, big = null, prev = null;\n    let inorder = function(r) {\n        if (r == null) return;\n        inorder(r.left);\n        if (prev && prev.val > r.val) {\n            small = r;\n            if(big) return;\n            big = prev;\n        }\n        prev = r;\n        inorder(r.right);\n        return;\n    }\n    inorder(root);\n    [small.val, big.val] = [big.val, small.val];\n};"
            },
            {
                "language": "python",
                "code": "int val;"
            },
            {
                "language": "",
                "code": "TreeNode *left;"
            },
            {
                "language": "",
                "code": "TreeNode *right;"
            },
            {
                "language": "javascript",
                "code": "TreeNode() : val(0), left(nullptr), right(nullptr) {}"
            },
            {
                "language": "cpp",
                "code": "TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}"
            },
            {
                "language": "javascript",
                "code": "TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}"
            },
            {
                "language": "cpp",
                "code": "TreeNode* fst;\nTreeNode* scnd;\nTreeNode* prv;\nTreeNode* nxt;\nvoid recoverTree(TreeNode* root) {\n    fst=NULL;\n    scnd=NULL;\n    nxt=NULL;\n    prv=new TreeNode(INT_MIN);\n    trav(root);\n    if(fst && scnd){swap(fst->val, scnd->val);}\n    else if(fst && nxt){swap(fst->val , nxt->val);}\n}\n\nvoid trav(TreeNode* root){\n    if(!root){return;}\n    trav(root->left);\n    if(prv && (root->val<prv->val)){\n        if(!fst){\n            fst=prv;\n            nxt=root;\n        }\n        else{\n            scnd=root;\n        }\n    }\n    prv=root;\n    trav(root->right);\n}"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    TreeNode prev=null,first=null,second=null;\n    void inorder(TreeNode root){\n        if(root==null)\n            return ;\n        inorder(root.left);\n        if(prev!=null&&root.val<prev.val){\n            if(first==null)\n                first=prev;\n            second=root;\n        }\n        prev=root;\n        inorder(root.right);\n    }\n    public void recoverTree(TreeNode root) {\n        if(root==null)\n            return ; \n        inorder(root);\n        int temp=first.val;\n        first.val=second.val;\n        second.val=temp;\n    }\n}"
            },
            {
                "language": "cpp",
                "code": "TreeNode* prev=NULL, *first=NULL,*second=NULL;\nvoid utility (TreeNode* root)\n{\n   if(root==NULL) return;\n\n   utility(root->left);\n   if(prev!=NULL && root->val<prev->val)"
            },
            {
                "language": "java",
                "code": "private void traverse (TreeNode root) {\n   if (root == null)\n      return;\n   traverse(root.left);\n   // Do some business\n   traverse(root.right);\n}"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    \n    TreeNode firstElement = null;\n    TreeNode secondElement = null;\n    // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized\n    TreeNode prevElement = new TreeNode(Integer.MIN_VALUE);\n    \n    public void recoverTree(TreeNode root) {\n        \n        // In order traversal to find the two elements\n        traverse(root);\n        \n        // Swap the values of the two nodes\n        int temp = firstElement.val;\n        firstElement.val = secondElement.val;\n        secondElement.val = temp;\n    }\n    \n    private void traverse(TreeNode root) {\n        \n        if (root == null)\n            return;\n            \n        traverse(root.left);\n        \n        // Start of \"do some business\", \n        // If first element has not been found, assign it to prevElement (refer to 6 in the example above)\n        if (firstElement == null && prevElement.val >= root.val) {\n            firstElement = prevElement;\n        }\n    \n        // If first element is found, assign the second element to the root (refer to 2 in the example above)\n        if (firstElement != null && prevElement.val >= root.val) {\n            secondElement = root;\n        }        \n        prevElement = root;\n\n        // End of \"do some business\"\n\n        traverse(root.right);\n}"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    private TreeNode first;\n    private TreeNode second;\n    private TreeNode pre;\n    public void recoverTree(TreeNode root) {\n        if(root==null) return;\n        first = null;"
            },
            {
                "language": "kotlin",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n TreeNode* firstMistake, *secondMistake, *pre;\n void recoverTree(TreeNode* root) {\n  pre = new TreeNode(INT_MIN);\n  inorder(root);\n  swap(firstMistake->val, secondMistake->val);\n }\n\n void inorder(TreeNode* root) {\n  if(root == nullptr) \n   return;\n\n  inorder(root->left);\n\n  if(firstMistake == nullptr && root->val < pre->val)\n   firstMistake = pre;\n  if(firstMistake != nullptr && root->val < pre->val)\n   secondMistake = root;\n  pre = root;\n\n  inorder(root->right);\n }\n};"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    vector <int> nodes;\n    int i = 0;\nprivate:\n    void traversal(TreeNode* root, vector <int>& nodes) {\n        if (root == NULL)\n            return;\n        traversal(root->left, nodes);\n        nodes.push_back(root->val);\n        traversal(root->right, nodes);    \n    }\n    void inorder(TreeNode* root, vector <int> nodes, int& i) {\n        if (root == NULL)\n            return;\n        inorder(root->left, nodes, i);\n        if (root->val != nodes[i])\n            root->val = nodes[i];\n        i++;    \n        inorder(root->right, nodes, i);    \n    }        \npublic:\n    void recoverTree(TreeNode* root) {\n        traversal(root, nodes);\n        sort(nodes.begin(), nodes.end());\n        inorder(root, nodes, i);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    TreeNode* prev = new TreeNode(INT_MIN);\n    TreeNode* first = NULL;\n    TreeNode* middle = NULL;\n    TreeNode* last = NULL;\nprivate:\n    void inorder(TreeNode* root) {\n        if (root == NULL)\n            return;\n        inorder(root->left);\n        if (prev->val > root->val) {\n            if (first == NULL) {\n                first = prev;\n                middle = root;\n            } else {\n                last = root;\n            }\n        }  \n        prev = root; \n        inorder(root->right);    \n    }        \npublic:\n    void recoverTree(TreeNode* root) {\n        inorder(root);\n        if (last != NULL)\n            swap(first->val, last->val);\n        else\n            swap(first->val, middle->val);  \n    }\n};"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* first=NULL;\n    TreeNode* sec=NULL;\n    TreeNode* prev=NULL;\n    void dfs(TreeNode* root)\n    {\n        if(root==NULL)\n        return;\n        dfs(root->left);\n        if(prev && prev->val>root->val)\n        {\n            if(first==NULL)\n            first=prev;\n            sec=root;\n        }\n        prev=root;\n        dfs(root->right);\n    }\n    void recoverTree(TreeNode* root) {\n        dfs(root);\n        int t=first->val;\n        first->val=sec->val;\n        sec->val=t;\n    }\n};"
            },
            {
                "language": "",
                "code": "   5\n  /   \\\n6     8\n  /\n  4"
            },
            {
                "language": "",
                "code": "   5\n  /   \\\n4     8\n  /\n  6"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n TreeNode* firstMistake, *secondMistake, *pre;\n void recoverTree(TreeNode* root) {\n  pre = new TreeNode(INT_MIN);\n  inorder(root);\n  swap(firstMistake->val, secondMistake->val);\n }\n\n void inorder(TreeNode* root) {\n  if(root == nullptr) \n   return;\n\n  inorder(root->left);\n\n  if(firstMistake == nullptr && root->val < pre->val)\n   firstMistake = pre;\n  if(firstMistake != nullptr && root->val < pre->val)\n   secondMistake = root;\n  pre = root;\n\n  inorder(root->right);\n }\n};"
            },
            {
                "language": "",
                "code": "   5\n  /   \\\n6     8\n     /\n     4"
            },
            {
                "language": "",
                "code": ""
            },
            {
                "language": "cpp",
                "code": "    TreeNode * first_mistake = nullptr, * second_mistake = nullptr; \n    TreeNode * prev = nullptr;\n    //prev holds \"the previous node\" in the follow sense:\n    //traverse() goes through the the nodes In-order, say the order is: node1, node2, node3, ....\n    //  so node1 will be the left-most node in the tree.\n    //If you're currently at node1 then prev == nullptr. \n    //If you're currently at node2 then prev == node1. "
            },
            {
                "language": "typescript",
                "code": ""
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\n        self.arr = []\n\n        def inorder(node):\n            if not node: return\n            inorder(node.left)\n            self.arr.append(node)\n            inorder(node.right)\n        \n        inorder(root)\n\n        sort = sorted(leaf.val for leaf in self.arr)\n\n        for i in range(len(sort)):\n            self.arr[i].val = sort[i]\n        "
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\n    void dfs(TreeNode* root, vector<int>& vec) {\n        if(!root) return;\n        dfs(root -> left, vec);\n        vec.push_back(root -> val);\n        dfs(root -> right, vec);\n    }\n    void in(TreeNode* root, vector<int>& vec, int &i) {\n        if(!root) return;\n        // i++;\n        in(root -> left, vec, i);\n        if(root -> val != vec[i]) root -> val = vec[i];\n        i++;\n        in(root -> right, vec, i);\n    }\npublic:\n    void recoverTree(TreeNode* root) {\n        vector<int> vec;\n        dfs(root, vec);\n        sort(vec.begin(), vec.end());\n        int i = 0;\n        in(root, vec, i);\n    }\n};"
            }
        ]
    },
    "99": {
        "question_id": 100,
        "title": "Same Tree",
        "difficulty": 1,
        "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.Two binary trees are considered the same if they are structurally identical, and the nodes have the same value. ",
        "examples": [
            {
                "input": "p = [1,2,3], q = [1,2,3]",
                "output": "true",
                "explanation": null
            },
            {
                "input": "p = [1,2], q = [1,null,2]",
                "output": "false",
                "explanation": null
            },
            {
                "input": "p = [1,2,1], q = [1,1,2]",
                "output": "false",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in both trees is in the range [0, 100].",
            "-104 <= Node.val <= 104"
        ],
        "solutions": [
            {
                "language": "kotlin",
                "code": "class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n      if(p==null && q==null) return true;\n      if(p==null || q==null) return false;\n      if(p.val == q.val){\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);  \n      }  \n        return false;"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == 0 || q == 0) return (p == 0 && q == 0);\n        if (p->val == q->val) return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n        return false;\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "    Queue<TreeNode> tq1 = new LinkedList<>();\n    Queue<TreeNode> tq2 = new LinkedList<>();\n\n    if(p!= null) tq1.offer(p);\n    if(q!= null) tq2.offer(q);\n\n    while(!tq1.isEmpty() && !tq2.isEmpty()){\n         TreeNode temp1 = tq1.poll();\n== null)) return false;\nright == null)) return false;"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        \"\"\"\n        O(n) O(n)\n        \"\"\"\n        stack = [p, q]\n        while stack:"
            },
            {
                "language": "kotlin",
                "code": "if (p == null || q == null)\n    return false;\n\nif (p.val != q.val)\n    return false;"
            },
            {
                "language": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n         List<Integer> list=new ArrayList<Integer>();\n         List<Integer> list2=new ArrayList<Integer>();\n         postOrder(p,list);\n         postOrder(q,list2);\n         if(list.equals(list2))return true;\n         else return false; \n    }\n    public void postOrder(TreeNode p,List<Integer> list){\n        if(p==null) return;\n        postOrder(p.left,list);\n        list.add(p.val);\n        postOrder(p.right,list);\n        if(p.left ==null) list.add(null);\n        if(p.right==null) list.add(null);\n        \n    }\n}"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q)    return true;\n        if(!p || !q)    return false;\n            return (p->val == q->val && isSameTree(p->right, q->right) && isSameTree(p->left, q->left));\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q)\n    {\n        stack<pair<TreeNode*, TreeNode*>> st;\n        st.push({p, q});\n        while (!st.empty()) {\n            auto [node1, node2] = st.top();\n            st.pop();\n            if (!node1 && !node2) continue;\n            if (!node1 || !node2 || node1->val != node2->val) return false;\n            st.push({node1->left, node2->left});\n            st.push({node1->right, node2->right});\n        }\n        return true;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n   if(p==NULL|| q==NULL)\n   return p==q;\n   return (p->val==q->val) && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void preorder(TreeNode* node, vector<int> &v){\n\n   if(node==NULL)\n   { \n       v.push_back(0);\n       return;\n    }\n   v.push_back(node->val);\n   preorder(node->left,v);\n   preorder(node->right,v);\n }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n       vector<int> P;\n       vector<int> Q;\n       preorder(p,P);\n       preorder(q,Q);\n       return P==Q;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "/*\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        //1. Both trees have only heads\n        if(p == NULL && q == NULL){\n            return true;\n        }\n        //2. If both heads are not null\n        if((p == NULL && q != NULL) ||(p != NULL && q == NULL)){\n            return false;\n        }\n        //3. If data is same then check corresponding left and right of both the heads.\n        if(p->val == q->val){\n            return (isSameTree(p->left,q->left) && isSameTree(p->right,q->right));\n        }\n        //4. Else return false data is not same\n        return false;\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "public class Solution{public bool IsSameTree(TreeNode p,TreeNode q){return p==null&&q==null?true:p==null||q==null?false:p.val!=q.val?false:IsSameTree(p.left,q.left)&&IsSameTree(p.right,q.right);}}"
            },
            {
                "language": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\n   if p==nil && q==nil{\n       return true \n   } else if p==nil || q==nil{\n       return false\n   }\n    if (*p).Val==(*q).Val{\n        if isSameTree(p.Right, q.Right) && isSameTree(p.Left, q.Left){\n            if (*p).Val==(*q).Val{\n                return true\n            }\n        } \n    }\n   return false  \n\n}"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        \n        if(p == NULL && q == NULL){\n            return true;\n        }\n        if(p == NULL && q!= NULL){\n            return false;\n        }\n        if(p != NULL && q == NULL){\n            return false;\n        }\n\n        bool left = isSameTree(p->left,q->left);\n        bool right = isSameTree(p->right,q->right);\n\n        bool valueCheck = p->val == q->val;\n\n        if(left && right && valueCheck){\n           return true;\n        }\n        return false;\n\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution \n{\n    // it will be updated to false if we find size difference, or diff value\n    boolean value = true;\n\n    public boolean isSameTree(TreeNode p, TreeNode q) \n    {\n        if(p == null && q == null)\n            return true;\n\n        //one tree is null, while other is not\n        else if(p == null || q == null)\n            return false;\n\n        traverse(p, q);    \n        return value;           \n    }\n\n    public void traverse (TreeNode ptr1, TreeNode ptr2)\n    {\n        //same size if verified\n        if(ptr1 == null && ptr2 == null)\n            return;\n\n        // if one tree is diff then the other in size\n        else if(ptr1 == null || ptr2 == null)\n        {\n            value = false;\n            return;\n        }\n\n        traverse(ptr1.left, ptr2.left);\n\n        if(ptr1.val != ptr2.val)\n        {\n            value = false;\n            return;\n        }\n\n        traverse(ptr1.right, ptr2.right);\n    }\n}"
            }
        ]
    },
    "100": {
        "question_id": 101,
        "title": "Symmetric Tree",
        "difficulty": 1,
        "description": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). ",
        "examples": [
            {
                "input": "root = [1,2,2,3,4,4,3]",
                "output": "true",
                "explanation": null
            },
            {
                "input": "root = [1,2,2,null,3,null,3]",
                "output": "false",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [1, 1000].",
            "-100 <= Node.val <= 100"
        ],
        "solutions": [
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    bool isEqual(TreeNode*r1,TreeNode*r2){\n        //if we have both root to nullptr then we will return true"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    private boolean isMirror(TreeNode root1, TreeNode root2){\n        if(root1 == null && root2 == null){\n            return true;\n        }\n        if(root1 == null || root2 == null){\n            return false;\n        }\n        return root1.val == root2.val && isMirror(root1.left, root2.right) && isMirror(root1.right, root2.left);"
            },
            {
                "language": "cpp",
                "code": "public:\n    bool isSymmetric(TreeNode* root) {\n        queue<TreeNode*> tree_left, tree_right;\n        tree_left.push(root->left);\n        tree_right.push(root->right);\n        while(!tree_left.empty() && !tree_right.empty()){\n            if(tree_left.front() == NULL && tree_right.front() == NULL){\n                tree_left.pop();"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public boolean isSymmetric(TreeNode root) {\n     if(root==null)  return true;\n     return isSame(root.left,root.right);   \n    }\n     public static boolean isSame(TreeNode l,TreeNode r){\n     if(l==null && r==null) return true;\n     if(l==null || r==null) return l==r;"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return isMirror(root, root);\n    }\n    private boolean isMirror(TreeNode n1, TreeNode n2){\n        if(n1==null && n2==null)\n            return true;\n        if(n1!=null && n2!=null && n1.val==n2.val)"
            },
            {
                "language": "rust",
                "code": "bool isSymmetricHelp(TreeNode* left, TreeNode* right){\n    if(left == NULL || right == NULL)\n        return left==right;\n    if(left->val != right->val) return false;"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\n\n        def checkIsSameTree(root1, root2):\n            if not root1 and not root2:\n                return True\n            if (not root1 and root2) or (root1 and not root2):"
            },
            {
                "language": "kotlin",
                "code": ""
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\n\n        def helper(root1, root2):\n            if root1 is None and root2 is None:\n                return True\n            if root1 is None and root2 is not None or root1 is not None and root2 is None:\n                return False"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isSymmetricHelper(TreeNode* leftNode, TreeNode* rightNode){\n        if(leftNode==NULL && rightNode==NULL) return true;\n        if(leftNode==NULL || rightNode==NULL || leftNode->val != rightNode->val) return false;\n        \n        return isSymmetricHelper(leftNode->left, rightNode->right) && isSymmetricHelper(leftNode->right, rightNode->left);\n    }\n\n    bool isSymmetric(TreeNode* root) {\n        if(root == NULL) return true;\n        return isSymmetricHelper(root->left, root->right);\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        if(root == NULL) return true;\n\n        queue<TreeNode*> q;\n        q.push(root->left);\n        q.push(root->right);\n        while(!q.empty()){\n            TreeNode* leftNode = q.front();\n            q.pop();\n            TreeNode* rightNode = q.front();\n            q.pop();\n\n            if(leftNode==NULL && rightNode==NULL) continue;\n            if(leftNode==NULL || rightNode==NULL || leftNode->val != rightNode->val) return false;\n            q.push(leftNode->left);\n            q.push(rightNode->right);\n            q.push(leftNode->right);\n            q.push(rightNode->left);\n        }\n        return true;\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return isMirror(root, root);\n    }\n    private boolean isMirror(TreeNode n1, TreeNode n2){\n        if(n1==null && n2==null)\n            return true;\n        if(n1!=null && n2!=null && n1.val==n2.val)"
            },
            {
                "language": "kotlin",
                "code": "public boolean isSymmetric(TreeNode root) {\n        return dfs(root.left,root.right);        \n    }\n    private boolean dfs(TreeNode root1,TreeNode root2){\n        if(root1==null && root2==null) return true;\n        if((root1==null || root2==null)) return false;\n        return (root1.val==root2.val)&&dfs(root1.left,root2.right) && dfs(root1.right,root2.left);\n    }"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n    if(!root) return 1;\n    queue<TreeNode*> q;\n    q.push(root), q.push(root);\n    while(!q.empty()) {\n        TreeNode* n(q.front());\n        q.pop();\n        TreeNode* n2(q.front());\n        q.pop();\n        if(n==nullptr and n2==nullptr) continue;\n        if(n==nullptr or n2==nullptr or n->val!=n2->val) return 0;\n        q.push(n->left), q.push(n2->right), q.push(n->right), q.push(n2->left);\n    }\n    return 1;\n    }\n};"
            },
            {
                "language": "cpp",
                "code": "class Solution {\nprivate:\n    bool isEquivalent(TreeNode* left, TreeNode* right) {\n        if (!left || !right) return left == right;\n        else return left->val == right->val && isEquivalent(left->left, right->right) && isEquivalent(right->left, left->right);\n    }\n\npublic:\n    bool isSymmetric(TreeNode* root) {\n        return isEquivalent(root->left, root->right);\n    }\n};"
            },
            {
                "language": "java",
                "code": "class Solution {\n    private boolean isEquivalent(TreeNode left, TreeNode right) {\n        if (left==null || right==null) return left == right;\n        else return left.val == right.val && isEquivalent(left.left, right.right) && isEquivalent(left.right, right.left);\n    }\n\n    public boolean isSymmetric(TreeNode root) {\n        return isEquivalent(root.left, root.right);\n    }\n}"
            },
            {
                "language": "rust",
                "code": "Thanks for visiting my solution.\ud83d\ude0a Keep Learning\nPlease give my solution an upvote! \ud83d\udc4d\nIt's a simple way to show your appreciation and\nkeep me motivated. Thank you! \ud83d\ude0a"
            },
            {
                "language": "kotlin",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    static boolean mir( TreeNode t1 , TreeNode t2 )\n    {\n        if( t1==null && t2== null ) return true;\n        else if( t1==null || t2==null ) return false;\n\n        return ( t1.val==t2.val ) && mir( t1.right , t2.left ) && mir( t1.left , t2.right );\n    }\n    public boolean isSymmetric(TreeNode root) \n    {\n        return mir( root , root );\n    \n    }\n}"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    bool isEqual(TreeNode*r1,TreeNode*r2){\n        //if we have both root to nullptr then we will return true\n        //else we will be returning false\n        \n        if(!r1||!r2)\n            return r1==r2;\n        //if not null then we will check for the r1 and r2 values\n        if(r1->val==r2->val){\n        //we will check for the r1 left and r2 right because they will be on opposite sides\n            return isEqual(r1->left,r2->right)&&isEqual(r1->right,r2->left);\n        }\n        //if r1 val not equal to r2 val then return false\n        return false;\n    }\n    bool isSymmetric(TreeNode* root) {\n        //The Approach is simple i.e. we will have to check if \n            //1. the right and left is equal \n        return isEqual(root->left,root->right);\n    }\n};"
            },
            {
                "language": "kotlin",
                "code": "public boolean isSymmetric(TreeNode root) {\n        return dfs(root.left,root.right);        \n    }\n    private boolean dfs(TreeNode root1,TreeNode root2){\n        if(root1==null && root2==null) return true;\n        if((root1==null || root2==null)) return false;\n        return (root1.val==root2.val)&&dfs(root1.left,root2.right) && dfs(root1.right,root2.left);\n    }"
            },
            {
                "language": "go",
                "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nvar answer bool\nfunc isSymmetric(root *TreeNode) bool {\n    answer = true\n    if root != nil{\n        recurseSymmetric(root.Left, root.Right)\n    }\n    return answer\n}\n\nfunc recurseSymmetric(root1, root2 *TreeNode){\n    if root1 == nil && root2 == nil || answer == false {\n        return\n    }\n    if root1 == nil || root2 == nil || root1.Val != root2.Val{\n        answer = false\n        return\n    }\n    recurseSymmetric(root1.Left, root2.Right)\n    recurseSymmetric(root1.Right, root2.Left)\n}"
            },
            {
                "language": "kotlin",
                "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isSymmetric = function(root) {\n    if(!root) return true;\n    return symmetryChk(root.left , root.right);\n};\n    \nconst symmetryChk = function (leftNode , rightNode) {\n    if (!leftNode && !rightNode) return true;\n    if(!leftNode || !rightNode) return false;\n    if(leftNode.val !== rightNode.val) return false;\n\n    return (symmetryChk(leftNode.left , rightNode.right) && symmetryChk(leftNode.right , rightNode.left));\n};"
            }
        ]
    }
}