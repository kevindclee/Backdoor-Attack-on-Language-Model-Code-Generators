{
    "0": {
        "question_id": 1,
        "title": "Two Sum",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/two-sum",
        "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.You may assume that each input would have exactly one solution, and you may not use the same element twice.You can return the answer in any order. ",
        "examples": [
            {
                "input": "nums = [2,7,11,15], target = 9",
                "output": "[0,1]",
                "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
            },
            {
                "input": "nums = [3,2,4], target = 6",
                "output": "[1,2]",
                "explanation": null
            },
            {
                "input": "nums = [3,3], target = 6",
                "output": "[0,1]",
                "explanation": null
            }
        ],
        "constraints": [
            "2 <= nums.length <= 10^4",
            "-10^9 <= nums[i] <= 10^9",
            "-10^9 <= target <= 10^9",
            "Only one valid answer exists."
        ],
        "solutions": [
            {
                "language": "python",
                "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \n        d = {}\n        for i, j in enumerate(nums):\n            r = target - j\n            if r in d: return [d[r], i]\n            d[j] = i\n  \n  # An Upvote will be encouraging",
                "url": "https://leetcode.com/problems/two-sum/solutions/2361743/python-java-c-simple-solution-o-n-time-o-n-space/",
                "vote_count": "1356"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                if (nums[i] + nums[j] == target) {\n                    return {i, j};\n                }\n            }\n        }\n        return {};\n    }\n};",
                "url": "https://leetcode.com/problems/two-sum/solutions/2990807/solution-c-java-python-both-brute-force-optimized-code/",
                "vote_count": "605"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int n=nums.length;\n        Map<Integer,Integer> map=new HashMap<>();\n        int[] result=new int[2];\n        for(int i=0;i<n;i++){\n            if(map.containsKey(target-nums[i])){\n                result[1]=i;\n                result[0]=map.get(target-nums[i]);\n                return result;\n            }\n            map.put(nums[i],i);\n        }\n        return result;\n    }\n}",
                "url": "https://leetcode.com/problems/two-sum/solutions/2671539/java-100-runtime-easy-to-understand/",
                "vote_count": "359"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] result = new int[2];\n        Map<Integer,Integer> map = new HashMap<>();\n        \n        for(int i=0; i<nums.length; i++){\n            if(map.containsKey(target - nums[i])){\n                result[1] = i;",
                "url": "https://leetcode.com/problems/two-sum/solutions/2671539/java-100-runtime-easy-to-understand/",
                "vote_count": "359"
            },
            {
                "language": "",
                "code": "1. 9 - 2 = 7\n2. 9 - 7 = 2",
                "url": "https://leetcode.com/problems/two-sum/solutions/3000141/javascript-w-map-time-space-o-n/",
                "vote_count": "85"
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    let mp = new Map()\n    \n    for (let i = 0; i < nums.length; i++) {\n        let diff = target - nums[i]\n        \n        if (mp.has(diff)) {\n            return [i, mp.get(diff)]\n        }\n        \n        mp.set(nums[i], i)\n    }\n};",
                "url": "https://leetcode.com/problems/two-sum/solutions/3000141/javascript-w-map-time-space-o-n/",
                "vote_count": "85"
            },
            {
                "language": "javascript",
                "code": "/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number[]}\n*/\nvar twoSum = function (nums, target) {\n   const mp = {}",
                "url": "https://leetcode.com/problems/two-sum/solutions/3000141/javascript-w-map-time-space-o-n/",
                "vote_count": "85"
            },
            {
                "language": "javascript",
                "code": "for (let i = 0; i < nums.length; i++) {\n    const pairNum = target - nums[i];\n    const indexOfNum = nums.indexOf(pairNum);\n\n    if (indexOfNum !== -1 && indexOfNum !== i) {\n        return [i, indexOfNum];\n    }\n}",
                "url": "https://leetcode.com/problems/two-sum/solutions/3000141/javascript-w-map-time-space-o-n/",
                "vote_count": "85"
            },
            {
                "language": "typescript",
                "code": "for(let i = 0; i<nums.length; i++) {\n\n    let diff: number = Math.abs(nums[i] - target);",
                "url": "https://leetcode.com/problems/two-sum/solutions/3000141/javascript-w-map-time-space-o-n/",
                "vote_count": "85"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        for(int i = 0;i < nums.size();i++){\n            for(int j = i+1;j<nums.size();j++){\n            if(nums[i] + nums[j] == target) return {i,j};\n          }\n        }\n    return {};\n    }\n};",
                "url": "https://leetcode.com/problems/two-sum/solutions/3216105/two-pointers-approach-c-simple-and-easy-c/",
                "vote_count": "72"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        dict={}\n        for i,n in enumerate(nums):\n            if n in dict:\n                return dict[n],i\n            else:\n                dict[target-n]=i\n    #please upvote me it would encourage me alot",
                "url": "https://leetcode.com/problems/two-sum/solutions/3307600/hash-table-concept-python3/",
                "vote_count": "51"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        prevMap = {} # val : index\n        \n        for i, n in enumerate(nums):\n            diff = target - n\n            if diff in prevMap:\n                return [prevMap[diff], i]\n            prevMap[n] = i\n        return",
                "url": "https://leetcode.com/problems/two-sum/solutions/3366532/100-solution-explained/",
                "vote_count": "25"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (nums[i] + nums[j] == target) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        return new int[]{-1, -1};\n    }\n}",
                "url": "https://leetcode.com/problems/two-sum/solutions/3343810/easy-solution-for-a-beginner-simple-2-approaches-2-languages/",
                "vote_count": "16"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<pair<int,int>> temp;\n        for(int i=0;i<nums.size();i++){\n            temp.push_back({nums[i],i});\n        }\n        sort(temp.begin(),temp.end());\n        int x=0,y=nums.size()-1;\n        while(x<y){\n            int sum=temp[x].first+temp[y].first;\n            if(sum==target)\n                return {temp[x].second,temp[y].second};\n            else if(sum<target)\n                x++;\n            else{\n                y--;\n            }\n        }\n        return {-1,-1};\n    }\n};",
                "url": "https://leetcode.com/problems/two-sum/solutions/3343810/easy-solution-for-a-beginner-simple-2-approaches-2-languages/",
                "vote_count": "16"
            }
        ]
    },
    "1": {
        "question_id": 2,
        "title": "Add Two Numbers",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/add-two-numbers",
        "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself. ",
        "examples": [
            {
                "input": "l1 = [2,4,3], l2 = [5,6,4]",
                "output": "[7,0,8]",
                "explanation": "342 + 465 = 807."
            },
            {
                "input": "l1 = [0], l2 = [0]",
                "output": "[0]",
                "explanation": null
            },
            {
                "input": "l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]",
                "output": "[8,9,9,9,0,0,0,1]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in each linked list is in the range [1, 100].",
            "0 <= Node.val <= 9",
            "It is guaranteed that the list represents a number that does not have leading zeros."
        ],
        "solutions": [
            {
                "language": "rust",
                "code": "ListNode* deleteDuplicates(ListNode* head) {\n    if(!head) return head;\n    ListNode *t = head, *p = head->next;\n    int pre = head->val;\n    while(p) {\n        if(pre != p->val) {\n            t->next = p;\n            pre = p->val;\n            t = t->next;\n        }\n        p = p->next;\n    }\n    t->next = NULL;\n    return head;\n}",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/1340/a-summary-about-how-to-solve-linked-list-problem-c/",
                "vote_count": "1933"
            },
            {
                "language": "rust",
                "code": "ListNode* deleteDuplicates(ListNode* head) {\n ListNode* dummy = new ListNode(0);\n dummy->next = head;\n ListNode* cur = dummy;\n int duplicate;\n while (cur->next && cur->next->next) {\n  if (cur->next->val == cur->next->next->val) {\n   duplicate = cur->next->val;\n   while (cur->next && cur->next->val == duplicate) \n    cur->next = cur->next->next;\n  }\n  else cur = cur->next;\n }\n return dummy->next;\n}",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/1340/a-summary-about-how-to-solve-linked-list-problem-c/",
                "vote_count": "1933"
            },
            {
                "language": "kotlin",
                "code": "ListNode* deleteDuplicates(ListNode* head) {\n    if (!head) return 0;\n    if (!head->next) return head;\n    int val = head->val;\n    ListNode* p = head->next;\n    if (p->val != val) { head->next = deleteDuplicates(p); return head;} \n    else { \n        while (p && p->val == val) p = p->next; \n        return deleteDuplicates(p); \n    }\n}",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/1340/a-summary-about-how-to-solve-linked-list-problem-c/",
                "vote_count": "1933"
            },
            {
                "language": "cpp",
                "code": "bool isPalindrome(ListNode* head) {\n    vector<int> v;\n    while(head) {\n        v.push_back(head->val);\n        head = head->next;\n    }\n    for(int i = 0; i < v.size()/2; ++i) {\n        if(v[i] != v[v.size()-i-1]) return false;\n    }\n    return true;\n}",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/1340/a-summary-about-how-to-solve-linked-list-problem-c/",
                "vote_count": "1933"
            },
            {
                "language": "rust",
                "code": "bool isPalindrome(ListNode* head) {\n    if(!head || !head->next) return true;\n    ListNode *slow = head, *fast = head->next;\n    while(fast && fast->next) {//split into two halves while the first half can be one-node longer;\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    fast = slow->next;\n    slow->next = NULL;\n    ListNode newHead(0); //reverse the second half;\n    ListNode *next = NULL, *p = fast;\n    while(p) {\n        next = p->next;\n        p->next = newHead.next;\n        newHead.next = p;\n        p = next;\n    }\n    fast = newHead.next; //compare the two lists;\n    while(fast) {\n        if(fast->val != head->val) return false;\n        fast = fast->next;\n        head = head->next;\n    }\n    return fast == NULL;\n}",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/1340/a-summary-about-how-to-solve-linked-list-problem-c/",
                "vote_count": "1933"
            },
            {
                "language": "ruby",
                "code": "ListNode* rotateRight(ListNode* head, int k) {\n    if(!head) return head;\n    int len = 1;\n    ListNode *p = head;\n    while(p->next) { len++; p = p->next; }\n    p->next = head;\n    if(k %= len)\n        for(int i = 0; i < len-k; ++i, p=p->next) ; \n    ListNode* newHead = p->next;\n    p->next = NULL;\n    return newHead;\n}",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/1340/a-summary-about-how-to-solve-linked-list-problem-c/",
                "vote_count": "1933"
            },
            {
                "language": "ruby",
                "code": "ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    int c = 0;\n    ListNode newHead(0);\n    ListNode *t = &newHead;\n    while(c || l1 || l2) {\n        c += (l1? l1->val : 0) + (l2? l2->val : 0);\n        t->next = new ListNode(c%10);\n        t = t->next;\n        c /= 10;\n        if(l1) l1 = l1->next;\n        if(l2) l2 = l2->next;\n    }\n    return newHead.next;\n}",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/1340/a-summary-about-how-to-solve-linked-list-problem-c/",
                "vote_count": "1933"
            },
            {
                "language": "cpp",
                "code": "ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    if(!l1 && !l2) return NULL;\n    int c = (l1? l1->val:0) + (l2? l2->val:0);\n    ListNode *newHead = new ListNode(c%10), *next = l1? l1->next:NULL;\n    c /= 10;\n    if(next) next->val += c;\n    else if(c) next = new ListNode(c);\n    newHead->next = addTwoNumbers(l2? l2->next:NULL, next);\n    return newHead;\n}",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/1340/a-summary-about-how-to-solve-linked-list-problem-c/",
                "vote_count": "1933"
            },
            {
                "language": "ruby",
                "code": "ListNode* reverseBetween(ListNode* head, int m, int n) {\n    ListNode newHead(0);\n    newHead.next = head;\n    ListNode *pre = &newHead, *cur = head, *next = NULL;\n    int i = 1;\n    while(i < n) {\n        if(i++ < m) { pre = cur; cur = cur->next; }\n        else { \n            next = cur->next; \n            cur->next = cur->next->next; \n            next->next = pre->next; \n            pre->next = next; \n        }\n    }\n    return newHead.next;\n}",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/1340/a-summary-about-how-to-solve-linked-list-problem-c/",
                "vote_count": "1933"
            },
            {
                "language": "ruby",
                "code": "ListNode *detectCycle(ListNode *head) {\n    ListNode *slow = head, *fast = head;   \n    while(fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if(slow == fast) break;\n    }\n    if(slow != fast) return NULL;\n    fast = head;\n    while(fast && fast->next) {\n        if(slow == fast) return slow;\n        slow = slow->next;\n        fast = fast->next;\n    }\n    return NULL;\n}",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/1340/a-summary-about-how-to-solve-linked-list-problem-c/",
                "vote_count": "1933"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    unordered_map<RandomListNode*, RandomListNode*> cloneMap;\n    RandomListNode *helper(RandomListNode* head){\n        if(head == NULL) return NULL;\n        if(cloneMap.count(head)) return cloneMap[head];\n        RandomListNode *cloned = new RandomListNode(head->label);\n        cloneMap[head] = cloned; //crucial;\n        cloned->next = helper(head->next);\n        cloned->random = helper(head->random);\n        return cloned;\n    }\npublic:\n    RandomListNode *copyRandomList(RandomListNode *head) {\n        return helper(head);\n    } \n};",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/1340/a-summary-about-how-to-solve-linked-list-problem-c/",
                "vote_count": "1933"
            },
            {
                "language": "rust",
                "code": "RandomListNode *copyRandomList(RandomListNode *head) {\n RandomListNode newHead(0), *p = head, *t = NULL;\n while(p) {\n  RandomListNode *cloned = new RandomListNode(p->label);\n  cloned->next = p->next;\n  p->next = cloned;\n  p = cloned->next;\n }\n p = head;\n while(p && p->next) {\n  if(p->random) p->next->random = p->random->next;\n  p = p->next->next;\n }\n p = head;\n t = &newHead;\n while(p && p->next) {\n  t->next = p->next;\n  p->next = p->next->next;\n  t = t->next;\n  p = p->next;\n }\n t->next = NULL;\n return newHead.next;\n}",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/1340/a-summary-about-how-to-solve-linked-list-problem-c/",
                "vote_count": "1933"
            },
            {
                "language": "rust",
                "code": "ListNode* reverseKGroup(ListNode* head, int k) {\n if(!head || !head->next) return head;\n ListNode newHead(0);\n ListNode *pre = &newHead, *cur = head, *next = NULL;\n newHead.next = head;\n int len = 0;\n for(ListNode *p = head; p; p = p->next) len++;\n int times = len/k;\n while(times) {\n  for(int i = 1; i < k; ++i) {\n   next = cur->next;\n   cur->next = cur->next->next;\n   next->next = pre->next;\n   pre->next = next;\n   if(i == k-1) {\n    pre = cur;\n    cur = cur->next;\n   }\n  }\n  times--;\n }\n return newHead.next;\n}",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/1340/a-summary-about-how-to-solve-linked-list-problem-c/",
                "vote_count": "1933"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummy=new ListNode();\n        ListNode* temp=dummy;\n        int carry=0;\n        while(l1!=NULL || l2!=NULL || carry){\n            int sum=0;\n            if(l1!=NULL){\n                sum+=l1->val;\n                l1=l1->next;\n            }\n            if(l2!=NULL){\n                sum+=l2->val;\n                l2=l2->next;\n            }\n            sum+=carry;\n            carry=sum/10;\n            ListNode* newnode=new ListNode(sum%10);\n            temp->next=newnode;\n            temp=temp->next;\n        }\n        return dummy->next;\n    }\n};\nif it helps plzz dont't forget to upvote it :)",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/2759116/c-easy-to-understand/",
                "vote_count": "682"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0); // creating an dummy list\n        ListNode curr = dummy; // intialising an pointer\n        int carry = 0; // intialising our carry with 0 intiall\n        // while loop will run, until l1 OR l2 not reaches null OR if they both reaches null. But our carry has some value in it. \n  // We will add that as well into our list\n        while(l1 != null || l2 != null || carry == 1){\n            int sum = 0; // intialising our sum\n            if(l1 != null){ // adding l1 to our sum & moving l1\n                sum += l1.val;\n                l1 = l1.next;\n            }\n            if(l2 != null){ // adding l2 to our sum & moving l2\n                sum += l2.val;\n                l2 = l2.next;\n            }\n            sum += carry; // if we have carry then add it into our sum\n            carry = sum/10; // if we get carry, then divide it by 10 to get the carry\n            ListNode node = new ListNode(sum % 10); // the value we'll get by moduloing it, will become as new node so. add it to our list\n            curr.next = node; // curr will point to that new node if we get\n            curr = curr.next; // update the current every time\n        }\n        return dummy.next; // return dummy.next bcz, we don't want the value we have consider in it intially!!\n    }\n}",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/1835535/java-c-a-very-beautiful-explanation-ever-exists/",
                "vote_count": "421"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode *dummy = new ListNode(0);\n        ListNode *curr = dummy;\n        int carry = 0;\n        \n        while(l1 != NULL || l2 != NULL || carry == 1){\n            int sum = 0;\n            if(l1 != NULL){\n                sum += l1->val;\n                l1 = l1->next;\n            }\n            if(l2 != NULL){\n                sum += l2->val;\n                l2 = l2->next;\n            }\n            sum += carry;\n            carry = sum/10;\n            ListNode *node = new ListNode(sum % 10);\n            curr->next = node;\n            curr = curr->next;\n        }\n        return dummy->next;\n    }\n};",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/1835535/java-c-a-very-beautiful-explanation-ever-exists/",
                "vote_count": "421"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dH = new ListNode(-1);\n        ListNode newHead = dH;\n        int carry = 0;\n        \n        while(l1!=null || l2!=null) {\n            int a = l1 == null ? 0 : l1.val;",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/1835535/java-c-a-very-beautiful-explanation-ever-exists/",
                "vote_count": "421"
            },
            {
                "language": "rust",
                "code": "class Solution\n{\npublic:\n    int carry = 0;\n    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2)\n    {\n        if (!l1 and !l2)\n        {",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/1835535/java-c-a-very-beautiful-explanation-ever-exists/",
                "vote_count": "421"
            },
            {
                "language": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        dummy = ListNode()\n        curr = dummy\n        carry = 0\n        while l1 or l2 or carry:\n            val = carry\n            if l1:\n                val += l1.val\n                l1 = l1.next\n            if l2:\n                val += l2.val\n                l2 = l2.next\n            carry, val = divmod(val, 10)\n            curr.next = ListNode(val)\n            curr = curr.next\n        return dummy.next",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/3160216/python-simple-solution-youtube-link-attached/",
                "vote_count": "85"
            },
            {
                "language": "javascript",
                "code": "var addTwoNumbers = function(l1, l2) {\n    const iter = (n1, n2, rest = 0) => {\n        if (!n1 && !n2 && !rest) return null;\n        const newVal = (n1?.val || 0) + (n2?.val || 0) + rest;\n        const nextNode = iter(n1?.next, n2?.next, Math.floor(newVal / 10));\n        return new ListNode(newVal % 10, nextNode);\n    }\n    return iter(l1, l2);\n};",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/3076872/javascript-simple-upvote-if/",
                "vote_count": "46"
            },
            {
                "language": "javascript",
                "code": "const numberOne = parseInt(l1.reverse('').join(''))\nconst numberTwo = parseInt(l2.reverse('').join(''))\nconst result = (numberOne + numberTwo)\nconst resultString = result.toString().split('').reverse('')\nconst resultArray = resultString.map( digito => parseInt(digito))\nreturn resultArray",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/3076872/javascript-simple-upvote-if/",
                "vote_count": "46"
            },
            {
                "language": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        d = n = ListNode(0)\n        num1 = num2 = \"\"\n        while l1:\n            num1 += str(l1.val)\n            l1 = l1.next\n        while l2:\n            num2 += str(l2.val)\n            l2 = l2.next\n        res = str(int(num1[::-1]) + int(num2[::-1]))[::-1]\n        for i in res:\n            d.next = ListNode(i)\n            d = d.next\n        return n.next    ",
                "url": "https://leetcode.com/problems/add-two-numbers/solutions/3330972/easy-solution-python-linked-list/",
                "vote_count": "12"
            }
        ]
    },
    "2": {
        "question_id": 3,
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters",
        "description": "Given a string s, find the length of the longest substring without repeating characters. ",
        "examples": [
            {
                "input": "s = \"abcabcbb\"",
                "output": "3",
                "explanation": "The answer is \"abc\", with the length of 3."
            },
            {
                "input": "s = \"bbbbb\"",
                "output": "1",
                "explanation": "The answer is \"b\", with the length of 1."
            },
            {
                "input": "s = \"pwwkew\"",
                "output": "3",
                "explanation": "The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring."
            }
        ],
        "constraints": [
            "0 <= s.length <= 5 * 10^4",
            "s consists of English letters, digits, symbols and spaces."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "Given a string s, find the length of the longest substring without repeating characters.",
                "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/2133524/java-c-a-reall-detailed-explanation/",
                "vote_count": "589"
            },
            {
                "language": "csharp",
                "code": "To, find out a sliding window problem :-\n> First thing is, we have given something like an \"Array\" | OR | \"String\"\n> Second thing is, they are talking about either \"subsequence\" | OR | \"substring\"\n> And third most thing is, either we have given a \"window size i.e. k\" | OR | we have to \"manually find out window size\" ",
                "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/2133524/java-c-a-reall-detailed-explanation/",
                "vote_count": "589"
            },
            {
                "language": "rust",
                "code": "> Are they talking about, \"Array\" or \"String\" --> yes they are talking about \"string\" +1 point\n> Are they asking to find out \"subsequence\" or \"substring\" --> yes they are talking about \"substring\" +1 point\n> Do, we have given a window size --> No, we don't have\n\nTotal score is \"2 / 3\" so, it's a 100% sliding window problem. If your score lies from 2/3 to 3/3 that's a gauranteed sliding window problem ",
                "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/2133524/java-c-a-reall-detailed-explanation/",
                "vote_count": "589"
            },
            {
                "language": "kotlin",
                "code": "while(j < size()){\n\n    // Calculation's happen's here\n-----------------------------------------------\n    if(condition < k){\n        j++;\n    }\n-----------------------------------------------\n\n-----------------------------------------------\n    else if(condition == k){\n        // ans <-- calculation\n        j++;\n    }\n----------------------------------------------\n\n----------------------------------------------\n    else if(condition > k){\n        while(condition > k){\n            // remove calculation for i\n            i++;\n        }\n        j++;\n    }\n----------------------------------------------\n}\nreturn ans;",
                "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/2133524/java-c-a-reall-detailed-explanation/",
                "vote_count": "589"
            },
            {
                "language": "javascript",
                "code": "Input: s = \"abcabcbb\"\nOutput: 3",
                "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/2133524/java-c-a-reall-detailed-explanation/",
                "vote_count": "589"
            },
            {
                "language": "rust",
                "code": "Let's understand it visually :-",
                "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/2133524/java-c-a-reall-detailed-explanation/",
                "vote_count": "589"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int i = 0;\n        int j = 0;\n        int max = 0;\n        while(j < s.length()){\n            map.put(s.charAt(j), map.getOrDefault(s.charAt(j), 0) + 1);\n            if(map.size() == j - i + 1){\n                max = Math.max(max, j - i + 1);\n                j++;\n            }\n            else if(map.size() < j - i + 1){\n                while(map.size() < j - i + 1){\n                    map.put(s.charAt(i), map.get(s.charAt(i)) - 1);\n                    if(map.get(s.charAt(i)) == 0) map.remove(s.charAt(i));\n                    i++;\n                }\n                j++;\n            }\n        }\n        return max;\n    }\n}",
                "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/2133524/java-c-a-reall-detailed-explanation/",
                "vote_count": "589"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if(s.length()==0)return 0;   //if string of length zero comes simply return 0\n        unordered_map<char,int> m;   //create map to store frequency,(get to know all unique characters\n        int i=0,j=0,ans=INT_MIN; \n        while(j<s.length())   \n        {\n            m[s[j]]++;  //increase the frequency of the element as you traverse the string\n            if(m.size()==j-i+1)  // whem map size is equal to the window size means suppose window size is 3 and map size is also three that means in map all unique characters are their\n            {\n                ans = max(ans,j-i+1);  //compare the length of the maximum window size\n            }\n            else if(m.size()<j-i+1)   //if the map size is less than the window size means there is some duplicate present like window size = 3 and map size = 2 means there is a duplicates\n            {\n                while(m.size()<j-i+1)  //so till the duplicates are removed completely\n                {\n                    m[s[i]]--;   //remove the duplicates\n                    if(m[s[i]]==0)  //if the frequency becomes zero \n                    {\n                        m.erase(s[i]);//delete it completely\n                    }\n                    i++;  //go for next element \n                }\n            }\n             j++;  //go for the next element\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/2133524/java-c-a-reall-detailed-explanation/",
                "vote_count": "589"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Set<Character>set=new HashSet<>();\n        int maxLength=0;\n        int left=0;\n        for(int right=0;right<s.length();right++){\n           \n            if(!set.contains(s.charAt(right))){\n                set.add(s.charAt(right));\n                maxLength=Math.max(maxLength,right-left+1);\n                \n            }else{\n                while(s.charAt(left)!=s.charAt(right)){\n                    set.remove(s.charAt(left));\n                    left++;\n                }\n                set.remove(s.charAt(left));left++;\n                set.add(s.charAt(right));\n            }\n            \n        }\n        return maxLength;\n    }\n}",
                "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/3157485/used-hashset-in-java-explained-approach/",
                "vote_count": "307"
            },
            {
                "language": "python",
                "code": "    public int lengthOfLongestSubstring(String s) {\n        Set<Character> set = new HashSet();\n        int max = 0;\n        int left = 0;\n        for (int right = 0; right < s.length(); right++) {\n            while(!set.add(s.charAt(right))) {\n                set.remove(s.charAt(left++));\n            }",
                "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/3157485/used-hashset-in-java-explained-approach/",
                "vote_count": "307"
            },
            {
                "language": "csharp",
                "code": "var lengthOfLongestSubstring = function (s) {\n    let set = new Set();\n    let left = 0;\n    let maxSize = 0;\n\n    if (s.length === 0) return 0;\n    if (s.length === 1) return 1;\n\n    for (let i = 0; i < s.length; i++) {\n\n        while (set.has(s[i])) {\n            set.delete(s[left])\n            left++;\n        }\n        set.add(s[i]);\n        maxSize = Math.max(maxSize, i - left + 1)\n    }\n    return maxSize;\n}",
                "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/2694302/js-98-sliding-window-with-exlanation/",
                "vote_count": "104"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if(s.length()==0)return 0;   //if string of length zero comes simply return 0\n        unordered_map<char,int> m;   //create map to store frequency,(get to know all unique characters\n        int i=0,j=0,ans=INT_MIN; \n        while(j<s.length())   \n        {\n            m[s[j]]++;  //increase the frequency of the element as you traverse the string\n            if(m.size()==j-i+1)  // whem map size is equal to the window size means suppose window size is 3 and map size is also three that means in map all unique characters are their\n            {\n                ans = max(ans,j-i+1);  //compare the length of the maximum window size\n            }\n            else if(m.size()<j-i+1)   //if the map size is less than the window size means there is some duplicate present like window size = 3 and map size = 2 means there is a duplicates\n            {\n                while(m.size()<j-i+1)  //so till the duplicates are removed completely\n                {\n                    m[s[i]]--;   //remove the duplicates\n                    if(m[s[i]]==0)  //if the frequency becomes zero \n                    {\n                        m.erase(s[i]);//delete it completely\n                    }\n                    i++;  //go for next element \n                }\n            }\n             j++;  //go for the next element\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/3279507/best-c-fast-solution/",
                "vote_count": "88"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        char_set = set()\n        max_len, start = 0, 0\n        for i, c in enumerate(s):\n            while c in char_set:\n                char_set.remove(s[start])\n                start += 1\n            char_set.add(c)\n            max_len = max(max_len, i - start + 1)\n        return max_len\n\n  \n  # An Upvote will be encouraging   \n        ",
                "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/3160192/python-simple-solution-efficient-solution/",
                "vote_count": "76"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Set<Character>set=new HashSet<>();\n        int maxLength=0;\n        int left=0;\n        for(int right=0;right<s.length();right++){\n           \n            if(!set.contains(s.charAt(right))){\n                set.add(s.charAt(right));\n                maxLength=Math.max(maxLength,right-left+1);\n                \n            }else{\n                while(s.charAt(left)!=s.charAt(right)){\n                    set.remove(s.charAt(left));\n                    left++;\n                }\n                set.remove(s.charAt(left));left++;\n                set.add(s.charAt(right));\n            }\n            \n        }\n        return maxLength;\n    }\n}",
                "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/3278822/best-java-fast-solution/",
                "vote_count": "43"
            }
        ]
    },
    "3": {
        "question_id": 4,
        "title": "Median of Two Sorted Arrays",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.The overall run time complexity should be O(log (m+n)). ",
        "examples": [
            {
                "input": "nums1 = [1,3], nums2 = [2]",
                "output": "2.00000",
                "explanation": "merged array = [1,2,3] and median is 2."
            },
            {
                "input": "nums1 = [1,2], nums2 = [3,4]",
                "output": "2.50000",
                "explanation": "merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
            }
        ],
        "constraints": [
            "nums1.length == m",
            "nums2.length == n",
            "0 <= m <= 1000",
            "0 <= n <= 1000",
            "1 <= m + n <= 2000",
            "-10^6 <= nums1[i], nums2[i] <= 10^6"
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "[2 3 / 5 7]",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2471/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation/",
                "vote_count": "1707"
            },
            {
                "language": "",
                "code": "N        Index of L / R\n1               0 / 0\n2               0 / 1\n3               1 / 1  \n4               1 / 2      \n5               2 / 2\n6               2 / 3\n7               3 / 3\n8               3 / 4",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2471/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation/",
                "vote_count": "1707"
            },
            {
                "language": "lisp",
                "code": "(L + R)/2 = (A[(N-1)/2] + A[N/2])/2",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2471/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation/",
                "vote_count": "1707"
            },
            {
                "language": "csharp",
                "code": "[6 9 13 18]  ->   [# 6 # 9 # 13 # 18 #]    (N = 4)\nposition index     0 1 2 3 4 5  6 7  8     (N_Position = 9)\n    \n[6 9 11 13 18]->   [# 6 # 9 # 11 # 13 # 18 #]   (N = 5)\nposition index      0 1 2 3 4 5  6 7  8 9 10    (N_Position = 11)",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2471/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation/",
                "vote_count": "1707"
            },
            {
                "language": "python",
                "code": "A1: [# 1 # 2 # 3 # 4 # 5 #]    (N1 = 5, N1_positions = 11)\n\nA2: [# 1 # 1 # 1 # 1 #]     (N2 = 4, N2_positions = 9)",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2471/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation/",
                "vote_count": "1707"
            },
            {
                "language": "python",
                "code": " [# 1 # 2 # 3 # (4/4) # 5 #]    \n\n [# 1 / 1 # 1 # 1 #]   ",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2471/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation/",
                "vote_count": "1707"
            },
            {
                "language": "",
                "code": " L1 = A1[(C1-1)/2]; R1 = A1[C1/2];\n L2 = A2[(C2-1)/2]; R2 = A2[C2/2];",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2471/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation/",
                "vote_count": "1707"
            },
            {
                "language": "",
                "code": "    L1 = A1[(7-1)/2] = A1[3] = 4; R1 = A1[7/2] = A1[3] = 4;\n    L2 = A2[(2-1)/2] = A2[0] = 1; R2 = A1[2/2] = A1[1] = 1;",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2471/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation/",
                "vote_count": "1707"
            },
            {
                "language": "",
                "code": "L1 <= R1 && L1 <= R2 && L2 <= R1 && L2 <= R2",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2471/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation/",
                "vote_count": "1707"
            },
            {
                "language": "csharp",
                "code": "If we have L1 > R2, it means there are too many large numbers on the left half of A1, then we must move C1 to the left (i.e. move C2 to the right); \nIf L2 > R1, then there are too many large numbers on the left half of A2, and we must move C2 to the left.\nOtherwise, this cut is the right one. \nAfter we find the cut, the medium can be computed as (max(L1, L2) + min(R1, R2)) / 2;",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2471/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation/",
                "vote_count": "1707"
            },
            {
                "language": "cpp",
                "code": " double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n    int N1 = nums1.size();\n    int N2 = nums2.size();\n    if (N1 < N2) return findMedianSortedArrays(nums2, nums1); // Make sure A2 is the shorter one.\n    \n    int lo = 0, hi = N2 * 2;\n    while (lo <= hi) {\n        int mid2 = (lo + hi) / 2;   // Try Cut 2 \n        int mid1 = N1 + N2 - mid2;  // Calculate Cut 1 accordingly\n        \n        double L1 = (mid1 == 0) ? INT_MIN : nums1[(mid1-1)/2]; // Get L1, R1, L2, R2 respectively\n        double L2 = (mid2 == 0) ? INT_MIN : nums2[(mid2-1)/2];\n        double R1 = (mid1 == N1 * 2) ? INT_MAX : nums1[(mid1)/2];\n        double R2 = (mid2 == N2 * 2) ? INT_MAX : nums2[(mid2)/2];\n        \n        if (L1 > R2) lo = mid2 + 1;  // A1's lower half is too big; need to move C1 left (C2 right)\n        else if (L2 > R1) hi = mid2 - 1; // A2's lower half too big; need to move C2 left.\n        else return (max(L1,L2) + min(R1, R2)) / 2; // Otherwise, that's the right cut.\n    }\n    return -1;\n} ",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2471/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation/",
                "vote_count": "1707"
            },
            {
                "language": "java",
                "code": "    double findMedianSortedArrays(vector<int>& a1, vector<int>& a2) {\n        if (a1.size() > a2.size()) swap(a1, a2); // make sure a1 is shorter\n        \n        int n1 = a1.size(), n2 = a2.size();\n        \n        // range of a1 cut location: n1 means no right half for a1\n        int lo = 0, hi = n1;\n        while (lo <= hi) {",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2471/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation/",
                "vote_count": "1707"
            },
            {
                "language": "python",
                "code": " def findMedianSortedArrays(self, nums1, nums2):\n        N1, N2 = len(nums1), len(nums2)\n        if N1 < N2: \n            nums1, N1, nums2, N2 = nums2, N2, nums1, N1\n        l, r = 0, N2*2\n        while l <= r:",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2471/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation/",
                "vote_count": "1707"
            },
            {
                "language": "cpp",
                "code": "// Brute Force:\n               // 1.Merge Both Array\n              // 2.Sort them\n             // 3.Find Median\n            // TIME COMPLEXITY: O(n)+O(nlogn)+O(n)\n            // SPACE COMPLEXITY: O(1)\n \nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n       // Initialization some neccessary variables\n        vector<int>v;\n        \n        // store the array in the new array\n        for(auto num:nums1)   // O(n1)\n            v.push_back(num);\n        \n        for(auto num:nums2)  // O(n2)\n            v.push_back(num);\n        \n        // Sort the array to find the median\n        sort(v.begin(),v.end());  // O(nlogn)\n        \n        // Find the median and Return it\n        int n=v.size();  // O(n)\n        \n        return n%2?v[n/2]:(v[n/2-1]+v[n/2])/2.0;\n    }\n};\n\n** Accepted **",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2651020/c-solution/",
                "vote_count": "353"
            },
            {
                "language": "cpp",
                "code": "// Optimized Using: Two Pointer with Extra Space\n  // Time Complexity: O(m+n)\n  // Space Complexity: O(m+n)\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n        // Create a single sorted by merging two sorted arrays\n        int n1=nums1.size();\n        int n2=nums2.size();\n        int i=0;\n        int j=0;\n        int lastindex=-1;\n             \n        // Initialize a new array\n           vector<int>v(n1+n2,0);\n        \n        while(i<n1&&j<n2)\n        {\n            if(nums1[i]<=nums2[j])\n                v[++lastindex]=nums1[i++];\n            else\n                v[++lastindex]=nums2[j++];\n        }\n        \n        while(i<n1)\n            v[++lastindex]=nums1[i++];\n        while(j<n2)\n            v[++lastindex]=nums2[j++];\n        \n    // Return the result\n        int n=n1+n2;\n        return n%2?v[n/2]:(v[n/2]+v[n/2-1])/2.0;\n        \n    }\n};\n\n** Accepted **",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2651020/c-solution/",
                "vote_count": "353"
            },
            {
                "language": "cpp",
                "code": "// Optimized Using: Two Pointer without Extra Space (Insertion Sort)\n  // Time Complexity: O(n1*n2)\n  // Space Complexity: O(1)\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n       // Calculate Total length of final array: O(N)\n        int n1=nums1.size();  \n        int n2=nums2.size();\n        int n=n1+n2;  \n      \n        // Edge Cases\n        if(n2==0)\n            return n1%2?nums1[n1/2]:(nums1[n1/2-1]+nums1[n1/2])/2.0;\n        if(n1==0)\n             return n2%2?nums2[n2/2]:(nums2[n2/2-1]+nums2[n2/2])/2.0;\n        \n        // Resize the array 'nums1': O(N), N is size of resized array\n        nums1.resize(n);\n        \n        // Now use pointer to compare arrays elements \n        int i=0;\n        int j=0;\n        \n       // Store all element in 'array 1' in sorted order \n        while(i<n1)  // O(n1)\n        {\n            if(nums1[i]>nums2[0])\n            {\n                swap(nums1[i],nums2[0]);  // O(1)\n                // Rearrange Array nums2\n                rearrangeArray(nums2);  // O(n2)\n            }\n            i++;\n        }\n        \n        // Store remaining elements of 'array 2' in 'array 1' \n        while(j<nums2.size()) // O(n2)\n            nums1[i++]=nums2[j++];\n        \n    // Return Result\n    return n%2?nums1[n/2]:(nums1[n/2-1]+nums1[n/2])/2.0;\n        \n    }\n    \n    void rearrangeArray(vector<int>&nums2)\n    {\n        // Using insertion sort for insertion \n           // worst case Time Complexity Would be: O(n)\n        for(int i=1;i<nums2.size()&&nums2[i]<nums2[i-1];i++)\n            swap(nums2[i],nums2[i-1]);\n    }\n};\n\n** Accepted **",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2651020/c-solution/",
                "vote_count": "353"
            },
            {
                "language": "cpp",
                "code": "// Optimized Approach: Using gap method:\n    // Time Complexity: O((log base 2 power N)*(N))\n   //  Space Complexity: O(1)\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n        // Do some pre-calculation : O(N)\n        int n1=nums1.size();\n        int n2=nums2.size();\n        int n=n1+n2;\n        \n        // Now Create Two Pointer\n        int gap=ceil((n1+n2)/2.0);\n        int i=0;\n        int j=gap;\n        \n        // Edge Cases\n        if(n1==0)\n            return n2%2?nums2[n2/2]:(nums2[n2/2]+nums2[n2/2-1])/2.0;\n        \n        if(n2==0)\n            return n1%2?nums1[n1/2]:(nums1[n1/2]+nums1[n1/2-1])/2.0;\n        \n        // Apply gap method: O((log base 2 power N)*N)\n        \n       while(gap)\n       {   i=0;\n           j=gap;\n       // Move both pointer until they reach at last \n        while(j<n)\n        {\n            // If 'i' in 'nums1' and 'j' is also in 'nums1'\n            if(i<n1&&j<n1&&nums1[i]>nums1[j])\n            swap(nums1[i],nums1[j]);\n        else\n            // if 'i' in 'nums1' and 'j' is in 'nums2'\n            if(i<n1&&j>=n1&&nums1[i]>nums2[j-n1])\n                swap(nums1[i],nums2[j-n1]);\n        else \n            // if 'i' in 'nums2' and 'j' is also in 'nums2'\n            if(i>=n1&&j>=n1&&nums2[i-n1]>nums2[j-n1])\n                 swap(nums2[i-n1],nums2[j-n1]);\n            \n        // Move both pointer ahead by only one step\n        i++;\n        j++;\n        }\n        \n        // Edge Case, because of 'ceil()' gap never becomes zero\n        if(gap==1)\n            gap=0;\n         \n         gap=ceil(gap/2.0);\n       }   \n        \n    //Return Result\n      if(n%2)\n          return n/2<n1?nums1[n/2]:nums2[n/2-n1];\n     else\n         if(n/2<n1)\n             return (nums1[n/2]+nums1[n/2-1])/2.0;\n        else\n            if((n/2-1)<n1)\n               return (nums1[n/2-1]+nums2[n/2-n1])/2.0;\n       else \n           return (nums2[n/2-n1]+nums2[n/2-1-n1])/2.0;\n       \n    }\n};\n\n** Accepted **",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2651020/c-solution/",
                "vote_count": "353"
            },
            {
                "language": "cpp",
                "code": "// Optimized Approach: Binary Search\n    // Time Complexity: O(log(min(m,n)))\n   //  Space Complexity: O(1)\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n                   // ** Intuition  **\n        // I have to find out correct left half and correct right half\n          // i.e : // 7 ,  || 12 , 14 , 15  --> parition it\n                  //  1 , 2 , 3 , 4 , || 9 , 11  --> parition it\n                  // Now just findout max(left1,left2), min(right1,right2)\n        \n        \n        // Initilaization of some neccessary variables\n        int n1=nums1.size();\n        int n2=nums2.size();\n        int n=n1+n2;\n         \n      if(n1>n2)  return findMedianSortedArrays(nums2,nums1);\n        \n     // When length is even, let's say 10 then left half length should be: (10+1)/2 =>5\n     // When length is odd, let's say 11 then left half length should be: (11+1)/2 =>6\n        // This mean that this formula gonna work in both condition\n        int partition=(n+1)/2; \n        \n    \n    // Edge Case\n    if(n1==0)\n        return n2%2?nums2[n2/2]:(nums2[n2/2]+nums2[n2/2-1])/2.0;\n    \n    if(n2==0)\n        return n1%2?nums1[n1/2]:(nums1[n1/2]+nums1[n1/2-1])/2.0;\n    \n    // Now do Partioning\n    int left1=0;\n    int right1=n1;\n    int cut1,cut2;\n    int l1,r1,l2,r2;\n    \n    do\n    {   \n        //Findout 'cut1' and 'cut2'\n        cut1=(left1+right1)/2;\n        cut2=partition-cut1;\n   \n        // Calculation for l1\n        l1=cut1==0?INT_MIN:nums1[cut1-1];\n        \n        // Calculation for l2\n        l2=cut2==0?INT_MIN:nums2[cut2-1];\n        \n        // Calculation for r1\n        r1=cut1>=n1?INT_MAX:nums1[cut1];\n        \n        // Calculation for r2\n        r2=cut2>=n2?INT_MAX:nums2[cut2];\n        \n        if(l1<=r2&&l2<=r1)\n             // Return Result\n             return n%2?max(l1,l2):(max(l1,l2)+min(r1,r2))/2.0;\n        else\n            \n        if(l1>r2)\n            right1=cut1-1;\n        else\n             left1=cut1+1;\n       \n       \n    }while(left1<=right1);\n        \n             \n    return 0.0;\n    }\n};\n\n** Accepted **",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2651020/c-solution/",
                "vote_count": "353"
            },
            {
                "language": "python",
                "code": "while(h>l)\n{   int mid=l+(h-l)/2;\n sorting(a,l,mid);",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/2651020/c-solution/",
                "vote_count": "353"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int n1 = nums1.length;\n        int n2 = nums2.length;\n        int n = n1 + n2;\n        int[] new_arr = new int[n];\n\n        int i=0, j=0, k=0;\n\n        while (i<=n1 && j<=n2) {\n            if (i == n1) {\n                while(j<n2) new_arr[k++] = nums2[j++];\n                break;\n            } else if (j == n2) {\n                while (i<n1) new_arr[k++] = nums1[i++];\n                break;\n            }\n\n            if (nums1[i] < nums2[j]) {\n                new_arr[k++] = nums1[i++];\n            } else {\n                new_arr[k++] = nums2[j++];\n            }\n        }\n\n        if (n%2==0) return (float)(new_arr[n/2-1] + new_arr[n/2])/2;\n        else return new_arr[n/2];\n    }\n}",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3283266/best-java-solution-beats-100/",
                "vote_count": "70"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        A, B = nums1, nums2\n        total = len(nums1) + len(nums2)\n        half = total // 2\n        \n        if len(B) < len(A):\n            A, B = B, A\n        # log(min(n, m))\n        l, r = 0, len(A) - 1\n        while True:\n            i = (l + r) // 2 # A\n            j = half - i - 2 # B\n        \n            Aleft = A[i] if i >= 0 else float(\"-infinity\")\n            Aright = A[i + 1] if (i + 1) < len(A) else float(\"infinity\")\n            Bleft = B[j] if j >= 0 else float(\"-infinity\")\n            Bright = B[j + 1] if (j + 1) < len(B) else float(\"infinity\")\n        \n            # partition is correct\n            if Aleft <= Bright and Bleft <= Aright:\n                # odd\n                if total % 2:\n                    return min(Aright, Bright)\n                # even\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2\n            elif Aleft > Bright:\n                r = i - 1\n            else:\n                l = i + 1",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3366580/100-solution-explained/",
                "vote_count": "16"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int n1 =nums1.size(),n2=nums2.size(),count =0;\n        float sum;\n        map<int, int> m;\n        vector<int> v;\n        for(int i=0;i<n1;i++){\n            v.push_back(nums1[i]);\n        }\n        for(int i=0;i<n2;i++){\n           v.push_back(nums2[i]);\n        }\n       sort(v.begin(),v.end());    \n        for(auto i:v){\n            count++;\n        }\n        float n= v.size();\n        int start =0, end = n-1;\n        float mid =start + (end -start)/2;\n        if (count%2==1){\n            \n            return v[mid];\n        }\n       \n        else if(count%2==0){\n           float sum = (float)((v[mid])+(v[mid+1]))/2;\n            return sum; \n        }\n       \n     return {};\n    }\n};",
                "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3292433/easy-to-understand-c-problem/",
                "vote_count": "14"
            }
        ]
    },
    "4": {
        "question_id": 5,
        "title": "Longest Palindromic Substring",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/longest-palindromic-substring",
        "description": "Given a string s, return the longest palindromic substring in s. ",
        "examples": [
            {
                "input": "s = \"babad\"",
                "output": "\"bab\"",
                "explanation": "\"aba\" is also a valid answer."
            },
            {
                "input": "s = \"cbbd\"",
                "output": "\"bb\"",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= s.length <= 1000",
            "s consist of only digits and English letters."
        ],
        "solutions": [
            {
                "language": "python",
                "code": "for start = end (e.g. 'a'), state(start, end) is True\nfor start + 1 = end (e.g. 'aa'), state(start, end) is True if s[start] = s[end]\nfor start + 2 = end (e.g. 'aba'),  state(start, end) is True if s[start] = s[end] and state(start + 1, end - 1)\nfor start + 3 = end (e.g. 'abba'),  state(start, end) is True if s[start] = s[end] and state(start + 1, end - 1)\n...",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/151144/bottom-up-dp-two-pointers/",
                "vote_count": "1080"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = True\n        longest_palindrome_start, longest_palindrome_len = 0, 1\n\n        for end in range(0, n):\n            for start in range(end - 1, -1, -1):\n                # print('start: %s, end: %s' % (start, end))\n                if s[start] == s[end]:\n                    if end - start == 1 or dp[start + 1][end - 1]:\n                        dp[start][end] = True\n                        palindrome_len = end - start + 1\n                        if longest_palindrome_len < palindrome_len:\n                            longest_palindrome_start = start\n                            longest_palindrome_len = palindrome_len\n        return s[longest_palindrome_start: longest_palindrome_start + longest_palindrome_len]",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/151144/bottom-up-dp-two-pointers/",
                "vote_count": "1080"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n = len(s)\n        longest_palindrome_start, longest_palindrome_len = 0, 1\n\n        for i in range(0, n):\n            right = i\n            while right < n and s[i] == s[right]:\n                right += 1\n            # s[i, right - 1] inclusive are equal characters e.g. \"aaa\"\n            \n            # while s[left] == s[right], s[left, right] inclusive is palindrome e.g. \"baaab\"\n            left = i - 1\n            while left >= 0 and right < n and s[left] == s[right]:\n                left -= 1\n                right += 1\n            \n            # s[left + 1, right - 1] inclusive is palindromic\n            palindrome_len = right - left - 1\n            if palindrome_len > longest_palindrome_len:\n                longest_palindrome_len = palindrome_len\n                longest_palindrome_start = left + 1\n            \n        return s[longest_palindrome_start: longest_palindrome_start + longest_palindrome_len]\n         ",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/151144/bottom-up-dp-two-pointers/",
                "vote_count": "1080"
            },
            {
                "language": "go",
                "code": "class Solution {\n    /**\n    If you do the brute force way you would generate a lot more strings than this method looks at.\n    which is set of all subsets ( rather substrings) - \n    E(sigma) (n-i) as i runs from 1 to n-1 = n-squared + n(n+1)/2 - O(n-squared) complexity.\n    This problem can be done using DP with n-squared complexity as shown above by [@GraceMeng](https://leetcode.com/GraceMeng) ",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/151144/bottom-up-dp-two-pointers/",
                "vote_count": "1080"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if not s:\n            return ''\n        l = len(s)\n        dp = [[None for j in range(l)] for i in range(l)]\n        lp = s[0]\n        for i in range(l - 1, -1, -1):",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/151144/bottom-up-dp-two-pointers/",
                "vote_count": "1080"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def longestPalindrome(self, s):\n        if not s:\n            return \"\"\n        n = len(s)\n        dpTable = [[False for _ in range(n)] for _ in range(n)]",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/151144/bottom-up-dp-two-pointers/",
                "vote_count": "1080"
            },
            {
                "language": "go",
                "code": "    public String longestPalindrome(String s) {\n        int len = s.length();\n        if (len <= 1) return s;\n        boolean[][] dp = new boolean[len][len];\n        int ml = 0;\n        int mr = 0;\n        for (int r = 0; r < len; r++) {\n            dp[r][r] = true;\n            for (int l = 0; l < r; l++) {",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/151144/bottom-up-dp-two-pointers/",
                "vote_count": "1080"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\nprivate int lo, maxLen;\n\npublic String longestPalindrome(String s) {\n int len = s.length();\n if (len < 2)\n  return s;\n \n    for (int i = 0; i < len-1; i++) {\n      extendPalindrome(s, i, i);  //assume odd length, try to extend Palindrome as possible\n      extendPalindrome(s, i, i+1); //assume even length.\n    }\n    return s.substring(lo, lo + maxLen);\n}\n\nprivate void extendPalindrome(String s, int j, int k) {\n while (j >= 0 && k < s.length() && s.charAt(j) == s.charAt(k)) {\n  j--;\n  k++;\n }\n if (maxLen < k - j - 1) {\n  lo = j + 1;\n  maxLen = k - j - 1;\n }\n}}",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2928/very-simple-clean-java-solution/",
                "vote_count": "1293"
            },
            {
                "language": "typescript",
                "code": "    public String longestPalindrome(String s) {\n        int max = 0, idx = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int len1 = extend(s, i, i), len2 = extend(s, i, i + 1);\n            if (max < Math.max(len1, len2)) {\n                idx = (len1 > len2) ? (i - len1 / 2) : (i - len2 / 2 + 1);\n                max = Math.max(len1, len2);\n            }",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2928/very-simple-clean-java-solution/",
                "vote_count": "1293"
            },
            {
                "language": "typescript",
                "code": "",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2928/very-simple-clean-java-solution/",
                "vote_count": "1293"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public String longestPalindrome(String s) {\n        int start = 0;\n        int end = 0;\n        for (int i = 0; i < s.length(); i++) {\n            //StringBuffer sb = new StringBuffer();\n            //sb.append(s.charAt[i]);",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2928/very-simple-clean-java-solution/",
                "vote_count": "1293"
            },
            {
                "language": "csharp",
                "code": "// Solution: Iterate the string, for each character, \n// try to expand left and right to get the longest palindromic substring\nclass Solution {\n    public String longestPalindrome(String s) {\n        if (s == null || s.trim().equals(\"\")) {\n            return s;\n        }\n        int len = s.length();",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2928/very-simple-clean-java-solution/",
                "vote_count": "1293"
            },
            {
                "language": "cpp",
                "code": "public String longestPalindrome(String s) {\n        int[] maxStart = new int[1], maxEnd = new int[1]; // use array in order to pass by reference instead of pass by value\n        \n        for (int i = 0; i < s.length()-1; i++) {\n            extend(s, i, i, maxStart, maxEnd);    \n            extend(s, i, i+1, maxStart, maxEnd);\n        }\n        ",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2928/very-simple-clean-java-solution/",
                "vote_count": "1293"
            },
            {
                "language": "python",
                "code": "if (len - i < max / 2)\n  break;",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2928/very-simple-clean-java-solution/",
                "vote_count": "1293"
            },
            {
                "language": "typescript",
                "code": "    public String longestPalindrome(String s) {\n        String result = \"\";\n        int len = 0;\n        boolean[][] isPali = new boolean[s.length()][s.length()];\n        for (int i = s.length() - 1; i >= 0; i--) {\n            for (int j = i; j < s.length(); j++) {\n                if (s.charAt(i) == s.charAt(j) && (j - i < 2 || isPali[i + 1][j - 1])) {\n                    isPali[i][j] = true;\n                    if (j - i + 1 > len) {",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2928/very-simple-clean-java-solution/",
                "vote_count": "1293"
            },
            {
                "language": "python",
                "code": "def longestPalindrome(self, s):\n    res = \"\"\n    for i in xrange(len(s)):\n        # odd case, like \"aba\"\n        tmp = self.helper(s, i, i)\n        if len(tmp) > len(res):\n            res = tmp\n        # even case, like \"abba\"\n        tmp = self.helper(s, i, i+1)\n        if len(tmp) > len(res):\n            res = tmp\n    return res\n \n# get the longest palindrome, l, r are the middle indexes   \n# from inner to outer\ndef helper(self, s, l, r):\n    while l >= 0 and r < len(s) and s[l] == s[r]:\n        l -= 1; r += 1\n    return s[l+1:r]",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2954/python-easy-to-understand-solution-with-comments-from-middle-to-two-ends/",
                "vote_count": "1011"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2954/python-easy-to-understand-solution-with-comments-from-middle-to-two-ends/",
                "vote_count": "1011"
            },
            {
                "language": "python",
                "code": "def longestPalindrome(s):\n    res = \"\"\n    for i in range(len(s)):        \n        odd  = palindromeAt(s, i, i)\n        even = palindromeAt(s, i, i+1)\n        \n        res = max(res, odd, even, key=len)\n    return res",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2954/python-easy-to-understand-solution-with-comments-from-middle-to-two-ends/",
                "vote_count": "1011"
            },
            {
                "language": "python",
                "code": "def longestPalindrome(self, s):\n    res = \"\"\n    for i in xrange(len(s)):\n        for k in xrange(2):\n            tmp = self.helper(s, i, i+k)\n            if len(tmp) > len(res):\n                res = tmp\n    return res",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2954/python-easy-to-understand-solution-with-comments-from-middle-to-two-ends/",
                "vote_count": "1011"
            },
            {
                "language": "typescript",
                "code": "public String longestPalindrome(String s) {\n  int n = s.length();\n  String res = null;\n    \n  boolean[][] dp = new boolean[n][n];\n    \n  for (int i = n - 1; i >= 0; i--) {\n    for (int j = i; j < n; j++) {\n      dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[i + 1][j - 1]);\n            \n      if (dp[i][j] && (res == null || j - i + 1 > res.length())) {\n        res = s.substring(i, j + 1);\n      }\n    }\n  }\n    \n  return res;\n}",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2921/share-my-java-solution-using-dynamic-programming/",
                "vote_count": "891"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public static String longestPalindrome(String s) {\n        int n = s.length();\n        String res = null;\n        int palindromeStartsAt = 0, maxLen = 0;\n\n        boolean[][] dp = new boolean[n][n];",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2921/share-my-java-solution-using-dynamic-programming/",
                "vote_count": "891"
            },
            {
                "language": "java",
                "code": "class Solution {\n public String longestPalindrome(String s) {\n  int n = s.length();\n  int start=0, end=0;\n  boolean[][] dp = new boolean[n][n];\n  for (int i=n-1;i>=0;i--) {\n   for(int j=i; j<n; j++) {",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2921/share-my-java-solution-using-dynamic-programming/",
                "vote_count": "891"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public String longestPalindrome(String s) {\n        if(s==null||s.length()==0) return s;\n        int n=s.length();\n        //substring(i,j) is panlidrome\n        boolean[][] dp=new boolean[n][n];\n        String res = null;\n        //[j, i]\n        for(int i=0;i<n;i++){",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2921/share-my-java-solution-using-dynamic-programming/",
                "vote_count": "891"
            },
            {
                "language": "java",
                "code": "public String longestPalindrome(String s) {\n    if(s==null || s.length() <= 1) return s;\n\n    boolean[][] dp = new boolean[s.length()][s.length()];\n    char[] w = s.toCharArray();\n    int maxLen = 0;\n    String maxSub = null;",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2921/share-my-java-solution-using-dynamic-programming/",
                "vote_count": "891"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n        String res = \"\";\n        for (int i = 0; i < n; i++){\n            for (int j = 0; j <= i; j++){\n                dp[j][i] = (j+1 > i-1 || dp[j+1][i-1]) && s.charAt(j) == s.charAt(i);\n                if (dp[j][i] && res.length() < i - j + 1){",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2921/share-my-java-solution-using-dynamic-programming/",
                "vote_count": "891"
            },
            {
                "language": "go",
                "code": "public String longestPalindrome(String s) {\n        int len = s.length();\n        if(len < 2) return s;        \n        boolean dp[] = new boolean[len];\n        int start = 0;\n        int maxLen = 0;\n        ",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/2921/share-my-java-solution-using-dynamic-programming/",
                "vote_count": "891"
            },
            {
                "language": "python",
                "code": "def longestPalindrome(self, s):\n        longest_palindrom = ''\n        dp = [[0]*len(s) for _ in range(len(s))]\n        #filling out the diagonal by 1\n        for i in range(len(s)):\n            dp[i][i] = True\n            longest_palindrom = s[i]\n   \n        # filling the dp table\n        for i in range(len(s)-1,-1,-1):\n    # j starts from the i location : to only work on the upper side of the diagonal \n            for j in range(i+1,len(s)):  \n                if s[i] == s[j]:  #if the chars mathces\n                    # if len slicied sub_string is just one letter if the characters are equal, we can say they are palindomr dp[i][j] =True \n                    #if the slicied sub_string is longer than 1, then we should check if the inner string is also palindrom (check dp[i+1][j-1] is True)\n                    if j-i ==1 or dp[i+1][j-1] is True:\n                        dp[i][j] = True\n                        # we also need to keep track of the maximum palindrom sequence \n                        if len(longest_palindrom) < len(s[i:j+1]):\n                            longest_palindrom = s[i:j+1]\n                \n        return longest_palindrom",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/900639/python-solution-with-detailed-explanation-using-dp/",
                "vote_count": "607"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        dp = [[False]*len(s) for _ in range(len(s)) ]\n        for i in range(len(s)):\n            dp[i][i]=True\n        ans=s[0]\n        for j in range(len(s)):\n            for i in range(j):",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/900639/python-solution-with-detailed-explanation-using-dp/",
                "vote_count": "607"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \n        if len(s) == 1:\n            return s",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/900639/python-solution-with-detailed-explanation-using-dp/",
                "vote_count": "607"
            },
            {
                "language": "python",
                "code": "def longestPalindrome(self, s):\n        longest_palindrom = (0, 1)\n        dp = [[0]*len(s) for _ in range(len(s))]\n        # filling out the diagonal by 1\n        for i in range(len(s)):\n            dp[i][i] = True\n   ",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/900639/python-solution-with-detailed-explanation-using-dp/",
                "vote_count": "607"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        N = len(s)\n        dp=collections.defaultdict(bool)\n\n        lp = []\n        ",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/900639/python-solution-with-detailed-explanation-using-dp/",
                "vote_count": "607"
            },
            {
                "language": "csharp",
                "code": "// https://leetcode.com/problems/longest-palindromic-substring/\n\n/*\nSolution 1: Brute Force Approach (Give TLE)\n\nGenerate all substring and check it is palindrome or not.\nIf it is palindrome then check it is longest or not.\n\nTime Complexity - O(N^3),  O(N^2) to generate all substring and O(N) to check it is palindrome or not.\nSpace complexity - O(1).\n*/\n\nclass Solution\n{\npublic:\n    bool isPalindrome(string s)\n    {\n        int i = 0, j = s.size() - 1;\n\n        while (i < j)\n        {\n            if (s[i++] != s[j--])\n                return false;\n        }\n        return true;\n    }\n\n    string longestPalindrome(string s)\n    {\n        int n = s.size();\n        if (n == 0)\n            return \"\";\n\n        if (n == 1)\n            return s;\n\n        string result = \"\";\n        for (int i = 0; i < n - 1; i++)\n        {\n            for (int j = 1; j <= n - i; j++)\n            {\n                if (isPalindrome(s.substr(i, j)))\n                {\n                    if (result.size() < j)\n                        result = s.substr(i, j);\n                }\n            }\n        }\n        return result;\n    }\n};\n\n/*\nAbove Solution Give TLE....\n\nHow Can we optimise our code?\n\nGot it in above solution, we do unnecessary recompution while validating palindomes.\nFor example : if we know string \"aba\" is palindrome then \"cabac\" must be palindrome as left and right are equal.\n\nSolution 2: Using DP\n\nP(i, j) == P(i+1, j-1) && s[i] == s[j];\n\nBase cases :\n\n//One character\nP(i, i) = true;\n\n//Two character\nP(i, i+1) = s[i] == s[i+1];\n\nTime Complexity - O(N^2), Space Complexity - O(N^2) (caching all substring)\n*/\n\nclass Solution\n{\npublic:\n    string longestPalindrome(string s)\n    {\n        int n = s.size();\n        if (n == 0)\n            return \"\";\n\n        // dp[i][j] will be 'true' if the string from index i to j is a palindrome.\n        bool dp[n][n];\n\n        //Initialize with false\n\n        memset(dp, 0, sizeof(dp));\n\n        //Every Single character is palindrome\n        for (int i = 0; i < n; i++)\n            dp[i][i] = true;\n\n        string ans = \"\";\n        ans += s[0];\n\n        for (int i = n - 1; i >= 0; i--)\n        {\n            for (int j = i + 1; j < n; j++)\n            {\n                if (s[i] == s[j])\n                {\n                    //If it is of two character OR if its susbtring is palindrome.\n                    if (j - i == 1 || dp[i + 1][j - 1])\n                    {\n                        //Then it will also a palindrome substring\n                        dp[i][j] = true;\n\n                        //Check for Longest Palindrome substring\n                        if (ans.size() < j - i + 1)\n                            ans = s.substr(i, j - i + 1);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/844586/very-easy-to-understand-well-commented-2-approaches-thinking-process/",
                "vote_count": "298"
            },
            {
                "language": "csharp",
                "code": "    while (i < j)\n    {\n        if (s[i++] != s[j--])",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/844586/very-easy-to-understand-well-commented-2-approaches-thinking-process/",
                "vote_count": "298"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    string longestPalindrome(string s);\n    bool isPalindrome(const string_view &s);\n};\n\nstring Solution::longestPalindrome(string s) {",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/844586/very-easy-to-understand-well-commented-2-approaches-thinking-process/",
                "vote_count": "298"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N^3), Here three nested loop creates the time complexity. Where N is the size of the\n    string(s).\n\n    Space Complexity : O(1), Constant space.\n\n    Solved using string(Three Nested Loop). Brute Force Approach.\n\n    Note : this may give TLE.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\nprivate: \n    bool check(string &s, int i, int j){\n        while(i<j){\n            if(s[i] != s[j]){\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }            \npublic:\n    string longestPalindrome(string s) {\n        int n = s.size();\n        int starting_index = 0;\n        int max_len = 0;\n        for(int i=0; i<n; i++){\n            for(int j=i; j<n; j++){\n                if(check(s, i, j)){\n                    if(j-i+1 > max_len){\n                        max_len = j-i+1;\n                        starting_index = i;\n                    }\n                }\n            }\n        }\n        return s.substr(starting_index, max_len);\n    }\n}; \n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^2), Here Two nested loop creates the time complexity. Where N is the size of the\n    string(s).\n\n    Space Complexity : O(N^2*N), vector(substring) space.\n\n    Solved using string(TwoNested Loop). Brute Force Approach.\n\n    Note : this may give TLE.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution { \nprivate: \n    bool check(string &s, int i, int j){\n        while(i<j){\n            if(s[i] != s[j]){\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\npublic:\n    string longestPalindrome(string s) {\n        int n = s.size();\n        vector<string> substring;\n        for(int i=0; i<n; i++){\n            string temp = \"\";\n            for(int j=i; j<n; j++){\n                temp += s[j];\n                substring.push_back(temp);\n            }\n        }\n        int max_len = 0;\n        string finalans = substring[0];\n        int m = substring.size();\n        for(int i=0; i<m; i++){\n            int s = substring[i].size();\n            if(check(substring[i], 0, s-1)){\n                if(s > max_len){\n                    max_len = s;\n                    finalans = substring[i];\n                }\n            }       \n        }\n        return finalans;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^2), The time complexity of the above code is O(N^2) because we are traversing over all\n    the substrings and then checking each substring if it is a palindrome or not. There are N^2 substrings and\n    checking a substring takes O(1) time, so total time complexity is O(N^2).\n\n    Space Complexity : (N^2), The space complexity of the above code is O(N^2) because we are using the dp array\n    in which we are storing whether a substring is a palindrome or not.\n\n    Solved using Dynamic Programming Approach(tabulation). Optimized Approach.\n\n*/\n\n\n/***************************************** Approach 3 *****************************************/\n\nclass Solution {\nprivate: \n    bool solve(vector<vector<bool>> &dp, int i, int j, string &s){\n        if(i == j){\n            return dp[i][j] = true;\n        }\n        if(j-i == 1){\n            if(s[i] == s[j]){\n                return dp[i][j] = true;\n            }\n            else{\n                return dp[i][j] = false;\n            }\n        }\n        if(s[i] == s[j] && dp[i+1][j-1] == true){\n            return dp[i][j] = true;\n        } else {\n            return dp[i][j] = false;\n        }\n    }\npublic:\n    string longestPalindrome(string s) {\n        int n = s.size();\n        int startIndex = 0; int maxlen = 0;\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\n        for(int g=0; g<n; g++){\n            for(int i=0, j=g; j<n; i++, j++){\n                solve(dp, i, j, s);\n                if(dp[i][j] == true){\n                    if(j-i+1 > maxlen){\n                        startIndex = i;\n                        maxlen = j-i+1;\n                    }\n                }\n            }\n        }\n        return s.substr(startIndex, maxlen);\n    }\n};",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/3202985/best-c-3-solution-dp-string-brute-force-optimize-one-stop-solution/",
                "vote_count": "137"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/longest-palindromic-substring/solutions/3202985/best-c-3-solution-dp-string-brute-force-optimize-one-stop-solution/",
                "vote_count": "137"
            }
        ]
    },
    "5": {
        "question_id": 6,
        "title": "Zigzag Conversion",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/zigzag-conversion",
        "description": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P   A   H   NA P L S I I GY   I   RAnd then read line by line: \"PAHNAPLSIIGYIR\"Write the code that will take a string and make this conversion given a number of rows:string convert(string s, int numRows); ",
        "examples": [
            {
                "input": "s = \"PAYPALISHIRING\", numRows = 3",
                "output": "\"PAHNAPLSIIGYIR\"",
                "explanation": null
            },
            {
                "input": "s = \"PAYPALISHIRING\", numRows = 4",
                "output": "\"PINALSIGYAHRPI\"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I",
                "explanation": null
            },
            {
                "input": "s = \"A\", numRows = 1",
                "output": "\"A\"",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= s.length <= 1000",
            "s consists of English letters (lower-case and upper-case), ',' and '.'.",
            "1 <= numRows <= 1000"
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n\n    string convert(string s, int numRows) {\n    \n    if(numRows <= 1) return s;\n\n    vector<string>v(numRows, \"\"); \n\n    int j = 0, dir = -1;\n\n    for(int i = 0; i < s.length(); i++)\n    {\n\n        if(j == numRows - 1 || j == 0) dir *= (-1); \n   \n        v[j] += s[i];\n\n        if(dir == 1) j++;\n\n        else j--;\n    }\n\n    string res;\n\n    for(auto &it : v) res += it; \n\n    return res;\n\n    }\n};",
                "url": "https://leetcode.com/problems/zigzag-conversion/solutions/3134053/c-faster-than-95-easy-understanding-clean-concise-code/",
                "vote_count": "155"
            },
            {
                "language": "php",
                "code": "class Solution {\npublic:\n    string convert(string s, int numRows) {\n        if (numRows <= 1) {\n            return s;\n        }\n        std::vector<std::string> list(numRows, \"\");\n        int currentLine = 0;",
                "url": "https://leetcode.com/problems/zigzag-conversion/solutions/3134053/c-faster-than-95-easy-understanding-clean-concise-code/",
                "vote_count": "155"
            },
            {
                "language": "ruby",
                "code": "# simulate and add each character to the corresponding row\n# go down -> reach bottom -> go up -> reach top -> go down ...\nclass Solution:\n    def convert(self, s: str, n: int) -> str:\n        # edge case\n        if n == 1: return s\n        rows = ['' for _ in range(n)]\n        # j is the index to track which rows a character should be added to\n        # d is the direction: -1 means go up, 1 means go down\n        j, d = 0, 1\n        for i in range(len(s)):\n            # add the current character to corresponding row\n            rows[j] += s[i]\n            # if it reaches to the last row, we need to go up\n            if j == n - 1: d = -1\n            # if it reaches to the first row, we need to go down\n            elif j == 0: d = 1\n            # move j pointer\n            j += d;\n        # rows would look like below in the first example\n        # ['PAHN', 'APLSIIG', 'YIR']\n        # we use join to build the final answer\n        return ''.join(rows)",
                "url": "https://leetcode.com/problems/zigzag-conversion/solutions/3134126/leetcode-the-hard-way-explained-line-by-line/",
                "vote_count": "30"
            },
            {
                "language": "csharp",
                "code": "// simulate and add each character to the corresponding row\n// go down -> reach bottom -> go up -> reach top -> go down ...\nclass Solution {\npublic:\n    string convert(string s, int n) {\n        // edge case\n        if (n == 1) return s;\n        vector<string> rows(n);\n        // j is the index to track which rows a character should be added to\n        // d is the direction: -1 means go up, 1 means go down\n        int j = 0, d = 1;\n        for (int i = 0; i < s.size(); i++) {\n            // add the current character to corresponding row\n            rows[j] += s[i];\n            // if it reaches to the last row, we need to go up\n            if(j == n - 1) d = -1;\n            // if it reaches to the first row, we need to go down\n            else if(j == 0) d = 1;\n            // move j pointer\n            j += d;\n        }\n        // rows would look like below in the first example\n        // ['PAHN', 'APLSIIG', 'YIR']\n        // we use `accumulate` to build the final answer (in C++ 20, it takes O(n) only)\n        return accumulate(rows.begin(), rows.end(), string{});\n    }\n};",
                "url": "https://leetcode.com/problems/zigzag-conversion/solutions/3134126/leetcode-the-hard-way-explained-line-by-line/",
                "vote_count": "30"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string convert(string s, int numRows) {\n        if(numRows == 1)\n            return s;\n        vector<string> rows(numRows);\n        int j = 0, d = 1;\n        for (int i = 0; i < s.size(); i++) {",
                "url": "https://leetcode.com/problems/zigzag-conversion/solutions/3134126/leetcode-the-hard-way-explained-line-by-line/",
                "vote_count": "30"
            }
        ]
    },
    "6": {
        "question_id": 7,
        "title": "Reverse Integer",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/reverse-integer",
        "description": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.Assume the environment does not allow you to store 64-bit integers (signed or unsigned). ",
        "examples": [
            {
                "input": "x = 123",
                "output": "321",
                "explanation": null
            },
            {
                "input": "x = -123",
                "output": "-321",
                "explanation": null
            },
            {
                "input": "x = 120",
                "output": "21",
                "explanation": null
            }
        ],
        "constraints": [
            "-2^31 <= x <= 2^31 - 1"
        ],
        "solutions": [
            {
                "language": "erlang",
                "code": "- Space complexity:  O(1) ",
                "url": "https://leetcode.com/problems/reverse-integer/solutions/3099545/my-c-solution-beats-100-0ms-run-time/",
                "vote_count": "98"
            },
            {
                "language": "java",
                "code": "class Solution {                      \npublic:\n    int reverse(int x) {\n        long r=0;      // decleare r \n        while(x){\n         r=r*10+x%10; // find remainder and add its to r\n         x=x/10;     // Update the value of x\n        }\n        if(r>INT_MAX || r<INT_MIN) return 0; // check 32 bit range if r is outside the range then return 0  \n        return int(r);  // if r in the 32 bit range return r\n    }\n}; ",
                "url": "https://leetcode.com/problems/reverse-integer/solutions/3099545/my-c-solution-beats-100-0ms-run-time/",
                "vote_count": "98"
            },
            {
                "language": "kotlin",
                "code": "//System.out.println(\"Original Number: \" + x);\n\n// run loop until num becomes 0",
                "url": "https://leetcode.com/problems/reverse-integer/solutions/3099545/my-c-solution-beats-100-0ms-run-time/",
                "vote_count": "98"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int reverse(int x) {\n        long finalNum = 0;\n        while(x!=0){\n            int lastDig = x%10;\n            finalNum += lastDig;\n            finalNum = finalNum*10;\n            x= x/10;\n        }\n        finalNum = finalNum/10;\n        if(finalNum > Integer.MAX_VALUE || finalNum<Integer.MIN_VALUE){\n            return 0;\n        }\n        if(x<0){\n            return (int)(-1*finalNum);\n        }\n        return (int)finalNum;\n    }\n}",
                "url": "https://leetcode.com/problems/reverse-integer/solutions/3136892/java-beat-100-well-explained-code/",
                "vote_count": "93"
            },
            {
                "language": "dart",
                "code": "    if (x < 0) {\n        x = -x;\n        negative = true;\n    }\n    while(x!=0){  \n        int a=x%10; \n        // Check if the next operation is going to cause an overflow",
                "url": "https://leetcode.com/problems/reverse-integer/solutions/3136892/java-beat-100-well-explained-code/",
                "vote_count": "93"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def reverse(self, x: int) -> int:\n        rev = 0\n        sign = 1 if x >= 0 else -1\n        x *= sign\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x //= 10\n        rev *= sign\n        return rev if rev >= -(2**31) and rev <= (2**31 - 1) else 0",
                "url": "https://leetcode.com/problems/reverse-integer/solutions/3160253/python-simple-solution-efficient-solution/",
                "vote_count": "25"
            }
        ]
    },
    "7": {
        "question_id": 8,
        "title": "String to Integer (atoi)",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/string-to-integer-atoi",
        "description": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).The algorithm for myAtoi(string s) is as follows:Read in and ignore any leading whitespace.Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.Return the integer as the final result.Note:Only the space character ' ' is considered a whitespace character.Do not ignore any characters other than the leading whitespace or the rest of the string after the digits. ",
        "examples": [
            {
                "input": "s = \"42\"",
                "output": "42",
                "explanation": "The underlined characters are what is read in, the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range [-231, 231 - 1], the final result is 42."
            },
            {
                "input": "s = \"   -42\"",
                "output": "-42\nExplanation:\nStep 1: \"   -42\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -42\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -42\" (\"42\" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range [-231, 231 - 1], the final result is -42.",
                "explanation": null
            },
            {
                "input": "s = \"4193 with words\"",
                "output": "4193\nExplanation:\nStep 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range [-231, 231 - 1], the final result is 4193.",
                "explanation": null
            }
        ],
        "constraints": [
            "0 <= s.length <= 200",
            "s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'."
        ],
        "solutions": [
            {
                "language": "kotlin",
                "code": "if(result > (Integer.MAX_VALUE / 10) || (result == (Integer.MAX_VALUE / 10) && digit > 7))\n                return isNegative ? Integer.MIN_VALUE : Integer.MAX_VALUE;",
                "url": "https://leetcode.com/problems/string-to-integer-atoi/solutions/1402936/java-c-simple-pictorial-explanation-32-bit-int-easy/",
                "vote_count": "230"
            },
            {
                "language": "kotlin",
                "code": "if(result > (Integer.MAX_VALUE - digit) / 10)\n                return isNegative ? Integer.MIN_VALUE : Integer.MAX_VALUE;",
                "url": "https://leetcode.com/problems/string-to-integer-atoi/solutions/1402936/java-c-simple-pictorial-explanation-32-bit-int-easy/",
                "vote_count": "230"
            },
            {
                "language": "kotlin",
                "code": "if(result > (INT_MAX / 10) || (result == (INT_MAX / 10) && digit > 7))\n                return isNegative ? INT_MIN : INT_MAX;",
                "url": "https://leetcode.com/problems/string-to-integer-atoi/solutions/1402936/java-c-simple-pictorial-explanation-32-bit-int-easy/",
                "vote_count": "230"
            },
            {
                "language": "kotlin",
                "code": "if(result > (INT_MAX - digit) / 10)\n                return isNegative ? INT_MIN : INT_MAX;",
                "url": "https://leetcode.com/problems/string-to-integer-atoi/solutions/1402936/java-c-simple-pictorial-explanation-32-bit-int-easy/",
                "vote_count": "230"
            },
            {
                "language": "dart",
                "code": "/*\n\n    Time Complexity : O(logN), Since we are going through the entire number digit by digit, the time complexity\n    should be O(log10N). The reason behind log10 is because we are dealing with integers which are base 10.\n\n    Space Complexity : O(1), We are not using any data structure for interim operations, therefore, the space\n    complexity is O(1).\n\n    Solved using String.\n\n*/\n\nclass Solution {\npublic:\n    int myAtoi(string s) {\n        int len = s.size();\n        double num = 0;\n        int i=0;\n        while(s[i] == ' '){\n            i++;\n        }\n        bool positive = s[i] == '+';\n        bool negative = s[i] == '-';\n        positive == true ? i++ : i;\n        negative == true ? i++ : i;\n        while(i < len && s[i] >= '0' && s[i] <= '9'){\n            num = num*10 + (s[i]-'0');\n            i++;\n        }\n        num = negative ? -num : num;\n        cout<<num<<endl;\n        num = (num > INT_MAX) ? INT_MAX : num;\n        num = (num < INT_MIN) ? INT_MIN : num;\n        cout<<num<<endl;\n        return int(num);\n    }\n};",
                "url": "https://leetcode.com/problems/string-to-integer-atoi/solutions/3202876/best-c-solution-ever-easy-to-understand-string-one-stop-solution/",
                "vote_count": "57"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def myAtoi(self, str: str) -> int:\n        str = str.strip()\n        if not str:\n            return 0\n        sign = -1 if str[0] == '-' else 1\n        str = str[1:] if str[0] in ['-', '+'] else str\n        res = 0\n        for char in str:\n            if not char.isdigit():\n                break\n            res = res * 10 + int(char)\n            if res * sign >= 2**31 - 1:\n                return 2**31 - 1\n            if res * sign <= -2**31:\n                return -2**31\n        return res * sign",
                "url": "https://leetcode.com/problems/string-to-integer-atoi/solutions/3160262/python-simple-solution-efficient-solution/",
                "vote_count": "15"
            }
        ]
    },
    "8": {
        "question_id": 9,
        "title": "Palindrome Number",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/palindrome-number",
        "description": "Given an integer x, return true if x is a palindrome, and false otherwise. ",
        "examples": [
            {
                "input": "x = 121",
                "output": "true",
                "explanation": "121 reads as 121 from left to right and from right to left."
            },
            {
                "input": "x = -121",
                "output": "false",
                "explanation": "From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome."
            },
            {
                "input": "x = 10",
                "output": "false",
                "explanation": "Reads 01 from right to left. Therefore it is not a palindrome."
            }
        ],
        "constraints": [
            "-2^31\u00a0<= x <= 2^31\u00a0- 1"
        ],
        "solutions": [
            {
                "language": "ruby",
                "code": "def isPalindrome(self, x: int) -> bool:\n if x < 0:\n  return False\n \n return str(x) == str(x)[::-1]",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/785314/python-3-1-solution-is-89-20-faster-2nd-is-99-14-faster-explanation-added/",
                "vote_count": "535"
            },
            {
                "language": "java",
                "code": "def isPalindrome(self, x: int) -> bool:\n if x<0:\n  return False\n\n inputNum = x\n newNum = 0\n while x>0:\n  newNum = newNum * 10 + x%10\n  x = x//10\n return newNum == inputNum",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/785314/python-3-1-solution-is-89-20-faster-2nd-is-99-14-faster-explanation-added/",
                "vote_count": "535"
            },
            {
                "language": "kotlin",
                "code": "def isPalindrome(self, x: int) -> bool:\n if x < 0 or (x > 0 and x%10 == 0):   # if x is negative, return False. if x is positive and last digit is 0, that also cannot form a palindrome, return False.\n  return False\n \n result = 0\n while x > result:\n  result = result * 10 + x % 10\n  x = x // 10\n  \n return True if (x == result or x == result // 10) else False",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/785314/python-3-1-solution-is-89-20-faster-2nd-is-99-14-faster-explanation-added/",
                "vote_count": "535"
            },
            {
                "language": "javascript",
                "code": "x == result or x == result // 10",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/785314/python-3-1-solution-is-89-20-faster-2nd-is-99-14-faster-explanation-added/",
                "vote_count": "535"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        myString=str(x)\n        for i in range(len(myString)//2):\n            if myString[i]==myString[~i]:\n                continue\n            else: return False\n        return True",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/785314/python-3-1-solution-is-89-20-faster-2nd-is-99-14-faster-explanation-added/",
                "vote_count": "535"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \n        if x < 0 or (x % 10 == 0 and x > 0):\n            return False        \n       \n        revert = 0\n        while x > revert:                   ",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/785314/python-3-1-solution-is-89-20-faster-2nd-is-99-14-faster-explanation-added/",
                "vote_count": "535"
            },
            {
                "language": "python",
                "code": "   class Solution:\n       def isPalindrome(self, x):\n           rev = x[::-1]\n           if x==rev:\n                return True\n           else:\n                return False\n        ",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/785314/python-3-1-solution-is-89-20-faster-2nd-is-99-14-faster-explanation-added/",
                "vote_count": "535"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean isPalindrome(int x) {\n        String s = String.valueOf(x); // Convert to String\n        int n = s.length(); // Store the String length to int n\n\n        for (int i=0; i<n/2; i++) {\n            // We check whether the elements at the same distance from\n            // beginning and from ending are same, if not we return false\n            if (s.charAt(i) != s.charAt(n-i-1)) return false;\n        }\n\n        // if no flaws are found we return true\n        return true;\n    }\n}",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/3213890/fastest-java-solution/",
                "vote_count": "231"
            },
            {
                "language": "javascript",
                "code": "original number: 543\nreverse number: 0\n\n//Get the last digit of the original number\noriginal % 10 = 543 % 10 = 3\n//Put this digit as the last one in the reverse number\nreverse * 10 + digit = 0 * 10 + 3 = 0 + 3 = 3\nreverse: 3\n//Remove this digit from the original number\noriginal / 10 = 543 / 10 = 54.3\n~~54.3 = 54\noriginal: 54\n\n//Repeat\noriginal % 10 = 54 % 10 = 4\nreverse * 10 + digit = 3 * 10 + 4 = 30 + 4 = 34\nreverse: 34\noriginal / 10 = 54 / 10 = 5.4\n~~5.4 = 5\noriginal: 5\n\n//Repeat\noriginal % 10 = 5 % 10 = 5\nreverse * 10 + digit = 34 * 10 + 5 = 340 + 5 = 345\nreverse: 345\noriginal / 10 = 5 / 10 = 0.5\n~~0.5 = 0\noriginal: 0\n\ninput: 543\noutput: 345",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/2499161/99-22-javascript-dart-without-converting-the-integer-to-a-string/",
                "vote_count": "106"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0:\n            return False\n        rev = 0\n        orig = x\n        while x != 0:\n            rev = rev * 10 + x % 10\n            x //= 10\n        return rev == orig",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/3160269/python-simple-solution-efficient-solution/",
                "vote_count": "86"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean isPalindrome(int x) {\n      String s = String.valueOf(x);  \n\n        int i = 0;                   \n        int j = s.length() - 1; \n       \n          while(i <= j)      \n        {\n            if(s.charAt(i) != s.charAt(j))  \n                return false;\n            i++;                                \n            j--;                                \n        }  \n        \n        return true;\n        \n    }\n}",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/3176639/java-c-best-solution-simple-solution/",
                "vote_count": "66"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        stack<int> st;\n        if(x<0)\n            return false;\n        int y=x;\n        while(x)\n        {\n            st.push(x%10);\n            x/=10;\n        }\n        while(y)\n        {\n            if(st.top()!=(y%10))\n               return false;\n             st.pop();\n               y/=10;\n        }\n        return true;\n    }\n};",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/3047788/accepted-easy-solution-short-simple-best-method/",
                "vote_count": "59"
            },
            {
                "language": "java",
                "code": "Example 1:\nlet x = 123,\nthen y = reverse of x = 321;\nSince, 123 != 321, Hence, x is NOT palindrome.\n\nExample 2:\nlet x = 1221,\nthen y = reverse of x = 1221;\nSince 1221 == 1221, Hence, x is palindrome.",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-100-easy-to-understand/",
                "vote_count": "47"
            },
            {
                "language": "erlang",
                "code": "Step1: Convert the integer into string.\nStep2: Point two variable at first and last indices of the string.\nStep3: Compare the characters at those indices.\nStep4: Update the variables.",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-100-easy-to-understand/",
                "vote_count": "47"
            },
            {
                "language": "kotlin",
                "code": "    **If this solution helped you, give it a like to help others.**",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-100-easy-to-understand/",
                "vote_count": "47"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean isPalindrome(int x) {\n\n        // Two-Pointer Approach\n        \n        \n        // Step1: Convert the integer into string.\n        // Step2: Point two variable at first and last indices of the string.\n        // Step3: Compare the characters at those indices.\n        // Step4: Update the variables.\n\n        String s = String.valueOf(x);  // convert integer to string.\n\n        int i = 0;                     // i will initially point to first index.\n        int j = s.length() - 1;        // j will initially point to last index. \n        \n        // i and j are opposite indices of the string. \n        // 1. If 'i' is first then 'j' is last.\n        // 2. Similarly, if 'i' is second then 'j' is second last index of s.\n        // This is because they are updated simultaneously.\n\n        while(i <= j)                   // loop will break when i and j cross each other\n        {\n            if(s.charAt(i) != s.charAt(j))  // characters at indices i and j will be compared.\n                // If the characters are unequal then false will be returned.\n                return false;\n            i++;                                // i is incremented.\n            j--;                                // j is decremented.\n        }\n        \n        // If loop ends without returning false, it means that every 'ith' character\n        // is equal to every 'jth' character. Thus, the number is palindrome.\n        // Hence, return true;\n        \n        return true;\n        \n    }\n}",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-100-easy-to-understand/",
                "vote_count": "47"
            },
            {
                "language": "javascript",
                "code": "   check only Half of the digits of given Number\n   to prevent from OVERFLOW",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/3283534/accepted-beats-98-o-n-2-easiest-java-c-code-just/",
                "vote_count": "34"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean isPalindrome(int x) {\n        if(x<0 || x!=0 && x%10 ==0 ) return false;\n        int check=0;\n        while(x>check){\n            check = check*10 + x%10;\n            x/=10;\n        }\n        return (x==check || x==check/10);\n    }\n}",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/3283534/accepted-beats-98-o-n-2-easiest-java-c-code-just/",
                "vote_count": "34"
            },
            {
                "language": "cpp",
                "code": "bool isPalindrome(int x){\n    if(x<0 || x!=0 && x%10 ==0 ) return false;\n    int check=0;\n    while(x>check){\n        check = check*10 + x%10;\n        x/=10;\n    }\n    return (x==check || x==check/10);\n}",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/3283534/accepted-beats-98-o-n-2-easiest-java-c-code-just/",
                "vote_count": "34"
            },
            {
                "language": "javascript",
                "code": " **   Use similar Math in PYTHON / C++   **",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/3283534/accepted-beats-98-o-n-2-easiest-java-c-code-just/",
                "vote_count": "34"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n       long long int copy=x;\n       long long int rev=0;\n        while(x!=0){\n            long long int rem;\n            rem=x%10;\n            rev=rev*10 +rem;\n            x=x/10;\n            \n        }\n         bool check=false;\n        if(rev<0){\n            return check;\n        }\n       \n        else if(rev==copy){\n            check=true;\n            return check;\n        }else return check;\n        \n    }\n};",
                "url": "https://leetcode.com/problems/palindrome-number/solutions/3109195/easily-understandable-solution-beats-99-30/",
                "vote_count": "30"
            }
        ]
    },
    "9": {
        "question_id": 10,
        "title": "Regular Expression Matching",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/regular-expression-matching",
        "description": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:'.' Matches any single character.\u200b\u200b\u200b\u200b'*' Matches zero or more of the preceding element.The matching should cover the entire input string (not partial). ",
        "examples": [
            {
                "input": "s = \"aa\", p = \"a\"",
                "output": "false",
                "explanation": "\"a\" does not match the entire string \"aa\"."
            },
            {
                "input": "s = \"aa\", p = \"a*\"",
                "output": "true",
                "explanation": "'*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\"."
            },
            {
                "input": "s = \"ab\", p = \".*\"",
                "output": "true",
                "explanation": "\".*\" means \"zero or more (*) of any character (.)\"."
            }
        ],
        "constraints": [
            "1 <= s.length\u00a0<= 20",
            "1 <= p.length\u00a0<= 20",
            "s contains only lowercase English letters.",
            "p contains only lowercase English letters, '.', and\u00a0'*'.",
            "It is guaranteed for each appearance of the character '*', there will be a previous valid character to match."
        ],
        "solutions": [
            {
                "language": "python",
                "code": "1, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-1][j-1];\n2, If p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1];\n3, If p.charAt(j) == '*': \n   here are two sub conditions:\n               1   if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty\n               2   if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.':\n                              dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a \n                           or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a\n                           or dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5651/easy-dp-java-solution-with-detailed-explanation/",
                "vote_count": "982"
            },
            {
                "language": "typescript",
                "code": "public boolean isMatch(String s, String p) {\n\n    if (s == null || p == null) {\n        return false;\n    }\n    boolean[][] dp = new boolean[s.length()+1][p.length()+1];\n    dp[0][0] = true;\n    for (int i = 0; i < p.length(); i++) {\n        if (p.charAt(i) == '*' && dp[0][i-1]) {\n            dp[0][i+1] = true;\n        }\n    }\n    for (int i = 0 ; i < s.length(); i++) {\n        for (int j = 0; j < p.length(); j++) {\n            if (p.charAt(j) == '.') {\n                dp[i+1][j+1] = dp[i][j];\n            }\n            if (p.charAt(j) == s.charAt(i)) {\n                dp[i+1][j+1] = dp[i][j];\n            }\n            if (p.charAt(j) == '*') {\n                if (p.charAt(j-1) != s.charAt(i) && p.charAt(j-1) != '.') {\n                    dp[i+1][j+1] = dp[i+1][j-1];\n                } else {\n                    dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]);\n                }\n            }\n        }\n    }\n    return dp[s.length()][p.length()];\n}",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5651/easy-dp-java-solution-with-detailed-explanation/",
                "vote_count": "982"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean isMatch(String s, String p) {\n        // corner case\n        if(s == null || p == null) return false;",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5651/easy-dp-java-solution-with-detailed-explanation/",
                "vote_count": "982"
            },
            {
                "language": "typescript",
                "code": "public class Solution {\n    public boolean isMatch(String s, String p) {\n        if(s == null || p == null) {\n            return false;\n        }\n        boolean[][] state = new boolean[s.length() + 1][p.length() + 1];\n        state[0][0] = true;\n        // no need to initialize state[i][0] as false",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5651/easy-dp-java-solution-with-detailed-explanation/",
                "vote_count": "982"
            },
            {
                "language": "java",
                "code": "  public boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    char[] sc = s.toCharArray(), pc = p.toCharArray();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n    for(int i = 2; i <= n; i++){\n      if(pc[i - 1] == '*'){",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5651/easy-dp-java-solution-with-detailed-explanation/",
                "vote_count": "982"
            },
            {
                "language": "ruby",
                "code": "2 if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.':i->j\nit should be \"2 if p.charAt(j-1) == s.charAt(i) or p.charAt(j-1) == '.'",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5651/easy-dp-java-solution-with-detailed-explanation/",
                "vote_count": "982"
            },
            {
                "language": "javascript",
                "code": "s='aab', p='c*a*b'\n\n      c * a * b \n    0 1 2 3 4 5\n  0 y\na 1\na 2\nb 3",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/191830/java-dp-solution-beats-100-with-explanation/",
                "vote_count": "494"
            },
            {
                "language": "javascript",
                "code": "s='aab', p='c*a*b'\n\n      c * a * b \n    0 1 2 3 4 5\n  0 y\na 1 n\na 2 n\nb 3 n",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/191830/java-dp-solution-beats-100-with-explanation/",
                "vote_count": "494"
            },
            {
                "language": "lisp",
                "code": "        for (int j=2; j<=p.length(); j++) {\n            dp[0][j] = p.charAt(j-1) == '*' && dp[0][j-2]; \n        }",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/191830/java-dp-solution-beats-100-with-explanation/",
                "vote_count": "494"
            },
            {
                "language": "javascript",
                "code": "s='aab', p='c*a*b'\n\n      c * a * b \n    0 1 2 3 4 5\n  0 y n y n y n\na 1 n\na 2 n\nb 3 n",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/191830/java-dp-solution-beats-100-with-explanation/",
                "vote_count": "494"
            },
            {
                "language": "javascript",
                "code": "s='aab', p='c*a*b'\n\n      c * a * b \n    0 1 2 3 4 5\n  0 y n y n y n\na 1 n n n y y n\na 2 n n n n y n\nb 3 n n n n n y",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/191830/java-dp-solution-beats-100-with-explanation/",
                "vote_count": "494"
            },
            {
                "language": "typescript",
                "code": "public boolean isMatch(String s, String p) {\n        if (p == null || p.length() == 0) return (s == null || s.length() == 0);\n        \n        boolean dp[][] = new boolean[s.length()+1][p.length()+1];\n        dp[0][0] = true;\n        for (int j=2; j<=p.length(); j++) {\n            dp[0][j] = p.charAt(j-1) == '*' && dp[0][j-2]; \n        }\n        \n        for (int j=1; j<=p.length(); j++) {\n            for (int i=1; i<=s.length(); i++) {\n                if (p.charAt(j-1) == s.charAt(i-1) || p.charAt(j-1) == '.') \n     dp[i][j] = dp[i-1][j-1];\n                else if(p.charAt(j-1) == '*')\n                    dp[i][j] = dp[i][j-2] || ((s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == '.') && dp[i-1][j]); \n            }\n        }\n        return dp[s.length()][p.length()];\n    }",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/191830/java-dp-solution-beats-100-with-explanation/",
                "vote_count": "494"
            },
            {
                "language": "php",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        if (p.empty())    return s.empty();\n        \n        if ('*' == p[1])\n            // x* matches empty string or at least one character: x* -> xx*\n            // *s is to ensure s is non-empty\n            return (isMatch(s, p.substr(2)) || !s.empty() && (s[0] == p[0] || '.' == p[0]) && isMatch(s.substr(1), p));\n        else\n            return !s.empty() && (s[0] == p[0] || '.' == p[0]) && isMatch(s.substr(1), p.substr(1));\n    }\n};\n\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        /**\n         * f[i][j]: if s[0..i-1] matches p[0..j-1]\n         * if p[j - 1] != '*'\n         *      f[i][j] = f[i - 1][j - 1] && s[i - 1] == p[j - 1]\n         * if p[j - 1] == '*', denote p[j - 2] with x\n         *      f[i][j] is true iff any of the following is true\n         *      1) \"x*\" repeats 0 time and matches empty: f[i][j - 2]\n         *      2) \"x*\" repeats >= 1 times and matches \"x*x\": s[i - 1] == x && f[i - 1][j]\n         * '.' matches any single character\n         */\n        int m = s.size(), n = p.size();\n        vector<vector<bool>> f(m + 1, vector<bool>(n + 1, false));\n        \n        f[0][0] = true;\n        for (int i = 1; i <= m; i++)\n            f[i][0] = false;\n        // p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] is '*' and p[0..j - 3] matches empty\n        for (int j = 1; j <= n; j++)\n            f[0][j] = j > 1 && '*' == p[j - 1] && f[0][j - 2];\n        \n        for (int i = 1; i <= m; i++)\n            for (int j = 1; j <= n; j++)\n                if (p[j - 1] != '*')\n                    f[i][j] = f[i - 1][j - 1] && (s[i - 1] == p[j - 1] || '.' == p[j - 1]);\n                else\n                    // p[0] cannot be '*' so no need to check \"j > 1\" here\n                    f[i][j] = f[i][j - 2] || (s[i - 1] == p[j - 2] || '.' == p[j - 2]) && f[i - 1][j];\n        \n        return f[m][n];\n    }\n};",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5665/my-concise-recursive-and-dp-solutions-with-full-explanation-in-c/",
                "vote_count": "406"
            },
            {
                "language": "java",
                "code": "public boolean isMatch(String s, String p) {\n    /*\n        'match' below including .\n    f(i,j) means s where s.len=i matches p where p.len=j\n    f(i,j) =\n        if (p_j-1 != * ) f(i-1, j-1) and s_i-1 matches p_j-1\n        if (p_j-1 == * )\n            * matches zero times: f(i,j-2)\n- 2));",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5665/my-concise-recursive-and-dp-solutions-with-full-explanation-in-c/",
                "vote_count": "406"
            },
            {
                "language": "csharp",
                "code": " class Solution {\n public:\n  bool isMatch(string s, string p) {\n int m = s.size();\n int n = p.size();\n vector<bool> dp(n + 1, 0);\n dp[0] = 1;",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5665/my-concise-recursive-and-dp-solutions-with-full-explanation-in-c/",
                "vote_count": "406"
            },
            {
                "language": "lisp",
                "code": "if ('*' == p[1])",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5665/my-concise-recursive-and-dp-solutions-with-full-explanation-in-c/",
                "vote_count": "406"
            },
            {
                "language": "lisp",
                "code": "if ((p.length >= 2) and '*' == p[1])",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5665/my-concise-recursive-and-dp-solutions-with-full-explanation-in-c/",
                "vote_count": "406"
            },
            {
                "language": "python",
                "code": "def isMatch(self, s, p):\n    m, n = len(s), len(p)\n    f = [[False] * (n+1) for _ in xrange(m+1)]\n    f[0][0] = True\n    # p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] is '*' and p[0..j - 3] matches empty\n    for j in xrange(2, n+1):\n        f[0][j] = p[j-1] == '*' and f[0][j-2];",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5665/my-concise-recursive-and-dp-solutions-with-full-explanation-in-c/",
                "vote_count": "406"
            },
            {
                "language": "",
                "code": "s[i - 1] == x && f[i - 1][j]",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5665/my-concise-recursive-and-dp-solutions-with-full-explanation-in-c/",
                "vote_count": "406"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int m = s.size(), n = p.size();\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\n        dp[0][0] = true;\n        for (int i = 0; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p[j - 1] == '*') {\n                    dp[i][j] = dp[i][j - 2] || (i && dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n                } else {\n                    dp[i][j] = i && dp[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == '.');\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5684/c-o-n-space-dp/",
                "vote_count": "379"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int m = s.size(), n = p.size();\n        vector<bool> pre(n + 1, false), cur(n + 1, false);\n        cur[0] = true;\n        for (int i = 0; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p[j - 1] == '*') {\n                    cur[j] = cur[j - 2] || (i && pre[j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n                } else {\n                    cur[j] = i && pre[j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == '.');\n                }\n            }\n            fill(pre.begin(), pre.end(), false);\n   swap(pre, cur);\n        }\n        return pre[n];\n    }\n};",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5684/c-o-n-space-dp/",
                "vote_count": "379"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int m = s.size(), n = p.size();\n        vector<bool> cur(n + 1, false);\n        for (int i = 0; i <= m; i++) {\n            bool pre = cur[0];\n            cur[0] = !i;\n            for (int j = 1; j <= n; j++) {\n                bool temp = cur[j];\n                if (p[j - 1] == '*') {\n                    cur[j] = cur[j - 2] || (i && cur[j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n                } else {\n                    cur[j] = i && pre && (s[i - 1] == p[j - 1] || p[j - 1] == '.');\n                }\n                pre = temp;\n            }\n        }\n        return cur[n];\n    }\n};",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5684/c-o-n-space-dp/",
                "vote_count": "379"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        // dynamic programming\n        int m=s.length(), n = p.length();\n        vector<vector<bool>> dp (m+1, vector<bool> (n+1, false));\n        // initial state\n == '.')); ",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5684/c-o-n-space-dp/",
                "vote_count": "379"
            },
            {
                "language": "python",
                "code": "    def isMatch(self, s, p):\n        m, n = len(s), len(p)\n        dp = [[False] * (n+1) for _ in xrange(m+1)]\n        dp[0][0] = True\n        for i in xrange(0, m+1):\n            for j in xrange(1, n+1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-2] or ( i>0 and (s[i-1] == p[j-2] or p[j-2] == '.') and dp[i-1][j])",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5684/c-o-n-space-dp/",
                "vote_count": "379"
            },
            {
                "language": "php",
                "code": "        int m = s.length(), n = p.length();\n        boolean dp[][] = new boolean[m + 1][n + 1];\n        dp[0][0] = true;\n        for(int i = 0; i <= m; ++i) {\n            for(int j = 1; j <= n; ++j) {\n                if(p.charAt(j - 1) == '*') {\n                    dp[i][j] = dp[i][j - 2] || i > 0 && j > 1 && dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.');\n                } else {\n|| p.charAt(j - 1) == '.');",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5684/c-o-n-space-dp/",
                "vote_count": "379"
            },
            {
                "language": "lisp",
                "code": "    for(int j = 1; j <= n; j++) \n        dp[0][j] = (j > 1 && p.charAt(j-1) == '*' && dp[0][j-2]);",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5684/c-o-n-space-dp/",
                "vote_count": "379"
            },
            {
                "language": "csharp",
                "code": "    bool isMatch(string s, string p) {\n        return isMatch(0,s,0,p);    \n    }\n    bool isMatch(int i, string& s, int j, string &p) {\n        int pn=p.size(), sn = s.size();\n        if(j==pn) return i==sn;\n        if(p[j+1]=='*') {\n            if(isMatch(i,s,j+2,p)) return 1;\n            while(i<sn && (p[j]==s[i]||p[j]=='.')) \n    if(isMatch(++i,s,j+2,p)) return 1;\n        } else if (i<sn && (p[j]=='.'|| s[i]==p[j]) && isMatch(i+1,s,j+1,p)) \n   return 1;\n        return 0;\n    }",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5847/evolve-from-brute-force-to-dp/",
                "vote_count": "313"
            },
            {
                "language": "typescript",
                "code": " public boolean isMatch(String s, String p) {\n        return isMatch(0,s,0,p);\n    }\n    private boolean isMatch(int i, String s, int j, String p) { \n        int sn = s.length(), pn = p.length();\n        if(j==pn) { // since * in p can match 0 of previous char, so empty string(i==sn) may match p\n            return i==sn;    \n        }\n        char pj = p.charAt(j);\n        if(j+1<pn && p.charAt(j+1)=='*') { //match *, needs to look at the next char to repeate current char\n            if(isMatch(i,s,j+2,p)) {\n                return true;\n            }\n            while(i<sn && (pj == '.'||pj==s.charAt(i))) {\n                if(isMatch(++i,s,j+2,p)) {\n                    return true;\n                }\n            }\n        } else if(i<sn && (s.charAt(i) == pj ||    //match char\n                   pj=='.')) {              //match dot\n            return isMatch(i+1, s, j+1, p);\n        }\n        return false;\n    }",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5847/evolve-from-brute-force-to-dp/",
                "vote_count": "313"
            },
            {
                "language": "csharp",
                "code": "    bool isMatch(string s, string p) {\n        return isMatch(0,s,0,p);    \n    }\n    bool isMatch(int i, string& s, int j, string &p) {\n        int pn=p.size(), sn = s.size();\n        if(j==pn) return i==sn;\n        if(p[j+1]=='*') {\n            if(isMatch(i,s,j+2,p) || \n               i<sn && (p[j] == '.' || s[i] == p[j]) && isMatch(i+1,s,j,p)) \n      return 1;\n        } else if (i<sn && (p[j]=='.'|| s[i]==p[j]) && isMatch(i+1,s,j+1,p)) \n   return 1;\n        return 0;\n    }",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5847/evolve-from-brute-force-to-dp/",
                "vote_count": "313"
            },
            {
                "language": "typescript",
                "code": " public boolean isMatch(String s, String p) {\n        return isMatch(0,s,0,p);\n    }\n    private boolean isMatch(int i, String s, int j, String p) { \n        int sn = s.length(), pn = p.length();\n        if(j==pn) { // since * in p can match 0 of previous char, so empty string(i==sn) may match p\n            return i==sn;    \n        }\n        char pj = p.charAt(j);\n        if(j+1<pn && p.charAt(j+1)=='*') { //match *, needs to look at the next char to repeate current char\n            if(isMatch(i,s,j+2,p)) {\n                return true;\n            }\n            if(i<sn && (pj == '.'||pj==s.charAt(i))) {\n                if(isMatch(i+1,s,j,p)) {\n                    return true;\n                }\n            }\n        } else if(i<sn && (s.charAt(i) == pj ||    //match char\n                   pj=='.')) {              //match dot\n            return isMatch(i+1, s, j+1, p);\n        }\n        return false;\n    }",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5847/evolve-from-brute-force-to-dp/",
                "vote_count": "313"
            },
            {
                "language": "cpp",
                "code": "    bool isMatch(string s, string p) {\n        vector<vector<char>> dp(s.size()+1,vector<char>(p.size()+1,-1));\n        return isMatch(0,s,0,p,dp);    \n    }\n    bool isMatch(int i, string& s, int j, string &p, vector<vector<char>> &dp) {\n        if(dp[i][j] > -1) return dp[i][j];\n        int pn=p.size(), sn = s.size();\n        if(j==pn) return dp[i][j] = i==sn;\n        if(p[j+1]=='*') {\n            if(isMatch(i,s,j+2,p,dp) || \n               i<sn && (p[j] == '.' || s[i] == p[j]) && isMatch(i+1,s,j,p,dp)) \n      return dp[i][j] = 1;\n        } else if (i<sn && (p[j]=='.'|| s[i]==p[j]) && isMatch(i+1,s,j+1,p,dp)) \n   return dp[i][j] = 1;\n        return dp[i][j] = 0;\n    }",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5847/evolve-from-brute-force-to-dp/",
                "vote_count": "313"
            },
            {
                "language": "typescript",
                "code": " Boolean[][] mem;\n    public boolean isMatch(String s, String p) {\n        mem = new Boolean[s.length()+1][p.length()];\n        return isMatch(0,s,0,p);\n    }\n    private boolean isMatch(int i, String s, int j, String p) { \n        int sn = s.length(), pn = p.length();\n        if(j==pn) { // since * in p can match 0 of previous char, so empty string(i==sn) may match p\n            return i==sn;    \n        }\n        if(mem[i][j]!=null) {\n            return mem[i][j];\n        }\n        char pj = p.charAt(j);\n        if(j+1<pn && p.charAt(j+1)=='*') { //match *, needs to look at the next char to repeate current char\n            if(isMatch(i,s,j+2,p)) {\n                return mem[i][j]=true;\n            }\n            if(i<sn && (pj == '.'||pj==s.charAt(i))) {\n                if(isMatch(i+1,s,j,p)) {\n                    return mem[i][j]=true;\n                }\n            }\n        } else if(i<sn && (s.charAt(i) == pj ||    //match char\n                   pj=='.')) {              //match dot\n            return mem[i][j]=isMatch(i+1, s, j+1, p);\n        }\n        return mem[i][j]=false;\n    }",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5847/evolve-from-brute-force-to-dp/",
                "vote_count": "313"
            },
            {
                "language": "cpp",
                "code": "     bool isMatch(string s, string p) {\n        int pn=p.size(), sn = s.size();\n        vector<vector<bool>> dp(sn+1,vector<bool>(pn+1));\n        dp[sn][pn] = 1;\n        for(int i = sn;i>=0;i--) \n            for(int j=pn-1;j>=0;j--) \n                if(p[j+1]=='*') \n     dp[i][j] = dp[i][j+2] || i<sn && (p[j] == '.' || s[i] == p[j]) && dp[i+1][j];\n                else dp[i][j] = i<sn && (p[j]=='.'|| s[i]==p[j]) && dp[i+1][j+1];\n        return dp[0][0];    \n    }",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5847/evolve-from-brute-force-to-dp/",
                "vote_count": "313"
            },
            {
                "language": "typescript",
                "code": " public boolean isMatch(String s, String p) {\n        int sn=s.length(),pn=p.length();\n        boolean[][] dp=new boolean[sn+1][pn+1];\n        dp[sn][pn]=true;\n        for(int i=sn;i>=0;i--)\n            for(int j=pn-1;j>=0;j--)\n                if(j+1<pn&&p.charAt(j+1)=='*') {\n                    dp[i][j]=dp[i][j+2];\n                    if(i<sn&&(p.charAt(j)=='.'||s.charAt(i)==p.charAt(j))) \n                        dp[i][j]|=dp[i+1][j];\n                } else if(i<sn&&(p.charAt(j)=='.'||s.charAt(i)==p.charAt(j))) \n                    dp[i][j]=dp[i+1][j+1];\n        return dp[0][0];    \n    }\n}",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5847/evolve-from-brute-force-to-dp/",
                "vote_count": "313"
            },
            {
                "language": "typescript",
                "code": " public boolean isMatch(String s, String p) {\n        return s.matches(p); \n    }",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5847/evolve-from-brute-force-to-dp/",
                "vote_count": "313"
            },
            {
                "language": "kotlin",
                "code": "if(p[j+1]=='*') {\n  if(isMatch(i,s,j+2,p)) return 1;        // try to get away with throwing out the *\n  while(i<sn && (p[j]==s[i]||p[j]=='.'))  // eat one at s[i]\n  if(isMatch(++i,s,j+2,p)) return 1;      // try to terminate the * ASAP - if we fail, try to eat another one with star in previous line\n} else if (i<sn && (p[j]=='.'|| s[i]==p[j]) && isMatch(i+1,s,j+1,p))  // BASE CASE\n  return 1;",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5847/evolve-from-brute-force-to-dp/",
                "vote_count": "313"
            },
            {
                "language": "cpp",
                "code": "bool util(string s,int sptr,string p,int pptr,vector<vector<int>> &dp)\n    {\n        if(pptr==p.length())\n            return sptr==s.length();\n        \n        if(dp[sptr][pptr]!=-1)\n            return dp[sptr][pptr];\n        \n&& util(s,sptr+1,p,pptr,dp)))\ndp))",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/5847/evolve-from-brute-force-to-dp/",
                "vote_count": "313"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int n = s.length(), m = p.length();\n        bool dp[n+1][m+1];\n        memset(dp, false, sizeof(dp));\n        dp[0][0] = true;\n        \n        for(int i=0; i<=n; i++){\n            for(int j=1; j<=m; j++){\n                if(p[j-1] == '*'){\n                    dp[i][j] = dp[i][j-2] || (i > 0 && (s[i-1] == p[j-2] || p[j-2] == '.') && dp[i-1][j]);\n                }\n                else{\n                    dp[i][j] = i > 0 && dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.');\n                }\n            }\n        }\n        \n        return dp[n][m];\n    }\n};",
                "url": "https://leetcode.com/problems/regular-expression-matching/solutions/2976919/solution/",
                "vote_count": "33"
            }
        ]
    },
    "10": {
        "question_id": 11,
        "title": "Container With Most Water",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/container-with-most-water",
        "description": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store.Notice that you may not slant the container. ",
        "examples": [
            {
                "input": "height = [1,8,6,2,5,4,8,3,7]",
                "output": "49",
                "explanation": "The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49."
            },
            {
                "input": "height = [1,1]",
                "output": "1",
                "explanation": null
            }
        ],
        "constraints": [
            "n == height.length",
            "2 <= n <= 10^5",
            "0 <= height[i] <= 10^4"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "class Solution:\n    def maxArea(self, height):\n        i, j = 0, len(height) - 1\n        water = 0\n        while i < j:\n            water = max(water, (j - i) * min(height[i], height[j]))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return water",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/6100/simple-and-clear-proof-explanation/",
                "vote_count": "1865"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/6100/simple-and-clear-proof-explanation/",
                "vote_count": "1865"
            },
            {
                "language": "javascript",
                "code": "    `[3....<10 sticks>....5]` water between 3, 5 = 3*11 = 33.\n    ",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/6100/simple-and-clear-proof-explanation/",
                "vote_count": "1865"
            },
            {
                "language": "dart",
                "code": "",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/6100/simple-and-clear-proof-explanation/",
                "vote_count": "1865"
            },
            {
                "language": "rust",
                "code": "",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/6100/simple-and-clear-proof-explanation/",
                "vote_count": "1865"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int maxArea(int[] heights) {\n        int maxArea = 0;\n        \n        int left = 0;\n        int right = heights.length - 1;\n        \n        int maxHeight = 0;",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/6100/simple-and-clear-proof-explanation/",
                "vote_count": "1865"
            },
            {
                "language": "python",
                "code": "        l = 0\n        r = len(height) - 1\n        max_area = 0\n        \n        while l < r:\n            if height[l] >= height[r]:\n                max_area = max(max_area,height[r]*(r-l))\n                r -= 1",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/6100/simple-and-clear-proof-explanation/",
                "vote_count": "1865"
            },
            {
                "language": "",
                "code": "  1 2 3 4 5 6\n1 x ------- o\n2 x x\n3 x x x \n4 x x x x\n5 x x x x x\n6 x x x x x x",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/6099/yet-another-way-to-see-what-happens-in-the-o-n-algorithm/",
                "vote_count": "1722"
            },
            {
                "language": "",
                "code": "  1 2 3 4 5 6\n1 x ------- o\n2 x x       o\n3 x x x     |\n4 x x x x   |\n5 x x x x x |\n6 x x x x x x",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/6099/yet-another-way-to-see-what-happens-in-the-o-n-algorithm/",
                "vote_count": "1722"
            },
            {
                "language": "",
                "code": "  1 2 3 4 5 6\n1 x ------- o\n2 x x - o o o\n3 x x x o | |\n4 x x x x | |\n5 x x x x x |\n6 x x x x x x",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/6099/yet-another-way-to-see-what-happens-in-the-o-n-algorithm/",
                "vote_count": "1722"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        MAX = 0 \n        x = len(height) - 1",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/6099/yet-another-way-to-see-what-happens-in-the-o-n-algorithm/",
                "vote_count": "1722"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n        public:\n            int maxArea(vector<int>& height) {\n                int maxArea = 0;\n                int i = 0, j = height.size() - 1;\n                while(i < j)\n                {\n                    maxArea = max(maxArea, min(height[i], height[j]) * (j - i));\n                    if(height[i] < height[j])",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/6099/yet-another-way-to-see-what-happens-in-the-o-n-algorithm/",
                "vote_count": "1722"
            },
            {
                "language": "php",
                "code": "You are given an integer array height of length n\n\nReturn the maximum amount of water a container can store.",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/1915172/java-c-easiest-explanations/",
                "vote_count": "608"
            },
            {
                "language": "",
                "code": "8    |                                     |\n7    |                                     |             |\n6    |     |                             |             |\n5    |     |             |             |             |\n4    |     |             |     |     |             |\n3    |     |             |     |     |     |     |\n2    |     |     |     |     |     |     |     |\n1    |     |     |     |     |     |     |     |     |\n       0        1       2       3       4       5       6       7       8\n             ^                                       ^",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/1915172/java-c-easiest-explanations/",
                "vote_count": "608"
            },
            {
                "language": "python",
                "code": "> max area which is intially 0\n> Then, we going to have 2 pointers. One in left start at 0th index & one right start from last index.",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/1915172/java-c-easiest-explanations/",
                "vote_count": "608"
            },
            {
                "language": "swift",
                "code": "8    |                                     |\n7    |                                     |             |                             width = 8 - 0 = 8\n6    |     |                             |             |                             height = min(1, 7)\n5    |     |             |             |             |                             Area = 8 * 1 = 8\n4    |     |             |     |     |             |\n3    |     |             |     |     |     |     |                             max = 0 -> max = 8\n2    |     |     |     |     |     |     |     |\n1    |     |     |     |     |     |     |     |     |\n       0        1       2       3       4       5       6       7       8\n    ^                                                                ^\n   left                                                            right",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/1915172/java-c-easiest-explanations/",
                "vote_count": "608"
            },
            {
                "language": "swift",
                "code": "8    |                                     |\n7    |                                     |             |                             width = 8 - 1 = 7\n6    |     |                             |             |                             height = min(8, 7)\n5    |     |             |             |             |                             Area = 7 * 7 = 49\n4    |     |             |     |     |             |\n3    |     |             |     |     |     |     |                             max = 8 -> max = 49\n2    |     |     |     |     |     |     |     |\n1    |     |     |     |     |     |     |     |     |\n       0        1       2       3       4       5       6       7       8\n             ^                                                       ^\n            left                                                   right",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/1915172/java-c-easiest-explanations/",
                "vote_count": "608"
            },
            {
                "language": "python",
                "code": "8    |                                     |\n7    |                                     |             |                             width = 7 - 1 = 6\n6    |     |                             |             |                             height = min(8, 3)\n5    |     |             |             |             |                             Area = 6 * 3 = 18\n4    |     |             |     |     |             |\n3    |     |             |     |     |     |     |                             max = 49\n2    |     |     |     |     |     |     |     |\n1    |     |     |     |     |     |     |     |     |\n       0        1       2       3       4       5       6       7       8\n             ^                                               ^\n            left                                           right",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/1915172/java-c-easiest-explanations/",
                "vote_count": "608"
            },
            {
                "language": "python",
                "code": "8    |                                     |\n7    |                                     |             |                             width = 6 - 1 = 5\n6    |     |                             |             |                             height = min(8, 8)\n5    |     |             |             |             |                             Area = 8 * 5 = 40\n4    |     |             |     |     |             |\n3    |     |             |     |     |     |     |                             max = 49\n2    |     |     |     |     |     |     |     |\n1    |     |     |     |     |     |     |     |     |\n       0        1       2       3       4       5       6       7       8\n             ^                                       ^\n            left                                   right",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/1915172/java-c-easiest-explanations/",
                "vote_count": "608"
            },
            {
                "language": "python",
                "code": "8    |                                     |\n7    |                                     |             |                             width = 5 - 2 = 3\n6    |     |                             |             |                             height = min(4, 6)\n5    |     |             |             |             |                             Area = 4 * 3 = 12\n4    |     |             |     |     |             |\n3    |     |             |     |     |     |     |                             max = 49\n2    |     |     |     |     |     |     |     |\n1    |     |     |     |     |     |     |     |     |\n       0        1       2       3       4       5       6       7       8\n                     ^                       ^\n                    left                   right",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/1915172/java-c-easiest-explanations/",
                "vote_count": "608"
            },
            {
                "language": "python",
                "code": "8    |                                     |\n7    |                                     |             |                             width = 4 - 2 = 2\n6    |     |                             |             |                             height = min(5, 6)\n5    |     |             |             |             |                             Area = 5 * 2 = 10\n4    |     |             |     |     |             |\n3    |     |             |     |     |     |     |                             max = 49\n2    |     |     |     |     |     |     |     |\n1    |     |     |     |     |     |     |     |     |\n       0        1       2       3       4       5       6       7       8\n                     ^               ^\n                    left           right",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/1915172/java-c-easiest-explanations/",
                "vote_count": "608"
            },
            {
                "language": "python",
                "code": "8    |                                     |\n7    |                                     |             |                             width = 3 - 2 = 1\n6    |     |                             |             |                             height = min(2, 6)\n5    |     |             |             |             |                             Area = 2 * 1 = 2\n4    |     |             |     |     |             |\n3    |     |             |     |     |     |     |                             max = 49\n2    |     |     |     |     |     |     |     |\n1    |     |     |     |     |     |     |     |     |\n       0        1       2       3       4       5       6       7       8\n                     ^       ^\n                    left   right",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/1915172/java-c-easiest-explanations/",
                "vote_count": "608"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int maxArea(int[] height) {\n        int left = 0;\n        int right = height.length - 1;\n        int max = 0;\n        while(left < right){\n            int w = right - left;\n            int h = Math.min(height[left], height[right]);\n            int area = h * w;\n            max = Math.max(max, area);\n            if(height[left] < height[right]) left++;\n            else if(height[left] > height[right]) right--;\n            else {\n                left++;\n                right--;\n            }\n        }\n        return max;\n    }\n}",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/1915172/java-c-easiest-explanations/",
                "vote_count": "608"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int left = 0;\n        int right = height.size() - 1;\n        int maxi = 0;\n        while(left < right){\n            int w = right - left;\n            int h = min(height[left], height[right]);\n            int area = h * w;\n            maxi = max(maxi, area);\n            if(height[left] < height[right]) left++;\n            else if(height[left] > height[right]) right--;\n            else {\n                left++;\n                right--;\n            }\n        }\n        return maxi;\n    }\n};",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/1915172/java-c-easiest-explanations/",
                "vote_count": "608"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxArea(vector<int> &height) {\n        int i = 0, j = height.size() - 1, area = 0;\n        while (i < j) {\n            area = max(area, min(height[i], height[j]) * (j - i));\n            height[i] < height[j] ? i++ : j--;\n        }",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/1915172/java-c-easiest-explanations/",
                "vote_count": "608"
            },
            {
                "language": "python",
                "code": "    int i=0;\n    int j=height.size()-1;\n    int ans=0;\n    while(i<j){\n        if(height[i]<=height[j]){",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/1915172/java-c-easiest-explanations/",
                "vote_count": "608"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxArea(vector<int>& height) {\n       int ans = 0, n = height.size();\n       int i = 0, j = n-1;\n       while(i<j){\n           if(height[i]>height[j]){\n               ans = max(ans, (j-i)*height[j]);\n               j--;\n           }\n           else{\n               ans = max(ans, (j-i)*height[i]);\n               i++;\n           }\n       }\n       return ans;\n    }\n};\n\nDo Upvote if it helps.",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/3278302/c-accepted-code-beginner-friendly-two-pointers-approach/",
                "vote_count": "43"
            },
            {
                "language": "ruby",
                "code": "  Code in JAVA and C :-",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/3277192/accepted-o-n-simple-and-fast-java-c-solution/",
                "vote_count": "26"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int maxArea(int[] arr) {\n        final int N = arr.length;\n        int max = 0 , test, i=0, j=N-1;\n        while(j>i){\n            test = arr[i] < arr[j] ? arr[i] : arr[j];\n            test = (j - i) * test;\n            if(max < test) max = test;\n            if(arr[i] < arr[j]) i++ ;\n            else j--;\n        }\n        return max;\n    }\n}",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/3277192/accepted-o-n-simple-and-fast-java-c-solution/",
                "vote_count": "26"
            },
            {
                "language": "python",
                "code": "int maxArea(int* arr, int N){\n    int max = 0,test,i=0,j=N-1;\n    while(j>i){\n        test = arr[i];\n        if(test>arr[j]) test = arr[j];\n        test = (j - i) * test;\n        if(max < test) max = test;\n        if(arr[i] < arr[j]) i++ ;\n        else j--;\n    }\n    return max;\n}",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/3277192/accepted-o-n-simple-and-fast-java-c-solution/",
                "vote_count": "26"
            },
            {
                "language": "cpp",
                "code": "public int maxArea(int[] height) {      \n       final int N = height.length;\n       int max = 0 , area, i=0, j=N-1, min_height;\n       while(j > i)  {\n           // find the smaller side of the bucket",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/3277192/accepted-o-n-simple-and-fast-java-c-solution/",
                "vote_count": "26"
            },
            {
                "language": "javascript",
                "code": "var maxArea = function (height) {\n    var leftIndex = 0;\n    var rightIndex = height.length - 1;\n    var maxStoredWater = 0;\n\n    while (leftIndex < rightIndex) {\n        const leftHeight = height[leftIndex];\n        const rightHeight = height[rightIndex];\n        const width = rightIndex - leftIndex;\n        const smallerHeight = leftHeight < rightHeight ? leftHeight : rightHeight;\n        const storedWater = width * smallerHeight;\n\n        maxStoredWater = storedWater > maxStoredWater ? storedWater : maxStoredWater;\n        smallerHeight == leftHeight ? leftIndex++ : rightIndex--;\n    }\n\n    return maxStoredWater;\n};",
                "url": "https://leetcode.com/problems/container-with-most-water/solutions/3329256/98-59-javascript-simply-as-possible-with-readable-variables/",
                "vote_count": "10"
            }
        ]
    },
    "11": {
        "question_id": 12,
        "title": "Integer to Roman",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/integer-to-roman",
        "description": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.Symbol       ValueI             1V             5X             10L             50C             100D             500M             1000For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.Given an integer, convert it to a roman numeral. ",
        "examples": [
            {
                "input": "num = 3",
                "output": "\"III\"",
                "explanation": "3 is represented as 3 ones."
            },
            {
                "input": "num = 58",
                "output": "\"LVIII\"",
                "explanation": "L = 50, V = 5, III = 3."
            },
            {
                "input": "num = 1994",
                "output": "\"MCMXCIV\"",
                "explanation": "M = 1000, CM = 900, XC = 90 and IV = 4."
            }
        ],
        "constraints": [
            "1 <= num <= 3999"
        ],
        "solutions": [
            {
                "language": "dart",
                "code": "public static String intToRoman(int num) {\n    String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\n    String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\n    String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\n    String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\n    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];\n}",
                "url": "https://leetcode.com/problems/integer-to-roman/solutions/6274/simple-solution/",
                "vote_count": "2441"
            },
            {
                "language": "dart",
                "code": "class Solution {\n    public:\n        string intToRoman(int num) {\n            static const string s[4][10]= \n            { \n                {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"},\n                {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"},\n                {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"},",
                "url": "https://leetcode.com/problems/integer-to-roman/solutions/6274/simple-solution/",
                "vote_count": "2441"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string intToRoman(int num) {\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\n        \n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\n    }\n};",
                "url": "https://leetcode.com/problems/integer-to-roman/solutions/1293176/c-easy-solution-o-1/",
                "vote_count": "532"
            },
            {
                "language": "kotlin",
                "code": "    while(num){\n        s.push((num%10)*power);\n        power*=10;\n        num/=10;",
                "url": "https://leetcode.com/problems/integer-to-roman/solutions/1293176/c-easy-solution-o-1/",
                "vote_count": "532"
            },
            {
                "language": "dart",
                "code": "    public String intToRoman(int num) {\n        int value[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n        String symbol[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\n        StringBuilder sb = new StringBuilder();\n        while(num>0){\n            for(int i=0;i<value.length;i++){\n                if(num>=value[i]){",
                "url": "https://leetcode.com/problems/integer-to-roman/solutions/1293176/c-easy-solution-o-1/",
                "vote_count": "532"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string intToRoman(int num) {\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\n        \n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\n    }\n};",
                "url": "https://leetcode.com/problems/integer-to-roman/solutions/2962674/easiest-o-1-faang-method-ever/",
                "vote_count": "128"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string intToRoman(int num) {\n        int normal[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};\n        string roman[]={\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\n        string res;\n        for(int i=0;i<13;i++){\n            while(num>=normal[i]){\n                res.append(roman[i]);\n                num-=normal[i];\n            }\n        }\n        return res;\n    }\n};",
                "url": "https://leetcode.com/problems/integer-to-roman/solutions/2723774/c-simple-and-easy-solution/",
                "vote_count": "113"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic: \n    string intToRoman(int A) {\n    string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\n    string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\n    string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\n    string thns[] = {\"\",\"M\",\"MM\",\"MMM\"};\n    return thns[A/1000] + hrns[(A%1000)/100] + tens[(A%100)/10] + ones[A%10];\n}",
                "url": "https://leetcode.com/problems/integer-to-roman/solutions/2723774/c-simple-and-easy-solution/",
                "vote_count": "113"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        # Creating Dictionary for Lookup\n        num_map = {\n            1: \"I\",\n            5: \"V\",    4: \"IV\",\n            10: \"X\",   9: \"IX\",\n            50: \"L\",   40: \"XL\",\n            100: \"C\",  90: \"XC\",\n            500: \"D\",  400: \"CD\",\n            1000: \"M\", 900: \"CM\",\n        }\n        \n        # Result Variable\n        r = ''\n        \n        \n        for n in [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]:\n            # If n in list then add the roman value to result variable\n            while n <= num:\n                r += num_map[n]\n                num-=n\n        return r",
                "url": "https://leetcode.com/problems/integer-to-roman/solutions/2724200/python-s-simple-and-easy-to-understand-solution-99-faster/",
                "vote_count": "94"
            },
            {
                "language": "dart",
                "code": "r = ''\nfor key, value in num_map.items():\n    while key <= num:\n        r += value\n        num -= key\nreturn r",
                "url": "https://leetcode.com/problems/integer-to-roman/solutions/2724200/python-s-simple-and-easy-to-understand-solution-99-faster/",
                "vote_count": "94"
            },
            {
                "language": "cpp",
                "code": "//Approach 1 : \n//time complexity - O(1) since the algorithm always iterates through a constant number of values (13 in this case).\n//O(1) since the amount of extra space used is constant (the size of the storeIntRoman vector, which is also 13 in this case\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        string Roman = \"\";\n        // Creating vector of pairs to store the Roman numeral values and their corresponding symbols\n        vector<pair<int, string>> storeIntRoman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\n        // Iterating through the vector and repeatedly adds the corresponding symbols to the result string while subtracting the corresponding value from the input integer until the input integer becomes zero.\n        for (int i = 0; i < storeIntRoman.size(); i++) {\n            while (num >= storeIntRoman[i].first) {\n                Roman += storeIntRoman[i].second;\n                num -= storeIntRoman[i].first;\n            }\n        }\n        return Roman;\n    }\n};",
                "url": "https://leetcode.com/problems/integer-to-roman/solutions/3216797/easiest-beginner-friendly-sol-c-java-python/",
                "vote_count": "56"
            },
            {
                "language": "csharp",
                "code": "string intToRoman(int num) {\n    string str[13] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n    int val[13] = {1000, 900, 500, 400, 100,  90,  50,  40, 10,   9,   5,   4,  1};\n    string ans;\n    for (int i=0; i<13; i++) {\n        for (int j=0; j<(num/val[i]); j++) {\n            ans += str[i];\n        }\n        num %= val[i];\n    }\n    return ans;\n}",
                "url": "https://leetcode.com/problems/integer-to-roman/solutions/2724006/c-integer-to-roman-just-8-lines-of-code/",
                "vote_count": "20"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(1), We are scanning Array(val) of the number one by one therefore, the maximum time can\n    be used to iterate over Array(val) is O(1) which is constant because we can maximum do around 18 iteration\n    which is constant.\n\n    Space Complexity : O(1), We are using integer arrays and one string array whose sizes don\u2019t depend on the\n    input size hence the space complexity will be O(1).\n\n    Solved using String + Hash Table + Math.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        string res;\n        string sym[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n        int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n\n        for(int i=0; num != 0; i++){\n            while(num >= val[i]){\n                num -= val[i];\n                res += sym[i];\n            }\n        }\n        return res;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(1), We are scanning each digit of the number one by one therefore, the time complexity\n    will be O(log10N). But N cannot be grater than 3999, therefore, the maximum time can be O(loh103999) ~= \n    O(3.60) which is constant hence the overall time complexity will be O(1).\n\n    Space Complexity : O(1), We are using four arrays whose sizes don\u2019t depend on the input size hence the space\n    complexity will be O(1).\n\n    Solved using String + Hash Table + Math.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        vector<string> ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\n        vector<string> tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\n        vector<string> hundred = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\n        vector<string> thousand = {\"\", \"M\", \"MM\", \"MMM\"};\n        \n        string ans = \"\";\n        \n        ans += thousand[num/1000] + hundred[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/integer-to-roman/solutions/3202670/best-c-2-solution-hash-table-math-string-one-stop-solution/",
                "vote_count": "14"
            }
        ]
    },
    "12": {
        "question_id": 13,
        "title": "Roman to Integer",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/roman-to-integer",
        "description": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.Symbol       ValueI             1V             5X             10L             50C             100D             500M             1000For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer. ",
        "examples": [
            {
                "input": "s = \"III\"",
                "output": "3",
                "explanation": "III = 3."
            },
            {
                "input": "s = \"LVIII\"",
                "output": "58",
                "explanation": "L = 50, V= 5, III = 3."
            },
            {
                "input": "s = \"MCMXCIV\"",
                "output": "1994",
                "explanation": "M = 1000, CM = 900, XC = 90 and IV = 4."
            }
        ],
        "constraints": [
            "1 <= s.length <= 15",
            "s contains only\u00a0the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').",
            "It is guaranteed\u00a0that s is a valid roman numeral in the range [1, 3999]."
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        translations = {\n            \"I\": 1,\n            \"V\": 5,\n            \"X\": 10,\n            \"L\": 50,\n            \"C\": 100,\n            \"D\": 500,\n            \"M\": 1000\n        }\n        number = 0\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\")\n        s = s.replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\")\n        s = s.replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\n        for char in s:\n            number += translations[char]\n        return number",
                "url": "https://leetcode.com/problems/roman-to-integer/solutions/264743/clean-python-beats-99-78/",
                "vote_count": "1555"
            },
            {
                "language": "typescript",
                "code": "    result_number = 0 \n    prevous_number = 0\n    mapping = {'I':1, \n            'V':5, ",
                "url": "https://leetcode.com/problems/roman-to-integer/solutions/264743/clean-python-beats-99-78/",
                "vote_count": "1555"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        roman_to_integer = {'I': 1,\n                            'V': 5,\n                            'X': 10,\n                            'L': 50,\n                            'C': 100,\n                            'D': 500,",
                "url": "https://leetcode.com/problems/roman-to-integer/solutions/264743/clean-python-beats-99-78/",
                "vote_count": "1555"
            },
            {
                "language": "kotlin",
                "code": "return sum(map(data.get, s))",
                "url": "https://leetcode.com/problems/roman-to-integer/solutions/264743/clean-python-beats-99-78/",
                "vote_count": "1555"
            },
            {
                "language": "dart",
                "code": " public int romanToInt(String s) {\n         int ans = 0, num = 0;\n        for (int i = s.length()-1; i >= 0; i--) {\n            switch(s.charAt(i)) {\n                case 'I': num = 1; break;\n                case 'V': num = 5; break;\n                case 'X': num = 10; break;\n                case 'L': num = 50; break;\n                case 'C': num = 100; break;\n                case 'D': num = 500; break;\n                case 'M': num = 1000; break;\n            }\n            if (4 * num < ans) ans -= num;\n            else ans += num;\n        }\n        return ans;\n    }",
                "url": "https://leetcode.com/problems/roman-to-integer/solutions/2632431/java-90-faster-solution/",
                "vote_count": "637"
            },
            {
                "language": "typescript",
                "code": "public int romanToInt(String s) {\n    \n    int answer = 0, number = 0, prev = 0;\n\n    for (int j = s.length() - 1; j >= 0; j--) {\n        switch (s.charAt(j)) {\n            case 'M' -> number = 1000;",
                "url": "https://leetcode.com/problems/roman-to-integer/solutions/2632431/java-90-faster-solution/",
                "vote_count": "637"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\nint romanToInt(string s) {\n    unordered_map<char,int> mp{\n        {'I',1},\n        {'V',5},\n        {'X',10},\n        {'L',50},\n        {'C',100},\n        {'D',500},\n        {'M',1000},\n    };\n    int ans =0;\n    for(int i=0;i<s.size();i++){\n        if(mp[s[i]]<mp[s[i+1]])\n            ans-=mp[s[i]];\n        else\n            ans+=mp[s[i]];\n    }\n    return ans;\n    \n}\n};",
                "url": "https://leetcode.com/problems/roman-to-integer/solutions/2426521/c-o-n-short-code-clean-code-fast-and-easy/",
                "vote_count": "331"
            },
            {
                "language": "lisp",
                "code": "    int ans=0;\n    for(int i=s.length();i>=0;i--)\n        ((i+1)<s.length() and m1[s[i]]<m1[s[i+1]])?ans-=m1[s[i]]:ans+=m1[s[i]];\n    ",
                "url": "https://leetcode.com/problems/roman-to-integer/solutions/2426521/c-o-n-short-code-clean-code-fast-and-easy/",
                "vote_count": "331"
            },
            {
                "language": "",
                "code": "",
                "url": "https://leetcode.com/problems/roman-to-integer/solutions/2426521/c-o-n-short-code-clean-code-fast-and-easy/",
                "vote_count": "331"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        roman_to_integer = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000,\n        }\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\").replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\").replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\n        return sum(map(lambda x: roman_to_integer[x], s))",
                "url": "https://leetcode.com/problems/roman-to-integer/solutions/2428756/python-easily-understood-faster-than-98-less-than-76-o-n/",
                "vote_count": "298"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def romanToInt(self, s: str) -> int:\n    \n        # rti is a dict for roman to intgers values\n        rti = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000}\n\n        # ans is for our sum value\n        ans=0",
                "url": "https://leetcode.com/problems/roman-to-integer/solutions/2428756/python-easily-understood-faster-than-98-less-than-76-o-n/",
                "vote_count": "298"
            },
            {
                "language": "csharp",
                "code": "def romanToInt(s: str) -> int:\n        conversion = {\n            'I':1,\n            'V':5,\n            'X':10,\n            'L':50,\n            'C':100,\n            'D':500,\n).replace('CD','CCCC').replace('CM','DCCCC')",
                "url": "https://leetcode.com/problems/roman-to-integer/solutions/2428756/python-easily-understood-faster-than-98-less-than-76-o-n/",
                "vote_count": "298"
            },
            {
                "language": "rust",
                "code": "def romanToInt(self, s: str) -> int:\n    roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000, \"k\": 0}\n    tmp = s + \"k\"\n    res = idx = 0\n\n    while idx != len(s):",
                "url": "https://leetcode.com/problems/roman-to-integer/solutions/2428756/python-easily-understood-faster-than-98-less-than-76-o-n/",
                "vote_count": "298"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int romanToInt(string s) {\n        int ans=0;\n        unordered_map <char,int> mp{\n        {'I',1},{'V',5},{'X',10},{'L',50},{'C',100},{'D',500},{'M',1000}};\n\n    for(int i=0;i<s.size();i++){\n        if(mp[s[i]]<mp[s[i+1]]){\n            //for cases such as IV,CM, XL, etc...\n            ans=ans-mp[s[i]];\n        }\n        else{\n            ans=ans+mp[s[i]];\n        }\n    }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/roman-to-integer/solutions/3051142/easy-c-solution-with-short-code/",
                "vote_count": "203"
            },
            {
                "language": "cpp",
                "code": "if (const auto& iter = mp.find('\\0'); iter != mp.end()) {\n    std::cout << \"Contains null-terminator: \" << mp.at('\\0') << std::endl;\n}",
                "url": "https://leetcode.com/problems/roman-to-integer/solutions/3051142/easy-c-solution-with-short-code/",
                "vote_count": "203"
            },
            {
                "language": "javascript",
                "code": "var romanToInt = function(s) {\n      const sym = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    }\n\n    let result = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        const cur = sym[s[i]];\n        const next = sym[s[i + 1]];\n\n        if (cur < next) {\n            result += next - cur;\n            i++;\n        } else {\n            result += cur;\n        }\n    }\n\n    return result;\n};",
                "url": "https://leetcode.com/problems/roman-to-integer/solutions/2706813/js-hash-table-with-exlanation/",
                "vote_count": "144"
            },
            {
                "language": "go",
                "code": "/*\n\n    Time Complexity : O(1), The maximum length of the string(s) can be 15 (as per the Constgraint), therefore, the\n    worst case time complexity can be O(15) or O(1).\n\n    Space Complexity : O(1), We are using unordered_map(map) to store the Roman symbols and their corresponding\n    integer values but there are only 7 symbols hence the worst case space complexity can be O(7) which is\n    equivalent to O(1).\n\n    Solved using String + Hash Table + Math.\n\n*/\n\nclass Solution {\npublic:\n    int romanToInt(string s) {\n        unordered_map<char, int> map;\n\n        map['I'] = 1;\n        map['V'] = 5;\n        map['X'] = 10;\n        map['L'] = 50;\n        map['C'] = 100;\n        map['D'] = 500;\n        map['M'] = 1000;\n        \n        int ans = 0;\n        \n        for(int i=0; i<s.length(); i++){\n            if(map[s[i]] < map[s[i+1]]){\n                ans -= map[s[i]];\n            }\n            else{\n                ans += map[s[i]];\n            }\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/roman-to-integer/solutions/3202671/best-c-solution-hash-table-math-string-one-stop-solution/",
                "vote_count": "52"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int romanToInt(String s) {\n        Map<Character,Integer>map=new HashMap<>();\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        int value=0;\n        for(int i=0;i<s.length();i++){\n            if(i<s.length()-1 && map.get(s.charAt(i))<map.get(s.charAt(i+1))){\n                value-=map.get(s.charAt(i));\n            }\n            else{\n                value+=map.get(s.charAt(i));\n            }\n        }\n        return value;\n    }\n}",
                "url": "https://leetcode.com/problems/roman-to-integer/solutions/3302492/hashmap-solution-java-very-easy/",
                "vote_count": "15"
            }
        ]
    },
    "13": {
        "question_id": 14,
        "title": "Longest Common Prefix",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.If there is no common prefix, return an empty string \"\". ",
        "examples": [
            {
                "input": "strs = [\"flower\",\"flow\",\"flight\"]",
                "output": "\"fl\"",
                "explanation": null
            },
            {
                "input": "strs = [\"dog\",\"racecar\",\"car\"]",
                "output": "\"\"",
                "explanation": "There is no common prefix among the input strings."
            }
        ],
        "constraints": [
            "1 <= strs.length <= 200",
            "0 <= strs[i].length <= 200",
            "strs[i] consists of only lowercase English letters."
        ],
        "solutions": [
            {
                "language": "python",
                "code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        String prefix = strs[0];\n        for(int index=1;index<strs.length;index++){\n            while(strs[index].indexOf(prefix) != 0){\n                prefix=prefix.substring(0,prefix.length()-1);\n            }\n        }\n        return prefix;\n    }\n}\n\n/*\nPLEASE UPVOTE IF IT HELPS YOU! THANK YOU!\nRecommend to dry run along with the example.\n\nWorking:\n1)Take the first(index=0) string in the array as prefix.\n2)Iterate from second(index=1) string till the end.\n3)Use the indexOf() function to check if the prefix is there in the strs[i] or not.\nIf the prefix is there the function returns 0 else -1.\n4)Use the substring function to chop the last letter from prefix each time the function return -1.\n\neg:\nstrs=[\"flower\", \"flow\", \"flight\"]\nprefix=flower\nindex=1\n    while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flower\")!=0)\n    Since flower as a whole is not in flow, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flowe\"\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flowe\")!=0)\n    Since flowe as a whole is not in flow, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flow\"\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flow\")!=0)\n    Since flow as a whole is in flow, it returns 0 so now prefix=flow\nindex=2\n    while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"flow\")!=0)\n    Since flow as a whole is not in flight, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flo\"\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"flo\")!=0)\n    Since flo as a whole is not in flight, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"fl\"\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"fl\")!=0)\n    Since fl as a whole is in flight, it returns 0 so now prefix=fl\nindex=3, for loop terminates and we return prefix which is equal to fl\n*/",
                "url": "https://leetcode.com/problems/longest-common-prefix/solutions/1405155/java-detailed-solution-0-ms-faster-than-100/",
                "vote_count": "467"
            },
            {
                "language": "swift",
                "code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        String prefix = strs[0];\n        for(int i = 1;i < strs.length(); i++){\n            while(strs[i].indexOf(prefix) != 0)\n                prefix = prefix.substring(0, prefix.length() - 1);\n            if(prefix.isEmpty())",
                "url": "https://leetcode.com/problems/longest-common-prefix/solutions/1405155/java-detailed-solution-0-ms-faster-than-100/",
                "vote_count": "467"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        Arrays.sort(strs);\n        String s1 = strs[0];\n        String s2 = strs[strs.length-1];\n        int idx = 0;\n        while(idx < s1.length() && idx < s2.length()){\n            if(s1.charAt(idx) == s2.charAt(idx)){\n                idx++;\n            } else {\n                break;\n            }\n        }\n        return s1.substring(0, idx);\n    }\n}",
                "url": "https://leetcode.com/problems/longest-common-prefix/solutions/3174307/well-explained-code-using-strings-in-java/",
                "vote_count": "372"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& s) {\n        int ans = s[0].length(), n = s.size();\n        for(int i=1; i<n; i++){\n            int j = 0;\n            while(j<s[i].length() && s[i][j]==s[0][j])j++;\n            ans = min(ans, j);\n        }\n        return s[0].substr(0, ans);\n    }\n};",
                "url": "https://leetcode.com/problems/longest-common-prefix/solutions/2669032/c-very-easy-explained/",
                "vote_count": "236"
            },
            {
                "language": "csharp",
                "code": "string longestCommonPrefix(vector<string>& strs) {\n    string str=\"\";\n    string initial = strs[0];\n    for(int j=0;j<initial.size();j++)\n    {\n        int i=1;\n        for(;i<strs.size();i++)",
                "url": "https://leetcode.com/problems/longest-common-prefix/solutions/2669032/c-very-easy-explained/",
                "vote_count": "236"
            },
            {
                "language": "swift",
                "code": "    public String longestCommonPrefix(String[] strs) {\n        if(strs.length==0) return \"\";\n        String prefix=strs[0];\n        for(int i=1;i<strs.length;i++){\n            while(strs[i].indexOf(prefix)!=0){\n                prefix=prefix.substring(0,prefix.length()-1);\n            }\n            \n        }\n        return prefix;\n        \n        \n    }\n//Please upvote",
                "url": "https://leetcode.com/problems/longest-common-prefix/solutions/2748936/simple-java-solution/",
                "vote_count": "141"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def longestCommonPrefix(self, v: List[str]) -> str:\n        ans=\"\"\n        v=sorted(v)\n        first=v[0]\n        last=v[-1]\n        for i in range(min(len(first),len(last))):\n            if(first[i]!=last[i]):\n                return ans\n            ans+=first[i]\n        return ans ",
                "url": "https://leetcode.com/problems/longest-common-prefix/solutions/3273176/python3-c-19-ms-beats-99-91/",
                "vote_count": "112"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& v) {\n        string ans=\"\";\n        sort(v.begin(),v.end());\n        int n=v.size();\n        string first=v[0],last=v[n-1];\n        for(int i=0;i<min(first.size(),last.size());i++){\n            if(first[i]!=last[i]){\n                return ans;\n            }\n            ans+=first[i];\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/longest-common-prefix/solutions/3273176/python3-c-19-ms-beats-99-91/",
                "vote_count": "112"
            },
            {
                "language": "python",
                "code": "range(len(v[0])) # beats 79%",
                "url": "https://leetcode.com/problems/longest-common-prefix/solutions/3273176/python3-c-19-ms-beats-99-91/",
                "vote_count": "112"
            },
            {
                "language": "python",
                "code": "range(min(len(v[0]),len(v[-1]))) # beats 97%",
                "url": "https://leetcode.com/problems/longest-common-prefix/solutions/3273176/python3-c-19-ms-beats-99-91/",
                "vote_count": "112"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        sort(strs.begin(),strs.end());\n        int a=strs.size();\n        string n=strs[0],m=strs[a-1],ans=\"\";\n        for(int i=0;i<n.size();i++){\n            if(n[i]==m[i]){ans+=n[i];}\n            else break;\n        }\n        return ans;\n        \n    }\n};\nDo UPVOTE if you like",
                "url": "https://leetcode.com/problems/longest-common-prefix/solutions/3184623/simplest-c-code-easy-to-understand/",
                "vote_count": "94"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        res = \"\"\n        for a in zip(*strs):\n            if len(set(a)) == 1: \n                res += a[0]\n            else: \n                return res\n        return res\n                        ",
                "url": "https://leetcode.com/problems/longest-common-prefix/solutions/3031312/longest-common-prefix-in-python/",
                "vote_count": "86"
            }
        ]
    },
    "14": {
        "question_id": 15,
        "title": "3Sum",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/3sum",
        "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.Notice that the solution set must not contain duplicate triplets. ",
        "examples": [
            {
                "input": "nums = [-1,0,1,2,-1,-4]",
                "output": "[[-1,-1,2],[-1,0,1]]",
                "explanation": "\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter."
            },
            {
                "input": "nums = [0,1,1]",
                "output": "[]",
                "explanation": "The only possible triplet does not sum up to 0."
            },
            {
                "input": "nums = [0,0,0]",
                "output": "[[0,0,0]]",
                "explanation": "The only possible triplet sums up to 0."
            }
        ],
        "constraints": [
            "3 <= nums.length <= 3000",
            "-10^5 <= nums[i] <= 10^5"
        ],
        "solutions": [
            {
                "language": "ruby",
                "code": "std::sort(res.begin(), res.end());\nres.erase(unique(res.begin(), res.end()), res.end());",
                "url": "https://leetcode.com/problems/3sum/solutions/7402/share-my-ac-c-solution-around-50ms-o-n-n-with-explanation-and-comments/",
                "vote_count": "1195"
            },
            {
                "language": "cpp",
                "code": "vector<vector<int> > threeSum(vector<int> &num) {\n    \n    vector<vector<int> > res;\n\n    std::sort(num.begin(), num.end());\n\n    for (int i = 0; i < num.size(); i++) {\n        \n        int target = -num[i];\n        int front = i + 1;\n        int back = num.size() - 1;\n\n        while (front < back) {\n\n            int sum = num[front] + num[back];\n            \n            // Finding answer which start from number num[i]\n            if (sum < target)\n                front++;\n\n            else if (sum > target)\n                back--;\n\n            else {\n                vector<int> triplet = {num[i], num[front], num[back]};\n                res.push_back(triplet);\n                \n                // Processing duplicates of Number 2\n                // Rolling the front pointer to the next different number forwards\n                while (front < back && num[front] == triplet[1]) front++;\n\n                // Processing duplicates of Number 3\n                // Rolling the back pointer to the next different number backwards\n                while (front < back && num[back] == triplet[2]) back--;\n            }\n            \n        }\n\n        // Processing duplicates of Number 1\n        while (i + 1 < num.size() && num[i + 1] == num[i]) \n            i++;\n\n    }\n    \n    return res;\n    \n}",
                "url": "https://leetcode.com/problems/3sum/solutions/7402/share-my-ac-c-solution-around-50ms-o-n-n-with-explanation-and-comments/",
                "vote_count": "1195"
            },
            {
                "language": "cpp",
                "code": "vector<vector<int>> threeSum(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int n=nums.size();\n        vector<vector<int>> res;\n        for(int i=0;i<n-2;i++){\n               if(i>0 && (nums[i]==nums[i-1]) )continue;\n               int l=i+1, r= n-1;\n               while(l<r){",
                "url": "https://leetcode.com/problems/3sum/solutions/7402/share-my-ac-c-solution-around-50ms-o-n-n-with-explanation-and-comments/",
                "vote_count": "1195"
            },
            {
                "language": "kotlin",
                "code": "        if(target < 0)\n        {\n            break;\n        }",
                "url": "https://leetcode.com/problems/3sum/solutions/7402/share-my-ac-c-solution-around-50ms-o-n-n-with-explanation-and-comments/",
                "vote_count": "1195"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/3sum/solutions/7402/share-my-ac-c-solution-around-50ms-o-n-n-with-explanation-and-comments/",
                "vote_count": "1195"
            },
            {
                "language": "cpp",
                "code": "vector<vector<int>> threeSum(vector<int>& nums) {\n    vector<vector<int>> result;\n\n    sort(nums.begin(), nums.end());\n\n    for (auto i = 0; i < nums.size();) {\n        auto target = -nums[i];\n        int l = i + 1, u = nums.size() - 1;",
                "url": "https://leetcode.com/problems/3sum/solutions/7402/share-my-ac-c-solution-around-50ms-o-n-n-with-explanation-and-comments/",
                "vote_count": "1195"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n      if (nums.size() == 0) return {};\n      \n      vector<vector<int>> zeroed;\n      \n      sort(nums.begin(), nums.end());",
                "url": "https://leetcode.com/problems/3sum/solutions/7402/share-my-ac-c-solution-around-50ms-o-n-n-with-explanation-and-comments/",
                "vote_count": "1195"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        sort(nums.begin() , nums.end());    //Sorted Array\n        if(nums.size() < 3){    //Base case 1\n            return {};\n        }\n        if(nums[0] > 0){        //Base case 2\n            return {};\n        }\n        vector<vector<int>> answer;\n        for(int i = 0 ; i < nums.size() ; ++i){     //Traversing the array to fix the number.\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can't make it zero by searching after it.\n                break;\n            }\n            if(i > 0 && nums[i] == nums[i - 1]){    //If number is getting repeated, ignore the lower loop and continue.\n                continue;\n            }\n            int low = i + 1 , high = nums.size() - 1;   //Make two pointers high and low, and initialize sum as 0.\n            int sum = 0;\n            while(low < high){                          //Search between two pointers, just similiar to binary search.\n                sum = nums[i] + nums[low] + nums[high];\n                if(sum > 0){   //If sum is +ve, means, we need more -ve numbers to make it 0, decreament high (high--).\n                    high--;\n                } else if(sum < 0){ //If sum is -ve, means, we need more +ve numbers to make it 0, increament low (low++).\n                    low++;\n                } else {\n                    answer.push_back({nums[i] , nums[low] , nums[high]});  //we have found the required triplet, push it in answer vector\n                    int last_low_occurence = nums[low] , last_high_occurence = nums[high];  //Now again, to avoid duplicate triplets, we have to navigate to last occurences of num[low] and num[high] respectively\n                    while(low < high && nums[low] == last_low_occurence){   // Update the low and high with last occurences of low and high.\n                        low++;\n                    }\n                    while(low < high && nums[high] == last_high_occurence){\n                        high--;\n                    }\n                }\n            }\n        }\n        return answer;      //Return the answer vector.\n    }\n};",
                "url": "https://leetcode.com/problems/3sum/solutions/1462423/c-both-two-pointers-and-hashmap-approach-explained/",
                "vote_count": "730"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        sort(nums.begin() , nums.end());     //Sorted Array\n        if(nums.size() < 3){                // Base Case 1\n            return {};\n        }\n        if(nums[0] > 0){                    // Base Case 2\n            return {};\n        }\n        unordered_map<int , int> hashMap;\n        for(int i = 0 ; i < nums.size() ; ++i){     //Hashing of Indices\n            hashMap[nums[i]] = i;\n        }\n        vector<vector<int>> answer;\n        for(int i = 0 ; i < nums.size() - 2 ; ++i){     //Traversing the array to fix the number.\n            if(nums[i] > 0){     //If number fixed is +ve, stop there because we can't make it zero by searching after it.\n                break;\n            }\n            for(int j = i + 1 ; j < nums.size() - 1 ; ++j){     //Fixing another number after first number\n                int required = -1*(nums[i] + nums[j]);    //To make sum 0, we would require the -ve sum of both fixed numbers.\n                if(hashMap.count(required) && hashMap.find(required)->second > j){ //If it exists in hashmap and its last occurrence index > 2nd fixed index, we found our triplet.\n                    answer.push_back({nums[i] , nums[j] , required});\n                }\n                j = hashMap.find(nums[j])->second; //Update j to last occurence of 2nd fixed number to avoid duplicate triplets.\n            }\n            i = hashMap.find(nums[i])->second;     //Update i to last occurence of 1st fixed number to avoid duplicate triplets.\n        }\n        return answer;  //Return answer vector.\n    }\n};",
                "url": "https://leetcode.com/problems/3sum/solutions/1462423/c-both-two-pointers-and-hashmap-approach-explained/",
                "vote_count": "730"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n public:\n vector<vector<int>> threeSum(vector<int>& nums) {\n    vector<vector<int>> ans;\n    unordered_map<int, int> m;\n    sort(nums.begin(), nums.end());    \n    \n    int n = nums.size();",
                "url": "https://leetcode.com/problems/3sum/solutions/1462423/c-both-two-pointers-and-hashmap-approach-explained/",
                "vote_count": "730"
            },
            {
                "language": "python",
                "code": "        public  List<List<Integer>> threeSum(int[] nums) {\n        Set<List<Integer>> res  = new HashSet<>();\n        if(nums.length==0) return new ArrayList<>(res);\n        Arrays.sort(nums);\n        for(int i=0; i<nums.length-2;i++){\n            int j =i+1;\n           int  k = nums.length-1;\n            while(j<k){\n                int sum = nums[i]+nums[j]+nums[k];\n                if(sum==0)res.add(Arrays.asList(nums[i],nums[j++],nums[k--]));\n                else if (sum >0) k--;\n                else if (sum<0) j++;\n            }\n\n        }\n        return new ArrayList<>(res);\n\n    }",
                "url": "https://leetcode.com/problems/3sum/solutions/143636/java-with-set/",
                "vote_count": "686"
            },
            {
                "language": "javascript",
                "code": "if(nums.length==0) return new ArrayList<>(res);",
                "url": "https://leetcode.com/problems/3sum/solutions/143636/java-with-set/",
                "vote_count": "686"
            },
            {
                "language": "kotlin",
                "code": "if (nums.length < 3) {\n    return Collections.emptyList();\n}",
                "url": "https://leetcode.com/problems/3sum/solutions/143636/java-with-set/",
                "vote_count": "686"
            },
            {
                "language": "php",
                "code": "def threeSum(self, nums: List[int]) -> List[List[int]]:\n\n res = set()\n\n #1. Split nums into three lists: negative numbers, positive numbers, and zeros\n n, p, z = [], [], []\n for num in nums:\n  if num > 0:\n   p.append(num)\n  elif num < 0: \n   n.append(num)\n  else:\n   z.append(num)\n\n #2. Create a separate set for negatives and positives for O(1) look-up times\n N, P = set(n), set(p)\n\n #3. If there is at least 1 zero in the list, add all cases where -num exists in N and num exists in P\n #   i.e. (-3, 0, 3) = 0\n if z:\n  for num in P:\n   if -1*num in N:\n    res.add((-1*num, 0, num))\n\n #3. If there are at least 3 zeros in the list then also include (0, 0, 0) = 0\n if len(z) >= 3:\n  res.add((0,0,0))\n\n #4. For all pairs of negative numbers (-3, -1), check to see if their complement (4)\n #   exists in the positive number set\n for i in range(len(n)):\n  for j in range(i+1,len(n)):\n   target = -1*(n[i]+n[j])\n   if target in P:\n    res.add(tuple(sorted([n[i],n[j],target])))\n\n #5. For all pairs of positive numbers (1, 1), check to see if their complement (-2)\n #   exists in the negative number set\n for i in range(len(p)):\n  for j in range(i+1,len(p)):\n   target = -1*(p[i]+p[j])\n   if target in N:\n    res.add(tuple(sorted([p[i],p[j],target])))\n\n return res",
                "url": "https://leetcode.com/problems/3sum/solutions/725950/python-5-easy-steps-beats-97-4-annotated/",
                "vote_count": "685"
            },
            {
                "language": "python",
                "code": "    if len(nums) < 3:\n        return []\n\n    res = set()\n\n    # 1. Split nums into three lists: negative numbers, positive numbers, and zeros",
                "url": "https://leetcode.com/problems/3sum/solutions/725950/python-5-easy-steps-beats-97-4-annotated/",
                "vote_count": "685"
            },
            {
                "language": "java",
                "code": "from collections import defaultdict\n\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        neg = defaultdict(int)\n        pos = defaultdict(int)\n        zeros = 0\n        ",
                "url": "https://leetcode.com/problems/3sum/solutions/725950/python-5-easy-steps-beats-97-4-annotated/",
                "vote_count": "685"
            },
            {
                "language": "lisp",
                "code": "-1*num\n-1*(n[i]+n[j])",
                "url": "https://leetcode.com/problems/3sum/solutions/725950/python-5-easy-steps-beats-97-4-annotated/",
                "vote_count": "685"
            },
            {
                "language": "lisp",
                "code": "-num\n-(n[i] + n[j])",
                "url": "https://leetcode.com/problems/3sum/solutions/725950/python-5-easy-steps-beats-97-4-annotated/",
                "vote_count": "685"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/3sum/solutions/725950/python-5-easy-steps-beats-97-4-annotated/",
                "vote_count": "685"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/3sum/solutions/725950/python-5-easy-steps-beats-97-4-annotated/",
                "vote_count": "685"
            },
            {
                "language": "python",
                "code": "        if len(z) >= 3:\n            result.add(tuple([0,0,0]))\n        \n        if not n or not p:\n            return result\n        \n        sp = set(p)",
                "url": "https://leetcode.com/problems/3sum/solutions/725950/python-5-easy-steps-beats-97-4-annotated/",
                "vote_count": "685"
            },
            {
                "language": "cpp",
                "code": "//Optimized Approach - O(n^2 + nlogn) - o(n^2) time and O(n) space\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int target = 0;\n        sort(nums.begin(), nums.end());\n        set<vector<int>> s;\n        vector<vector<int>> output;\n        for (int i = 0; i < nums.size(); i++){\n            int j = i + 1;\n            int k = nums.size() - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == target) {\n                    s.insert({nums[i], nums[j], nums[k]});\n                    j++;\n                    k--;\n                } else if (sum < target) {\n                    j++;\n                } else {\n                    k--;\n                }\n            }\n        }\n        for(auto triplets : s)\n            output.push_back(triplets);\n        return output;\n    }\n};",
                "url": "https://leetcode.com/problems/3sum/solutions/3109452/c-easiest-beginner-friendly-sol-set-two-pointer-approach-o-n-2-time-and-o-n-space/",
                "vote_count": "362"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N^3), Here three nested loop creates the time complexity. Where N is the size of the\n    array(nums).\n\n    Space Complexity : O(N), Hash Table(set) space.\n\n    Solved using Array(Three Nested Loop) + Sorting + Hash Table(set). Brute Force Approach.\n\n    Note : this will give TLE.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        set<vector<int>> set;\n        vector<vector<int>> output;\n        for(int i=0; i<n-2; i++){\n            for(int j=i+1; j<n-1; j++){\n                for(int k=j+1; k<n; k++){\n                    if((nums[i] + nums[j] + nums[k] == 0) && i != j && j != k && k != i){\n                        set.insert({nums[i], nums[j], nums[k]});\n                    }\n                }\n            }\n        }\n        for(auto it : set){\n            output.push_back(it);\n        }\n        return output;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^2), Here Two nested loop creates the time complexity. Where N is the size of the\n    array(nums).\n\n    Space Complexity : O(N), Hash Table(set) space.\n\n    Solved using Array(Two Nested Loop) + Sorting + Hash Table(set).\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        set<vector<int>> set;\n        vector<vector<int>> output;\n        for(int i=0; i<n-2; i++){\n            int low = i+1, high = n-1;\n            while(low < high){\n                if(nums[i] + nums[low] + nums[high] < 0){\n                    low++;\n                }\n                else if(nums[i] + nums[low] + nums[high] > 0){\n                    high--;\n                }\n                else{\n                    set.insert({nums[i], nums[low], nums[high]});\n                    low++;\n                    high--;\n                }\n            }\n        }\n        for(auto it : set){\n            output.push_back(it);\n        }\n        return output;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^2), Here Two nested loop creates the time complexity. Where N is the size of the\n    array(nums).\n\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the Vector(output), however the\n    output does not count towards the space complexity.\n\n    Solved using Array(Two Nested Loop) + Sorting. Optimized Approach.\n\n*/\n\n\n/***************************************** Approach 3 *****************************************/\n\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> output;\n        for(int i=0; i<n-1; i++){\n            int low = i+1, high = n-1;\n            while(low < high){\n                if(nums[i] + nums[low] + nums[high] < 0){\n                    low++;\n                }\n                else if(nums[i] + nums[low] + nums[high] > 0){\n                    high--;\n                }\n                else{\n                    output.push_back({nums[i], nums[low], nums[high]});\n                    int tempIndex1 = low, tempIndex2 = high;\n                    while(low < high && nums[low] == nums[tempIndex1]) low++;\n                    while(low < high && nums[high] == nums[tempIndex2]) high--;\n                }\n            }\n            while(i+1 < n && nums[i] == nums[i+1]) i++;\n        }\n        return output;\n    }\n};",
                "url": "https://leetcode.com/problems/3sum/solutions/3186495/best-c-3-solution-two-pointers-sorting-hash-table-brute-force-optimize/",
                "vote_count": "93"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]: \n        nums.sort() # sorting cause we need to avoid duplicates, with this duplicates will be near to each other\n        l=[]\n        for i in range(len(nums)):  #this loop will help to fix the one number i.e, i\n            if i>0 and nums[i-1]==nums[i]:  #skipping if we found the duplicate of i\n                continue \n   \n   #NOW FOLLOWING THE RULE OF TWO POINTERS AFTER FIXING THE ONE VALUE (i)\n            j=i+1 #taking j pointer larger than i (as said in ques)\n            k=len(nums)-1 #taking k pointer from last \n            while j<k: \n                s=nums[i]+nums[j]+nums[k] \n                if s>0: #if sum s is greater than 0(target) means the larger value(from right as nums is sorted i.e, k at right) \n    #is taken and it is not able to sum up to the target\n                    k-=1  #so take value less than previous\n                elif s<0: #if sum s is less than 0(target) means the shorter value(from left as nums is sorted i.e, j at left) \n    #is taken and it is not able to sum up to the target\n                    j+=1  #so take value greater than previous\n                else:\n                    l.append([nums[i],nums[j],nums[k]]) #if sum s found equal to the target (0)\n                    j+=1 \n                    while nums[j-1]==nums[j] and j<k: #skipping if we found the duplicate of j and we dont need to check \n     #the duplicate of k cause it will automatically skip the duplicate by the adjustment of i and j\n                        j+=1   \n        return l",
                "url": "https://leetcode.com/problems/3sum/solutions/2602454/python-solution-100-explained/",
                "vote_count": "69"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        Set<List<Integer>> ans=new HashSet<>();\n        for(int i = 0; i < nums.length-2; i++){\n            int p1 = i+1;\n            int p2 = nums.length-1;\n            while(p1 < p2){\n                int sum = nums[i]+nums[p1]+nums[p2];\n                if(sum == 0){\n                    ArrayList<Integer> sp = new ArrayList<>();\n                    sp.add(nums[i]);\n                    sp.add(nums[p1]);\n                    sp.add(nums[p2]);\n                    \n                    ans.add(sp);\n                    p1++;\n                }\n                else if(sum < 0){\n                    p1++;\n                }\n                else{\n                    p2--;\n                }\n            }\n        }\n        return new ArrayList<>(ans);\n    }\n}",
                "url": "https://leetcode.com/problems/3sum/solutions/3293156/easy-to-understand-simple-java-code-using-set/",
                "vote_count": "16"
            },
            {
                "language": "javascript",
                "code": "function binary_search(arr, target, L = 0, R = arr.length - 1) {\n    while (L < R) {\n        let mid = ~~(L / 2 + R / 2);\n        arr[mid] < target ? (L = mid + 1) : (R = mid);\n    }\n    return L === R && arr[L] === target ? L : -Infinity;\n}\nvar threeSum = function (a) {\n    let n = a.length;\n\n    a.sort((a, b) => a - b);\n\n    let aa = [];\n    let vis = new Set();\n    for (let i = 0; i < n; i++)\n        for (let j = i + 1; j < n; j++) {\n            let sum = a[i] + a[j];\n            let L = binary_search(a, -sum, j + 1, n - 1);\n            if (L !== -Infinity) {\n                let key = `${a[i]} ${a[j]} ${a[L]}`;\n                if (!vis.has(key)) {\n                    vis.add(key);\n                    aa.push([a[i], a[j], a[L]]);\n                }\n            }\n        }\n    return aa;\n};",
                "url": "https://leetcode.com/problems/3sum/solutions/3304382/javascript-15-3sum/",
                "vote_count": "10"
            },
            {
                "language": "javascript",
                "code": "function binary_search(arr, target, L = 0, R = arr.length - 1) {\n    while (L < R) {\n        let mid = ~~(L / 2 + R / 2);\n        arr[mid] < target ? (L = mid + 1) : (R = mid);\n    }\n    return L === R && arr[L] === target ? L : -Infinity;\n}\nvar threeSum = function (a) {\n    let n = a.length;\n\n    a.sort((a, b) => a - b);\n\n    let aa = [];\n    for (let i = 0; i < n; i++) {\n        if (i > 0 && a[i - 1] === a[i]) continue;\n\n        for (let L = i + 1; L < n; L++) {\n            if (L > i + 1 && a[L - 1] === a[L]) continue;\n\n            let R = binary_search(a, -(a[i] + a[L]), L + 1, n - 1);\n            if (R !== -Infinity) {\n                aa.push([a[i], a[L], a[R]]);\n            }\n        }\n    }\n    return aa;\n};",
                "url": "https://leetcode.com/problems/3sum/solutions/3304382/javascript-15-3sum/",
                "vote_count": "10"
            },
            {
                "language": "javascript",
                "code": "var threeSum = function (a) {\n    let n = a.length;\n\n    a.sort((a, b) => a - b);\n\n    let aa = [];\n    let vis = new Set();\n    for (let i = 0; i < n; i++) {\n        let t = -a[i]; // target;\n        for (let L = i + 1, R = n - 1; L < R; ) {\n            let sum = a[L] + a[R];\n            if (sum === t) {\n                let key = `${a[i]} ${a[L]} ${a[R]}`;\n                if (!vis.has(key)) {\n                    vis.add(key);\n                    aa.push([a[i], a[L], a[R]]);\n                }\n                L++;\n            } else if (sum < t) {\n                L++;\n            } else {\n                R--;\n            }\n        }\n    }\n    return aa;\n};",
                "url": "https://leetcode.com/problems/3sum/solutions/3304382/javascript-15-3sum/",
                "vote_count": "10"
            },
            {
                "language": "javascript",
                "code": "var threeSum = function (a) {\n    let n = a.length;\n\n    a.sort((a, b) => a - b);\n\n    let aa = [];\n    for (let i = 0; i < n; i++) {\n        if (i > 0 && a[i - 1] === a[i]) continue;\n\n        let t = -a[i]; // target;\n        for (let L = i + 1, R = n - 1; L < R; ) {\n            if (L > i + 1 && a[L - 1] === a[L]) {\n                L++;\n                continue;\n            }\n\n            let sum = a[L] + a[R];\n            if (sum === t) {\n                aa.push([a[i], a[L], a[R]]);\n                L++;\n            } else if (sum < t) {\n                L++;\n            } else {\n                R--;\n            }\n        }\n    }\n    return aa;\n};",
                "url": "https://leetcode.com/problems/3sum/solutions/3304382/javascript-15-3sum/",
                "vote_count": "10"
            },
            {
                "language": "javascript",
                "code": "var threeSum = function (a) {\n    let n = a.length;\n\n    a.sort((a, b) => a - b);\n\n    let aa = [];\n    for (let i = 0; i < n; i++) {\n        // optimization 1\n        if (a[i] > 0) break;\n\n        let t = -a[i]; // target;\n        for (let L = i + 1, R = n - 1; L < R; ) {\n            let sum = a[L] + a[R];\n            if (sum === t) {\n                aa.push([a[i], a[L], a[R]]);\n                // optimization 2\n                while (a[L] === a[L + 1]) L++;\n                L++;\n            } else if (sum < t) {\n                L++;\n            } else {\n                R--;\n            }\n        }\n\n        // optimization 3\n        while (a[i] === a[i + 1]) i++;\n    }\n\n    return aa;\n};",
                "url": "https://leetcode.com/problems/3sum/solutions/3304382/javascript-15-3sum/",
                "vote_count": "10"
            }
        ]
    },
    "15": {
        "question_id": 16,
        "title": "3Sum Closest",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/3sum-closest",
        "description": "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.Return the sum of the three integers.You may assume that each input would have exactly one solution. ",
        "examples": [
            {
                "input": "nums = [-1,2,1,-4], target = 1",
                "output": "2",
                "explanation": "The sum that is closest to the target is 2. (-1 + 2 + 1 = 2)."
            },
            {
                "input": "nums = [0,0,0], target = 1",
                "output": "0",
                "explanation": "The sum that is closest to the target is 0. (0 + 0 + 0 = 0)."
            }
        ],
        "constraints": [
            "3 <= nums.length <= 500",
            "-1000 <= nums[i] <= 1000",
            "-10^4 <= target <= 10^4"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        if len(nums) == 3:\n            return sum(nums)\n        \n        nums = sorted(nums)\n        minSum, minDiff = None, float('inf')\n        \n        for i in range(len(nums)-2):\n            left, right = i+1, len(nums)-1\n            \n            while left < right:\n                currSum = nums[i] + nums[left] + nums[right]\n                currDiff = abs(target - currSum)\n\n                if currDiff < minDiff:\n                    minDiff = currDiff\n                    minSum = currSum\n\n                if minDiff == 0:\n                    return minSum\n\n                if target > currSum:\n                    left += 1\n                else:\n                    right -= 1\n        \n        return minSum",
                "url": "https://leetcode.com/problems/3sum-closest/solutions/2194572/python-accepted-solution-getting-tle-now/",
                "vote_count": "35"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        N = len(nums)\n        if N == 3:\n            return sum(nums)\n        \n        nums = sorted(nums)\n        minSum, minDiff = None, inf\n        \n        for i in range(N-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n\n            left, right = i+1, N-1\n            \n            while left < right:\n                currSum = sum([nums[i], nums[left], nums[right]])\n                currDiff = abs(target - currSum)\n\n                if currDiff < minDiff:\n                    minDiff = currDiff\n                    minSum = currSum\n\n                    if minDiff == 0:\n                        return minSum\n\n                if target > currSum:\n                    left += 1\n                    while left < right and nums[left] == nums[left-1]:\n                        left += 1\n                else:\n                    right -= 1\n                    while left < right and nums[right] == nums[right+1]:\n                        right -= 1\n        \n        return minSum",
                "url": "https://leetcode.com/problems/3sum-closest/solutions/2194572/python-accepted-solution-getting-tle-now/",
                "vote_count": "35"
            },
            {
                "language": "python",
                "code": "                if target > currSum:\n                    left += 1\n                    while left < right and nums[left] == nums[left-1]:\n                        left += 1\n                else:\n                    right -= 1\n                    while left < right and nums[right] == nums[right+1]:\n                        right -= 1",
                "url": "https://leetcode.com/problems/3sum-closest/solutions/2194572/python-accepted-solution-getting-tle-now/",
                "vote_count": "35"
            },
            {
                "language": "",
                "code": "",
                "url": "https://leetcode.com/problems/3sum-closest/solutions/2194572/python-accepted-solution-getting-tle-now/",
                "vote_count": "35"
            },
            {
                "language": "cpp",
                "code": "for i in range(n-2):\n  left, right = i+1, n-1",
                "url": "https://leetcode.com/problems/3sum-closest/solutions/2194572/python-accepted-solution-getting-tle-now/",
                "vote_count": "35"
            },
            {
                "language": "python",
                "code": "for i in range(len(res) - 2):",
                "url": "https://leetcode.com/problems/3sum-closest/solutions/2194572/python-accepted-solution-getting-tle-now/",
                "vote_count": "35"
            },
            {
                "language": "",
                "code": "",
                "url": "https://leetcode.com/problems/3sum-closest/solutions/2194572/python-accepted-solution-getting-tle-now/",
                "vote_count": "35"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/3sum-closest/solutions/2194572/python-accepted-solution-getting-tle-now/",
                "vote_count": "35"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        int diff=INT_MAX;\n        int ans=0;\n     sort(nums.begin(), nums.end());\n for(int i=0;i<nums.size()-2;i++){\n     int low=i+1;\n     int high=nums.size()-1;\n     int first=nums[i];\n     while(low<high){\n         if(first+nums[low]+nums[high]==target){\n             return target;\n         }\n         else if(abs(first+nums[low]+nums[high]-target)<diff){\n             diff=abs(first+nums[low]+nums[high]-target);\n             ans=first+nums[low]+nums[high];\n         }\n         if(first+nums[low]+nums[high]<target){\n             low++; \n         }\n        else{ high--;\n            }\n     }\n }              \n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/3sum-closest/solutions/3116265/easily-understandable-solution-beats-99-30/",
                "vote_count": "19"
            }
        ]
    },
    "16": {
        "question_id": 17,
        "title": "Letter Combinations of a Phone Number",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number",
        "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. ",
        "examples": [
            {
                "input": "digits = \"23\"",
                "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
                "explanation": null
            },
            {
                "input": "digits = \"\"",
                "output": "[]",
                "explanation": null
            },
            {
                "input": "digits = \"2\"",
                "output": "[\"a\",\"b\",\"c\"]",
                "explanation": null
            }
        ],
        "constraints": [
            "0 <= digits.length <= 4",
            "digits[i] is a digit in the range ['2', '9']."
        ],
        "solutions": [
            {
                "language": "typescript",
                "code": "public List<String> letterCombinations(String digits) {\n  LinkedList<String> ans = new LinkedList<String>();\n  if(digits.isEmpty()) return ans;\n  String[] mapping = new String[] {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n  ans.add(\"\");\n  for(int i =0; i<digits.length();i++){\n   int x = Character.getNumericValue(digits.charAt(i));\n   while(ans.peek().length()==i){\n    String t = ans.remove();\n    for(char s : mapping[x].toCharArray())\n     ans.add(t+s);\n   }\n  }\n  return ans;\n }",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/8064/my-java-solution-with-fifo-queue/",
                "vote_count": "1192"
            },
            {
                "language": "typescript",
                "code": "public List<String> letterCombinations(String digits) {\n  LinkedList<String> ans = new LinkedList<String>();\n  if(digits.isEmpty()) return ans;\n  String[] mapping = new String[] {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n  ans.add(\"\");\n  while(ans.peek().length()!=digits.length()){\n   String remove = ans.remove();\n   String map = mapping[digits.charAt(remove.length())-'0'];\n   for(char c: map.toCharArray()){\n    ans.addLast(remove+c);\n   }\n  }\n  return ans;\n }",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/8064/my-java-solution-with-fifo-queue/",
                "vote_count": "1192"
            },
            {
                "language": "lisp",
                "code": "while(list.peek().length() == i)",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/8064/my-java-solution-with-fifo-queue/",
                "vote_count": "1192"
            },
            {
                "language": "kotlin",
                "code": "",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/8064/my-java-solution-with-fifo-queue/",
                "vote_count": "1192"
            },
            {
                "language": "dart",
                "code": " public List<String> letterCombinations(String digits) {\n  List<String> ans = new LinkedList<String>();\n  if (digits.isEmpty())\n   return ans;\n  String[] mapping = new String[] { \"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\n  ans.add(0, \"\");",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/8064/my-java-solution-with-fifo-queue/",
                "vote_count": "1192"
            },
            {
                "language": "python",
                "code": "int x = digits.charAt(i) - '0';",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/8064/my-java-solution-with-fifo-queue/",
                "vote_count": "1192"
            },
            {
                "language": "csharp",
                "code": "vector<string> letterCombinations(string digits) {",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/8064/my-java-solution-with-fifo-queue/",
                "vote_count": "1192"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        self.dfs(nums, [], res)\n        return res\n    \n    def dfs(self, nums, path, res):\n        res.append(path)\n        for i in range(len(nums)):\n            self.dfs(nums[i+1:], path + [nums[i]], res)     ",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/780232/backtracking-python-problems-solutions-interview-prep/",
                "vote_count": "579"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        nums.sort()\n        self.dfs(nums, [], res)\n        return res\n    \n    def dfs(self, nums, path, res):\n        res.append(path)\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums[i+1:], path + [nums[i]], res)",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/780232/backtracking-python-problems-solutions-interview-prep/",
                "vote_count": "579"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res=[]\n        self.dfs(range(1, n+1), k, [], res)\n        return res\n    \n    def dfs(self, nums, k, path, res):\n        if len(path) == k:\n            res.append(path)\n            return\n        for i in range(len(nums)):\n            self.dfs(nums[i+1:], k, path+ [nums[i]], res)",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/780232/backtracking-python-problems-solutions-interview-prep/",
                "vote_count": "579"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        candidates.sort()\n        self.dfs(candidates, target, [], res)\n        return res\n    \n    def dfs(self, candidates, target, path, res):\n        if target < 0:\n            return   #backtracking\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(len(candidates)):\n            self.dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)  ",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/780232/backtracking-python-problems-solutions-interview-prep/",
                "vote_count": "579"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        candidates.sort()\n        self.dfs(candidates, target, [], res)\n        return res\n    \n    def dfs(self, candidates, target, path, res):\n        if target < 0:\n            return\n        \n        if target == 0:\n            res.append(path)\n        for i in range(len(candidates)):\n            if i > 0 and candidates[i] == candidates[i-1]:\n                continue\n                \n            if candidates[i]> target:\n                break\n                \n            self.dfs(candidates[i+1:], target - candidates[i], path + [candidates[i]], res)",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/780232/backtracking-python-problems-solutions-interview-prep/",
                "vote_count": "579"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        self.dfs(nums, [], res)\n        return res\n    \n    def dfs(self, nums, path, res):\n        if len(nums) == 0:\n            res.append(path)\n            return\n        for i in range(len(nums)):\n            self.dfs(nums[:i] + nums[i+1:], path + [nums[i]], res)   ",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/780232/backtracking-python-problems-solutions-interview-prep/",
                "vote_count": "579"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        nums.sort()\n        self.dfs(nums, [], res)\n        return res\n    \n    def dfs(self, nums, path, res):\n        if len(nums) == 0:\n            res.append(path)\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums[:i] + nums[i+1:], path + [nums[i]], res)",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/780232/backtracking-python-problems-solutions-interview-prep/",
                "vote_count": "579"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        dic = { \"2\": \"abc\", \"3\": \"def\", \"4\":\"ghi\", \"5\":\"jkl\", \"6\":\"mno\", \"7\":\"pqrs\", \"8\":\"tuv\", \"9\":\"wxyz\"}\n        \n        res=[]\n        if len(digits) ==0:\n            return res\n            \n        self.dfs(digits, 0, dic, '', res)\n        return res\n    \n    def dfs(self, nums, index, dic, path, res):\n        if index >=len(nums):\n            res.append(path)\n            return\n        string1 =dic[nums[index]]\n        for i in string1:\n            self.dfs(nums, index+1, dic, path + i, res)",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/780232/backtracking-python-problems-solutions-interview-prep/",
                "vote_count": "579"
            },
            {
                "language": "ruby",
                "code": "def subsets(self, nums):\n    def backtrack(start, end, tmp):\n        ans.append(tmp[:])\n        for i in range(start, end):\n            tmp.append(nums[i])\n            backtrack(i+1, end, tmp)\n            tmp.pop()",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/780232/backtracking-python-problems-solutions-interview-prep/",
                "vote_count": "579"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        res = []\n        \n        def recurse(n_open: int, n_close: int, curr: List[str]):\n            if n_open == n_close == n:\n                res.append(\"\".join(curr))\n                return",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/780232/backtracking-python-problems-solutions-interview-prep/",
                "vote_count": "579"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def expand(self, s: str) -> List[str]:\n                        \n        result = []\n        self.dfs(s, \"\", result)\n        result.sort()",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/780232/backtracking-python-problems-solutions-interview-prep/",
                "vote_count": "579"
            },
            {
                "language": "kotlin",
                "code": "",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/780232/backtracking-python-problems-solutions-interview-prep/",
                "vote_count": "579"
            },
            {
                "language": "ruby",
                "code": "",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/780232/backtracking-python-problems-solutions-interview-prep/",
                "vote_count": "579"
            },
            {
                "language": "ruby",
                "code": "",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/780232/backtracking-python-problems-solutions-interview-prep/",
                "vote_count": "579"
            },
            {
                "language": "kotlin",
                "code": "",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/780232/backtracking-python-problems-solutions-interview-prep/",
                "vote_count": "579"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def countArrangement(self, n: int) -> int:\n        #instance class variable because ints are immutable so if you\n        # += below in the dfs method it would have to create a new \"output\" in memory each each time\n        # and \"reset\" it to 0 essentially\n        self.output = 0\n        \n        self.dfs(list(range(1, n+1)), [], n, n)",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/780232/backtracking-python-problems-solutions-interview-prep/",
                "vote_count": "579"
            },
            {
                "language": "ruby",
                "code": "    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        \n        nums.sort()\n        self.recurseSubset(res, nums, [])\n        \n        return res",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/780232/backtracking-python-problems-solutions-interview-prep/",
                "vote_count": "579"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(3^N \u00d7 4^M) where N is the number of digits which have 3 letters( ex: 2,3,4) assigned to\n    it and M is the number of digits which has 4 letters(ex: 7,9) assigned to it.\n\n    Space Complexity : O(3^N \u00d7 4^M) where N is the number of digits which have 3 letters( ex: 2,3,4) assigned to\n    it and M is the number of digits which has 4 letters(ex: 7,9) assigned to it.\n\n    Solved using String + Backtracking + Hash Table. Recursive Approach.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\nprivate:\n    void letterCombinations(string digits, vector<string>& output, string &temp, vector<string>& pad, int index){\n        if(index == digits.size()){\n            output.push_back(temp);\n            return;\n        }\n        string value = pad[digits[index]-'0'];\n        for(int i=0; i<value.size(); i++){\n            temp.push_back(value[i]);\n            letterCombinations(digits, output, temp, pad, index+1);\n            temp.pop_back();\n        }\n    }\npublic:\n    vector<string> letterCombinations(string digits) {\n        if(digits.empty()){\n            return {};\n        }\n        vector<string> pad = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        vector<string> output;\n        string temp;\n        letterCombinations(digits, output, temp, pad, 0);\n        return output;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(3^N \u00d7 4^M) where N is the number of digits which have 3 letters( ex: 2,3,4) assigned to\n    it and M is the number of digits which has 4 letters(ex: 7,9) assigned to it.\n\n    Space Complexity : O(3^N \u00d7 4^M) where N is the number of digits which have 3 letters( ex: 2,3,4) assigned to\n    it and M is the number of digits which has 4 letters(ex: 7,9) assigned to it.\n\n    Solved using String + Hash Table. Iterative Approach.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        if(digits.empty()){\n            return {};\n        }\n        vector<string> pad = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        vector<string> output;\n        output.push_back(\"\");\n        for(auto key : digits){\n            vector<string> temp;\n            for(auto candidate : pad[key-'0']){\n                for(auto c : output){\n                    temp.push_back(c + candidate);\n                }\n            }\n            output.clear();\n            output = temp;\n        }\n        return output;\n    }\n};",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3222449/best-c-2-solution-backtracking-iterative-recursive-one-stop-solution/",
                "vote_count": "37"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    void solve(int ind, string &ds, vector<string> &ans, string mapping[], string digits){\n        if(ind==digits.size()){\n            ans.emplace_back(ds);\n            return;\n        }\n        string value = mapping[digits[ind]-'0'];\n\n        for(int i=0; i<value.size(); i++){\n                ds+=value[i];\n                solve(ind+1, ds, ans, mapping, digits);\n                ds.pop_back();\n       }\n\n    }\n    vector<string> letterCombinations(string digits) {\n        string ds;\n        vector<string> ans;\n        if(digits.size()==0)\n            return ans;\n        string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        solve(0, ds, ans, mapping, digits);\n        return ans;      \n    }\n};",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3031239/easy-c-solution-faang-interview-code/",
                "vote_count": "18"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    vector<string>ans;\n    map<int,string>mp;\n    void backtrack(string& dig,int start,string &temp){\n        \n        if(start==dig.size())ans.push_back(temp);\n\n          for(auto x:mp[dig[start]-'0']){\n              temp.push_back(x);\n              backtrack(dig,start+1,temp);\n              temp.pop_back();\n          }\n    }\n    vector<string> letterCombinations(string dig) {\n        if(dig==\"\") return ans;\n        mp[2] = \"abc\";\n        mp[3] = \"def\";\n        mp[4] = \"ghi\";\n        mp[5] = \"jkl\";\n        mp[6] = \"mno\";\n        mp[7] = \"pqrs\";\n        mp[8] = \"tuv\";\n        mp[9] = \"wxyz\";\n        string temp;\n        backtrack(dig,0,temp);\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3098110/c-very-simple-back-tracking-beats-100/",
                "vote_count": "17"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n        \n        phone = {\"2\": \"abc\", \"3\": \"def\", \"4\": \"ghi\", \"5\": \"jkl\", \"6\": \"mno\", \"7\": \"pqrs\", \"8\": \"tuv\", \"9\": \"wxyz\"}\n        res = []\n        \n        def backtrack(combination, next_digits):\n            if not next_digits:\n                res.append(combination)\n                return\n            \n            for letter in phone[next_digits[0]]:\n                backtrack(combination + letter, next_digits[1:])\n        \n        backtrack(\"\", digits)\n        return res",
                "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3313021/python-simple-solution-easiest/",
                "vote_count": "14"
            }
        ]
    },
    "17": {
        "question_id": 18,
        "title": "4Sum",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/4sum",
        "description": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:0 <= a, b, c, d < na, b, c, and d are distinct.nums[a] + nums[b] + nums[c] + nums[d] == targetYou may return the answer in any order. ",
        "examples": [
            {
                "input": "nums = [1,0,-1,0,-2,2], target = 0",
                "output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
                "explanation": null
            },
            {
                "input": "nums = [2,2,2,2,2], target = 8",
                "output": "[[2,2,2,2]]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 200",
            "-10^9 <= nums[i] <= 10^9",
            "-10^9 <= target <= 10^9"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "def fourSum(self, nums, target):\n    nums.sort()\n    results = []\n    self.findNsum(nums, target, 4, [], results)\n    return results\n\ndef findNsum(self, nums, target, N, result, results):\n    if len(nums) < N or N < 2: return\n\n    # solve 2-sum\n    if N == 2:\n        l,r = 0,len(nums)-1\n        while l < r:\n            if nums[l] + nums[r] == target:\n                results.append(result + [nums[l], nums[r]])\n                l += 1\n                r -= 1\n                while l < r and nums[l] == nums[l - 1]:\n                    l += 1\n                while r > l and nums[r] == nums[r + 1]:\n                    r -= 1\n            elif nums[l] + nums[r] < target:\n                l += 1\n            else:\n                r -= 1\n    else:\n        for i in range(0, len(nums)-N+1):   # careful about range\n            if target < nums[i]*N or target > nums[-1]*N:  # take advantages of sorted list\n                break\n            if i == 0 or i > 0 and nums[i-1] != nums[i]:  # recursively reduce N\n                self.findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\n    return",
                "url": "https://leetcode.com/problems/4sum/solutions/8545/python-140ms-beats-100-and-works-for-n-sum-n-2/",
                "vote_count": "621"
            },
            {
                "language": "python",
                "code": "def fourSum(self, nums, target):\n    def findNsum(nums, target, N, result, results):\n        if len(nums) < N or N < 2 or target < nums[0]*N or target > nums[-1]*N:  # early termination\n            return\n        if N == 2: # two pointers solve sorted 2-sum problem\n            l,r = 0,len(nums)-1\n            while l < r:\n                s = nums[l] + nums[r]\n                if s == target:\n                    results.append(result + [nums[l], nums[r]])\n                    l += 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                elif s < target:\n                    l += 1\n                else:\n                    r -= 1\n        else: # recursively reduce N\n            for i in range(len(nums)-N+1):\n                if i == 0 or (i > 0 and nums[i-1] != nums[i]):\n                    findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\n\n    results = []\n    findNsum(sorted(nums), target, 4, [], results)\n    return results\n   ",
                "url": "https://leetcode.com/problems/4sum/solutions/8545/python-140ms-beats-100-and-works-for-n-sum-n-2/",
                "vote_count": "621"
            },
            {
                "language": "python",
                "code": "def fourSum(self, nums, target):\n    def findNsum(l, r, target, N, result, results):\n        if r-l+1 < N or N < 2 or target < nums[l]*N or target > nums[r]*N:  # early termination\n            return\n        if N == 2: # two pointers solve sorted 2-sum problem\n            while l < r:\n                s = nums[l] + nums[r]\n                if s == target:\n                    results.append(result + [nums[l], nums[r]])\n                    l += 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                elif s < target:\n                    l += 1\n                else:\n                    r -= 1\n        else: # recursively reduce N\n            for i in range(l, r+1):\n                if i == l or (i > l and nums[i-1] != nums[i]):\n                    findNsum(i+1, r, target-nums[i], N-1, result+[nums[i]], results)\n\n    nums.sort()\n    results = []\n    findNsum(0, len(nums)-1, target, 4, [], results)\n    return results",
                "url": "https://leetcode.com/problems/4sum/solutions/8545/python-140ms-beats-100-and-works-for-n-sum-n-2/",
                "vote_count": "621"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n  def threeSum(self, nums, target):\n    results = []\n    nums.sort()\n    for i in range(len(nums)-2):\n      l = i + 1; r = len(nums) - 1\n      t = target - nums[i]\n      if i == 0 or nums[i] != nums[i-1]:",
                "url": "https://leetcode.com/problems/4sum/solutions/8545/python-140ms-beats-100-and-works-for-n-sum-n-2/",
                "vote_count": "621"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def fourSum(self, nums, target):\n        def findNsum(nums, target, N, cur):\n            if len(nums) < N or N < 2 or nums[0] * N > target or nums[-1] * N < target:  # if minimum possible sum (every element is first element) > target \n                return  # or maximum possible sum (every element is first element) < target, it's impossible to get target anyway          \n            if N == 2:  # 2-sum problem\n                l, r = 0, len(nums) - 1\n                while l < r:",
                "url": "https://leetcode.com/problems/4sum/solutions/8545/python-140ms-beats-100-and-works-for-n-sum-n-2/",
                "vote_count": "621"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]",
                "url": "https://leetcode.com/problems/4sum/solutions/8545/python-140ms-beats-100-and-works-for-n-sum-n-2/",
                "vote_count": "621"
            },
            {
                "language": "python",
                "code": "        for i in range(len(nums)-3):\n            if i>0 and nums[i]==nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j>i+1 and nums[j]==nums[j-1]:\n                    continue\n            # 2Sum solution with 2 pointers\n            # ...",
                "url": "https://leetcode.com/problems/4sum/solutions/8545/python-140ms-beats-100-and-works-for-n-sum-n-2/",
                "vote_count": "621"
            },
            {
                "language": "python",
                "code": "def findNSum(self, nums, start,target, N, path, paths):\n    if len(nums[start:]) < N or N < 2:\n        return\n    if nums[start] * N > target or nums[-1] * N < target:  # using sorted list property\n        return\n    \n    # solve 2Sum, base case\n    if N == 2:\n)",
                "url": "https://leetcode.com/problems/4sum/solutions/8545/python-140ms-beats-100-and-works-for-n-sum-n-2/",
                "vote_count": "621"
            },
            {
                "language": "python",
                "code": "def fourSum(nums, target):\n    n = len(nums)\n    if n <= 3:\n        return []\n\n    nums.sort()",
                "url": "https://leetcode.com/problems/4sum/solutions/8545/python-140ms-beats-100-and-works-for-n-sum-n-2/",
                "vote_count": "621"
            },
            {
                "language": "java",
                "code": "    public class Solution {\n        int len = 0;\n        public List<List<Integer>> fourSum(int[] nums, int target) {\n            len = nums.length;\n            Arrays.sort(nums);\n            return kSum(nums, target, 4, 0);\n        }\n       private ArrayList<List<Integer>> kSum(int[] nums, int target, int k, int index) {\n            ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\n            if(index >= len) {\n                return res;\n            }\n            if(k == 2) {\n             int i = index, j = len - 1;\n             while(i < j) {\n                    //find a pair\n                 if(target - nums[i] == nums[j]) {\n                  List<Integer> temp = new ArrayList<>();\n                     temp.add(nums[i]);\n                     temp.add(target-nums[i]);\n                        res.add(temp);\n                        //skip duplication\n                        while(i<j && nums[i]==nums[i+1]) i++;\n                        while(i<j && nums[j-1]==nums[j]) j--;\n                        i++;\n                        j--;\n                    //move left bound\n                 } else if (target - nums[i] > nums[j]) {\n                     i++;\n                    //move right bound\n                 } else {\n                     j--;\n                 }\n             }\n            } else{\n                for (int i = index; i < len - k + 1; i++) {\n                    //use current number to reduce ksum into k-1sum\n                    ArrayList<List<Integer>> temp = kSum(nums, target - nums[i], k-1, i+1);\n                    if(temp != null){\n                        //add previous results\n                        for (List<Integer> t : temp) {\n                            t.add(0, nums[i]);\n                        }\n                        res.addAll(temp);\n                    }\n                    while (i < len-1 && nums[i] == nums[i+1]) {\n                        //skip duplicated numbers\n                        i++;\n                    }\n                }\n            }\n            return res;\n        }\n    }",
                "url": "https://leetcode.com/problems/4sum/solutions/8609/my-solution-generalized-for-ksums-in-java/",
                "vote_count": "452"
            },
            {
                "language": "java",
                "code": "public List<List<Integer>> fourSum(int[] nums, int target) {\n        Arrays.sort(nums);\n        return kSum(nums, 0, 4, target);\n    }\n    private List<List<Integer>> kSum (int[] nums, int start, int k, int target) {\n        int len = nums.length;\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        if(k == 2) { //two pointers from left and right",
                "url": "https://leetcode.com/problems/4sum/solutions/8609/my-solution-generalized-for-ksums-in-java/",
                "vote_count": "452"
            },
            {
                "language": "java",
                "code": "public List<List<Integer>> fourSum(int[] nums, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(nums == null || nums.length < 4){  //corner case\n            return res;\n        }\n        Arrays.sort(nums);\n        for(int i = 0; i < nums.length - 3; i++){",
                "url": "https://leetcode.com/problems/4sum/solutions/8609/my-solution-generalized-for-ksums-in-java/",
                "vote_count": "452"
            },
            {
                "language": "go",
                "code": "public List<List<Integer>> kSum(int[] nums, int target, int k, int index,\n                                    int len) {\n\n        List<List<Integer>> res = new ArrayList<>();\n        int max = nums[len - 1];\n        ...\n        if (k == 2) {",
                "url": "https://leetcode.com/problems/4sum/solutions/8609/my-solution-generalized-for-ksums-in-java/",
                "vote_count": "452"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        List<List<Integer>> result = new ArrayList();\n        if(nums == null){\n            return result;\n        }\n        Arrays.sort(nums);\n        helper(result, nums, target, 4, 0, new ArrayList());\n, List<Integer> subR){",
                "url": "https://leetcode.com/problems/4sum/solutions/8609/my-solution-generalized-for-ksums-in-java/",
                "vote_count": "452"
            },
            {
                "language": "python",
                "code": "if(index >= len) {\n    return res;\n}",
                "url": "https://leetcode.com/problems/4sum/solutions/8609/my-solution-generalized-for-ksums-in-java/",
                "vote_count": "452"
            },
            {
                "language": "java",
                "code": "/*\nIdea: \n1. Reduce KSum to (K - 1)-Sum, then to (K - 2)-Sum until 2Sum.\n2. Take care of oneSum separately.\n\nComplexity - Time: O(n^(k - 1)), Space: O(k)\n*/\n\n {",
                "url": "https://leetcode.com/problems/4sum/solutions/8609/my-solution-generalized-for-ksums-in-java/",
                "vote_count": "452"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int len = 0;\n    vector<vector<int>> kSum(vector<int>& nums, int target, int k, int index) {\n        vector<vector<int>> res;\n        if (index >= len)\n            return res;",
                "url": "https://leetcode.com/problems/4sum/solutions/8609/my-solution-generalized-for-ksums-in-java/",
                "vote_count": "452"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int T) {\n        unordered_set<int> seen;\n        set<multiset<int>> ans_set;\n        int n = size(nums);\n<int>(begin(el), end(el)); });",
                "url": "https://leetcode.com/problems/4sum/solutions/1341213/c-python-2-solutions-clean-concise-follow-up-k-sum/",
                "vote_count": "243"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/4sum/solutions/1341213/c-python-2-solutions-clean-concise-follow-up-k-sum/",
                "vote_count": "243"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n        vector<vector<int>> ans;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n;",
                "url": "https://leetcode.com/problems/4sum/solutions/1341213/c-python-2-solutions-clean-concise-follow-up-k-sum/",
                "vote_count": "243"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N^4), Here Four nested loop creates the time complexity. Where N is the size of the\n    array(nums).\n\n    Space Complexity : O(N), Hash Table(set) space.\n\n    Solved using Array(Four Nested Loop) + Sorting + Hash Table(set). Brute Force Approach.\n\n    Note : this will give TLE.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        set<vector<int>> set;\n        vector<vector<int>> output;\n        for(int i=0; i<n-3; i++){\n            for(int j=i+1; j<n-2; j++){\n                for(int k=j+1; k<n-1; k++){\n                    for(int l=k+1; l<n; l++){\n                        if((long long)nums[i] + (long long)nums[j] + (long long)nums[k] + \n                        (long long)nums[l] == target){\n                            set.insert({nums[i], nums[j], nums[k], nums[l]});\n                        }\n                    }\n                }\n            }\n        }\n        for(auto it : set){\n            output.push_back(it);\n        }\n        return output;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^3), Here Three nested loop creates the time complexity. Where N is the size of the\n    array(nums).\n\n    Space Complexity : O(N), Hash Table(set) space.\n\n    Solved using Array(Three Nested Loop) + Sorting + Hash Table(set).\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        set<vector<int>> set;\n        vector<vector<int>> output;\n        for(int i=0; i<n-3; i++){\n            for(int j=i+1; j<n-2; j++){\n                long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];\n                int low = j+1, high = n-1;\n                while(low < high){\n                    if(nums[low] + nums[high] < newTarget){\n                        low++;\n                    }\n                    else if(nums[low] + nums[high] > newTarget){\n                        high--;\n                    }\n                    else{\n                        set.insert({nums[i], nums[j], nums[low], nums[high]});\n                        low++; high--;\n                    }\n                }\n            }\n        }\n        for(auto it : set){\n            output.push_back(it);\n        }\n        return output;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^3), Here Three nested loop creates the time complexity. Where N is the size of the\n    array(nums).\n\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the Vector(output), however the\n    output does not count towards the space complexity.\n\n    Solved using Array(Three Nested Loop) + Sorting. Optimized Approach.\n\n*/\n\n\n/***************************************** Approach 3 *****************************************/\n\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> output;\n        for(int i=0; i<n-3; i++){\n            for(int j=i+1; j<n-2; j++){\n                long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];\n                int low = j+1, high = n-1;\n                while(low < high){\n                    if(nums[low] + nums[high] < newTarget){\n                        low++;\n                    }\n                    else if(nums[low] + nums[high] > newTarget){\n                        high--;\n                    }\n                    else{\n                        output.push_back({nums[i], nums[j], nums[low], nums[high]});\n                        int tempIndex1 = low, tempIndex2 = high;\n                        while(low < high && nums[low] == nums[tempIndex1]) low++;\n                        while(low < high && nums[high] == nums[tempIndex2]) high--;\n                    }\n                }\n                while(j+1 < n && nums[j] == nums[j+1]) j++;\n            }\n            while(i+1 < n && nums[i] == nums[i+1]) i++;\n        }\n        return output;\n    }\n};",
                "url": "https://leetcode.com/problems/4sum/solutions/3186501/best-c-3-solution-two-pointers-sorting-hash-table-brute-force-optimize/",
                "vote_count": "82"
            },
            {
                "language": "cpp",
                "code": "//Optimized Approach using two pointer - O(n^3) time and O(n) space\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(nums.begin(), nums.end());\n        set<vector<int>> s;\n        vector<vector<int>> output;\n        for (int i = 0; i < nums.size(); i++){\n            for(int j = i+1; j < nums.size(); j++){\n                int k = j + 1;\n                int l = nums.size() - 1;\n                while (k < l) {\n                    //by writing below 4 statement this way it will not give runtime error\n                    long long int sum = nums[i];\n                    sum += nums[j];\n                    sum += nums[k];\n                    sum += nums[l];\n                    if (sum == target) {\n                        s.insert({nums[i], nums[j], nums[k], nums[l]});\n                        k++;\n                        l--;\n                    } else if (sum < target) {\n                        k++;\n                    } else {\n                        l--;\n                    }\n                }\n            }\n        }\n        for(auto quadruplets : s)\n            output.push_back(quadruplets);\n        return output;\n    }\n};",
                "url": "https://leetcode.com/problems/4sum/solutions/3110025/c-easiest-beginner-friendly-sol-set-two-pointer-approach-o-n-3-time-and-o-n-space/",
                "vote_count": "33"
            }
        ]
    },
    "18": {
        "question_id": 19,
        "title": "Remove Nth Node From End of List",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list",
        "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head. ",
        "examples": [
            {
                "input": "head = [1,2,3,4,5], n = 2",
                "output": "[1,2,3,5]",
                "explanation": null
            },
            {
                "input": "head = [1], n = 1",
                "output": "[]",
                "explanation": null
            },
            {
                "input": "head = [1,2], n = 1",
                "output": "[1]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is sz.",
            "1 <= sz <= 30",
            "0 <= Node.val <= 100",
            "1 <= n <= sz"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "var removeNthFromEnd = function(head, n) {\n    let fast = head, slow = head\n    for (let i = 0; i < n; i++) fast = fast.next\n    if (!fast) return head.next\n    while (fast.next) fast = fast.next, slow = slow.next\n    slow.next = slow.next.next\n    return head\n};",
                "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/1164542/js-python-java-c-easy-two-pointer-solution-w-explanation/",
                "vote_count": "865"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        fast, slow = head, head\n        for _ in range(n): fast = fast.next\n        if not fast: return head.next\n        while fast.next: fast, slow = fast.next, slow.next\n        slow.next = slow.next.next\n        return head",
                "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/1164542/js-python-java-c-easy-two-pointer-solution-w-explanation/",
                "vote_count": "865"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode fast = head, slow = head;\n        for (int i = 0; i < n; i++) fast = fast.next;\n        if (fast == null) return head.next;\n        while (fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        slow.next = slow.next.next;\n        return head;\n    }\n}",
                "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/1164542/js-python-java-c-easy-two-pointer-solution-w-explanation/",
                "vote_count": "865"
            },
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode *fast = head, *slow = head;\n        for (int i = 0; i < n; i++) fast = fast->next;\n        if (!fast) return head->next;\n        while (fast->next) fast = fast->next, slow = slow->next;\n        slow->next = slow->next->next;\n        return head;\n    }\n};",
                "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/1164542/js-python-java-c-easy-two-pointer-solution-w-explanation/",
                "vote_count": "865"
            },
            {
                "language": "go",
                "code": "ListNode* removeNthFromEnd(ListNode* head, int n) {\n ListNode* iter = head;\n int len = 0, i = 1;\n while(iter) iter = iter -> next, len++;    // finding the length of linked list\n if(len == n) return head -> next;          // if head itself is to be deleted, just return head -> next\n for(iter = head; i < len - n; i++) iter = iter -> next; // iterate first len-n nodes\n iter -> next = iter -> next -> next;      // remove the nth node from the end\n return head;\n}",
                "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/1164537/short-simple-one-pass-solution-w-explanation-beats-100-no-dummy-node-required/",
                "vote_count": "410"
            },
            {
                "language": "ruby",
                "code": "def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n ptr, length = head, 0\n while ptr:\n  ptr, length = ptr.next, length + 1\n if length == n : return head.next\n ptr = head\n for i in range(1, length - n):\n  ptr = ptr.next\n ptr.next = ptr.next.next\n return head",
                "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/1164537/short-simple-one-pass-solution-w-explanation-beats-100-no-dummy-node-required/",
                "vote_count": "410"
            },
            {
                "language": "rust",
                "code": "For eg. let the list be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9, and n = 4.\n\n1. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\n   ^slow               ^fast\n   |<--gap of n nodes-->|\n \n => Now traverse till fast reaches end\n \n 2. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\n                        ^slow               ^fast\n                        |<--gap of n nodes-->|\n      \n'slow' is at (n+1)th node from end.\nSo just delete nth node from end by assigning slow -> next as slow -> next -> next (which would remove nth node from end of list).",
                "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/1164537/short-simple-one-pass-solution-w-explanation-beats-100-no-dummy-node-required/",
                "vote_count": "410"
            },
            {
                "language": "rust",
                "code": "ListNode* removeNthFromEnd(ListNode* head, int n) {\n ListNode *fast = head, *slow = head;\n while(n--) fast = fast -> next;      // iterate first n nodes using fast\n if(!fast) return head -> next;       // if fast is already null, it means we have to delete head itself. So, just return next of head\n while(fast -> next)                  // iterate till fast reaches the last node of list\n  fast = fast -> next, slow = slow -> next;            \n slow -> next = slow -> next -> next; // remove the nth node from last\n return head;\n}",
                "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/1164537/short-simple-one-pass-solution-w-explanation-beats-100-no-dummy-node-required/",
                "vote_count": "410"
            },
            {
                "language": "ruby",
                "code": "def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n fast = slow = head\n for i in range(n):\n  fast = fast.next\n if not fast: return head.next\n while fast.next:\n  fast, slow = fast.next, slow.next\n slow.next = slow.next.next\n return head",
                "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/1164537/short-simple-one-pass-solution-w-explanation-beats-100-no-dummy-node-required/",
                "vote_count": "410"
            },
            {
                "language": "cpp",
                "code": "    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode synthetic(0, head);\n        ListNode* nodes[31];\n        int sz = 0;",
                "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/1164537/short-simple-one-pass-solution-w-explanation-beats-100-no-dummy-node-required/",
                "vote_count": "410"
            },
            {
                "language": "ruby",
                "code": "    map<int,ListNode*>mp;\n    \n    ListNode* cur=head;\n    int length=0;",
                "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/1164537/short-simple-one-pass-solution-w-explanation-beats-100-no-dummy-node-required/",
                "vote_count": "410"
            },
            {
                "language": "rust",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* temp=new ListNode();\n        temp->next=head;\n\n        ListNode* fast=temp;\n        ListNode* slow=temp;\n\n        for(int i=1;i<=n;i++){\n             fast=fast->next;\n        }\n\n        while(fast->next!=NULL){\n            fast=fast->next;\n            slow=slow->next;\n        }\n\n        ListNode* gaya=slow->next;\n        slow->next=slow->next->next;\n        delete(gaya);\n        \n        return temp->next;\n    }\n};\nif it helps plzz don't Forget to upvote it :)",
                "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2757145/c-del-n-th-node-from-the-end/",
                "vote_count": "65"
            },
            {
                "language": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n\n        // Create a temporary node and a counter to find the length of the linked list\n        ListNode temp = head;\n        int count = 0;\n\n        // Traverse the linked list and count the number of nodes\n        while (temp != null) {\n            count++;\n            temp = temp.next;\n        }\n\n        // Calculate the index of the node to be removed from the beginning of the list\n        int len = count - n;\n\n        // If the first node needs to be removed, update the head and return\n        if (len == 0) {\n            head = head.next;\n        } \n        else {\n             // Traverse the list until the node before the one to be removed\n            ListNode prev = head;\n            while (len - 1 != 0) {\n                prev = prev.next;\n                len--;\n            }\n        // Remove the node by updating the previous node's next pointer\n        prev.next = prev.next.next;\n        }\n\n    // Return the head node of the modified list\n    return head;\n    }\n}",
                "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3307508/100-faster-java-code-you-will-not-get-this-much-easy-code/",
                "vote_count": "13"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        int count = 1;\n        ListNode c = head;\n        while(c.next!=null){\n            count++;\n            c=c.next;\n        }\n        \n        if(n == count){\n            head = head.next;\n            return head;\n        }\n        \n        ListNode ln = head;\n        int i= 0;\n        while(++i<count-n){\n            ln = ln.next;  \n        }\n        ln.next = ln.next.next;\n        \n        return head;\n    }\n}",
                "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3222616/java-solution-for-beginners-linkedlist-easy-to-understand/",
                "vote_count": "12"
            }
        ]
    },
    "19": {
        "question_id": 20,
        "title": "Valid Parentheses",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/valid-parentheses",
        "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.An input string is valid if:Open brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order.Every close bracket has a corresponding open bracket of the same type. ",
        "examples": [
            {
                "input": "s = \"()\"",
                "output": "true",
                "explanation": null
            },
            {
                "input": "s = \"()[]{}\"",
                "output": "true",
                "explanation": null
            },
            {
                "input": "s = \"(]\"",
                "output": "false",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= s.length <= 10^4",
            "s consists of parentheses only '()[]{}'."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "public boolean isValid(String s) {\n Stack<Character> stack = new Stack<Character>();\n for (char c : s.toCharArray()) {\n  if (c == '(')\n   stack.push(')');\n  else if (c == '{')\n   stack.push('}');\n  else if (c == '[')\n   stack.push(']');\n  else if (stack.isEmpty() || stack.pop() != c)\n   return false;\n }\n return stack.isEmpty();\n}",
                "url": "https://leetcode.com/problems/valid-parentheses/solutions/9178/short-java-solution/",
                "vote_count": "3217"
            },
            {
                "language": "typescript",
                "code": "boolean isValid(String s) {\n  if ((s.length() & 1) == 1) return false;\n  else {\n    Deque<Character> p = new ArrayDeque<>(s.length());\n    for (int i = 0; i < s.length(); i++)\n      switch (s.charAt(i)) {\n        case '(': p.push(')'); break;\n        case '{': p.push('}'); break;",
                "url": "https://leetcode.com/problems/valid-parentheses/solutions/9178/short-java-solution/",
                "vote_count": "3217"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isValid(string s) {\n        // Initialize a stack and a index idx = 0...\n        stack<char> stack;\n        int idx = 0;\n        // If the string is empty, return true...\n        if(s.size() == 0){\n            return true;\n        }\n        // Create a loop to check parentheses...\n        while(idx < s.size()){\n            // If it contains the below parentheses, push the char to stack...\n            if( s[idx] == '(' || s[idx] == '[' || s[idx] == '{' ){\n                stack.push(s[idx]);\n            }\n            // If the current char is a closing brace provided, pop the top element...\n            // Stack is not empty...\n            else if ( (s[idx] == ')' && !stack.empty() && stack.top() == '(') ||\n                        (s[idx] == '}' && !stack.empty() && stack.top() == '{') ||\n                        (s[idx] == ']' && !stack.empty() && stack.top() == '[')\n                      ){\n                stack.pop();\n            }\n            else {\n                return false;       // If The string is not a valid parenthesis...\n            }\n            idx++;      // Increase the index...\n        }\n        // If stack.empty(), return true...\n        if(stack.empty()) {\n            return true;\n        }\n        return false;\n    }\n};",
                "url": "https://leetcode.com/problems/valid-parentheses/solutions/2411675/very-easy-100-fully-explained-c-java-python-js-python3/",
                "vote_count": "253"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public boolean isValid(String s) {\n        // Create hashmap to store the pairs...\n        HashMap<Character, Character> Hmap = new HashMap<Character, Character>();\n        Hmap.put(')','(');\n        Hmap.put('}','{');\n        Hmap.put(']','[');\n        // Create stack data structure...\n        Stack<Character> stack = new Stack<Character>();\n        // Traverse each charater in input string...\n        for (int idx = 0; idx < s.length(); idx++){\n            // If open parentheses are present, push it to stack...\n            if (s.charAt(idx) == '(' || s.charAt(idx) == '{' || s.charAt(idx) == '[') {\n                stack.push(s.charAt(idx));\n                continue;\n            }\n            // If the character is closing parentheses, check that the same type opening parentheses is being pushed to the stack or not...\n            // If not, we need to return false...\n            if (stack.size() == 0 || Hmap.get(s.charAt(idx)) != stack.pop()) {\n                return false;\n            }\n        }\n        // If the stack is empty, return true...\n        if (stack.size() == 0) {\n            return true;\n        }\n        return false;\n    }\n}",
                "url": "https://leetcode.com/problems/valid-parentheses/solutions/2411675/very-easy-100-fully-explained-c-java-python-js-python3/",
                "vote_count": "253"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def isValid(self, s):\n        # Create a pair of opening and closing parrenthesis...\n        opcl = dict(('()', '[]', '{}'))\n        # Create stack data structure...\n        stack = []\n        # Traverse each charater in input string...\n        for idx in s:\n            # If open parentheses are present, append it to stack...\n            if idx in '([{':\n                stack.append(idx)\n            # If the character is closing parentheses, check that the same type opening parentheses is being pushed to the stack or not...\n            # If not, we need to return false...\n            elif len(stack) == 0 or idx != opcl[stack.pop()]:\n                return False\n        # At last, we check if the stack is empty or not...\n        # If the stack is empty it means every opened parenthesis is being closed and we can return true, otherwise we return false...\n        return len(stack) == 0",
                "url": "https://leetcode.com/problems/valid-parentheses/solutions/2411675/very-easy-100-fully-explained-c-java-python-js-python3/",
                "vote_count": "253"
            },
            {
                "language": "cpp",
                "code": "var isValid = function(s) {\n    // Initialize stack to store the closing brackets expected...\n    let stack = [];\n    // Traverse each charater in input string...\n    for (let idx = 0; idx < s.length; idx++) {\n        // If open parentheses are present, push it to stack...\n        if (s[idx] == '{') {\n            stack.push('}');\n        } else if (s[idx] == '[') {\n            stack.push(']');\n        } else if (s[idx] == '(') {\n            stack.push(')');\n        }\n        // If a close bracket is found, check that it matches the last stored open bracket\n        else if (stack.pop() !== s[idx]) {\n            return false;\n        }\n    }\n    return !stack.length;\n};",
                "url": "https://leetcode.com/problems/valid-parentheses/solutions/2411675/very-easy-100-fully-explained-c-java-python-js-python3/",
                "vote_count": "253"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        # Create a pair of opening and closing parrenthesis...\n        opcl = dict(('()', '[]', '{}'))\n        # Create stack data structure...\n        stack = []\n        # Traverse each charater in input string...\n        for idx in s:\n            # If open parentheses are present, append it to stack...\n            if idx in '([{':\n                stack.append(idx)\n            # If the character is closing parentheses, check that the same type opening parentheses is being pushed to the stack or not...\n            # If not, we need to return false...\n            elif len(stack) == 0 or idx != opcl[stack.pop()]:\n                return False\n        # At last, we check if the stack is empty or not...\n        # If the stack is empty it means every opened parenthesis is being closed and we can return true, otherwise we return false...\n        return len(stack) == 0",
                "url": "https://leetcode.com/problems/valid-parentheses/solutions/2411675/very-easy-100-fully-explained-c-java-python-js-python3/",
                "vote_count": "253"
            },
            {
                "language": "kotlin",
                "code": "We can use a stack to store characters of the string.\nThen we can do two things:\n1. if char is open bracket (i.e. '(' or '{' or '[') then push it in stack.\n2. if char is closed bracket therefore we can check the following conditions:\n\n   1: if '{' is before '}'.\n   2: if '(' is before ')'.\n   3: if '[' is before ']'.\n\n   If any condition is false then return false.",
                "url": "https://leetcode.com/problems/valid-parentheses/solutions/2986468/simple-java-beats-100-runtime-easy-to-understand/",
                "vote_count": "154"
            },
            {
                "language": "kotlin",
                "code": "     **If this solution helped you, give it an up-vote to help others** ",
                "url": "https://leetcode.com/problems/valid-parentheses/solutions/2986468/simple-java-beats-100-runtime-easy-to-understand/",
                "vote_count": "154"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public boolean isValid(String s) {\n\n\n        // Create a new stack to store the characters.\n        Stack<Character> stack = new Stack<>();\n\n\n        // convert string into char array and access the characters using for each loop.\n        for(char ch: s.toCharArray())\n        {\n            // check ch\n            switch (ch)\n            {\n                // open bracket then push it in stack.\n                // close bracket then pop the item and compare.\n                case '(':\n                case '{':\n                case '[':\n                    stack.push(ch);\n                    break;\n                case ')':\n                    if(stack.isEmpty() || stack.pop() != '(')\n\n                    // if the stack is empty then it means string have no open bracket.\n                        // hence it is invalid.\n                    {\n                        return false;\n                    }\n                    break;\n                case '}':\n                    if(stack.isEmpty() || stack.pop() != '{')\n                    {\n                        return false;\n                    }\n                    break;\n                case ']':\n                    if(stack.isEmpty() || stack.pop() != '[')\n                    {\n                        return false;\n                    }\n                    break;\n            }\n        }\n\n\n        // After the loop we have to check one more condition.\n        // return true only if the stack is empty.\n        // if stack is not empty that means we have unused brackets.\n\n        return stack.isEmpty();\n        \n    }\n}",
                "url": "https://leetcode.com/problems/valid-parentheses/solutions/2986468/simple-java-beats-100-runtime-easy-to-understand/",
                "vote_count": "154"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public boolean isValid(String s) {\n        \n        Stack<Character> stack = new Stack<Character>();\n        HashMap<Character, Character> complement = \n            new HashMap<Character, Character>();\n\n        complement.put(')', '(');",
                "url": "https://leetcode.com/problems/valid-parentheses/solutions/2986468/simple-java-beats-100-runtime-easy-to-understand/",
                "vote_count": "154"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> st ; \n        for (int i = 0 ;  i< s.length() ; i++)\n        {\n            char ch = s[i];\n\n            // if opening bracket then push into the stack \n            if (ch == '(' || ch == '{' || ch == '[')\n            {\n                st.push(ch) ; \n            }\n\n            else {\n                // if a closing bracket then we compare with the top of the stack \n                // while comparing with top of stack we have 2 cases \n                // the stack can be empty or the stack is not empty \n                if (!st.empty())\n                {\n                    char top = st.top() ;\n                    if ((ch == ')' && top == '(') || \n                        (ch == '}' && top == '{') ||\n                        (ch == ']' && top == '[')) \n                        {\n                            // if matches then pop \n                            st.pop() ;\n                        }\n                        else \n                        {\n                            return false ; \n                        }\n                }\n                else \n                {\n                    // if stack is empty and we get a closing bracket means the string is unbalanced \n                    return false ;\n                }\n            }\n        }\n\n        // in the end if the stack is empty -- meaning there is no opening bracket present in the stack -- meaning all opening brackets have found their corresponding closing bracket and have been popped then we return trie \n        if (st.empty())\n        {\n            return true ; \n        }\n        return false ;\n    }\n};",
                "url": "https://leetcode.com/problems/valid-parentheses/solutions/3100615/c-solution-using-stack-explained/",
                "vote_count": "130"
            },
            {
                "language": "kotlin",
                "code": "",
                "url": "https://leetcode.com/problems/valid-parentheses/solutions/3100615/c-solution-using-stack-explained/",
                "vote_count": "130"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        while '()' in s or '[]'in s or '{}' in s:\n            s = s.replace('()','').replace('[]','').replace('{}','')\n        return False if len(s) !=0 else True",
                "url": "https://leetcode.com/problems/valid-parentheses/solutions/3030914/pythoneasy/",
                "vote_count": "85"
            }
        ]
    },
    "20": {
        "question_id": 21,
        "title": "Merge Two Sorted Lists",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/merge-two-sorted-lists",
        "description": "You are given the heads of two sorted linked lists list1 and list2.Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.Return the head of the merged linked list. ",
        "examples": [
            {
                "input": "list1 = [1,2,4], list2 = [1,3,4]",
                "output": "[1,1,2,3,4,4]",
                "explanation": null
            },
            {
                "input": "list1 = [], list2 = []",
                "output": "[]",
                "explanation": null
            },
            {
                "input": "list1 = [], list2 = [0]",
                "output": "[0]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in both lists is in the range [0, 50].",
            "-100 <= Node.val <= 100",
            "Both list1 and list2 are sorted in non-decreasing order."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "1. Easy C++\n2. Line by Line Explanation with Comments.\n3. Detailed Explanation \u2705\n4. Linked list problem, merge.\n5. Please Upvote if it helps\u2b06\ufe0f\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \u2b07\ufe0f\n // \ud83d\ude09If you Like the repository don't foget to star & fork the repository\ud83d\ude09",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/solutions/1826666/c-easy-to-understand-2-approaches-recursive-iterative/",
                "vote_count": "1546"
            },
            {
                "language": "kotlin",
                "code": "     // \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09Please upvote if it helps \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09\nclass Solution {\npublic:\n ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) \n  {\n  // if list1 happen to be NULL\n  // we will simply return list2.\n  if(l1 == NULL)\n        {\n   return l2;\n  }\n  \n  // if list2 happen to be NULL\n  // we will simply return list1.\n  if(l2 == NULL)\n        {\n   return l1;\n  } \n  \n  // if value pointend by l1 pointer is less than equal to value pointed by l2 pointer\n  // we wall call recursively l1 -> next and whole l2 list.\n  if(l1 -> val <= l2 -> val)\n        {\n   l1 -> next = mergeTwoLists(l1 -> next, l2);\n   return l1;\n  }\n  // we will call recursive l1 whole list and l2 -> next\n  else\n        {\n   l2 -> next = mergeTwoLists(l1, l2 -> next);\n   return l2;            \n  }\n }\n}; ",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/solutions/1826666/c-easy-to-understand-2-approaches-recursive-iterative/",
                "vote_count": "1546"
            },
            {
                "language": "rust",
                "code": "     // \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09Please upvote if it helps \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n       \n     // if list1 happen to be NULL\n  // we will simply return list2.\n        if(list1 == NULL)\n            return list2;\n  \n  // if list2 happen to be NULL\n  // we will simply return list1.\n        if(list2 == NULL)\n            return list1;\n        \n        ListNode * ptr = list1;\n        if(list1 -> val > list2 -> val)\n        {\n            ptr = list2;\n            list2 = list2 -> next;\n        }\n        else\n        {\n            list1 = list1 -> next;\n        }\n        ListNode *curr = ptr;\n        \n  // till one of the list doesn't reaches NULL\n        while(list1 &&  list2)\n        {\n            if(list1 -> val < list2 -> val){\n                curr->next = list1;\n                list1 = list1 -> next;\n            }\n            else{\n                curr->next = list2;\n                list2 = list2 -> next;\n            }\n            curr = curr -> next;\n                \n        }\n  \n  // adding remaining elements of bigger list.\n        if(!list1)\n            curr -> next = list2;\n        else\n            curr -> next = list1;\n            \n        return ptr;\n       \n    }\n};",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/solutions/1826666/c-easy-to-understand-2-approaches-recursive-iterative/",
                "vote_count": "1546"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode *dummy, *temp;\n        dummy = new ListNode();\n        temp = dummy;\n        \n        //when both list1 and list2 isn't empty",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/solutions/1826666/c-easy-to-understand-2-approaches-recursive-iterative/",
                "vote_count": "1546"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n   public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n    \n    if(list2==null) return list1;\n    if(list1==null) return list2;\n    \n    if(list1.val < list2.val) {\n        return mergeTwoListsUtil(list1, list2);",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/solutions/1826666/c-easy-to-understand-2-approaches-recursive-iterative/",
                "vote_count": "1546"
            },
            {
                "language": "kotlin",
                "code": "public ListNode mergeTwoLists(ListNode l1, ListNode l2){\n  if(l1 == null) return l2;\n  if(l2 == null) return l1;\n  if(l1.val < l2.val){\n   l1.next = mergeTwoLists(l1.next, l2);\n   return l1;\n  } else{\n   l2.next = mergeTwoLists(l1, l2.next);\n   return l2;\n  }\n}",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/solutions/9715/java-1-ms-4-lines-codes-using-recursion/",
                "vote_count": "1352"
            },
            {
                "language": "kotlin",
                "code": "public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if(l1 == null) return l2;\n        else if(l2 == null) return l1;\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        while(l1 != null && l2!= null){\n            if(l1.val <= l2.val){\n                curr.next = l1;",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/solutions/9715/java-1-ms-4-lines-codes-using-recursion/",
                "vote_count": "1352"
            },
            {
                "language": "kotlin",
                "code": "    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if( l1==null || l2==null ) return l2==null ? l1 : l2;\n        ListNode first = (l2.val<l1.val) ? l2 : l1;\n        first.next=mergeTwoLists( first.next, first==l1 ? l2 : l1 );\n        return first;\n    }",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/solutions/9715/java-1-ms-4-lines-codes-using-recursion/",
                "vote_count": "1352"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        cur = dummy = ListNode()\n        while list1 and list2:               \n            if list1.val < list2.val:\n                cur.next = list1\n                list1, cur = list1.next, list1\n            else:\n                cur.next = list2\n                list2, cur = list2.next, list2\n                \n        if list1 or list2:\n            cur.next = list1 if list1 else list2\n            \n        return dummy.next",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/solutions/1826693/python3-merging-explained/",
                "vote_count": "859"
            },
            {
                "language": "python",
                "code": "list1, cur = list1.next, list1",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/solutions/1826693/python3-merging-explained/",
                "vote_count": "859"
            },
            {
                "language": "python",
                "code": "cur = cur.next; list1 = list1.next;",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/solutions/1826693/python3-merging-explained/",
                "vote_count": "859"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        if not list1 and not list2:\n            return list1\n        if not list1 or not list2:\n            return list1 if not list2 else list2\n        seek, target = (list1, list2) if list1.val < list2.val else (list2, list1)\n        head = seek",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/solutions/1826693/python3-merging-explained/",
                "vote_count": "859"
            },
            {
                "language": "python",
                "code": "if list1 is None and list2 is None:\n    return None\nelif list1 is None:",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/solutions/1826693/python3-merging-explained/",
                "vote_count": "859"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        head = prev = ListNode()\n        get = lambda x,y: x if x.val < y.val else y\n        while l1 and l2:\n            prev.next = prev = (mini := get(l1,l2))\n            if mini == l1: l1 = l1.next\n            else: l2 = l2.next",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/solutions/1826693/python3-merging-explained/",
                "vote_count": "859"
            },
            {
                "language": "java",
                "code": "    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode prehead = new ListNode(-1);\n        ListNode cur = prehead;\n\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n\n        cur.next = l1 == null ? l2 : l1;\n        return prehead.next;\n    }",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/solutions/2809815/java/",
                "vote_count": "210"
            },
            {
                "language": "kotlin",
                "code": "var mergeTwoLists = function (l1, l2) {\n    if (!l1) return l2;\n    else if (!l2) return l1;\n    else if (l1.val <= l2.val) {\n        l1.next = mergeTwoLists(l1.next, l2);\n        return l1;\n    } else {\n        l2.next = mergeTwoLists(l1, l2.next);\n        return l2\n    }\n};",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/solutions/2705782/js-recursion-with-exlanation/",
                "vote_count": "110"
            },
            {
                "language": "kotlin",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n\n        if(list1!=null && list2!=null){\n        if(list1.val<list2.val){\n            list1.next=mergeTwoLists(list1.next,list2);\n            return list1;\n            }\n            else{\n                list2.next=mergeTwoLists(list1,list2.next);\n                return list2;\n        }\n        }\n        if(list1==null)\n            return list2;\n        return list1;\n    }\n}",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/solutions/3177193/simple-java-runtime-1-ms-beats-100/",
                "vote_count": "68"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        \n        if(l1 == NULL) return l2;\n        if(l2 == NULL) return l1;\n\n\n        if(l1->val > l2->val){  // taking L1 is smaller than l2 \n            swap(l1,l2);    // haar baar l1 hi chota hoga\n        }\n        ListNode* result = l1;\n        ListNode* temp = NULL;\n        while(l1 != NULL && l2 != NULL){\n            \n            if(l1->val <= l2->val ){\n                temp = l1;\n                l1 = l1->next;\n            }\n            else {\n                temp -> next = l2;\n                swap(l1,l2); // haar baar l1 hi chota hoga\n            }\n        }\n         while(l1 != NULL){\n            temp->next = l1;\n            temp = l1;\n            l2 = l2->next;\n        }\n        while(l2 != NULL){\n            temp->next = l2;\n            temp = l2;\n            l2 = l2 ->next;\n        }\n       \n        return result;\n    }\n};",
                "url": "https://leetcode.com/problems/merge-two-sorted-lists/solutions/3224012/simple-c-s-c-o-1-beats-99-84/",
                "vote_count": "22"
            }
        ]
    },
    "21": {
        "question_id": 22,
        "title": "Generate Parentheses",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/generate-parentheses",
        "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. ",
        "examples": [
            {
                "input": "n = 3",
                "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
                "explanation": null
            }
        ],
        "constraints": [],
        "solutions": [
            {
                "language": "python",
                "code": " public List<String> generateParenthesis(int n) {\n        List<String> list = new ArrayList<String>();\n        backtrack(list, \"\", 0, 0, n);\n        return list;\n    }\n    \n    public void backtrack(List<String> list, String str, int open, int close, int max){\n        \n        if(str.length() == max*2){\n            list.add(str);\n            return;\n        }\n        \n        if(open < max)\n            backtrack(list, str+\"(\", open+1, close, max);\n        if(close < open)\n            backtrack(list, str+\")\", open, close+1, max);\n    }",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/10100/easy-to-understand-java-backtracking-solution/",
                "vote_count": "1297"
            },
            {
                "language": "typescript",
                "code": "    public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList<>();\n        helper(res,n,0,\"\");",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/10100/easy-to-understand-java-backtracking-solution/",
                "vote_count": "1297"
            },
            {
                "language": "go",
                "code": "public List<String> generateParenthesis(int n) {\n     List<String> res = new ArrayList<>();\n     helper(res, new StringBuilder(), 0, 0, n);\n     return res;\n}\n\nprivate void helper(List<String> res, StringBuilder sb, int open, int close, int n) {",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/10100/easy-to-understand-java-backtracking-solution/",
                "vote_count": "1297"
            },
            {
                "language": "typescript",
                "code": "public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList<>();\n        if(n <= 0){\n            return res;\n        }\n        StringBuilder curr = new StringBuilder();\n        backTracking(n, n, res, curr);",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/10100/easy-to-understand-java-backtracking-solution/",
                "vote_count": "1297"
            },
            {
                "language": "ruby",
                "code": "def generateParenthesis(self, n: int) -> List[str]:\n def dfs(left, right, s):\n  if len(s) == n * 2:\n   res.append(s)\n   return \n\n  if left < n:\n   dfs(left + 1, right, s + '(')\n\n  if right < left:\n   dfs(left, right + 1, s + ')')\n\n res = []\n dfs(0, 0, '')\n return res",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/2542620/python-java-w-explanation-faster-than-96-w-proof-easy-to-understand/",
                "vote_count": "637"
            },
            {
                "language": "go",
                "code": "            (0, 0, '')\n              | \n         (1, 0, '(')  \n           /           \\\n       (2, 0, '((')      (1, 1, '()')\n          /                 \\\n      (2, 1, '(()')           (2, 1, '()(')\n         /                       \\\n     (2, 2, '(())')                (2, 2, '()()')\n            |                              |\n     res.append('(())')             res.append('()()')\n   ",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/2542620/python-java-w-explanation-faster-than-96-w-proof-easy-to-understand/",
                "vote_count": "637"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList<String>();\n        recurse(res, 0, 0, \"\", n);\n        return res;\n    }\n    \n    public void recurse(List<String> res, int left, int right, String s, int n) {\n        if (s.length() == n * 2) {\n            res.add(s);\n            return;\n        }\n        \n        if (left < n) {\n            recurse(res, left + 1, right, s + \"(\", n);\n        }\n        \n        if (right < left) {\n            recurse(res, left, right + 1, s + \")\", n);\n        }\n    }\n // See above tree diagram with parameters (left, right, s) for better understanding\n}",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/2542620/python-java-w-explanation-faster-than-96-w-proof-easy-to-understand/",
                "vote_count": "637"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        result = []\n        left = right = 0\n        q = [(left, right, '')]\n        while q:\n            left, right, s = q.pop()\n            if len(s) == 2 * n:",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/2542620/python-java-w-explanation-faster-than-96-w-proof-easy-to-understand/",
                "vote_count": "637"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<string>result;\n    \n    void helper(int open,int close,int n,string current)\n    {\n        if(current.length()==n*2)\n        {\n            result.push_back(current);\n            return;\n        }\n        if(open<n)  helper(open+1,close,n,current+\"(\");\n        if(close<open)  helper(open,close+1,n,current+\")\");\n    }\n    vector<string> generateParenthesis(int n) {\n        helper(0,0,n,\"\");\n        return result;\n    }\n};",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/1131364/clear-and-simple-explanation-with-intuition-100-faster/",
                "vote_count": "190"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<string>result;\n    \n    void helper(int open,int close,int n,string current)\n    {\n        if(current.length()==n*2) {\n            result.push_back(current);",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/1131364/clear-and-simple-explanation-with-intuition-100-faster/",
                "vote_count": "190"
            },
            {
                "language": "csharp",
                "code": "// count1 is used to flag the base case \n// count2 is used to react to the base case \ncount1=0 and count2=0 respectively.\n\n// following is the signature for the recursive function\nsubseq(int count1,int count2,string v,vector<string> &ans,int n)\n\n// only the first three parameters are determining the state of each recursive call.\n// vector<string> &ans   is passed with every recursive call to store the final valid strings\n// int n   is used to check the base condition",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/2679907/easy-recursive-c-solution-clearly-explained/",
                "vote_count": "52"
            },
            {
                "language": "javascript",
                "code": "if(count2<count1){\n subseq(count1,count2+1,v+\")\",ans,n);    \n}",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/2679907/easy-recursive-c-solution-clearly-explained/",
                "vote_count": "52"
            },
            {
                "language": "csharp",
                "code": "void subseq(int count1,int count2,string v,vector<string> &ans,int n){\n        if(count1==n){\n            // if there are n open '(', we simply push the rest closing ')'\n            while(count2<n){\n                v+=\")\";\n                count2+=1;\n            }\n   // v is pushed to the answer vector\n   \n            ans.push_back(v);\n            return;\n        }\n  \n        subseq(count1+1,count2,v+\"(\",ans,n);\n  \n        if(count2<count1){\n            subseq(count1,count2+1,v+\")\",ans,n);    \n        }\n    }\n    vector<string> generateParenthesis(int n) {\n        vector<string> ans;\n        string v;\n        subseq(0,0,v,ans,n);\n\n        return ans;\n    }",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/2679907/easy-recursive-c-solution-clearly-explained/",
                "vote_count": "52"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList();\n        findAll(\"(\",1,0,res,n);\n\n        return res;\n    }\n\n    void findAll(String current,int op , int cl , List<String> res, int n){\n        if(current.length()==2*n){\n            res.add(current);\n            return;\n        }\n        if(op<n)\n        findAll(current+\"(\", op+1,cl,res,n);\n        if(cl<op)\n        findAll(current+\")\",op,cl+1,res,n);\n    }\n}",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/2936271/simple-java-sol/",
                "vote_count": "31"
            },
            {
                "language": "csharp",
                "code": "}\n\nvoid findAll(String current,List<String> result,int op,int cl,int n){",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/2936271/simple-java-sol/",
                "vote_count": "31"
            },
            {
                "language": "javascript",
                "code": "                                \"_  _  _  _\"\n                                / \\     \n                              '(' ')'",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/3290261/i-bet-you-will-understand-intutive-solution-beginner-friendly-c/",
                "vote_count": "30"
            },
            {
                "language": "javascript",
                "code": "                                    op      ip\n                                    \"\"   O-3, C-3\n                            \n                                    \"(\",O-2,C-3\n                    \n                \"((\",O-1,C-3                            \"()\", O-2,C-2\n\n    \"(((\",0,3             \"(()\",1,2                       \"()(\",1,2\n\n    \"((()\",0,2      \"(()(\",0,2    \"(())\",1,1        \"()((\",0,2      \"()()\",1,1\n\n    \"((())\",0,1     \"(()()\",0,1   \"(())(\",0,1       \"()(()\",0,1     \"()()(\",0,1\n\n    \"((()))\",0,0   \"(()())\",0,0   \"(())()\",0,0      \"()(())\",0,0    \"()()()\", 0,0\n                        ",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/3290261/i-bet-you-will-understand-intutive-solution-beginner-friendly-c/",
                "vote_count": "30"
            },
            {
                "language": "go",
                "code": "class Solution {\npublic:\n    void solve(string op, int open, int close, vector<string> &ans){\n        if(open == 0 && close == 0){\n            ans.push_back(op);\n            return;\n        }\n        //when count of open and close brackets are same then \n        //we have only one choice to put open bracket \n        if(open == close){\n            string op1 = op;\n            op1.push_back('(');\n            solve(op1, open-1, close, ans);\n        }\n        else if(open == 0){\n            //only choice is to put close brackets \n            string op1 = op;\n            op1.push_back(')');\n            solve(op1, open, close-1, ans);\n        }\n        else if(close == 0){\n            //only choise is to use open bracket \n            string op1 = op;\n            op1.push_back('(');\n            solve(op1, open-1, close, ans);\n        }\n        else{\n            string op1 = op;\n            string op2 = op;\n            op1.push_back('(');\n            op2.push_back(')');\n            solve(op1, open-1, close, ans);\n            solve(op2, open, close-1, ans);\n        }\n    }\n    vector<string> generateParenthesis(int n) {\n        int open = n;\n        int close = n;\n        vector<string> ans;\n        string op = \"\";\n        solve(op, open, close, ans);\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/3290261/i-bet-you-will-understand-intutive-solution-beginner-friendly-c/",
                "vote_count": "30"
            },
            {
                "language": "python",
                "code": "void    tryCombinations(int open, int close, vector<string>& res, string str)\n{\n        if (open == 0 && close == 0)\n        {\n            res.push_back(str);",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/3290261/i-bet-you-will-understand-intutive-solution-beginner-friendly-c/",
                "vote_count": "30"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O((2^2*N)*N). For each of 2^2*N sequences, we need to create and validate the sequence,\n    which takes O(N) work.\n\n    Space Complexity : O((2^2*N)*N) vector(output) space.\n\n    Solved using Array + Backtracking. Brute Force Approach.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\nprivate:\n    bool valid(vector<char> temp){\n        int balance = 0;\n        for(auto c : temp){\n            if(c == '(') balance++;\n            else balance--;\n            if(balance < 0) return false;\n        }\n        return balance == 0;\n    }\n    void generateAllParenthesis(vector<string>& parenthesesCombinations, vector<char> temp, int position){\n        if(position == temp.size()){\n            if(valid(temp)){\n                string s(temp.begin(), temp.end());\n                parenthesesCombinations.push_back(s);\n            }\n            return;\n        }\n        temp[position] = '(';\n        generateAllParenthesis(parenthesesCombinations, temp, position+1);\n        temp[position] = ')';\n        generateAllParenthesis(parenthesesCombinations, temp, position+1); \n    }\npublic:\n    vector<string> generateParenthesis(int n) {\n        vector<string> parenthesesCombinations;\n        vector<char> temp(2*n);\n        generateAllParenthesis(parenthesesCombinations, temp, 0);\n        return parenthesesCombinations;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(O(2^2*N)The time complexity of the above code is O(2^(2N)) since in the worst case we\n    need to consider every possibility of opening and closing brackets where N = the number of pairs we need to\n    form.\n\n    Space Complexity : O((2^2*N)*N) vector(output) space.\n\n    Solved using Array + Backtracking. Brute Force Approach.\n\n*/\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\nprivate:\n    void recurse(vector<string>& output, string s, int open, int close, int n){\n        if(open==n and close==n){\n            output.push_back(s);\n            return;\n        }\n        if(open<n)\n            recurse(output, s+\"(\" , open+1, close, n);\n        if(close<open)\n            recurse(output, s+\")\", open, close+1, n);\n    }\npublic:\n    vector<string> generateParenthesis(int n) {\n        vector<string> output;\n        recurse(output, \"\", 0, 0, n);\n        return output;\n    }\n};",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/3211825/best-c-2-solution-ever-easy-solution-backtracking-one-stop-solution/",
                "vote_count": "20"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    vector<string> ans;\n    \n    void fun(int left,int right,string s)\n    {\n        if(left<0||right<0)\n        {\n          return;\n        }\n        if(left==0 and right==0)\n        {\n          ans.push_back(s);\n          return;\n        }\n      \n       fun(left-1,right,s+\"(\");\n    \n       if(right>left)\n    {\n    fun(left,right-1,s+\")\");\n    }\n    }\n    \n    vector<string> generateParenthesis(int n) {\n        fun(n,n,\"\");\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/generate-parentheses/solutions/3235446/c-simple-very-easy/",
                "vote_count": "11"
            }
        ]
    },
    "22": {
        "question_id": 23,
        "title": "Merge k Sorted Lists",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/merge-k-sorted-lists",
        "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.Merge all the linked-lists into one sorted linked-list and return it. ",
        "examples": [
            {
                "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
                "output": "[1,1,2,3,4,4,5,6]",
                "explanation": "The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6"
            },
            {
                "input": "lists = []",
                "output": "[]",
                "explanation": null
            },
            {
                "input": "lists = [[]]",
                "output": "[]",
                "explanation": null
            }
        ],
        "constraints": [
            "k == lists.length",
            "0 <= k <= 10^4",
            "0 <= lists[i].length <= 500",
            "-10^4 <= lists[i][j] <= 10^4",
            "lists[i] is sorted in ascending order.",
            "The sum of lists[i].length will not exceed 10^4."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if(lists.size() == 0) return NULL;\n        return mergeKListsHelper(lists, 0, lists.size()-1);\n    }\n\n    ListNode* mergeKListsHelper(vector<ListNode*>& lists, int start, int end) {\n        if(start>end) return NULL; \n        if(start==end) return lists[start];\n\n        int mid = start + (end-start)/2;\n        ListNode* left = mergeKListsHelper(lists, start, mid);\n        ListNode* right = mergeKListsHelper(lists, mid + 1, end);\n        return merge(left, right);\n    }\n\n    ListNode* merge(ListNode* list1Head, ListNode* list2Head) {\n        ListNode* dummyHead = new ListNode(-1);\n        ListNode* dummyTail = dummyHead;\n\n        while(list1Head!=NULL && list2Head!=NULL){\n            if(list1Head->val < list2Head->val){\n                dummyTail->next = list1Head;\n                list1Head = list1Head->next;\n            }else{\n                dummyTail->next = list2Head;\n                list2Head = list2Head->next;\n            }\n            dummyTail = dummyTail->next;\n        }\n        dummyTail->next = (list1Head != NULL) ? list1Head : list2Head;\n        return dummyHead->next;\n    }\n};",
                "url": "https://leetcode.com/problems/merge-k-sorted-lists/solutions/3286058/image-explanation-5-methods-divide-conquer-priority-queue-complete-intuition/",
                "vote_count": "67"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if(lists.size() == 0) return NULL;\n\n        ListNode* dummyHead = new ListNode(-1);\n        ListNode* dummyTail = dummyHead;\n\n        priority_queue<pair<int, ListNode*>, vector<pair<int, ListNode*>>, greater<pair<int, ListNode*>>> pq;\n        for(auto head : lists)  if(head != NULL) pq.push({head->val, head});\n\n        while(!pq.empty()){\n            ListNode* minNode = pq.top().second;\n            pq.pop();\n            if(minNode->next != NULL) pq.push({minNode->next->val, minNode->next});\n\n            dummyTail->next = minNode;\n            dummyTail = dummyTail->next;\n        }\n        return dummyHead->next;\n    }\n};",
                "url": "https://leetcode.com/problems/merge-k-sorted-lists/solutions/3286058/image-explanation-5-methods-divide-conquer-priority-queue-complete-intuition/",
                "vote_count": "67"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            return null;\n        }\n        return mergeKListsHelper(lists, 0, lists.length - 1);\n    }\n    \n    private ListNode mergeKListsHelper(ListNode[] lists, int start, int end) {\n        if (start == end) {\n            return lists[start];\n        }\n        if (start + 1 == end) {\n            return merge(lists[start], lists[end]);\n        }\n        int mid = start + (end - start) / 2;\n        ListNode left = mergeKListsHelper(lists, start, mid);\n        ListNode right = mergeKListsHelper(lists, mid + 1, end);\n        return merge(left, right);\n    }\n    \n    private ListNode merge(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        \n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                curr.next = l1;\n                l1 = l1.next;\n            } else {\n                curr.next = l2;\n                l2 = l2.next;\n            }\n            curr = curr.next;\n        }\n        \n        curr.next = (l1 != null) ? l1 : l2;\n        \n        return dummy.next;\n    }\n}",
                "url": "https://leetcode.com/problems/merge-k-sorted-lists/solutions/3285930/100-faster-c-java-python/",
                "vote_count": "64"
            },
            {
                "language": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        v=[]\n        for i in lists:\n            x=i\n            while x:\n                v+=[x.val]\n                x=x.next\n        v=sorted(v,reverse=True)\n        ans=None\n        for i in v:\n            ans=ListNode(i,ans)\n        return ans",
                "url": "https://leetcode.com/problems/merge-k-sorted-lists/solutions/3286803/python3-and-c-95-ms-beats-95-60-and-easy/",
                "vote_count": "31"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        vector<int>v;\n        for(int i=0;i<lists.size();i++){\n            while(lists[i]){\n                v.push_back(lists[i]->val);\n                lists[i]=lists[i]->next;\n            }\n        }\n        sort(rbegin(v),rend(v));\n        ListNode* ans=nullptr;\n        for(int i=0;i<v.size();i++){\n            ans=new ListNode(v[i],ans);\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/merge-k-sorted-lists/solutions/3286803/python3-and-c-95-ms-beats-95-60-and-easy/",
                "vote_count": "31"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* merge(ListNode *left, ListNode *right) {\n        ListNode *dummy = new ListNode(-1);\n        ListNode *temp = dummy;\n        while (left != nullptr && right != nullptr) {\n            if (left -> val < right -> val) {\n                temp -> next = left;\n                temp = temp -> next;\n                left = left -> next;\n            }\n            else {\n                temp -> next = right;\n                temp = temp -> next;\n                right = right -> next;\n            }\n        }\n        while (left != nullptr) {\n            temp -> next = left;\n            temp = temp -> next;\n            left = left -> next;\n        }\n        while (right != nullptr) {\n            temp -> next = right;\n            temp = temp -> next;\n            right = right -> next;\n        }\n        return dummy -> next;\n    }\n    ListNode* mergeSort(vector<ListNode*>& lists, int start, int end) {\n        if (start == end) \n            return lists[start];\n        int mid = start + (end - start) / 2;\n        ListNode *left = mergeSort(lists, start, mid);\n        ListNode *right = mergeSort(lists, mid + 1, end);\n        return merge(left, right);\n    }\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if (lists.size() == 0)\n            return nullptr;\n        return mergeSort(lists, 0, lists.size() - 1);\n    }\n};",
                "url": "https://leetcode.com/problems/merge-k-sorted-lists/solutions/3286070/day-71-divide-and-conquer-easiest-beginner-friendly-sol/",
                "vote_count": "24"
            }
        ]
    },
    "23": {
        "question_id": 24,
        "title": "Swap Nodes in Pairs",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/swap-nodes-in-pairs",
        "description": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.) ",
        "examples": [
            {
                "input": "head = [1,2,3,4]",
                "output": "[2,1,4,3]",
                "explanation": null
            },
            {
                "input": "head = []",
                "output": "[]",
                "explanation": null
            },
            {
                "input": "head = [1]",
                "output": "[1]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the\u00a0list\u00a0is in the range [0, 100].",
            "0 <= Node.val <= 100"
        ],
        "solutions": [
            {
                "language": "ruby",
                "code": "prevNode->next = currNode->next",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1775033/swapping-nodes-not-just-the-values-visual-explanation-well-explained-c/",
                "vote_count": "594"
            },
            {
                "language": "ruby",
                "code": "currNode->next = prevNode->next->next",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1775033/swapping-nodes-not-just-the-values-visual-explanation-well-explained-c/",
                "vote_count": "594"
            },
            {
                "language": "ruby",
                "code": "prevNode->next->next = currNode",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1775033/swapping-nodes-not-just-the-values-visual-explanation-well-explained-c/",
                "vote_count": "594"
            },
            {
                "language": "java",
                "code": "prevNode = currNode\ncurrNode = currNode->next",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1775033/swapping-nodes-not-just-the-values-visual-explanation-well-explained-c/",
                "vote_count": "594"
            },
            {
                "language": "rust",
                "code": "ListNode* swapPairs(ListNode* head) {\n        if(!head || !head->next) return head; //If there are less than 2 nodes in the given nodes, then no need to do anything just return the list as it is.\n  \n        ListNode* dummyNode = new ListNode();\n        \n        ListNode* prevNode=dummyNode;\n        ListNode* currNode=head;\n        \n        while(currNode && currNode->next){\n            prevNode->next = currNode->next;\n            currNode->next = prevNode->next->next;\n            prevNode->next->next = currNode;\n            \n            prevNode = currNode;\n            currNode = currNode->next;\n        }\n        \n        return dummyNode->next;\n    }",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1775033/swapping-nodes-not-just-the-values-visual-explanation-well-explained-c/",
                "vote_count": "594"
            },
            {
                "language": "java",
                "code": "public ListNode swapPairs(ListNode head) {\n    ListNode temp = new ListNode(0);\n    temp.next = head;\n    ListNode first = head;\n    if (head != null && head.next != null) {\n      first = head.next;\n    }\n    while (temp.next != null && temp.next.next != null) {",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1775033/swapping-nodes-not-just-the-values-visual-explanation-well-explained-c/",
                "vote_count": "594"
            },
            {
                "language": "ruby",
                "code": "def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n    \"\"\" O(N)TS \"\"\"\n    if (n1 := head) and (n2 := head.next):\n        n2.next, n1.next = n1, self.swapPairs(n2.next)\n        return n2\n    return head",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1775033/swapping-nodes-not-just-the-values-visual-explanation-well-explained-c/",
                "vote_count": "594"
            },
            {
                "language": "javascript",
                "code": "head = dummyNode->next;\ndelete dummyNode;\n\nreturn head;",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1775033/swapping-nodes-not-just-the-values-visual-explanation-well-explained-c/",
                "vote_count": "594"
            },
            {
                "language": "ruby",
                "code": "class Solution {\n    public ListNode swapPairs(ListNode head) {\n      if (head == null || head.next == null) \n          return head;\n        ListNode new_head = head.next;\n        ListNode temp = head.next.next;\n        new_head.next = head;",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1775033/swapping-nodes-not-just-the-values-visual-explanation-well-explained-c/",
                "vote_count": "594"
            },
            {
                "language": "scala",
                "code": "Let's take an example not given in question -\nSuppose our head pointer given to us as [1,9,2,8,3,7]\n\nSo, we have to swap every two adjcant nodes,\nthe answer should be [9,1,8,2,7,3]",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1774708/c-visual-image-how-links-change-explained-every-step-commented-code/",
                "vote_count": "511"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        // if head is NULL OR just having a single node, then no need to change anything \n        if(head == NULL || head -> next == NULL) \n        {\n            return head;\n        }\n            \n        ListNode* temp; // temporary pointer to store head -> next\n        temp = head->next; // give temp what he want\n        \n        head->next = swapPairs(head->next->next); // changing links\n        temp->next = head; // put temp -> next to head\n        \n        return temp; // now after changing links, temp act as our head\n    }\n};",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1774708/c-visual-image-how-links-change-explained-every-step-commented-code/",
                "vote_count": "511"
            },
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr ||\n            head->next == nullptr) {\n            return head;\n        }\n        ",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1774708/c-visual-image-how-links-change-explained-every-step-commented-code/",
                "vote_count": "511"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    ListNode *swapPairs(ListNode *head) {\n        if (!head or !head->next) return head;\n        ListNode *curr = head, *next = head->next;\n        while (next and next->next)\n        {\n            swap(curr->val, next->val);",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1774708/c-visual-image-how-links-change-explained-every-step-commented-code/",
                "vote_count": "511"
            },
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(!head || !head->next)    return head;\n        \n        ListNode* curr = head;\n        ListNode* temp = curr->next;\n        ",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1774708/c-visual-image-how-links-change-explained-every-step-commented-code/",
                "vote_count": "511"
            },
            {
                "language": "ruby",
                "code": "def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n if not head: return head\n\n prev, cur, ans = None, head, head.next\n while cur and cur.next:\n  adj = cur.next\n  if prev: prev.next = adj\n\n  cur.next, adj.next = adj.next, cur\n  prev, cur = cur, cur.next\n\n return ans or head",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1774318/python3-i-hate-linked-lists-not-explained/",
                "vote_count": "126"
            },
            {
                "language": "ruby",
                "code": "    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(None, head)\n        prev, cur = dummy, head\n        while cur and cur.next:\n            prev.next = cur.next",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1774318/python3-i-hate-linked-lists-not-explained/",
                "vote_count": "126"
            },
            {
                "language": "ruby",
                "code": "class Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode sentinal = new ListNode(-1);\n        ListNode prev = sentinal;\n        while(head != null && head.next != null){\n            prev.next  = head.next;\n            ListNode next = head.next.next;",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1774318/python3-i-hate-linked-lists-not-explained/",
                "vote_count": "126"
            },
            {
                "language": "ruby",
                "code": "",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1774318/python3-i-hate-linked-lists-not-explained/",
                "vote_count": "126"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or head.next is None:\n            return head\n        \n        swap1 = swap2 = None",
                "url": "https://leetcode.com/problems/swap-nodes-in-pairs/solutions/1774318/python3-i-hate-linked-lists-not-explained/",
                "vote_count": "126"
            }
        ]
    },
    "24": {
        "question_id": 25,
        "title": "Reverse Nodes in k-Group",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/reverse-nodes-in-k-group",
        "description": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.You may not alter the values in the list's nodes, only nodes themselves may be changed. ",
        "examples": [
            {
                "input": "head = [1,2,3,4,5], k = 2",
                "output": "[2,1,4,3,5]",
                "explanation": null
            },
            {
                "input": "head = [1,2,3,4,5], k = 3",
                "output": "[3,2,1,4,5]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is n.",
            "1 <= k <= n <= 5000",
            "0 <= Node.val <= 1000"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "public ListNode reverseKGroup(ListNode head, int k) {\n    ListNode curr = head;\n    int count = 0;\n    while (curr != null && count != k) { // find the k+1 node\n        curr = curr.next;\n        count++;\n    }\n    if (count == k) { // if k+1 node is found\n        curr = reverseKGroup(curr, k); // reverse list with k+1 node as head\n        // head - head-pointer to direct part, \n        // curr - head-pointer to reversed part;\n        while (count-- > 0) { // reverse current k-group: \n            ListNode tmp = head.next; // tmp - next head in direct part\n            head.next = curr; // preappending \"direct\" head to the reversed list \n            curr = head; // move head of reversed part to a new node\n            head = tmp; // move \"direct\" head to the next node in direct part\n        }\n        head = curr;\n    }\n    return head;\n}",
                "url": "https://leetcode.com/problems/reverse-nodes-in-k-group/solutions/11423/short-but-recursive-java-code-with-comments/",
                "vote_count": "608"
            },
            {
                "language": "java",
                "code": "public ListNode reverseKGroup(ListNode head, int k) {\n        int n = 0;\n        for (ListNode i = head; i != null; n++, i = i.next);\n        \n        ListNode dmy = new ListNode(0);\n        dmy.next = head;\n        for(ListNode prev = dmy, tail = head; n >= k; n -= k) {\n            for (int i = 1; i < k; i++) {",
                "url": "https://leetcode.com/problems/reverse-nodes-in-k-group/solutions/11423/short-but-recursive-java-code-with-comments/",
                "vote_count": "608"
            },
            {
                "language": "java",
                "code": " public ListNode reverseKGroup(ListNode head, int k) {\n    //1. test weather we have more then k node left, if less then k node left we just return head \n    ListNode node = head;\n    int count = 0;\n    while (count < k) { \n        if(node == null)return head;\n        node = node.next;",
                "url": "https://leetcode.com/problems/reverse-nodes-in-k-group/solutions/11423/short-but-recursive-java-code-with-comments/",
                "vote_count": "608"
            },
            {
                "language": "python",
                "code": "public ListNode reverseKGroup(ListNode head, int k) {\n        if(head == null) return null;\n        \n        int len = 0;\n        ListNode l = head; //len is the length of this list\n        while(l != null)\n        {\n            len++;",
                "url": "https://leetcode.com/problems/reverse-nodes-in-k-group/solutions/11423/short-but-recursive-java-code-with-comments/",
                "vote_count": "608"
            },
            {
                "language": "python",
                "code": "public ListNode reverseKGroup(ListNode head, int k) {\n        if(head == null || k == 1) return head;\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode cur = dummy , nex = dummy, pre = dummy;\n        int count = 0;\n        while(cur.next != null){\n            cur = cur.next;",
                "url": "https://leetcode.com/problems/reverse-nodes-in-k-group/solutions/11423/short-but-recursive-java-code-with-comments/",
                "vote_count": "608"
            }
        ]
    },
    "25": {
        "question_id": 26,
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array",
        "description": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.Consider the number of unique elements of nums be k, to get accepted, you need to do the following things:Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.Return k.Custom Judge:The judge will test your solution with the following code:int[] nums = [...]; // Input arrayint[] expectedNums = [...]; // The expected answer with correct lengthint k = removeDuplicates(nums); // Calls your implementationassert k == expectedNums.length;for (int i = 0; i < k; i++) {    assert nums[i] == expectedNums[i];}If all assertions pass, then your solution will be accepted. ",
        "examples": [
            {
                "input": "nums = [1,1,2]",
                "output": "2, nums = [1,2,_]",
                "explanation": "Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            },
            {
                "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
                "output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
                "explanation": "Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            }
        ],
        "constraints": [
            "1 <= nums.length <= 3 * 10^4",
            "-100 <= nums[i] <= 100",
            "nums is sorted in non-decreasing order."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": " def removeDuplicates(self, nums: List[int]) -> int:\n  nums[:] = sorted(set(nums))\n  return len(nums)",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2107606/py-all-4-methods-intuitions-walk-through-wrong-answer-explanations-for-beginners-python/",
                "vote_count": "289"
            },
            {
                "language": "python",
                "code": " nums = sorted(set(nums))\n return len(nums)",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2107606/py-all-4-methods-intuitions-walk-through-wrong-answer-explanations-for-beginners-python/",
                "vote_count": "289"
            },
            {
                "language": "java",
                "code": " def removeDuplicates(self, nums: List[int]) -> int:\n  slow, fast = 0, 1\n  while fast in range(len(nums)):\n   if nums[slow] == nums[fast]:\n    fast += 1\n   else:\n    nums[slow+1] = nums[fast]\n    fast += 1\n    slow += 1\n\n  return slow + 1",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2107606/py-all-4-methods-intuitions-walk-through-wrong-answer-explanations-for-beginners-python/",
                "vote_count": "289"
            },
            {
                "language": "java",
                "code": " def removeDuplicates(self, nums: List[int]) -> int:\n  j = 0\n  for i in range(1, len(nums)):\n   if nums[j] != nums[i]:\n    j += 1\n    nums[j] = nums[i]\n  return j + 1",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2107606/py-all-4-methods-intuitions-walk-through-wrong-answer-explanations-for-beginners-python/",
                "vote_count": "289"
            },
            {
                "language": "php",
                "code": " def removeDuplicates(self, nums: List[int]) -> int:\n  i = 1\n  while i < len(nums):\n   if nums[i] == nums[i - 1]:\n    nums.pop(i)\n   else:\n    i += 1\n  return len(nums)",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2107606/py-all-4-methods-intuitions-walk-through-wrong-answer-explanations-for-beginners-python/",
                "vote_count": "289"
            },
            {
                "language": "python",
                "code": "from collections import OrderedDict\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        nums[:] =  OrderedDict.fromkeys(nums)\n        return len(nums)",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2107606/py-all-4-methods-intuitions-walk-through-wrong-answer-explanations-for-beginners-python/",
                "vote_count": "289"
            },
            {
                "language": "python",
                "code": "    numsset = set(numsset)\n    numsset = list(numsset)\n    numsset.sort()\n    # print(numsset)\n    # print(nums)\n    nums[:len(numsset)+1] = numsset[:]",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2107606/py-all-4-methods-intuitions-walk-through-wrong-answer-explanations-for-beginners-python/",
                "vote_count": "289"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n    set<int> s; \n        for(int i =0; i<nums.size(); i++)\n        {\n            s.insert(nums[i]);\n        }\n        \n        int ans = s.size();\n        nums.clear();\n        for(auto i:s)\n        {\n           //int k = *i;\n           nums.push_back(i);\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3105108/c-easy-solution-using-set/",
                "vote_count": "112"
            },
            {
                "language": "",
                "code": "IF MY EFFORTS HELP YOU PLEASE LIKE IT\ud83d\ude0a\ud83d\ude0a",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3105108/c-easy-solution-using-set/",
                "vote_count": "112"
            },
            {
                "language": "python",
                "code": " int k=1;\n for(int i=1; i<nums.size(); i++)        \n  if(nums[i]!=nums[i-1]) nums[k++] = nums[i];     \n return k;",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2693084/c-easy-three-line-solution/",
                "vote_count": "111"
            },
            {
                "language": "python",
                "code": "        for(int i = 1; i < nums.size(); i++){\n            if(nums[i] != nums[i - 1]){\n                nums[k] = nums[i];\n                k++;\n            }\n        }\n        return k;",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2693084/c-easy-three-line-solution/",
                "vote_count": "111"
            },
            {
                "language": "lisp",
                "code": "return distance(nums.begin(), unique(nums.begin(), nums.end()));",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2693084/c-easy-three-line-solution/",
                "vote_count": "111"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        if(nums.length == 0)\n            return 0;\n        \n        int addIndex = 1; //index that unique characters will be inserted at\n\n        for(int i = 0; i < nums.length - 1; i++) {\n            \n            if(nums[i] < nums[i + 1]){ //if true, num[i + 1] is a new unique number\n              nums[addIndex] = nums[i + 1];\n              addIndex++;\n            }\n        }\n        return addIndex;\n    }\n}",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/2983019/java-solution-explanation-runtime-1ms-beats-100/",
                "vote_count": "95"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        i,j=0,1\n        while i<=j and j<len(nums):\n            if nums[i]==nums[j]:\n                j+=1\n            else:\n                nums[i+1]=nums[j]\n                i+=1\n        return i+1\n\n\n        ",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3310164/8-lines-two-pointer-in-python/",
                "vote_count": "33"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        mp=defaultdict(int)\n        ans=[]\n        x=0\n        for i in nums:\n            mp[i]+=1\n            if mp[i]==1:\n                nums[x]=i\n                x+=1\n        return len(mp)",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3343351/python3-dictionary-map/",
                "vote_count": "18"
            },
            {
                "language": "csharp",
                "code": "public int removeDuplicates(int[] nums) {\n        \n        int newIndex = 1; // Start with index 1 because the first element is already in place\n\n        for (int i = 0; i < nums.length - 1; i++) {\n\n            if (nums[i] < nums[i+1]) { // If the current element is less than the next element\n            \n                nums[newIndex] = nums[i+1]; // Move the next element to the new index\n                newIndex++; // Increment the new index\n            }\n        }\n    return newIndex; // Return the length of the new subarray\n\n\n\n---\nSecond Approach (here we are using extra space for this space complexity will be O(N))\n\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n\n        //Insert all array element in the Set. \n        //Set does not allow duplicates and sets like LinkedHashSet maintains the order of insertion so it will remove duplicates and elements will be printed in the same order in which it is inserted\n\n        LinkedHashSet<Integer> set = new LinkedHashSet<>();\n\n        for(int i = 0; i < nums.length; i++){\n            set.add(nums[i]);\n        }\n        //copy unique element back to array\n        int i = 0;\n\n        for(int ele:set){\n            nums[i++] = ele;\n        }\n        return set.size();\n    }\n}",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3342081/100-faster-java-2-approaches-step-by-step-explained/",
                "vote_count": "11"
            }
        ]
    },
    "26": {
        "question_id": 27,
        "title": "Remove Element",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/remove-element",
        "description": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:Change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.Return k.Custom Judge:The judge will test your solution with the following code:int[] nums = [...]; // Input arrayint val = ...; // Value to removeint[] expectedNums = [...]; // The expected answer with correct length.                            // It is sorted with no values equaling val.int k = removeElement(nums, val); // Calls your implementationassert k == expectedNums.length;sort(nums, 0, k); // Sort the first k elements of numsfor (int i = 0; i < actualLength; i++) {    assert nums[i] == expectedNums[i];}If all assertions pass, then your solution will be accepted. ",
        "examples": [
            {
                "input": "nums = [3,2,2,3], val = 3",
                "output": "2, nums = [2,2,_,_]",
                "explanation": "Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            },
            {
                "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
                "output": "5, nums = [0,1,4,0,3,_,_,_]",
                "explanation": "Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            }
        ],
        "constraints": [
            "0 <= nums.length <= 100",
            "0 <= nums[i] <= 50",
            "0 <= val <= 100"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        int i = 0;\n        for (int j = 0; j < nums.length; j++) {\n            if (nums[j] != val) {\n                int temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n                i++;\n            }\n        }\n        return i;\n    }\n}",
                "url": "https://leetcode.com/problems/remove-element/solutions/3102906/java-best-solution-o-n-time-complexity/",
                "vote_count": "141"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int j=0;\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]!=val){\n                nums[j++]=nums[i];\n            }\n        }\n        return j;        \n    }\n};",
                "url": "https://leetcode.com/problems/remove-element/solutions/2785400/c-faster-than-100-two-pointer-simple-code/",
                "vote_count": "75"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        while val in nums:\n            nums.remove(val)\n#please upvote me it would encourage me alot",
                "url": "https://leetcode.com/problems/remove-element/solutions/3263550/2-lines-of-code-python3/",
                "vote_count": "41"
            },
            {
                "language": "cpp",
                "code": "int removeElement(int *nums, int numsSize, int val) {\n    int count = 0;\n\n    for (int i = 0; i < numsSize; i++)\n        if (nums[i] == val) \n            count++;\n        else \n            nums[i - count] = nums[i];\n    return (numsSize - count);\n}",
                "url": "https://leetcode.com/problems/remove-element/solutions/3300181/clear-c-solution-let-s-find-best-solution-together/",
                "vote_count": "11"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) \n    {\n        int count = 0, res = 0;\n        int n = nums.size();\n        for(int i = 0; i<n; i++)\n        {\n            if(nums[i]!=val)\n            {\n                swap(nums[i],nums[res]);\n                res++;\n            }\n            else if(nums[i]==val)\n            count++;\n        }\n        return n-count;\n\n        \n    }\n};",
                "url": "https://leetcode.com/problems/remove-element/solutions/3226460/beginner-friendly-0ms-solution-c-solution/",
                "vote_count": "10"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        int count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != val) {\n                nums[count++] = nums[i];\n            }\n        }\n        return count;\n    }\n}",
                "url": "https://leetcode.com/problems/remove-element/solutions/2750567/simple-java-solution/",
                "vote_count": "10"
            }
        ]
    },
    "27": {
        "question_id": 28,
        "title": "Find the Index of the First Occurrence in a String",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string",
        "description": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. ",
        "examples": [
            {
                "input": "haystack = \"sadbutsad\", needle = \"sad\"",
                "output": "0",
                "explanation": "\"sad\" occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0."
            },
            {
                "input": "haystack = \"leetcode\", needle = \"leeto\"",
                "output": "-1",
                "explanation": "\"leeto\" did not occur in \"leetcode\", so we return -1."
            }
        ],
        "constraints": [
            "1 <= haystack.length, needle.length <= 10^4",
            "haystack and needle consist of only lowercase English characters."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        int haylength=haystack.length();\n        int needlelength=needle.length();\n        if(haylength<needlelength)\n            return -1;\n        for(int i=0;i<=haystack.length()-needle.length();i++){\n            int j=0;\n            while(j<needle.length() && haystack.charAt(i+j)==needle.charAt(j))\n                j++;\n            if(j==needle.length()){\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
                "url": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3249783/java-easy-with-explanation/",
                "vote_count": "158"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            return haystack.indexOf(needle);\n        }\n    return -1;\n    }\n}",
                "url": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3249783/java-easy-with-explanation/",
                "vote_count": "158"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    int strStr(string h, string s) {\n        int m=h.size(), n=s.size(), i=0, j=0, k=0;\n        if(m<n) return -1;\n        while(i<m && j<n) {\n            if(h[i]==s[j]) {i++; j++;}\n            else {i=k+1; j=0; k=i;}",
                "url": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3249783/java-easy-with-explanation/",
                "vote_count": "158"
            },
            {
                "language": "rust",
                "code": "-> m\n-> i\nnot match, reinitialize window start to next index of m. \nThat is \"i\" from the word \"mississipi\"\n\n-> i s s i s\n-> i s s i p\ns and p mismatch\n\nso, reinitialize the window's start\n-> s\n-> i\nnot match\n\nreinitialize\n-> s\n-> i\nnot match\n\nreinitialize\n-> i s s i p\n-> i s s i p\nthis time it was a match!",
                "url": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3250360/think-as-a-sliding-window-code-like-a-pro-beats-100/",
                "vote_count": "97"
            }
        ]
    },
    "28": {
        "question_id": 29,
        "title": "Divide Two Integers",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/divide-two-integers",
        "description": "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.Return the quotient after dividing dividend by divisor.Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231. ",
        "examples": [
            {
                "input": "dividend = 10, divisor = 3",
                "output": "3",
                "explanation": "10/3 = 3.33333.. which is truncated to 3."
            },
            {
                "input": "dividend = 7, divisor = -3",
                "output": "-2",
                "explanation": "7/-3 = -2.33333.. which is truncated to -2."
            }
        ],
        "constraints": [
            "-2^31 <= dividend, divisor <= 2^31 - 1",
            "divisor != 0"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        if (dividend == INT_MIN && divisor == -1) {\n            return INT_MAX;\n        }\n        long dvd = labs(dividend), dvs = labs(divisor), ans = 0;\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\n        while (dvd >= dvs) {\n            long temp = dvs, m = 1;\n            while (temp << 1 <= dvd) {\n                temp <<= 1;\n                m <<= 1;\n            }\n            dvd -= temp;\n            ans += m;\n        }\n        return sign * ans;\n    }\n};",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/13407/c-bit-manipulations/",
                "vote_count": "1230"
            },
            {
                "language": "java",
                "code": "public int divide(int dividend, int divisor) {\n    //other code...\n    if(dividend==Integer.MIN_VALUE){\n        if(divisor==-1) return Integer.MAX_VALUE;\n        else if(divisor==1)  return dividend;",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/13407/c-bit-manipulations/",
                "vote_count": "1230"
            },
            {
                "language": "cpp",
                "code": "public int divide(int dividend, int divisor) {\n    if(divisor==0||dividend==Integer.MIN_VALUE&&divisor==-1) return Integer.MAX_VALUE;\n    int res=0;\n    int sign=(dividend<0)^(divisor<0)?-1:1;\n    long dvd=Math.abs((long)dividend);\n    long dvs=Math.abs((long)divisor);\n    while(dvs<=dvd){\n        long temp=dvs,mul=1;",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/13407/c-bit-manipulations/",
                "vote_count": "1230"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int divide(int dividend, int divisor) {\n        int sign = (dividend<0)^(divisor<0) ? -1 : 1, quotient = 0;\n        if(dividend == Integer.MIN_VALUE){\n            if(divisor == -1) return Integer.MAX_VALUE;\n            if(divisor == Integer.MIN_VALUE) return 1;\n            dividend += Math.abs(divisor);",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/13407/c-bit-manipulations/",
                "vote_count": "1230"
            },
            {
                "language": "java",
                "code": "class Solution {\npublic:\n    int divide(int dividend, int divisor);\n};\n\n// a / b\nint Solution::divide(int a, int b) {\n    // First, deal with bunch of special conditions",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/13407/c-bit-manipulations/",
                "vote_count": "1230"
            },
            {
                "language": "cpp",
                "code": "    public static int divide(int dividend, int divisor) {\n        if (divisor == 0 || //divide by zero\n                dividend == Integer.MIN_VALUE && divisor == -1 //overflow check\n                ) {\n            return Integer.MAX_VALUE;\n        }\n\n        int sign = 1;",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/13407/c-bit-manipulations/",
                "vote_count": "1230"
            },
            {
                "language": "lisp",
                "code": " dividend = (quotient) * divisor + remainder",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/1516367/complete-thinking-process-intuitive-explanation-all-rules-followed-c-code/",
                "vote_count": "751"
            },
            {
                "language": "javascript",
                "code": " 58 = (2^3 + 2^1 + 2^0) * 5 + 3                // --- (I)\n 58 = [(2^3 * 5) + (2^1 * 5) + (2^0 * 5)] + 3  // --- (II)",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/1516367/complete-thinking-process-intuitive-explanation-all-rules-followed-c-code/",
                "vote_count": "751"
            },
            {
                "language": "javascript",
                "code": " 5 << 0 = 5               // less than dividend\n 5 << 1 = 5*2 = 10        // less than dividend\n 5 << 2 = 5*2*2 = 20      // less than dividend\n 5 << 3 = 5*2*2*2 = 40    // less than dividend\n 5 << 4 = 5*2*2*2*2 = 80  // (stop and consider the previous value as the result is greater than dividend",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/1516367/complete-thinking-process-intuitive-explanation-all-rules-followed-c-code/",
                "vote_count": "751"
            },
            {
                "language": "lisp",
                "code": " 58 - (2^3 * 5)  =  (something * 5) + rem\n 58 - (8 * 5) = something * 5 + rem\n 58 - 40 = something * 5 + rem\n 18 = something * 5 + rem",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/1516367/complete-thinking-process-intuitive-explanation-all-rules-followed-c-code/",
                "vote_count": "751"
            },
            {
                "language": "javascript",
                "code": " 5 << 0 = 5           // less than dividend\n 5 << 1 = 5*2 = 10    // less than dividend\n 5 << 2 = 5*2*2 = 20  // (stop and consider the previous value as the result is greater than dividend",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/1516367/complete-thinking-process-intuitive-explanation-all-rules-followed-c-code/",
                "vote_count": "751"
            },
            {
                "language": "lisp",
                "code": " 18  =  (2^1 * 5) + (something * 5) + rem\n 58 - (2^3 * 5) = (2^1 * 5) + (something * 5) + rem\n 58 =  (2^3 * 5) + (2^1 * 5) + (something * 5) + rem",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/1516367/complete-thinking-process-intuitive-explanation-all-rules-followed-c-code/",
                "vote_count": "751"
            },
            {
                "language": "lisp",
                "code": " 18 - (2^1 * 5)  =  (something * 5) + rem\n 18 - (2 * 5) = something * 5 + rem\n 18 - 10 = something * 5 + rem\n 8 = something * 5 + rem",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/1516367/complete-thinking-process-intuitive-explanation-all-rules-followed-c-code/",
                "vote_count": "751"
            },
            {
                "language": "javascript",
                "code": " 5 << 0 = 5           // less than dividend\n 5 << 1 = 5*2 = 10    // (stop and consider the previous value as the result is greater than dividend",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/1516367/complete-thinking-process-intuitive-explanation-all-rules-followed-c-code/",
                "vote_count": "751"
            },
            {
                "language": "erlang",
                "code": " 8 = (2^0 * 5) + (something * 5) + rem\n 8 - 5 = something * 5 + rem\n 3 = something * 5 + rem",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/1516367/complete-thinking-process-intuitive-explanation-all-rules-followed-c-code/",
                "vote_count": "751"
            },
            {
                "language": "lisp",
                "code": " 3 = 0*5 + rem\n 8 = (2^0 * 5) + 3\n 18  =  (2^0 * 5) + (2^1 * 5) + 3\n 58 = (2^3 * 5) + (2^1 * 5) + (2^0 * 5) + 3",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/1516367/complete-thinking-process-intuitive-explanation-all-rules-followed-c-code/",
                "vote_count": "751"
            },
            {
                "language": "cpp",
                "code": " int divide(int dividend, int divisor) {\n        if(dividend == divisor)\n            return 1;\n        bool isPositive = (dividend<0 == divisor<0);    // if both are of same sign, answer is positive\n        unsigned int a = abs(dividend);\n        unsigned int b = abs(divisor);\n        unsigned int ans = 0;\n        while(a >= b){  // while dividend is greater than or equal to divisor\n            short q = 0;\n            while(a > (b<<(q+1)))\n                q++;\n            ans += (1<<q);  // add the power of 2 found to the answer\n            a = a - (b<<q);  // reduce the dividend by divisor * power of 2 found\n        }\n        if(ans == (1<<31) and isPositive)   // if ans cannot be stored in signed int\n            return INT_MAX;\n        return isPositive ? ans : -ans;\n    }",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/1516367/complete-thinking-process-intuitive-explanation-all-rules-followed-c-code/",
                "vote_count": "751"
            },
            {
                "language": "lisp",
                "code": "58 = (2^3 + 2^1 + 2^0) * 5 + 3 ",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/1516367/complete-thinking-process-intuitive-explanation-all-rules-followed-c-code/",
                "vote_count": "751"
            },
            {
                "language": "cpp",
                "code": "    int divide(int A, int B) {\n        if (A == INT_MIN && B == -1) return INT_MAX;\n        int a = abs(A), b = abs(B), res = 0, x = 0;\n        while (a - b >= 0) {\n            for (x = 0; a - (b << x << 1) >= 0; x++);\n            res += 1 << x;\n            a -= b << x;\n        }\n        return (A > 0) == (B > 0) ? res : -res;\n    }",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/142849/c-java-python-should-not-use-long-int/",
                "vote_count": "537"
            },
            {
                "language": "cpp",
                "code": "    public int divide(int A, int B) {\n        if (A == 1 << 31 && B == -1) return (1 << 31) - 1;\n        int a = Math.abs(A), b = Math.abs(B), res = 0, x = 0;\n        while (a - b >= 0) {\n            for (x = 0; a - (b << x << 1) >= 0; x++);\n            res += 1 << x;\n            a -= b << x;\n        }\n        return (A > 0) == (B > 0) ? res : -res;\n    }",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/142849/c-java-python-should-not-use-long-int/",
                "vote_count": "537"
            },
            {
                "language": "cpp",
                "code": "    int divide(int A, int B) {\n        if (A == INT_MIN && B == -1) return INT_MAX;\n        int a = abs(A), b = abs(B), res = 0;\n        for (int x = 31; x >= 0; x--)\n            if ((signed)((unsigned)a >> x) - b >= 0)\n                res += 1 << x, a -= b << x;\n        return (A > 0) == (B > 0) ? res : -res;\n    }",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/142849/c-java-python-should-not-use-long-int/",
                "vote_count": "537"
            },
            {
                "language": "cpp",
                "code": "    public int divide(int A, int B) {\n        if (A == 1 << 31 && B == -1) return (1 << 31) - 1;\n        int a = Math.abs(A), b = Math.abs(B), res = 0;\n        for (int x = 31; x >= 0; x--)\n            if ((a >>> x) - b >= 0) {\n                res += 1 << x;\n                a -= b << x;\n            }\n        return (A > 0) == (B > 0) ? res : -res;\n    }",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/142849/c-java-python-should-not-use-long-int/",
                "vote_count": "537"
            },
            {
                "language": "python",
                "code": "    def divide(self, A, B):\n        if (A == -2147483648 and B == -1): return 2147483647\n        a, b, res = abs(A), abs(B), 0\n        for x in range(32)[::-1]:\n            if (a >> x) - b >= 0:\n                res += 1 << x\n                a -= b << x\n        return res if (A > 0) == (B > 0) else -res",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/142849/c-java-python-should-not-use-long-int/",
                "vote_count": "537"
            },
            {
                "language": "cpp",
                "code": "    public static int divide(int dividend, int divisor) {\n        if (Integer.MIN_VALUE == dividend && divisor == -1) {\n            return Integer.MAX_VALUE;\n        }\n        int res = 0;\n        int a = Math.abs(dividend);\n        int b = Math.abs(divisor);\n        while (a - b >= 0) {\n            int tmp = b;",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/142849/c-java-python-should-not-use-long-int/",
                "vote_count": "537"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        if (divisor == INT_MIN) {",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/142849/c-java-python-should-not-use-long-int/",
                "vote_count": "537"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int divide(int A, int B) {\n        // for the corner case, If A is INT_MIN, and B is -1, \n        // the result will be 1 + INT_MAX, hence overflowing \n        // 32 bits, handle it first\n        if (A == INT_MIN && B == -1) ",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/142849/c-java-python-should-not-use-long-int/",
                "vote_count": "537"
            },
            {
                "language": "cpp",
                "code": "int divide(int A, int B) {\n    if (A == INT_MIN && B == -1) return INT_MAX;\n    if (A == INT_MIN && B == 1) return INT_MIN;\n    if (B == INT_MIN) return A == INT_MIN;\n    int a = abs(A), b = abs(B), res = 0, n = 0;\n    if (A == INT_MIN){\n        res = 1;\n        a = abs(A + b);",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/142849/c-java-python-should-not-use-long-int/",
                "vote_count": "537"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        \n        //Handling corner cases\n        if(dividend==INT_MIN && divisor==-1) return INT_MAX;\n        if(dividend==INT_MIN && divisor==1) return INT_MIN;\n\n        \n        //Converting divisors and dividend to their positive values\n        long int dd = abs(dividend), dv = abs(divisor);\n        \n        //Result Variables\n        int res=0;\n        while(dv<=dd) {\n            long int mul=dv, tmp=1;\n            while(mul<=dd-mul) {\n                mul+=mul;\n                tmp+=tmp;\n            }\n            res+=tmp;\n            dd-=mul;\n        }\n        \n        //If either of dividend or divisor is negative our result will be negative\n        if((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\n        \n        return res;\n        \n    }\n};",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/2089533/easy-solution-in-c/",
                "vote_count": "105"
            },
            {
                "language": "kotlin",
                "code": "if (dividend < 0 ^ divisor < 0)\n    return -res;\nelse\n    return res;",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/2089533/easy-solution-in-c/",
                "vote_count": "105"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int divide(int dividend, int divisor)\n    {\n        if (dividend == INT_MIN && divisor == -1)\n            return INT_MAX;\n        if (dividend == INT_MIN && divisor == 1)\n            return INT_MIN;",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/2089533/easy-solution-in-c/",
                "vote_count": "105"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(log(N)*log(N)), The time complexity of the code is O(log(N)*log(N)) since the outer loop\n    and the inner loop both runs log(N) times, where N is the dividend.\n\n    Space Complexity : O(1), The space complexity of the above code is O(1) since we\u2019re using constant extra\n    space.\n\n    Solved using Math + Bit Manipulation.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        if(dividend == INT_MIN && divisor == -1){\n            return INT_MAX;\n        }\n        long long dvd = labs(dividend), dvs = labs(divisor), result = 0;\n        int sign = (dividend > 0) ^ (divisor > 0) == 0 ? 1 : -1;\n        while(dvd >= dvs){\n            long long temp = dvs, mul = 1;\n            while(temp << 1 <= dvd){\n                temp <<= 1;\n                mul <<= 1;\n            }\n            dvd -= temp;\n            result += mul;\n        } \n        return sign*result;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(1), Constant Operation.\n\n    Space Complexity : O(1), Constant space.\n\n    Solved using Math.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        if(dividend == INT_MIN && divisor == -1){\n            return INT_MAX;\n        }\n        return dividend/divisor;\n    }\n};",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/3233898/best-c-2-solution-easy-solution-math-bit-manipulation-one-stop-solution/",
                "vote_count": "27"
            },
            {
                "language": "kotlin",
                "code": "if(sign == -1) result = 0 - result;\nreturn result;",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/3233898/best-c-2-solution-easy-solution-math-bit-manipulation-one-stop-solution/",
                "vote_count": "27"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        sign = -1 if (dividend >= 0 and divisor < 0) or (dividend < 0 and divisor >= 0) else 1\n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        result = len(range(0, dividend-divisor+1, divisor))\n        if sign == -1:\n            result = -result\n        minus_limit = -(2**31)\n        plus_limit = (2**31 - 1)\n        result = min(max(result, minus_limit), plus_limit)\n        return result",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/2871168/python3-easiest-solution/",
                "vote_count": "20"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        # Handle division by zero\n        if divisor == 0:\n            return 2**31 - 1\n        \n        # Handle overflow case\n        if dividend == -2**31 and divisor == -1:\n            return 2**31 - 1\n        \n        # Get the sign of the result\n        sign = 1\n        if dividend < 0:\n            dividend = -dividend\n            sign = -sign\n        if divisor < 0:\n            divisor = -divisor\n            sign = -sign\n        \n        # Find the largest multiple of the divisor that is less than or equal to the dividend\n        multiple = 1\n        while dividend >= (divisor << 1):\n            divisor <<= 1\n            multiple <<= 1\n        \n        # Perform division using binary search\n        quotient = 0\n        while multiple > 0:\n            if dividend >= divisor:\n                dividend -= divisor\n                quotient += multiple\n            divisor >>= 1\n            multiple >>= 1\n        \n        # Apply the sign to the result\n        return sign * quotient",
                "url": "https://leetcode.com/problems/divide-two-integers/solutions/3222214/efficient-bit-manipulation-algorithm-for-integer-division-without-multiplication-or-mod-operator/",
                "vote_count": "11"
            }
        ]
    },
    "29": {
        "question_id": 30,
        "title": "Substring with Concatenation of All Words",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words",
        "description": "You are given a string s and an array of strings words. All the strings of words are of the same length.A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.For example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.Return the starting indices of all the concatenated substrings in s. You can return the answer in any order. ",
        "examples": [
            {
                "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
                "output": "[0,9]",
                "explanation": "Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\nThe output order does not matter. Returning [9,0] is fine too."
            },
            {
                "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
                "output": "[]",
                "explanation": "Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\nWe return an empty array."
            },
            {
                "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
                "output": "[6,9,12]",
                "explanation": "Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words."
            }
        ],
        "constraints": [
            "1 <= s.length <= 10^4",
            "1 <= words.length <= 5000",
            "1 <= words[i].length <= 30",
            "s and words[i] consist of lowercase English letters."
        ],
        "solutions": [
            {
                "language": "dart",
                "code": "class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        final Map<String, Integer> counts = new HashMap<>();\n        for (final String word : words) {\n            counts.put(word, counts.getOrDefault(word, 0) + 1);\n        }\n        final List<Integer> indexes = new ArrayList<>();\n        final int n = s.length(), num = words.length, len = words[0].length();\n        for (int i = 0; i < n - num * len + 1; i++) {\n            final Map<String, Integer> seen = new HashMap<>();\n            int j = 0;\n            while (j < num) {\n                final String word = s.substring(i + j * len, i + (j + 1) * len);\n                if (counts.containsKey(word)) {\n                    seen.put(word, seen.getOrDefault(word, 0) + 1);\n                    if (seen.get(word) > counts.getOrDefault(word, 0)) {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n                j++;\n            }\n            if (j == num) {\n                indexes.add(i);\n            }\n        }\n        return indexes;\n    }\n}",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/13658/easy-two-map-solution-c-java/",
                "vote_count": "398"
            },
            {
                "language": "dart",
                "code": "    public List<Integer> findSubstring(String s, String[] words) {\n        if (s == null || words == null || s.length() == 0 || words.length == 0) {\n            return new ArrayList<>();\n        }\n        Map<String, Integer> counts = new HashMap<>();\n        for (String word : words) {\n            counts.put(word, counts.getOrDefault(word, 0) + 1);\n        }",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/13658/easy-two-map-solution-c-java/",
                "vote_count": "398"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        unordered_map<string, int> counts;\n        vector<int> indexes;\n        or (string word : words)\n        counts[word]++;",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/13658/easy-two-map-solution-c-java/",
                "vote_count": "398"
            },
            {
                "language": "python",
                "code": "from collections import Counter, defaultdict\n\nclass Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/13658/easy-two-map-solution-c-java/",
                "vote_count": "398"
            },
            {
                "language": "go",
                "code": "public List<Integer> findSubstring(String s, String[] words) {\n        if(s == null || s.length() == 0 || words == null || words.length == 0) return Collections.emptyList();\n        HashMap<String,Integer> map = new HashMap<>();            // map to record frequency of word \n        int len = words[0].length()*words.length;\n        for(String str: words){\n            int count = map.getOrDefault(str,0);\n            map.put(str,count+1);\n        }",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/13658/easy-two-map-solution-c-java/",
                "vote_count": "398"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        int n = s.size(), total = words.size(), len = words[0].size(); ",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/13658/easy-two-map-solution-c-java/",
                "vote_count": "398"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if words == []:\n            return []\n        counts = dict(collections.Counter(words))\n        res = set([])\n        \n        n, num, word_len = len(s), len(words), len(words[0])",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/13658/easy-two-map-solution-c-java/",
                "vote_count": "398"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    bool checkSubstring(unordered_map<string, int> wordCount, string s, int wordLen) {\n        for(int j=0; j<s.size(); j+=wordLen) {\n            string w = s.substr(j, wordLen);\n            if(wordCount.find(w) != wordCount.end()) {\n                if(--wordCount[w] == -1) {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> res;\n        int wordLen = words[0].size();\n        int sLen = s.size();\n        int wordsWindow = words.size() * wordLen;\n        \n        unordered_map<string, int> wordCount;\n        for(int i=0; i<words.size(); i++) {\n            wordCount[words[i]]++;\n        }\n        \n        int i = 0;\n        while(i + wordsWindow <= sLen) {\n            if(checkSubstring(wordCount, s.substr(i, wordsWindow), wordLen)) {\n                res.push_back(i);\n            }\n            i++;\n        }\n        return res;\n    }\n};",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/2418173/c-unordered-map-sliding-window-simple-easy-to-understand/",
                "vote_count": "91"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words){\n        int n = s.length(), k = words.size(), wordLength = words[0].length(), totalLength = wordLength * k;\n        \n        unordered_map<string, int> wordCount;\n        for(string word: words)\n            ++wordCount[word];\n wordLength, int totalLength, vector<int> &res) {",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/2418173/c-unordered-map-sliding-window-simple-easy-to-understand/",
                "vote_count": "91"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> ans;\n        \n        int wordLen = words[0].size(), total = words.size(), len = s.size();\n        \n        unordered_map<string, int> mx;\n        for (int i = 0; i < total; i++) mx[words[i]]++;",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/2418173/c-unordered-map-sliding-window-simple-easy-to-understand/",
                "vote_count": "91"
            },
            {
                "language": "rust",
                "code": " i  ---> i+w ---> i+2w ----> i+3w ----> i+4w  (These all can re-use their computations)\n ",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/1753357/clear-solution-easy-to-understand-with-diagrams-o-n-x-w-approach/",
                "vote_count": "82"
            },
            {
                "language": "rust",
                "code": "        i  ---> i+w ---> i+2w ----> i+3w ----> i+4w \n  ",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/1753357/clear-solution-easy-to-understand-with-diagrams-o-n-x-w-approach/",
                "vote_count": "82"
            },
            {
                "language": "lisp",
                "code": "        (i+1)  ---> (i+1)+w ---> (i+1)+2w ----> (i+1)+3w ----> (i+1)+4w ",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/1753357/clear-solution-easy-to-understand-with-diagrams-o-n-x-w-approach/",
                "vote_count": "82"
            },
            {
                "language": "lisp",
                "code": "        (i+2)  ---> (i+2)+w ---> (i+2)+2w ----> (i+2)+3w ----> (i+2)+4w \n  ",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/1753357/clear-solution-easy-to-understand-with-diagrams-o-n-x-w-approach/",
                "vote_count": "82"
            },
            {
                "language": "lisp",
                "code": "        (i+3)  ---> (i+3)+w ---> (i+3)+2w ----> (i+3)+3w ----> (i+3)+4w \n  ",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/1753357/clear-solution-easy-to-understand-with-diagrams-o-n-x-w-approach/",
                "vote_count": "82"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        unordered_map<string, int> dict;\n        for(auto &w: words) dict[w]++;\n        vector<int> res;\n        int n = s.length(), m = words[0].length(), w = words.size();",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/1753357/clear-solution-easy-to-understand-with-diagrams-o-n-x-w-approach/",
                "vote_count": "82"
            },
            {
                "language": "rust",
                "code": "bar -> foo -> foo -> bar -> the -> foo -> bar -> man\nignore b -> arf -> oof -> oob -> art -> hef -> oob -> arm -> ignore an\nignore ba -> rfo -> ofo -> oba -> rth -> efo -> oba -> rma -> ignore n",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/2419817/python-easily-understood-faster-than-96-less-than-78-o-nm/",
                "vote_count": "43"
            },
            {
                "language": "rust",
                "code": "1) word_count.get(word, 0) >= 0 \n    -> word_count[word] -= 1 as it uses one of the string in words\n -> queue.append(word)\n \n2) word_count.get(word, 0) == 0 \n    -> while queue.pop()\n  -> queue.pop() == word\n   -> queue.append(queue.pop()) # Only the beginning word is dropped, the remaining words are still in use\n   -> break\n  -> queue.pop() != word\n   # Since the beginning word is dropped, the count of beginning word should be added 1.\n   -> word_dict[last_element] += 1\n    -> word_dict[last_element] exceeds its original value, reset the whole word_dict\n   -> continue",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/2419817/python-easily-understood-faster-than-96-less-than-78-o-nm/",
                "vote_count": "43"
            },
            {
                "language": "go",
                "code": "from collections import deque, defaultdict\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        word_len = len(words[0])\n        ori_word_dict = defaultdict(int)\n  \n        for word in words:\n            ori_word_dict[word] += 1\n        \n        all_word_len = len(words) * word_len\n        result = []\n        for i in range(word_len):\n            queue = deque()\n            word_dict = ori_word_dict.copy()\n            for j in range(i, len(s) - word_len + 1, word_len):\n                word = s[j:j + word_len]\n                if word_dict.get(word, 0) != 0:\n                    word_dict[word] -= 1\n                    queue.append(word)\n                    if sum(word_dict.values()) == 0:\n                        result.append(j - all_word_len + word_len)\n                        last_element = queue.popleft()\n                        word_dict[last_element] = word_dict.get(last_element, 0) + 1\n                else:\n                    while len(queue):\n                        last_element = queue.popleft()\n                        if last_element == word:\n                            queue.append(word)\n                            break\n                        else:\n                            word_dict[last_element] = word_dict.get(last_element, 0) + 1\n                            if word_dict[last_element] > ori_word_dict[last_element]:\n                                word_dict = ori_word_dict.copy()\n\n        return result",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/2419817/python-easily-understood-faster-than-96-less-than-78-o-nm/",
                "vote_count": "43"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        def check_presence(i):\n            WC = collections.Counter(words)\n            words_found = 0\n\n            for j in range(i, i+size, words_len):\n                sub = s[j:j+words_len]",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/2419817/python-easily-understood-faster-than-96-less-than-78-o-nm/",
                "vote_count": "43"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        word_len = len(words[0])\n        all_word_len  = word_len * len(words)\n        target = Counter(words)  \n        res = []\n        ",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/2419817/python-easily-understood-faster-than-96-less-than-78-o-nm/",
                "vote_count": "43"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen = len(words[0])\n        wslen = len(words) * len(words[0])\n        res = []\n        \n        for pos in range(wlen):\n            i = pos\n            d = Counter(words)\n            \n            for j in range(i, len(s) + 1 - wlen, wlen):\n                word = s[j: j + wlen]\n                d[word] -= 1\n                \n                while d[word] < 0:\n                    d[s[i: i + wlen]] += 1\n                    i += wlen\n                if i + wslen == j + wlen:\n                    res. append(i)\n        \n        return res",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/2417727/python-90-with-detailed-explanation-sliding-windows-using-counter/",
                "vote_count": "29"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        n, k, word_length = len(s), len(words), len(words[0])\n        substring_size = k * word_length\n        ret = []\n        \n        for left in range(word_length):\n            counter = Counter(words)",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/2417727/python-90-with-detailed-explanation-sliding-windows-using-counter/",
                "vote_count": "29"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n struct matcher {\n  struct info { int mtindex, count; };\n  unordered_map<string_view, info>dict;\n  int different_word_count;\n\n  vector<int>slot;\n  int maching_slot_count;\n\n  matcher(const vector<string>& words) {\n   int mtind = 0;\n   for (auto& word : words) {\n    auto find = dict.find(word);\n    if (find != dict.end()) {\n     ++find->second.count;\n    }\n    else { dict[word] = { mtind++,1 }; }\n   }\n   different_word_count = mtind;\n   slot = vector<int>(different_word_count, 0);\n   maching_slot_count = 0;\n  }\n\n  void reset() {\n   for (auto& i : slot) { i = 0; }\n   maching_slot_count = 0;\n  }\n  bool match() {\n   return maching_slot_count == different_word_count;\n  }\n  void push(string_view sv) {\n   auto find = dict.find(sv);\n   if (find == dict.end())return;\n   if (++slot[find->second.mtindex] == find->second.count) {\n    ++maching_slot_count;\n   }\n  }\n  void pop(string_view sv) {\n   auto find = dict.find(sv);\n   if (find == dict.end())return;\n   if (--slot[find->second.mtindex] == find->second.count - 1) {\n    --maching_slot_count;\n   }\n  }\n };\n vector<int> findSubstring(string s, const vector<string>& words) {\n  int word_count = words.size();\n  int word_len = words[0].size();\n\n  matcher matcher(words);\n\n  const char* str = s.c_str();\n  int len = s.size();\n  vector<int> ret;\n\n  for (int off = 0; off < word_len; off++) {\n   const char* beg = str + off, * end = str + len;\n   if (beg + word_len * word_count <= end) {\n    matcher.reset();\n    for (int i = 0; i < word_count; i++) {\n     string_view sv(beg + i * word_len, word_len);\n     matcher.push(sv);\n    }\n    if (matcher.match()) {\n     ret.push_back(beg - str);\n    }\n    const char* pos = beg + word_len * word_count;\n    while (pos + word_len <= end) {\n     string_view del(beg, word_len);\n     string_view add(pos, word_len);\n     beg += word_len;\n     pos += word_len;\n     matcher.pop(del);\n     matcher.push(add);\n     if (matcher.match()) {\n      ret.push_back(beg - str);\n     }\n    }\n   }\n  }\n  return ret;\n }\n};",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/2992611/solution/",
                "vote_count": "25"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int>ans;\n        int n=words.size();\n        int m=words[0].size();\n        int total=n*m;\n        if(s.size()<total){\n            return ans;\n        }\n        for(int i=0;i<=s.size()-total;i++){\n            unordered_map<string,int>mp;\n            \n            for(int j=0;j<words.size();j++){\n                mp[words[j]]++;\n            }\n            int k;\n            for(k=0;k<n;k++){\n                \n                string temp=s.substr(i+k*m,m);\n                // cout<<temp<<\" \"<<i<<endl;\n                if(mp.count(temp)==0){\n                    break;\n                }\n                else{\n                    if(mp[temp]!=0){\n                        mp[temp]--;\n                    }\n                    else{\n                        break;\n                    }\n                }\n            }\n            if(k==n){\n                ans.push_back(i);\n            }\n            \n        }\n        return ans ;\n    }\n};",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/2417602/c-easy-solution-using-hashmap/",
                "vote_count": "18"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        int wordsquan= words.size();\n        int wordsleng= words[0].size();\n        int target= wordsquan * wordsleng;\n        unordered_map<string, int> unmap;\n        \n    for(int j=0; j< wordsquan; j++)\n    {\n        unmap[words[j]]++; \n    }\n        vector<int > ans;\n        if(s.size()<target)\n        {\n            return ans;\n        }\n    for(int i=0; i<=s.size()-target; i++)\n    {\n        unordered_map<string, int> unmap2;\n        unmap2= unmap; \n        int k;\n        for( k=0; k< wordsquan; k++)\n        {\n                string s1= s.substr(i+k*wordsleng, wordsleng);\n                if(unmap2.count(s1)==0)\n                break;\n                else if(unmap2[s1]!=0)\n                    unmap2[s1]--;\n                else\n                    break;       \n        }\n            \n                if(k==wordsquan)\n                {\n                ans.push_back(i);\n                }\n            \n            \n    }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/2418640/short-c-java-python-explained-solution-beginner-friendly-by-mr-coder/",
                "vote_count": "15"
            },
            {
                "language": "dart",
                "code": "class Solution \n{\n    public List<Integer> findSubstring(String s, String[] words) \n    {\n        if(words[0].length()*words.length>s.length())\n            return new ArrayList<>();\n        \n        Map<String,Integer> word_frq=new HashMap<>();\n        List<Integer> ans=new ArrayList<>();\n        \n        // Map store the frequency of every word in words[]\n        \n        for(String str:words)\n            word_frq.put(str,word_frq.getOrDefault(str,0)+1);\n        \n        int wordlen=words[0].length();  \n        \n        String[] str=new String[s.length()];\n        \n        for(int i=0;i<wordlen;i++)\n        {\n            Map<String,Integer> frq=new HashMap<>();  // count frequency of words inside the window\n            \n            int begin=i,size=0; // size is the no. of window and begin is the starting index of window\n            \n            // s.length()-wordlen -> based on observation\n            \n            for(int j=i;j<=s.length()-wordlen;j+=wordlen)\n            {\n                str[j]=s.substring(j,j+wordlen);  // window\n                if(word_frq.containsKey(str[j]))\n                {\n                    begin= begin==-1? j:begin; // begin=-1 means new window need to be started\n                    frq.put(str[j],frq.getOrDefault(str[j],0)+1); \n                    size++; \n                    \n                    if(size==words.length)  // substring may be possible\n                    {\n                        if(frq.equals(word_frq))\n                            ans.add(begin);\n                        \n                        // sliding the window \n                        \n                        frq.put(str[begin],frq.get(str[begin])-1); \n                        begin+=wordlen;  // new starting index\n                        size--;\n                    }\n                }\n                else  // reset window\n                {\n                    begin=-1;\n                    size=0;\n                    frq.clear();\n                }\n            }\n        }\n        return ans;\n    }\n}",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/2418640/short-c-java-python-explained-solution-beginner-friendly-by-mr-coder/",
                "vote_count": "15"
            },
            {
                "language": "go",
                "code": "   res = []\n    WordLen = [len(s) for s in words]\n    WordIni = [  s[0] for s in words]\n    TotWordLen =     sum(WordLen)\n    LongestWordLen = max(WordLen)\n    \n    d = {}\n    for i in range(len(words)):\n        if words[i] not in d:\n            d[words[i]] = [i]\n        else:\n            d[words[i]].append(i) \n            \n    \n    def isCCT(string):\n        \n        copy_d = copy.deepcopy(d)\n        temp = ''\n        #print('isCCT:',string,copy_d)\n        \n        for c in string:\n            temp += c\n            if temp in copy_d:\n                \n                if len(copy_d[temp]) > 1:\n                    copy_d[temp].pop()\n                else:\n                    del copy_d[temp]\n                temp = ''\n            elif len(temp) >= LongestWordLen:\n                #print('isCCT:',string, temp, 'zero patience')\n                return False\n        \n        #print('isCCT:',string, temp)    \n        if temp == '' and len(copy_d) == 0:\n            return True\n        else:\n            return False\n    \n    \n    for i in range(len(s)):\n        if s[i] in WordIni:\n            if (i + TotWordLen - 1) <= len(s): \n                testSubStr = s[i:i + TotWordLen]\n                #print(i,testSubStr)\n                if isCCT(testSubStr) == True:\n                    res.append(i)\n                \n    return res\n```**Please Don't forget to UPVOTE if you LIKE!!**",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/2418640/short-c-java-python-explained-solution-beginner-friendly-by-mr-coder/",
                "vote_count": "15"
            },
            {
                "language": "python",
                "code": "    int n = words.size();\n    int len = words[0].size();\n    vector<int> ans;\n    \n    unordered_map<string, int> mp;\n    \n    for(string &str : words) {\n        mp[str]++;\n    }\n    \n    for(int i=0; i<s.size()-(n*len)+1; i++) {\n        unordered_map<string, int>m;\n        for(int j=i; j<i+n*len; j+=len) {\n            string str = s.substr(j, len);\n            m[str]++;\n        }\n        if(mp == m) {\n            ans.push_back(i);\n        }\n       \n    }\n    return ans;\n}",
                "url": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/2417760/hashmap/",
                "vote_count": "11"
            }
        ]
    },
    "30": {
        "question_id": 31,
        "title": "Next Permutation",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/next-permutation",
        "description": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).For example, the next permutation of arr = [1,2,3] is [1,3,2].Similarly, the next permutation of arr = [2,3,1] is [3,1,2].While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.Given an array of integers nums, find the next permutation of nums.The replacement must be in place and use only constant extra memory. ",
        "examples": [
            {
                "input": "nums = [1,2,3]",
                "output": "[1,3,2]",
                "explanation": null
            },
            {
                "input": "nums = [3,2,1]",
                "output": "[1,2,3]",
                "explanation": null
            },
            {
                "input": "nums = [1,1,5]",
                "output": "[1,5,1]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 100",
            "0 <= nums[i] <= 100"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n     int n = nums.size(), k, l;\n     for (k = n - 2; k >= 0; k--) {\n            if (nums[k] < nums[k + 1]) {\n                break;\n            }\n        }\n     if (k < 0) {\n         reverse(nums.begin(), nums.end());\n     } else {\n         for (l = n - 1; l > k; l--) {\n                if (nums[l] > nums[k]) {\n                    break;\n                }\n            } \n         swap(nums[k], nums[l]);\n         reverse(nums.begin() + k + 1, nums.end());\n        }\n    }\n}; ",
                "url": "https://leetcode.com/problems/next-permutation/solutions/13867/c-from-wikipedia/",
                "vote_count": "1075"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/next-permutation/solutions/13867/c-from-wikipedia/",
                "vote_count": "1075"
            },
            {
                "language": "javascript",
                "code": "    // 1. Find the largest index k such that nums[k] < nums[k + 1]. If no such index , just reverse\n    // 2. Find the largest index l > k such that nums[k] < nums[l]\n    // 3. Swap nums[k] and nums[l]\n    // 4. Reverse the sub-array nums[k + 1:]\n    \n    // how to understand it:\n    // step-1: easy, find the first digit that can be swapped to make permutation bigger\n    // step-2: easy, find the digit bigger but closest to nums[k]\n    // step-3: swap(nums[k], nums[l])",
                "url": "https://leetcode.com/problems/next-permutation/solutions/13867/c-from-wikipedia/",
                "vote_count": "1075"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        // Find from the smallest k such that nums[k - 1] < nums[k].",
                "url": "https://leetcode.com/problems/next-permutation/solutions/13867/c-from-wikipedia/",
                "vote_count": "1075"
            },
            {
                "language": "cpp",
                "code": "// The following algorithm generates the next permutation lexicographically after a given permutation. It changes the given permutation in-place.\nclass Solution {\n    public void nextPermutation(int[] nums) {\n        // Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation.\n        int k = -1;\n        for (int i = 0; i < nums.length - 1; i++)\n            if (nums[i] < nums[i + 1])\n                k = i;",
                "url": "https://leetcode.com/problems/next-permutation/solutions/13867/c-from-wikipedia/",
                "vote_count": "1075"
            },
            {
                "language": "cpp",
                "code": "void nextPermutation(vector<int>& nums) \n    {\n        int n=nums.size();\n        int l,r;\n        for(l=n-2;l>=0;l--)                           // find decreasing sequence\n        {\n            if(nums[l]<nums[l+1]) break;\n        }\n        if(l<0) reverse(nums.begin(),nums.end());\n        else\n        {\n            for(r=n-1;r>l;r--)                       // find rightmost successor to pivot\n            {\n                if(nums[r]>nums[l]) break;\n            }\n            swap(nums[l],nums[r]);                  // swap l,r\n            \n            reverse(nums.begin()+l+1,nums.end());   // reverse from l+1 to end\n        }\n    }",
                "url": "https://leetcode.com/problems/next-permutation/solutions/1909229/simple-easy-c-solution/",
                "vote_count": "136"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N), Since we traverse the entire Array(nums) once in the worst case. Where N = size of\n    the Array(nums).\n\n    Space Complexity : O(1), Constant Space.\n\n    Solved using Array + Two Pointers.\n\n*/\n\n\n/***************************************** Approach 1 First Code *****************************************/\n\nclass Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        int n = nums.size(), index = -1;\n        for(int i=n-2; i>=0; i--){\n            if(nums[i] < nums[i+1]){\n                index = i;\n                break;\n            }\n        }\n        for(int i=n-1; i>=index && index != -1; i--){\n            if(nums[i] > nums[index]){\n                swap(nums[i], nums[index]);\n                break;\n            }\n        }\n        reverse(nums.begin() + index + 1, nums.end());\n    }\n};\n\n\n\n\n\n\n/***************************************** Approach 1 Second Code *****************************************/\n\nclass Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        next_permutation(nums.begin(), nums.end());\n    }\n};",
                "url": "https://leetcode.com/problems/next-permutation/solutions/3169948/best-c-2-solution-two-pointers-optimized-solution/",
                "vote_count": "72"
            }
        ]
    },
    "31": {
        "question_id": 32,
        "title": "Longest Valid Parentheses",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/longest-valid-parentheses",
        "description": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring. ",
        "examples": [
            {
                "input": "s = \"(()\"",
                "output": "2",
                "explanation": "The longest valid parentheses substring is \"()\"."
            },
            {
                "input": "s = \")()())\"",
                "output": "4",
                "explanation": "The longest valid parentheses substring is \"()()\"."
            },
            {
                "input": "s = \"\"",
                "output": "0",
                "explanation": null
            }
        ],
        "constraints": [
            "0 <= s.length <= 3 * 10^4",
            "s[i] is '(', or ')'."
        ],
        "solutions": [
            {
                "language": "php",
                "code": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int n = s.length(), longest = 0;\n        stack<int> st;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '(') st.push(i);\n            else {\n                if (!st.empty()) {\n                    if (s[st.top()] == '(') st.pop();\n                    else st.push(i);\n                }\n                else st.push(i);\n            }\n        }\n        if (st.empty()) longest = n;\n        else {\n            int a = n, b = 0;\n            while (!st.empty()) {\n                b = st.top(); st.pop();\n                longest = max(longest, a-b-1);\n                a = b;\n            }\n            longest = max(longest, a);\n        }\n        return longest;\n    }\n};",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14126/my-o-n-solution-using-a-stack/",
                "vote_count": "965"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        stack<int> stk;\n        stk.push(-1);\n        int ans = 0;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == '(') {",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14126/my-o-n-solution-using-a-stack/",
                "vote_count": "965"
            },
            {
                "language": "cpp",
                "code": "public int longestValidParentheses(String s) {\n    boolean valid[] = new boolean[s.length()];\n\n    Stack<Integer> stack = new Stack<>();\n    for (int i = 0; i < s.length(); i++) {\n        if (s.charAt(i) == '(') stack.push(i);\n        else if (!stack.isEmpty()) {",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14126/my-o-n-solution-using-a-stack/",
                "vote_count": "965"
            },
            {
                "language": "python",
                "code": "public int longestValidParentheses(String s) {\n    char[] S = s.toCharArray();\n    int[] V = new int[S.length];\n    int open = 0;\n    int max = 0;",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14126/my-o-n-solution-using-a-stack/",
                "vote_count": "965"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\npublic int longestValidParentheses(String s) {\n    int max = Integer.MIN_VALUE;\n    s += \"x\";\n    Stack<Integer> stack = new Stack<>();\n    for(int i = 0; i < s.length(); i++){\n        if(s.charAt(i) == ')' && !stack.empty() && s.charAt(stack.peek())== '(')",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14126/my-o-n-solution-using-a-stack/",
                "vote_count": "965"
            },
            {
                "language": "cpp",
                "code": "int longestValidParentheses(string s) {\n    int size = s.size(), res = 0;\n    if(size < 2) return res;\n    stack<int> si;\n    for(int i = 0; i < size; ++i) {\n        if('(' == s[i]) si.push(i);",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14126/my-o-n-solution-using-a-stack/",
                "vote_count": "965"
            },
            {
                "language": "cpp",
                "code": "    def longestValidParentheses(self, s):\n         stack, res, s = [0], 0, ')'+s\n         for i in xrange(1, len(s)):\n             if s[i] == ')' and s[stack[-1]] == '(':\n                 stack.pop()\n                 res = max(res, i - stack[-1])\n             else:\n                 stack.append(i)",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14126/my-o-n-solution-using-a-stack/",
                "vote_count": "965"
            },
            {
                "language": "python",
                "code": "    public int longestValidParenthesesOnline(String s) {\n        if (s == null) return -1;\n        if (s.length() == 0) return 0;",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14126/my-o-n-solution-using-a-stack/",
                "vote_count": "965"
            },
            {
                "language": "cpp",
                "code": "    public int longestValidParentheses(String s) {\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') stack.push(i);\n            else if (!stack.empty() && s.charAt(stack.peek()) == '(') stack.pop();  \n            else stack.push(i);\n        }\n        if (stack.empty()) return s.length();\n        int res = 0, high = s.length();",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14126/my-o-n-solution-using-a-stack/",
                "vote_count": "965"
            },
            {
                "language": "csharp",
                "code": "    int longestValidParentheses(string s) {\n        calcInvalid(s, '(');\n        reverse(s.begin(), s.end());\n        return calcInvalid(s, ')');\n    }\n    \n    int calcInvalid(string& s, char plus) {\n        int stack_ = 0, invalid = 0, longest = 0, length = 0;",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14126/my-o-n-solution-using-a-stack/",
                "vote_count": "965"
            },
            {
                "language": "cpp",
                "code": "   int longestValidParentheses(string s) {\n            if(s.length() <= 1) return 0;\n            int curMax = 0;\n            vector<int> longest(s.size(),0);\n            for(int i=1; i < s.length(); i++){\n                if(s[i] == ')'){\n                    if(s[i-1] == '('){\n                        longest[i] = (i-2) >= 0 ? (longest[i-2] + 2) : 2;\n                        curMax = max(longest[i],curMax);\n                    }\n                    else{ // if s[i-1] == ')', combine the previous length.\n                        if(i-longest[i-1]-1 >= 0 && s[i-longest[i-1]-1] == '('){\n                            longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 >= 0)?longest[i-longest[i-1]-2]:0);\n                            curMax = max(longest[i],curMax);\n                        }\n                    }\n                }\n                //else if s[i] == '(', skip it, because longest[i] must be 0\n            }\n            return curMax;\n        }",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14133/my-dp-o-n-solution-without-using-stack/",
                "vote_count": "584"
            },
            {
                "language": "cpp",
                "code": "int longestValidParentheses(string s) {\n        if(s.length() <= 1) return 0;\n        int curMax = 0;\n        vector<int> longest(s.size(),0);\n        for(int i=1; i < s.length(); i++){\n            if(s[i] == ')' && i-longest[i-1]-1 >= 0 && s[i-longest[i-1]-1] == '('){\n                    longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 >= 0)?longest[i-longest[i-1]-2]:0);\n                    curMax = max(longest[i],curMax);\n            }\n        }\n        return curMax;\n    }",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14133/my-dp-o-n-solution-without-using-stack/",
                "vote_count": "584"
            },
            {
                "language": "cpp",
                "code": "int longestValidParentheses(string s) {\n        s = \")\" + s;\n        int curMax = 0;\n        vector<int> longest(s.size(),0);\n        for(int i=1; i < s.length(); i++){\n            if(s[i] == ')' && s[i-longest[i-1]-1] == '('){\n                    longest[i] = longest[i-1] + 2 + longest[i-longest[i-1]-2];\n                    curMax = max(longest[i],curMax);",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14133/my-dp-o-n-solution-without-using-stack/",
                "vote_count": "584"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14133/my-dp-o-n-solution-without-using-stack/",
                "vote_count": "584"
            },
            {
                "language": "cpp",
                "code": "public int longestValidParentheses(String s) {\n        int ans = 0;\n        int[] dp = new int[s.length()];\n        for(int i = 0;i<s.length();i++){\n            if(s.charAt(i) == ')' && i-1 >= 0){                           //read dp[i-1] to get index of \"(\" related to \")\" in this position\n                int checkLeftIndex = i - dp[i-1] - 1;\n                if(checkLeftIndex >= 0 && s.charAt(checkLeftIndex) == '('){\n                    dp[i] = dp[i-1] + 2;                                          //case \"(( ))\" , dp = {0,0,2,2+2}",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14133/my-dp-o-n-solution-without-using-stack/",
                "vote_count": "584"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\n public int longestValidParentheses(String s){\n  if (s==null||s.length()==0) return 0;\n  \n  Stack<Integer> stack= new Stack<Integer>(); //Store indices of '('\n  int[] result=new int[s.length()];//Store the length of the current longest valid sequence.\n  Arrays.fill(result, 0);",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14133/my-dp-o-n-solution-without-using-stack/",
                "vote_count": "584"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int res = 0;\n        vector<int> dp(s.size()+1, 0);\n        for(int i=1; i<s.size(); i++) {\n            if(s[i]==')' && i-dp[i] && s[i-dp[i]-1]=='(') {\n                dp[i+1] = dp[i] + dp[i-dp[i]-1] + 2;",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14133/my-dp-o-n-solution-without-using-stack/",
                "vote_count": "584"
            },
            {
                "language": "cpp",
                "code": "public int longestValidParentheses(String s) {\n    s = \")\" + s;\n    int[] longest = new int[s.length() + 1];\n    \n    for (int i = 1; i < s.length(); i++){\n        if (s.charAt(i) == ')' && s.charAt(i - longest[i - 1] - 1) == '(') {\n            longest[i] = longest[i - 1] + 2 + longest[i - longest[i - 1] - 2];\n            longest[s.length()] = Math.max(longest[i], longest[s.length()]); ",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14133/my-dp-o-n-solution-without-using-stack/",
                "vote_count": "584"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n int longestValidParentheses(string s) {\n  s = \")\" + s;\n  int n = s.length();\n  vector<int> longest(n,0);\n  int res = 0;\n  for (int i=1; i < n; i++) {\n   if (s[i]=='(')",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/14133/my-dp-o-n-solution-without-using-stack/",
                "vote_count": "584"
            },
            {
                "language": "php",
                "code": "Example - '()())()'\nInitial stack(from bottom to top) :  [ -1 ] , MAX = 0\n\n1. i = 0          |   s[i] = '('        =>     case-1: push current index into stack\nstack : [-1, 0]   |   MAX = 0\n\n2. i = 1          |   s[i] = ')'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\nstack : [-1]      |   MAX = max(0, 1 - (-1)) = 2.\n\n'NOTE : Since the index starts from 0, having index preceding to the start of valid parentheses will give us actual length of the valid parentheses,\ninstead of us having to add 1 to it everytime.'\n\n3. i = 2          |   s[i] = '('        =>     case-1: push current index into stack\nstack : [-1, 1]   |   MAX = 2.\n\n4. i = 3          |   s[i] = ')'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\nstack : [-1]      |   MAX = max(2, 3 - (-1)) = 4.\n\n5. i = 4          |   s[i] = ')'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\nThis denotes any valid parentheses from now will start from next index and previous valid parentheses cant be extended further.\nstack : [4]       |   MAX = 4.\n\n6. i = 5          |   s[i] = '('        =>     case-1: push current index into stack\nstack : [4, 5]    |   MAX = 4.\n\n7. i = 6          |   s[i] = ')'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\nstack : [4]       |   MAX = max(4, 6 - 4) = 4.",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/1139990/longest-valid-parentheses-short-easy-w-explanation-using-stack/",
                "vote_count": "185"
            },
            {
                "language": "cpp",
                "code": "int longestValidParentheses(string s) {\n int MAX = 0;  // denotes length of maximum valid parentheses\n stack<int> stk;\n stk.push(-1); // bottom of stack will always hold index preceding to potential start of valid parentheses\n for(int i = 0; i < size(s); i++)\n  if(s[i] == '(') stk.push(i);            \n  else{                \n   stk.pop();\n   if(stk.empty()) stk.push(i);\n   else MAX = max(MAX, i - stk.top());\n  }        \n return MAX;\n}",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/1139990/longest-valid-parentheses-short-easy-w-explanation-using-stack/",
                "vote_count": "185"
            },
            {
                "language": "cpp",
                "code": "int n=s.length();\n        if(n==0)\n            return 0;\n        Stack<Character> stack=new Stack<Character>();\n        int max=0;\n        int count=0;\n        for(int i=0;i<n;i++)",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/1139990/longest-valid-parentheses-short-easy-w-explanation-using-stack/",
                "vote_count": "185"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        max_length = 0\n        stck=[-1] # initialize with a start index\n        for i in range(len(s)):\n            if s[i] == '(':\n                stck.append(i)\n            else:\n                stck.pop()\n                if not stck: # if popped -1, add a new start index\n                    stck.append(i)\n                else:\n                    max_length=max(max_length, i-stck[-1]) # update the length of the valid substring\n        return max_length",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/2068235/python-easy-2-approaches-space-o-n-and-o-1/",
                "vote_count": "45"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        max_length = 0\n                \n        l,r=0,0        \n        # traverse the string from left to right\n        for i in range(len(s)):\n            if s[i] == '(':\n                l+=1\n            else:\n                r+=1                        \n            if l == r:# valid balanced parantheses substring \n                max_length=max(max_length, l*2)\n            elif r>l: # invalid case as ')' is more\n                l=r=0\n        \n        l,r=0,0        \n        # traverse the string from right to left\n        for i in range(len(s)-1,-1,-1):\n            if s[i] == '(':\n                l+=1\n            else:\n                r+=1            \n            if l == r:# valid balanced parantheses substring \n                max_length=max(max_length, l*2)\n            elif l>r: # invalid case as '(' is more\n                l=r=0\n        return max_length",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/2068235/python-easy-2-approaches-space-o-n-and-o-1/",
                "vote_count": "45"
            },
            {
                "language": "php",
                "code": "class Solution {\n    // TC : O(n)\n    // SC : O(n)\n    public int longestValidParentheses(String s) {\n        if(s==null || s.length()<2){\n            return 0;\n        }\n\n        Stack<Integer> st =new Stack<>();\n\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i) == '('){\n                st.push(i);\n            } else{\n\n                // current closing bracket\n\n                if(!st.empty() && s.charAt(st.peek()) == '('){\n                    // balanced case\n                    st.pop();\n                } else {\n                    // unbalanced case\n                    st.push(i);\n                }\n            }\n        }\n     \n        int maxLen = 0;\n        int endTerminal = s.length();\n\n        while(!st.empty()){\n            int startTerminal  = st.pop();\n            maxLen = Math.max(maxLen, endTerminal - startTerminal -1);\n            endTerminal = startTerminal;\n        }\n\n        return Math.max(endTerminal, maxLen);\n        \n    }\n}",
                "url": "https://leetcode.com/problems/longest-valid-parentheses/solutions/2950489/simple-java-solution-with-o-n/",
                "vote_count": "10"
            }
        ]
    },
    "32": {
        "question_id": 33,
        "title": "Search in Rotated Sorted Array",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/search-in-rotated-sorted-array",
        "description": "There is an integer array nums sorted in ascending order (with distinct values).Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.You must write an algorithm with O(log n) runtime complexity. ",
        "examples": [
            {
                "input": "nums = [4,5,6,7,0,1,2], target = 0",
                "output": "4",
                "explanation": null
            },
            {
                "input": "nums = [1], target = 0",
                "output": "-1",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 5000",
            "-10^4 <= nums[i] <= 10^4",
            "All values of nums are unique.",
            "nums is an ascending array that is possibly rotated.",
            "-10^4 <= target <= 10^4"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n     int n = nums.size();\n      int left = 0;\n      int right = n-1;\n      int mid= left + (right - left) / 2;\n      while(left <= right){\n        if(nums[mid] == target)\n         return mid;\n        if(nums[mid] >= nums[left]) {\n          if(target >= nums[left] && target <= nums[mid])\n            {\n                right = mid - 1;\n            }\n           else left = mid + 1;\n        } \n        else {\n          if(target >= nums[mid] && target <= nums[right]) \n            left = mid + 1;\n          else right = mid - 1;\n        }\n          mid = left + (right - left) / 2;\n      }\n      return -1;\n    }\n};",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3283609/easy-to-understand-c-100-beats/",
                "vote_count": "41"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n\n        \n    int search(vector<int>& nums, int target) {\n        int size=nums.size();\n       int s=0,e=size-1,m=0;\n        while(s<=e){\n                m=s+(e-s)/2;\n                if(nums[m]==target) return m;\n                if(nums[m]>=nums[s]){\n                if(nums[m]>=target && nums[s]<=target) e=m-1;\n                else s=m+1;}\n                else{\n                    if(nums[m]<=target && nums[e]>=target) s=m+1;\n                    else e=m-1;\n                }\n        }\n        return -1;\n        \n\n        \n    }\n};",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3227761/beats-100-easy-approach-detailed-explanation/",
                "vote_count": "23"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int search(int[] nums, int target) {\n      int start=0;\n        int end=nums.length-1;\n        \n        while(start<=end){\n        int mid= start+(end-start) /2;\n        if(nums[mid]==target) return mid;\n        if(nums[start]<=nums[mid]){\n            if(target<=nums[mid] && target>=nums[start]){\n                end=mid-1;\n            }else{\n                start=mid+1;\n            }\n        }\n        else{\n            if(target>=nums[mid] && target<=nums[end]){  \n                start=mid+1;\n            }else{\n                end=mid-1;\n            }\n        }\n        }\n        return -1;\n    }\n    \n}",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3347991/100-beats-java-solutions-clean-and-easy-to-understand-code-look-at-once/",
                "vote_count": "15"
            }
        ]
    },
    "33": {
        "question_id": 34,
        "title": "Find First and Last Position of Element in Sorted Array",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array",
        "description": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.If target is not found in the array, return [-1, -1].You must write an algorithm with O(log n) runtime complexity. ",
        "examples": [
            {
                "input": "nums = [5,7,7,8,8,10], target = 8",
                "output": "[3,4]",
                "explanation": null
            },
            {
                "input": "nums = [], target = 0",
                "output": "[-1,-1]",
                "explanation": null
            }
        ],
        "constraints": [
            "0 <= nums.length <= 10^5",
            "-10^9\u00a0<= nums[i]\u00a0<= 10^9",
            "nums is a non-decreasing array.",
            "-10^9\u00a0<= target\u00a0<= 10^9"
        ],
        "solutions": [
            {
                "language": "javascript",
                "code": "case 1: [5 7] (A[i] = target < A[j])\ncase 2: [5 3] (A[i] = target > A[j])\ncase 3: [5 5] (A[i] = target = A[j])\ncase 4: [3 5] (A[j] = target > A[i])\ncase 5: [3 7] (A[i] < target < A[j])\ncase 6: [3 4] (A[i] < A[j] < target)\ncase 7: [6 7] (target < A[i] < A[j])",
                "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/14699/clean-iterative-solution-with-two-binary-searches-with-explanation/",
                "vote_count": "1264"
            },
            {
                "language": "java",
                "code": "2* If A[mid] <= target, then i = mid;",
                "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/14699/clean-iterative-solution-with-two-binary-searches-with-explanation/",
                "vote_count": "1264"
            },
            {
                "language": "csharp",
                "code": "[5 7], target = 5",
                "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/14699/clean-iterative-solution-with-two-binary-searches-with-explanation/",
                "vote_count": "1264"
            },
            {
                "language": "lisp",
                "code": "mid = (i+j)/2+1",
                "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/14699/clean-iterative-solution-with-two-binary-searches-with-explanation/",
                "vote_count": "1264"
            },
            {
                "language": "cpp",
                "code": "vector<int> searchRange(int A[], int n, int target) {\n    int i = 0, j = n - 1;\n    vector<int> ret(2, -1);\n    // Search for the left one\n    while (i < j)\n    {\n        int mid = (i + j) /2;\n        if (A[mid] < target) i = mid + 1;\n        else j = mid;\n    }\n    if (A[i]!=target) return ret;\n    else ret[0] = i;\n    \n    // Search for the right one\n    j = n-1;  // We don't have to set i to 0 the second time.\n    while (i < j)\n    {\n        int mid = (i + j) /2 + 1; // Make mid biased to the right\n        if (A[mid] > target) j = mid - 1;  \n        else i = mid;    // So that this won't make the search range stuck.\n    }\n    ret[1] = j;\n    return ret; \n}",
                "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/14699/clean-iterative-solution-with-two-binary-searches-with-explanation/",
                "vote_count": "1264"
            },
            {
                "language": "java",
                "code": "public int[] searchRange(int[] nums, int target) {\n        double left = target - 0.5, right = target + 0.5;\n        int l = bs(nums, left), r = bs(nums, right);\n        if(l == r) return new int[]{-1, -1};\n        return new int[]{l, r-1};\n}\n    \npublic int bs(int[] nums, double target) {",
                "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/14699/clean-iterative-solution-with-two-binary-searches-with-explanation/",
                "vote_count": "1264"
            },
            {
                "language": "java",
                "code": "public int[] searchRange(int[] a, int target){\n  \n  int[] result = {-1, -1};\n  \n  if (a == null || a.length == 0)\n   return result;\n  \n  result[0] = findStartPosition(a, target);",
                "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/14699/clean-iterative-solution-with-two-binary-searches-with-explanation/",
                "vote_count": "1264"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums:",
                "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/14699/clean-iterative-solution-with-two-binary-searches-with-explanation/",
                "vote_count": "1264"
            },
            {
                "language": "java",
                "code": "public class Solution {\n       public  int[] searchRange(int[] nums, int target) {\n            int hi = nums.length - 1;\n            int low = 0;\n            int[] rs = new int[2];\n           // base case\n            if(nums == null || nums.length == 0)\n             return new int[]{-1, -1 };",
                "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/14699/clean-iterative-solution-with-two-binary-searches-with-explanation/",
                "vote_count": "1264"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        vector<int> ans = {-1, -1};\n        if (nums.empty()) {\n            return ans;\n        }",
                "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/14699/clean-iterative-solution-with-two-binary-searches-with-explanation/",
                "vote_count": "1264"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/14699/clean-iterative-solution-with-two-binary-searches-with-explanation/",
                "vote_count": "1264"
            },
            {
                "language": "java",
                "code": "public int[] searchRange(int[] nums, int target) {\n        int[] ans = new int[]{-1,-1};\n        if(nums == null || nums.length == 0) return ans;\n        int low = 0;\n        int high = nums.length - 1;\n        int foundIndex = binarySearch(nums,target,low,high);",
                "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/14699/clean-iterative-solution-with-two-binary-searches-with-explanation/",
                "vote_count": "1264"
            },
            {
                "language": "cpp",
                "code": "   class Solution {\n            public:\n        vector<int> searchRange(vector<int>& nums, int target) {\n            \n            auto lit=lower_bound(nums.begin(),nums.end(),target);\n            auto rit=upper_bound(nums.begin(),nums.end(),target);\n            --rit;\n            if(*lit!=target||(*rit)!=target)",
                "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/14699/clean-iterative-solution-with-two-binary-searches-with-explanation/",
                "vote_count": "1264"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N), because in the worst case we traverse the <= N element. Where N is the size of the\n    Array(nums).\n                    \n    Space Complexity : O(1), the space complexity is constant.\n\n    Solved using Linear Search.\n\n*/\n\n\n/***************************************** Approach 1 First Code *****************************************/\n\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int startingPosition = -1, endingPosition = -1;\n        int n = nums.size();\n        for(int i=0; i<n; i++){\n            if(nums[i] == target){\n                startingPosition = i;\n                break;\n            }\n        }\n        for(int i=n-1; i>=0; i--){\n            if(nums[i] == target){\n                endingPosition = i;\n                break;\n            }\n        }\n        return {startingPosition, endingPosition};\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\n    is logarithmic.\n\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\n    constant.\n\n    Solved using Binary Search.\n\n*/\n\n\n/***************************************** Approach 2 First Code *****************************************/\n\nclass Solution {\nprivate:\n    int lower_bound(vector<int>& nums, int low, int high, int target){\n        while(low <= high){\n            int mid = (low + high) >> 1;\n            if(nums[mid] < target){\n                low = mid + 1;\n            }\n            else{\n                high = mid - 1;\n            }\n        }\n        return low;\n    }\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int low = 0, high = nums.size()-1;\n        int startingPosition = lower_bound(nums, low, high, target);\n        int endingPosition = lower_bound(nums, low, high, target + 1) - 1;\n        if(startingPosition < nums.size() && nums[startingPosition] == target){\n            return {startingPosition, endingPosition};\n        }\n        return {-1, -1};\n    }\n};\n\n\n\n\n\n\n/***************************************** Approach 2 Second Code *****************************************/\n\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int startingPosition = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\n        int endingPosition = lower_bound(nums.begin(), nums.end(), target+1) - nums.begin() - 1;\n        if(startingPosition < nums.size() && nums[startingPosition] == target){\n            return {startingPosition, endingPosition};\n        }\n        return {-1, -1};\n    }\n};",
                "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3188625/best-c-2-solution-binary-search-linear-search-brute-force-optimize-one-stop-solu/",
                "vote_count": "104"
            }
        ]
    },
    "34": {
        "question_id": 35,
        "title": "Search Insert Position",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/search-insert-position",
        "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.You must write an algorithm with O(log n) runtime complexity. ",
        "examples": [
            {
                "input": "nums = [1,3,5,6], target = 5",
                "output": "2",
                "explanation": null
            },
            {
                "input": "nums = [1,3,5,6], target = 2",
                "output": "1",
                "explanation": null
            },
            {
                "input": "nums = [1,3,5,6], target = 7",
                "output": "4",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 10^4",
            "-10^4 <= nums[i] <= 10^4",
            "nums contains distinct values sorted in ascending order.",
            "-10^4 <= target <= 10^4"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int start = 0;\n        int end = nums.length-1;\n\n        while (start <= end) {\n            int mid = start + (end-start)/2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] > target) end = mid-1;\n            else start = mid+1;\n        }\n\n        return start;\n    }\n}",
                "url": "https://leetcode.com/problems/search-insert-position/solutions/3208460/fastest-java-solution/",
                "vote_count": "179"
            }
        ]
    },
    "35": {
        "question_id": 36,
        "title": "Valid Sudoku",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/valid-sudoku",
        "description": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:Each row must contain the digits 1-9 without repetition.Each column must contain the digits 1-9 without repetition.Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.Note:A Sudoku board (partially filled) could be valid but is not necessarily solvable.Only the filled cells need to be validated according to the mentioned rules. ",
        "examples": [
            {
                "input": "board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
                "output": "true",
                "explanation": null
            },
            {
                "input": "board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
                "output": "false",
                "explanation": "Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid."
            }
        ],
        "constraints": [
            "board.length == 9",
            "board[i].length == 9",
            "board[i][j] is a digit 1-9 or '.'."
        ],
        "solutions": [
            {
                "language": "java",
                "code": "public boolean isValidSudoku(char[][] board) {\n    Set seen = new HashSet();\n    for (int i=0; i<9; ++i) {\n        for (int j=0; j<9; ++j) {\n            if (board[i][j] != '.') {\n                String b = \"(\" + board[i][j] + \")\";\n                if (!seen.add(b + i) || !seen.add(j + b) || !seen.add(i/3 + b + j/3))\n                    return false;\n            }\n        }\n    }\n    return true;\n}",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/15472/short-simple-java-using-strings/",
                "vote_count": "2706"
            },
            {
                "language": "typescript",
                "code": "public boolean isValidSudoku(char[][] board) {\n    Set seen = new HashSet();\n    for (int i=0; i<9; ++i) {\n        for (int j=0; j<9; ++j) {\n            char number = board[i][j];\n            if (number != '.')\n                if (!seen.add(number + \" in row \" + i) ||\n                    !seen.add(number + \" in column \" + j) ||\n                    !seen.add(number + \" in block \" + i/3 + \"-\" + j/3))\n                    return false;\n        }\n    }\n    return true;\n}",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/15472/short-simple-java-using-strings/",
                "vote_count": "2706"
            },
            {
                "language": "php",
                "code": "public boolean isValidSudoku(char[][] board) {\n        for(int i = 0;i < 9;i++){\n            boolean[] rowCheck = new boolean[9];\n            boolean[] colCheck = new boolean[9];\n            boolean[] boxCheck = new boolean[9];\n            for(int j = 0;j< 9;j++){\n                if(board[i][j] == '.'){}\n                else if(rowCheck[board[i][j] - '1']) return false;",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/15472/short-simple-java-using-strings/",
                "vote_count": "2706"
            },
            {
                "language": "dart",
                "code": "class Solution\n{\npublic:\n    bool isValidSudoku(vector<vector<char> > &board)\n    {\n        int used1[9][9] = {0}, used2[9][9] = {0}, used3[9][9] = {0};\n        \n        for(int i = 0; i < board.size(); ++ i)\n            for(int j = 0; j < board[i].size(); ++ j)\n                if(board[i][j] != '.')\n                {\n                    int num = board[i][j] - '0' - 1, k = i / 3 * 3 + j / 3;\n                    if(used1[i][num] || used2[j][num] || used3[k][num])\n                        return false;\n                    used1[i][num] = used2[j][num] = used3[k][num] = 1;\n                }\n        \n        return true;\n    }\n};",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/15464/my-short-solution-by-c-o-n2/",
                "vote_count": "964"
            },
            {
                "language": "",
                "code": "0  0  0 | 1  1  1 | 2  2  2\n0  0  0 | 1  1  1 | 2  2  2\n0  0  0 | 1  1  1 | 2  2  2\n--------+---------+---------\n3  3  3 | 4  4  4 | 5  5  5\n3  3  3 | 4  4  4 | 5  5  5",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/15464/my-short-solution-by-c-o-n2/",
                "vote_count": "964"
            },
            {
                "language": "dart",
                "code": "int num = board[i][j] - '0' - 1, k = i / 3 * 3 + j / 3;",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/15464/my-short-solution-by-c-o-n2/",
                "vote_count": "964"
            },
            {
                "language": "",
                "code": "+---------+---------+---------+\n| .  .  . | .  .  . | 1  .  . |\n| .  .  . | .  .  . | .  .  . |\n| .  .  . | .  .  . | .  .  . |\n+---------+---------+---------+\n| .  .  . | .  .  . | .  2  . |\n| .  .  . | .  .  . | .  3  . |\n| .  .  . | .  .  . | .  4  . |\n+---------+---------+---------+",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/15464/my-short-solution-by-c-o-n2/",
                "vote_count": "964"
            },
            {
                "language": "cpp",
                "code": "public boolean isValidSudoku(char[][] board) {\n        int[] row = new int[9], col = new int[9], rect = new int[9];\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] == '.') continue;\n                int k = board[i][j] - '0';\n                int ri = i / 3 * 3 + j / 3;\n                if ((row[i] >> k & 1)  == 1 || (col[j] >> k & 1) == 1 ||(rect[ri] >> k & 1) == 1) return false;",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/15464/my-short-solution-by-c-o-n2/",
                "vote_count": "964"
            },
            {
                "language": "python",
                "code": "def isValidSudoku(self,board):\n            if not board:return False\n            m,n=len(board),len(board[0])\n            check_row=[[0 for i in range(9)] for j in range(9)]#three 2d array to check each row, col and sub box\n            check_col=[[0 for i in range(9)] for j in range(9)]#three 2d array to check each row, col and sub box\n            check_box=[[0 for i in range(9)] for j in range(9)]#three 2d array to check each row, col and sub box\n            for i in xrange(m):\n                for j in xrange(n):",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/15464/my-short-solution-by-c-o-n2/",
                "vote_count": "964"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        rows = [set() for x in range(9)]\n        columns = [set() for x in range(9)]\n        squares = [[set() for x in range(3)] for y in range(3)]\n        \n        for x in range(9):\n            for y in range(9):\n                cell_value = board[x][y]\n                if cell_value == \".\":\n                    continue\n                if cell_value in rows[x] or cell_value in columns[y] or cell_value in squares[x//3][y//3]:\n                    return False\n\n                rows[x].add(cell_value)\n                columns[y].add(cell_value)\n                squares[x//3][y//3].add(cell_value)\n        \n        return True",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/2572765/python-explained-steps-clean-code-best-method/",
                "vote_count": "83"
            },
            {
                "language": "java",
                "code": "public class ValidSudoku {\n\n    // Main Method to check the valid sudoku.\n    public boolean isValidSudoku(char[][] board) {\n        // Checking every number in the 'board'.\n        for (int row = 0; row < 9; row++) {\n            for (int column = 0; column < 9; column++) {\n                // If the position is a number (!= '.'), and it is a not a valid placement, then return false.\n                if (board[row][column] != '.' && !isValidPlacement(board, board[row][column], row, column))\n                    return false;\n            }\n        }\n        // If all checks succeed, then the 'board' is a valid sudoku.\n        return true;\n    }\n\n    // Method to check if identical number found in the row.\n    private boolean isNumberInRow(char[][] board, char number, int row, int column) {\n        for (int i = 0; i < 9; i++) {\n            // \"column != i\" to skip the current number.\n            // Otherwise, check if any identical number in the row and return true if found.\n            if (column != i && board[row][i] == number) return true;\n        }\n        // If we did not find any identical number in the row, then return false.\n        return false;\n    }\n\n    private boolean isNumberInColumn(char[][] board, char number, int row, int column) {\n        for (int i = 0; i < 9; i++) {\n            // \"row != i\" to skip the current number.\n            // Otherwise, check if any identical number in the column and return true if found.\n            if (row != i && board[i][column] == number) return true;\n        }\n        // If we did not find any identical number in the column, then return false.\n        return false;\n    }\n\n    private boolean isNumberInBox(char[][] board, char number, int row, int column) {\n        // Here, we get the top left corner position of the box the 'number' is in,\n        // because we are going to scan from top left to bottom right of the box.\n        int boxRow = row - row % 3;\n        int boxColumn = column - column % 3;\n\n        // Checking just the 3 row and 3 column position in the box.\n        for (int i = boxRow; i < boxRow + 3; i++) {\n            for (int j = boxColumn; j < boxColumn + 3; j++) {\n                // \"row != i && column != j\" to skip the current number.\n                // Otherwise, check if any identical number in the box and return true if found.\n                if (row != i && column != j && board[i][j] == number) return true;\n            }\n        }\n        // If we did not find any identical number in the box, then return false.\n        return false;\n    }\n\n    // Additional wrapper method for all three checks to make the code more readable.\n    private boolean isValidPlacement(char[][] board, char number, int row, int column) {\n        // If the number is not found in the row, column and the box, then it is a valid placement and return true.\n        return !isNumberInRow(board, number, row, column) &&\n                !isNumberInColumn(board, number, row, column) &&\n                !isNumberInBox(board, number, row, column);\n    }\n}",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/2840656/java-explained-in-detail-simple-fast-solution-intuitive-hash-table/",
                "vote_count": "48"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        for (int row = 0; row < 9; row++) {\n            for (int column = 0; column < 9; column++) {\n                if (board[row][column] != '.' && !isValidPlacement(board, board[row][column], row, column))\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean isNumberInRow(char[][] board, char number, int row, int column) {\n        for (int i = 0; i < 9; i++) {\n            if (column != i && board[row][i] == number) return true;\n        }\n        return false;\n    }\n\n    private boolean isNumberInColumn(char[][] board, char number, int row, int column) {\n        for (int i = 0; i < 9; i++) {\n            if (row != i && board[i][column] == number) return true;\n        }\n        return false;\n    }\n\n    private boolean isNumberInBox(char[][] board, char number, int row, int column) {\n        int boxRow = row - row % 3;\n        int boxColumn = column - column % 3;\n        for (int i = boxRow; i < boxRow + 3; i++) {\n            for (int j = boxColumn; j < boxColumn + 3; j++) {\n                if (row != i && column != j && board[i][j] == number) return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isValidPlacement(char[][] board, char number, int row, int column) {\n        return !isNumberInRow(board, number, row, column) &&\n                !isNumberInColumn(board, number, row, column) &&\n                !isNumberInBox(board, number, row, column);\n    }\n}",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/2840656/java-explained-in-detail-simple-fast-solution-intuitive-hash-table/",
                "vote_count": "48"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n\n    public boolean isValidSudoku(char[][] board) {\n        Set<String> set = new HashSet<>();\n        for (int row = 0; row < 9; row++) {\n            for (int column = 0; column < 9; column++) {\n                char number = board[row][column];\n                // If the position is a number (!= '.'),\n                // then we can try adding the number and its information into the HashSet.\n                if (number != '.') {\n                    // The HashSet.add() function returns a boolean result, true if added successfully and false otherwise.\n                    // As such, we can just use this boolean return from add() to check if we successfully added.\n                    // If any of the 3 (row, column and box) is not added successfully,\n                    // then 'board' is not a valid sudoku board.\n                    // 1. Store the number in the row.\n                    // 2. Store the number in the column.\n                    // 3. Store the number in the box. (Make sure to separate row and column information with a delimiter).\n                    if (!set.add(number + \" in row \" + row) ||\n                            !set.add(number + \" in column \" + column) ||\n                            !set.add(number + \" in block \" + (row / 3) + \",\" + (column / 3)))\n                        return false;\n                }\n            }\n        }\n        // If all checks succeed, then the 'board' is a valid sudoku.\n        return true;\n    }\n}",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/2840656/java-explained-in-detail-simple-fast-solution-intuitive-hash-table/",
                "vote_count": "48"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        Set<String> set = new HashSet<>();\n        for (int row = 0; row < 9; row++) {\n            for (int column = 0; column < 9; column++) {\n                char number = board[row][column];\n                if (number != '.') {\n                    if (!set.add(number + \" in row \" + row) ||\n                            !set.add(number + \" in column \" + column) ||\n                            !set.add(number + \" in block \" + (row / 3) + \",\" + (column / 3)))\n                        return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/2840656/java-explained-in-detail-simple-fast-solution-intuitive-hash-table/",
                "vote_count": "48"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \n        # Given an arr of row/col/sub,\n        # check if there are duplicates.\n        def isValid(arr):\n            s = ''.join(arr).replace('.','')\n            return len(s) == len(set(s))\n        \n        # Check each row in the board\n        def checkRow():\n            for row in board:\n                if not isValid(row):\n                    return False\n            return True\n        \n        # Check each col in the board,\n        # To access each col, we first unpack the board into sperate lists using *\n        # We then zip these rows together into columns.\n        def checkCol():\n            for col in zip(*board):\n                if not isValid(col):\n                    return False\n            return True\n        \n        # To get each sub-box, we first get the top-left indices of each sub-box,\n        # We then go 3 steps on each row and 3 steps on each col to construct the box.\n        def checkSub():\n            for r in range(0,9,3):\n                for c in range(0,9,3):\n                    sub = [board[r+dr][c+dc] for dr in range(3) for dc in range(3)]\n                    if not isValid(sub):\n                        return False\n            return True\n        \n        # In order to be a valid Sudoku, all row, col, and sub-box need to be valid\n        return checkRow() and checkCol() and checkSub()",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/2840666/python3-easy-to-understand-beginner-friendly/",
                "vote_count": "47"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \n        # Row, Col, and subBox will each contain 9 sets to keep track of the visited element.\n        # Using 0-8 as the id for each row, col, and sub-box.\n        # At any time if the same number is visited twice, return False. \n        Row = defaultdict(set)\n        Col = defaultdict(set)\n        subBox = defaultdict(set)\n        \n        for r in range(9):\n            for c in range(9):\n                \n                cur = board[r][c]\n                if cur=='.':\n                    continue\n                \n                # r is the id for Row \n                if cur in Row[r]:\n                    return False\n                Row[r].add(cur)\n                \n                # c is the id for Col\n                if cur in Col[c]:\n                    return False\n                Col[c].add(cur)\n                \n                # sub-box id is a little bit tricky\n                # r//3*3 will map the number 0-8 to 0,3,6 which is the starting id for each row.\n                # c//3 will map the number 0-8 to 0,1,2, which is the column.\n                # So r//3*3+c//3 is corresponding to sub-box id as shown\n                                                             ----- ----- -----\n                boxId = r//3*3+c//3                         |  0  |  1  |  2  |\n                if cur in subBox[boxId]:                     ----- ----- -----\n                    return False                            |  3  |  4  |  5  |\n                subBox[boxId].add(cur)                       ----- ----- -----\n                                                            |  6  |  7  |  8  |\n                                                             ----- ----- -----\n        # We passed all the tests, return True\n        return True",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/2840666/python3-easy-to-understand-beginner-friendly/",
                "vote_count": "47"
            },
            {
                "language": "kotlin",
                "code": "from collections import defaultdict\n\n\nclass Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        rows, cols, subboxes = defaultdict(set), defaultdict(set), defaultdict(set)\n        for i in range(9):\n            for j in range(9):",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/2840666/python3-easy-to-understand-beginner-friendly/",
                "vote_count": "47"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \n        # a function to check rows, columns and blocks using O(logN) space\n        def not_valid(digits, m=0):\n            return any( 1 & (m >> int(d)) + (m := (m | (1 << int(d))))*0\n                        for d in digits if d != \".\")\n                       \n        # a generator to extract blocks\n        def blocks():\n            for i in range(3):\n                for j in range(3):\n                    yield (n for row in board[i*3:(i+1)*3] for n in row[j*3:(j+1)*3])\n        \n        if any(map(not_valid, board))       : return False       # [1] test rows\n        if any(map(not_valid, zip(*board))) : return False       # [2] test columns\n        if any(map(not_valid, blocks()))    : return False       # [3] test blocks\n        \n        return True",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/2840529/python-c-java-o-logn-space-and-other-approaches-bonus-one-liner-explained/",
                "vote_count": "47"
            },
            {
                "language": "python",
                "code": "def not_valid(digits, m=0):\n for d in digits:\n  if d != \".\":\n   if (1 & (m >> int(d))) == 1 : return True\n   m |= (1 << int(d))\n return False",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/2840529/python-c-java-o-logn-space-and-other-approaches-bonus-one-liner-explained/",
                "vote_count": "47"
            },
            {
                "language": "python",
                "code": "def not_valid(digits):\n return len(set(s:= [d for d in digits if d != \".\"])) != len(s)",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/2840529/python-c-java-o-logn-space-and-other-approaches-bonus-one-liner-explained/",
                "vote_count": "47"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \n        seen = []\n        \n        for i, row in enumerate(board):\n            for j, d in enumerate(row):\n                if  d != \".\":\n                    seen.extend([(d,i), (j,d), (d,i//3,j//3)])    # these tuples never interfere!\n        \n        return len(set(seen)) == len(seen)",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/2840529/python-c-java-o-logn-space-and-other-approaches-bonus-one-liner-explained/",
                "vote_count": "47"
            },
            {
                "language": "kotlin",
                "code": "import numpy as np\n\nclass Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \n        board = np.array(board)\n        \n        def not_valid(digits):\n            s = \"\".join(digits).replace(\".\", \"\")\n            return len(s) != len(set(s))\n        \n        for k in range(9):\n            r, c = board[k,:], board[:,k]\n            i, j = 3*(k//3), 3*(k%3)\n            b    = board[i:i+3,j:j+3].flatten()\n            if any(map(not_valid, (r,c,b))) : return False\n        \n        return True",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/2840529/python-c-java-o-logn-space-and-other-approaches-bonus-one-liner-explained/",
                "vote_count": "47"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \n        return len(seen := sum(([(d,i),(j,d),(d,i//3,j//3)]\n                                if  d != \".\" else []\n                                for i, row in enumerate(board)\n                                for j, d   in enumerate(row)),[])) == len(set(seen))",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/2840529/python-c-java-o-logn-space-and-other-approaches-bonus-one-liner-explained/",
                "vote_count": "47"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def isValidSudoku(self, board):\n        res = []\n        for i in range(9):\n            for j in range(9):\n                element = board[i][j]\n                if element != '.':\n                    res += [(i, element), (element, j), (i // 3, j // 3, element)]\n        return len(res) == len(set(res))",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/3277043/beats-96-78-short-7-line-python-solution-with-detailed-explanation/",
                "vote_count": "24"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        block = [[set() for _ in range(3)] for _ in range(3)]\n\n        for i in range(9):\n            for j in range(9):\n                curr = board[i][j]\n                if curr == '.':\n                    continue\n                if (curr in rows[i]) or (curr in cols[j]) or (curr in block[i // 3][j // 3]):\n                    return False\n                rows[i].add(curr)\n                cols[j].add(curr)\n                block[i // 3][j // 3].add(curr)\n        return True",
                "url": "https://leetcode.com/problems/valid-sudoku/solutions/3194965/python-clean-simple-faster-than-96-in-runtime/",
                "vote_count": "17"
            }
        ]
    },
    "36": {
        "question_id": 37,
        "title": "Sudoku Solver",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/sudoku-solver",
        "description": "Write a program to solve a Sudoku puzzle by filling the empty cells.A sudoku solution must satisfy all of the following rules:Each of the digits 1-9 must occur exactly once in each row.Each of the digits 1-9 must occur exactly once in each column.Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.The '.' character indicates empty cells. ",
        "examples": [
            {
                "input": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
                "output": "[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\nExplanation:\u00a0The input board is shown above and the only valid solution is shown below:\n\n",
                "explanation": null
            }
        ],
        "constraints": [
            "board.length == 9",
            "board[i].length == 9",
            "board[i][j] is a digit or '.'.",
            "It is guaranteed that the input board has only one solution."
        ],
        "solutions": [
            {
                "language": "java",
                "code": "public class Solution {\n    public void solveSudoku(char[][] board) {\n        if(board == null || board.length == 0)\n            return;\n        solve(board);\n    }\n    \n    public boolean solve(char[][] board){\n        for(int i = 0; i < board.length; i++){\n            for(int j = 0; j < board[0].length; j++){\n                if(board[i][j] == '.'){\n                    for(char c = '1'; c <= '9'; c++){//trial. Try 1 through 9\n                        if(isValid(board, i, j, c)){\n                            board[i][j] = c; //Put c for this cell\n                            \n                            if(solve(board))\n                                return true; //If it's the solution return true\n                            else\n                                board[i][j] = '.'; //Otherwise go back\n                        }\n                    }\n                    \n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    private boolean isValid(char[][] board, int row, int col, char c){\n        for(int i = 0; i < 9; i++) {\n            if(board[i][col] != '.' && board[i][col] == c) return false; //check row\n            if(board[row][i] != '.' && board[row][i] == c) return false; //check column\n            if(board[3 * (row / 3) + i / 3][ 3 * (col / 3) + i % 3] != '.' && \nboard[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; //check 3*3 block\n        }\n        return true;\n    }\n}",
                "url": "https://leetcode.com/problems/sudoku-solver/solutions/15752/straight-forward-java-solution-using-backtracking/",
                "vote_count": "851"
            },
            {
                "language": "java",
                "code": "    public void solveSudoku(char[][] board) {\n        doSolve(board, 0, 0);\n    }\n    ",
                "url": "https://leetcode.com/problems/sudoku-solver/solutions/15752/straight-forward-java-solution-using-backtracking/",
                "vote_count": "851"
            },
            {
                "language": "java",
                "code": "    private boolean isValid(char[][] board, int row, int col, char c){\n        int regionRow = 3 * (row / 3);  //region start row\n        int regionCol = 3 * (col / 3);    //region start col",
                "url": "https://leetcode.com/problems/sudoku-solver/solutions/15752/straight-forward-java-solution-using-backtracking/",
                "vote_count": "851"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: void Do not return anything, modify board in-place instead.\n        \"\"\"\n        if not board or len(board) == 0:",
                "url": "https://leetcode.com/problems/sudoku-solver/solutions/15752/straight-forward-java-solution-using-backtracking/",
                "vote_count": "851"
            },
            {
                "language": "java",
                "code": "    public boolean solve(char[][] board, int i, int j) {\n        if(i == 9 && j == 0) return true;\n        if(board[i][j] != '.') return solve(board, (j+1) == 9? i+1 : i, (j+1) == 9? 0 : j+1);\n        \n        for(char num = '1'; num <= '9'; num++) {\n            if(isValid(board, i, j, num)){\n                board[i][j] = num;\n                if(solve(board, (j+1) == 9? i+1 : i, (j+1) == 9? 0 : j+1)) return true;",
                "url": "https://leetcode.com/problems/sudoku-solver/solutions/15752/straight-forward-java-solution-using-backtracking/",
                "vote_count": "851"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board, 0);\n    }\n    \n bool solve(vector<vector<char>>& board, int cur) {  ",
                "url": "https://leetcode.com/problems/sudoku-solver/solutions/15752/straight-forward-java-solution-using-backtracking/",
                "vote_count": "851"
            },
            {
                "language": "java",
                "code": "private boolean isValid(char[][] board, int row, int col, char c) {\n    for(int i=0; i<9; i++) {\n        if(board[i][col] != '.' && board[i][col] == c) return false;\n        if(board[row][i] != '.' && board[row][i] == c) return false;\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3] != '.' && board[3*(row/3)+i/3][3*(col/3)+i%3] == c) return false;\n    }\n    return true;\n}",
                "url": "https://leetcode.com/problems/sudoku-solver/solutions/15752/straight-forward-java-solution-using-backtracking/",
                "vote_count": "851"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\nprivate:\n    bool solve(vector<vector<char>>& board) {\n        for (int r = 0; r < 9; r++) {",
                "url": "https://leetcode.com/problems/sudoku-solver/solutions/15752/straight-forward-java-solution-using-backtracking/",
                "vote_count": "851"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(9^(N*N)) : For every unassigned index there are 9 possible options so the worst-case time\n    complexity of sudoku solver is O(9^(N*N)).\n\n    Space Complexity : O(1), Constant space.\n\n    Solved using Matrix + Backtracking.\n\n*/\n\nclass Solution {\nprivate:\n    bool isValid(vector<vector<char>>& board, int row, int col, char ch){\n        for(int i=0; i<9; i++){\n            if(board[i][col] == ch){\n                return false;\n            }\n            if(board[row][i] == ch){\n                return false;\n            }\n            if(board[3*(row/3)+i/3][3*(col/3)+i%3] == ch){\n                return false;\n            }\n        }\n        return true;\n    }\n    bool solve(vector<vector<char>>& board) {\n        for(int i=0; i<board.size(); i++){\n            for(int j=0; j<board[0].size(); j++){\n                if(board[i][j] == '.'){\n                    for(char ch='1'; ch<='9'; ch++){\n                        if(isValid(board, i, j, ch)){\n                            board[i][j] = ch;\n                            if(solve(board) == true){\n                                return true;\n                            }\n                            board[i][j] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\npublic:\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\n};",
                "url": "https://leetcode.com/problems/sudoku-solver/solutions/3226518/best-c-solution-ever-easy-solution-backtracking-one-stop-solution/",
                "vote_count": "19"
            },
            {
                "language": "javascript",
                "code": "                        board[i][j] = '.';",
                "url": "https://leetcode.com/problems/sudoku-solver/solutions/3226518/best-c-solution-ever-easy-solution-backtracking-one-stop-solution/",
                "vote_count": "19"
            }
        ]
    },
    "37": {
        "question_id": 38,
        "title": "Count and Say",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/count-and-say",
        "description": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:countAndSay(1) = \"1\"countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.To determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.For example, the saying and conversion for digit string \"3322251\":Given a positive integer n, return the nth term of the count-and-say sequence. ",
        "examples": [
            {
                "input": "n = 1",
                "output": "\"1\"",
                "explanation": "This is the base case."
            },
            {
                "input": "n = 4",
                "output": "\"1211\"\nExplanation:\ncountAndSay(1) = \"1\"\ncountAndSay(2) = say \"1\" = one 1 = \"11\"\ncountAndSay(3) = say \"11\" = two 1's = \"21\"\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= n <= 30"
        ],
        "solutions": []
    },
    "38": {
        "question_id": 39,
        "title": "Combination Sum",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/combination-sum",
        "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input. ",
        "examples": [
            {
                "input": "candidates = [2,3,6,7], target = 7",
                "output": "[[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.",
                "explanation": null
            },
            {
                "input": "candidates = [2,3,5], target = 8",
                "output": "[[2,2,2,2],[2,3,3],[3,5]]",
                "explanation": null
            },
            {
                "input": "candidates = [2], target = 1",
                "output": "[]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= candidates.length <= 30",
            "2 <= candidates[i] <= 40",
            "All elements of candidates are distinct.",
            "1 <= target <= 40"
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "public List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n}",
                "url": "https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "4405"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n        if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n} ",
                "url": "https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "4405"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> permute(int[] nums) {\n   List<List<Integer>> list = new ArrayList<>();\n   // Arrays.sort(nums); // not necessary\n   backtrack(list, new ArrayList<>(), nums);\n   return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n   if(tempList.size() == nums.length){\n      list.add(new ArrayList<>(tempList));\n   } else{\n      for(int i = 0; i < nums.length; i++){ \n         if(tempList.contains(nums[i])) continue; // element already exists, skip\n         tempList.add(nums[i]);\n         backtrack(list, tempList, nums);\n         tempList.remove(tempList.size() - 1);\n      }\n   }\n} ",
                "url": "https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "4405"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> permuteUnique(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\n    if(tempList.size() == nums.length){\n        list.add(new ArrayList<>(tempList));\n    } else{\n        for(int i = 0; i < nums.length; i++){\n            if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\n            used[i] = true; \n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, used);\n            used[i] = false; \n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "4405"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> combinationSum(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\n    if(remain < 0) return;\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\n    else{ \n        for(int i = start; i < nums.length; i++){\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "4405"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> combinationSum2(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n    \n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\n    if(remain < 0) return;\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\n    else{\n        for(int i = start; i < nums.length; i++){\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i + 1);\n            tempList.remove(tempList.size() - 1); \n        }\n    }\n} ",
                "url": "https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "4405"
            },
            {
                "language": "typescript",
                "code": "public List<List<String>> partition(String s) {\n   List<List<String>> list = new ArrayList<>();\n   backtrack(list, new ArrayList<>(), s, 0);\n   return list;\n}\n\npublic void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\n   if(start == s.length())\n      list.add(new ArrayList<>(tempList));\n   else{\n      for(int i = start; i < s.length(); i++){\n         if(isPalindrome(s, start, i)){\n            tempList.add(s.substring(start, i + 1));\n            backtrack(list, tempList, s, i + 1);\n            tempList.remove(tempList.size() - 1);\n         }\n      }\n   }\n}\n\npublic boolean isPalindrome(String s, int low, int high){\n   while(low < high)\n      if(s.charAt(low++) != s.charAt(high--)) return false;\n   return true;\n} ",
                "url": "https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "4405"
            },
            {
                "language": "kotlin",
                "code": "if(tempList.contains(nums[i])) continue;",
                "url": "https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "4405"
            },
            {
                "language": "erlang",
                "code": "1. If the sum of the current combination is greater than target, then even if we move forward with this combination, the sum will only increase, so there is no fun to moving further with such a combination as we can never achieve the target sum from this. So backtrack from this.\n2. If the sum of the current combination is equal to the target, then we have a solution, so store this combination in the answers. Now moving forward with this combnation also will only increase the sum and we can't achieve the target sum again from this ever. So backtrack from here.\n3. if we are here then that means the sum of the combination is still less that the target sum, and we have a scope of finding a combination whose sum can be equal to the target.\n  i) Now consider all possible options into this combination, one at a time.\n  ii) Go check if considering the current option can give us the solution.\n  iii) Now when this option backtracks to this place again, now remove this option and try another option. e.g. at [2, 2, _ ] we have 3 options to fill the 3rd place i.e. [2, 3, 5].\n  So firstly we will go on with [2, 2, 2]. Then when this backtracks to this place again, remove the last 2 and try the next option which is 3 that means [2, 2, 3].\n  When this also backtracks remove 3 to try 5, that means [2, 2, 5].\n  Now as all the options are exhausted for [2, 2, _ ], now backtrack to its previous state which is [2, 2], and so on...",
                "url": "https://leetcode.com/problems/combination-sum/solutions/1777569/full-explanation-with-state-space-tree-recursion-and-backtracking-well-explained-c/",
                "vote_count": "699"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    void combination(vector<int>& candidates, int target, vector<int> currComb, int currSum, int currIndex, vector<vector<int>>& ans){\n        if(currSum>target) return; //backtrack\n        if(currSum==target){\n            ans.push_back(currComb); //store the solution and backtrack\n            return;\n        }\n        \n        for(int i=currIndex; i<candidates.size(); i++){ //try all possible options for the next level\n            currComb.push_back(candidates[i]); //put 1 option into the combination\n            currSum+=candidates[i];\n            combination(candidates, target, currComb, currSum, i, ans); //try with this combination, whether it gives a solution or not.\n            currComb.pop_back(); //when this option backtrack to here, remove this and go on to the next option.\n            currSum-=candidates[i];\n        }\n        \n    }\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        vector<vector<int>> ans;\n        vector<int> currComb;\n        combination(candidates, target, currComb, 0, 0, ans);\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/combination-sum/solutions/1777569/full-explanation-with-state-space-tree-recursion-and-backtracking-well-explained-c/",
                "vote_count": "699"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    void combination(const vector<int>& candidates, int target, vector<int> &currComb, int currSum, int currIndex, vector<vector<int>>& ans){\n        if(currSum>target) return; //backtrack\n        if(currSum==target){\n            ans.push_back(currComb); //store the solution and backtrack\n            return;\n        }\n        ",
                "url": "https://leetcode.com/problems/combination-sum/solutions/1777569/full-explanation-with-state-space-tree-recursion-and-backtracking-well-explained-c/",
                "vote_count": "699"
            },
            {
                "language": "swift",
                "code": "Let's take an example not given in question -\nSuppose our array is given to us as arr[]: [2, 3] and target as 6\n\nThen, all possible combinations of array whose sum is equal to 6 is-\n[[2,2,2] , [3,3]]",
                "url": "https://leetcode.com/problems/combination-sum/solutions/1777334/c-detailed-explanation-w-tree-diagram-recursion-backtracking-each-step-explained/",
                "vote_count": "403"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> ans; // 2 D vector to store our answer\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target)\n    {\n        // if our target becomes zero at any point, then yess!! we wil find a possible combination\n        if(target == 0) \n        {\n            ans.push_back(temp); // include that combination in our answer\n            return; // and then return, we are now not gonna explore more possiblity\n        }\n        \n        // if at any point target becomes less than zero, then simply return, saying that no it is notpossible to our target combination sum\n        if(target < 0)\n            return;\n        \n        // if index crosses the last index, we will return saying that no more element is left to choosee\n        if(i == arr.size())\n            return;\n        \n        // As we dicussed for every element we have two choices whether to include in our answer or not include in our answer. \n  //so now, we are doing that\n        \n        // we are not taking the ith element,\n        // so without decreasing sum we will move to next index because it will not contribute in making our sum\n        solve(i + 1, arr, temp, target);\n        \n        // we are taking the ith element and not moving onto the next element because it may be possible that this element again contribute in making our sum.\n        // but we decrease our target sum as we are consediring that this will help us in making our target sum\n        \n        temp.push_back(arr[i]); // including ith element\n        solve(i, arr, temp, target - arr[i]); // decreasing sum,and call again function\n        temp.pop_back(); // backtrack\n        \n    }\n    vector<vector<int>> combinationSum(vector<int>& arr, int target) {\n        ans.clear(); // clear global array, make to sure that no garbage value is present in it\n        \n        vector<int> temp; // temporary vector that tries all possible combination\n        \n        solve(0, arr, temp, target); // calling function, and see we start from index zero\n        \n        return ans; // finally return the answer array\n    }\n};",
                "url": "https://leetcode.com/problems/combination-sum/solutions/1777334/c-detailed-explanation-w-tree-diagram-recursion-backtracking-each-step-explained/",
                "vote_count": "403"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    // for the sake of convience, not to include again and again in my function call, I declare target here\n    int target;\n    \n    vector<vector<int>> ans; // 2-D vector to store our answer\n    \n    void solve(vector<int>& arr, int i, int sum, vector<int> op)\n    {\n        // if i crosses the array size, we will return saying that no more possibilty is left to choose\n        \n        if(i >= arr.size()) \n        {\n            return;\n        }\n        \n        // if value at ith index + sum becomes equal to target, then we will store it in our answer array, saying that yes it is a possible combination\n        if(arr[i] + sum == target)\n        {\n            op.push_back(arr[i]);\n            ans.push_back(op);\n            return;\n        }\n        \n        // if value at ith index + sum is less than target, then we have two choices i.e whether to include this value in our possible combiation array or not include that,\n        if(arr[i] + sum < target)\n        {\n            // we make two output vector, one for calling function at same index and anthor for calling function frm next index. Because for every element we have unlimited choices, that it will contribute in making our sum any number of times.\n            vector<int> op1 = op;\n            vector<int> op2 = op;\n            \n            op2.push_back(arr[i]);\n            solve(arr, i, sum + arr[i], op2);\n            solve(arr, i + 1, sum, op1);\n        }\n        else\n        {\n            solve(arr, i + 1, sum, op); // call for the next index\n        }\n    }\n    \n    vector<vector<int>> combinationSum(vector<int>& arr, int required_target) {\n        ans.clear(); //clear global array, make to sure that no garbage value is present in it\n        \n        target = required_target; // give target what he wants \n        vector<int> op; // op array to try all possible combination\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\n        solve(arr, 0, 0, op); // call function\n        \n        return ans; // return the final answer array\n    }\n};",
                "url": "https://leetcode.com/problems/combination-sum/solutions/1777334/c-detailed-explanation-w-tree-diagram-recursion-backtracking-each-step-explained/",
                "vote_count": "403"
            },
            {
                "language": "lisp",
                "code": "(defn into-set [acc coll]\n  (if (some #{(frequencies coll)} (map frequencies acc)) acc (conj acc coll)))\n(defn combisum [inp targ]\n  (cond\n    (<= targ 0) []\n    :else (reduce\n           (fn [acc [ntar n]]\n             (reduce into-set acc (map (fn [r] (conj r n)) (combisum inp ntar))))",
                "url": "https://leetcode.com/problems/combination-sum/solutions/1777334/c-detailed-explanation-w-tree-diagram-recursion-backtracking-each-step-explained/",
                "vote_count": "403"
            },
            {
                "language": "cpp",
                "code": "void solve(vector<int> &cand, vector<vector<int>> &ans, vector<int> v, int i, int sum, int target){\n        if(i>=cand.size()){\n            return;\n        }\n        \n        if(sum==target){\n            ans.push_back(v);\n            return;",
                "url": "https://leetcode.com/problems/combination-sum/solutions/1777334/c-detailed-explanation-w-tree-diagram-recursion-backtracking-each-step-explained/",
                "vote_count": "403"
            },
            {
                "language": "python",
                "code": "1. Easy C++\n2. Line by Line Explanation with Comments.\n3. Please Upvote if it helps\u2b06\ufe0f\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \u2b07\ufe0f",
                "url": "https://leetcode.com/problems/combination-sum/solutions/1777135/c-easy-to-understand-backtracking/",
                "vote_count": "292"
            },
            {
                "language": "python",
                "code": "1. Sort the vector(non-decreasing).\n2. First remove all the duplicates from vector.\n3. Then use recursion and backtracking to solve \n   the problem.\n   (A) If at any time sub-problem sum == 0 then \n       add that vector to the result (vector of \n       vectors).\n   (B) Else if sum is negative then ignore that \n       sub-problem.\n   (C) Else insert the present index in that \n       vector to the current vector and call \n       the function with sum = sum-ar[index] and\n       index = index, then pop that element from \n       current index (backtrack) and call the \n       function with sum = sum and index = index+1",
                "url": "https://leetcode.com/problems/combination-sum/solutions/1777135/c-easy-to-understand-backtracking/",
                "vote_count": "292"
            },
            {
                "language": "cpp",
                "code": "     // \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09Please upvote if it helps \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09\nclass Solution {\npublic:\n\n    void Sum(vector<int>& candidates, int target, vector<vector<int> >& res, vector<int>& r, int i)\n    {\n        \n        if(target == 0)\n        {\n            // if we get exact answer\n            res.push_back(r);\n            return;\n        }\n        \n        while(i <  candidates.size() && target - candidates[i] >= 0)\n        {\n            // Till every element in the array starting\n            // from i which can contribute to the target\n            r.push_back(candidates[i]);// add them to vector\n            \n            // recur for next numbers\n            Sum(candidates,target - candidates[i],res,r,i);\n            ++i;\n            \n            // Remove number from vector (backtracking)\n            r.pop_back();\n        }\n}\n    \n     \n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        sort(candidates.begin(),candidates.end()); // sort candidates array\n        \n        // remove duplicates\n        candidates.erase(unique(candidates.begin(),candidates.end()),candidates.end());\n        \n        vector<int> r;\n        vector<vector<int> > res;\n        \n        Sum(candidates,target,res,r,0);\n        \n        return res;\n    }\n};",
                "url": "https://leetcode.com/problems/combination-sum/solutions/1777135/c-easy-to-understand-backtracking/",
                "vote_count": "292"
            },
            {
                "language": "javascript",
                "code": "sort(candidates.begin(),candidates.end()); // sort candidates array\n        \n// remove duplicates\ncandidates.erase(unique(candidates.begin(),candidates.end()),candidates.end());",
                "url": "https://leetcode.com/problems/combination-sum/solutions/1777135/c-easy-to-understand-backtracking/",
                "vote_count": "292"
            },
            {
                "language": "csharp",
                "code": ">> result) {",
                "url": "https://leetcode.com/problems/combination-sum/solutions/1777135/c-easy-to-understand-backtracking/",
                "vote_count": "292"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    vector<vector<int>> ans;\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        vector<int> temp;\n        dfs(0,target,candidates,temp);\n        return ans;\n    }",
                "url": "https://leetcode.com/problems/combination-sum/solutions/1777135/c-easy-to-understand-backtracking/",
                "vote_count": "292"
            },
            {
                "language": "ruby",
                "code": "candidates.erase(unique(candidates.begin(),candidates.end()),candidates.end());",
                "url": "https://leetcode.com/problems/combination-sum/solutions/1777135/c-easy-to-understand-backtracking/",
                "vote_count": "292"
            },
            {
                "language": "cpp",
                "code": "void dfs(vector<int>&arr,int target,int start,vector<vector<int>>&ans,vector<int>&v)\n{\n    // base case\n    // the current path is a valid subset\n        if(target == 0)",
                "url": "https://leetcode.com/problems/combination-sum/solutions/1777135/c-easy-to-understand-backtracking/",
                "vote_count": "292"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void helper(vector<int> &res, int &sum, vector<int>& candidates, int &target, set<vector<int>> &ans){\n        if(sum==target){\n            sort(res.begin(), res.end());\n            ans.insert(res);\n            return;",
                "url": "https://leetcode.com/problems/combination-sum/solutions/1777135/c-easy-to-understand-backtracking/",
                "vote_count": "292"
            },
            {
                "language": "python",
                "code": "def comboSum(target,candidates):\n    '''\n    1. No duplicates\n    2. Same number can be repeated\n    3. Same combo is not repeated\n\n    '''\n\n    result = []\n\n    def helper(start,sum_so_far,subset,level=0):\n        space= ' '*level\n        print(f'{space} {subset}')\n        if sum_so_far == target:\n            result.append(subset[::])\n            return\n        if sum_so_far > target:\n            return\n\n        for i in range(start,len(candidates)):\n            num = candidates[i]\n            subset.append(num)\n            sum_so_far +=num\n            level+=1\n            helper(i,sum_so_far,subset,level)\n            level-=1\n            sum_so_far -=num\n            subset.pop()\n\n    helper(0,0,[])\n    return result\n\nif __name__ == \"__main__\":\n    candidates = [1,2,3]\n    target = 3\n    print(comboSum(target,candidates))\n ```",
                "url": "https://leetcode.com/problems/combination-sum/solutions/2920513/python/",
                "vote_count": "16"
            },
            {
                "language": "1_c++_recursive",
                "code": "",
                "url": "https://leetcode.com/problems/combination-sum/solutions/2920513/python/",
                "vote_count": "16"
            },
            {
                "language": "combinations",
                "code": "",
                "url": "https://leetcode.com/problems/combination-sum/solutions/2920513/python/",
                "vote_count": "16"
            },
            {
                "language": "subset",
                "code": "",
                "url": "https://leetcode.com/problems/combination-sum/solutions/2920513/python/",
                "vote_count": "16"
            },
            {
                "language": "comsum1",
                "code": "",
                "url": "https://leetcode.com/problems/combination-sum/solutions/2920513/python/",
                "vote_count": "16"
            },
            {
                "language": "python",
                "code": "def comboSum(target,candidates):\n    '''\n    1. No duplicates\n    2. Same number can be repeated\n    3. Same combo is not repeated\n\n    '''\n\n    result = []\n\n    def helper(start,sum_so_far,subset,level=0):\n        space= ' '*level\n        print(f'{space} {subset}')\n        if sum_so_far == target:\n            result.append(subset[::])\n            return\n        if sum_so_far > target:\n            return\n\n        for i in range(start,len(candidates)):\n            num = candidates[i]\n            subset.append(num)\n            sum_so_far +=num\n            level+=1\n            helper(i,sum_so_far,subset,level)\n            level-=1\n            sum_so_far -=num\n            subset.pop()\n\n    helper(0,0,[])\n    return result\n\nif __name__ == \"__main__\":\n    candidates = [1,2,3]\n    target = 3\n    print(comboSum(target,candidates))\n ```",
                "url": "https://leetcode.com/problems/combination-sum/solutions/2595577/my-solution/",
                "vote_count": "10"
            }
        ]
    },
    "39": {
        "question_id": 40,
        "title": "Combination Sum II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/combination-sum-ii",
        "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.Each number in candidates may only be used once in the combination.Note: The solution set must not contain duplicate combinations. ",
        "examples": [
            {
                "input": "candidates = [10,1,2,7,6,1,5], target = 8",
                "output": "\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]",
                "explanation": null
            },
            {
                "input": "candidates = [2,5,2,1,2], target = 5",
                "output": "\n[\n[1,2,2],\n[5]\n]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <=\u00a0candidates.length <= 100",
            "1 <=\u00a0candidates[i] <= 50",
            "1 <= target <= 30"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> result;\n    \n    void powerset(vector<int> nums, int curr, vector<int> res, int n){\n        if(curr == n){\n            result.push_back(res);\n            return;\n        }\n        powerset(nums, curr+1, res, n);\n        res.push_back(nums[curr]);\n        powerset(nums, curr+1, res, n);\n    }\n    vector<vector<int>> subsets(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> res;\n        powerset(nums, 0, res, n);\n        return result;\n    }\n};",
                "url": "https://leetcode.com/problems/combination-sum-ii/solutions/1277764/combination-sum-i-ii-and-iii-subsets-i-and-ii-permutations-i-and-ii-one-stop-c-solutions/",
                "vote_count": "142"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> result;\n    \n    void subs(vector<int> &nums, int curr, vector<int> &res){\n        result.push_back(res);\n        for(int i = curr; i < nums.size(); i++){\n            if(i!=curr && nums[i]==nums[i-1]){\n                continue;\n            }\n            res.push_back(nums[i]);\n            subs(nums, i+1, res);\n            res.pop_back();\n            \n        }\n    }\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        if(nums.size() == 0){\n            return result;\n        }\n        vector<int> res;\n        sort(nums.begin(), nums.end());\n        subs(nums, 0, res);\n        return result;\n    }\n};",
                "url": "https://leetcode.com/problems/combination-sum-ii/solutions/1277764/combination-sum-i-ii-and-iii-subsets-i-and-ii-permutations-i-and-ii-one-stop-c-solutions/",
                "vote_count": "142"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    vector<vector<int>> result;\n    \n    vector<int> swap(vector<int> &nums, int a, int b){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n        return nums;\n    }\n    \n    void perm(vector<int> &nums, int l, int r){\n        if(l==r){\n            result.push_back(nums);\n            return;\n        }\n        for(int i = l; i <= r; i++){\n            nums = swap(nums, l, i);\n            perm(nums, l+1, r);\n            nums = swap(nums, l, i);\n        }\n    }\n    \n    vector<vector<int>> permute(vector<int>& nums) {\n        perm(nums, 0, nums.size()-1);\n        return result;\n    } \n};",
                "url": "https://leetcode.com/problems/combination-sum-ii/solutions/1277764/combination-sum-i-ii-and-iii-subsets-i-and-ii-permutations-i-and-ii-one-stop-c-solutions/",
                "vote_count": "142"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> result;\n    \n    vector<int> swap(vector<int> &nums, int a, int b){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n        return nums;\n    }\n    \n    void perm(vector<int> &nums, int l, int r){\n        if(l==r){\n            result.push_back(nums);\n            return;\n        }\n        set<int> s;\n        for(int i = l; i <= r; i++){\n                if(s.find(nums[i]) != s.end() )\n                    continue;\n                s.insert(nums[i]);\n                nums = swap(nums, l, i);\n                perm(nums, l+1, r);\n                nums = swap(nums, l, i);  \n        }\n    }\n    \n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        perm(nums, 0, nums.size()-1);\n        return result;  \n    }\n};",
                "url": "https://leetcode.com/problems/combination-sum-ii/solutions/1277764/combination-sum-i-ii-and-iii-subsets-i-and-ii-permutations-i-and-ii-one-stop-c-solutions/",
                "vote_count": "142"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> result;\n    \n    void comSum(vector<int> &curr, int curInd, int sum, vector<int> &candidates, int target, int n){\n        if(sum == target){\n            result.push_back(curr);\n            return;\n        }      \n        else if(sum > target){\n            return;\n        }\n        \n        for(int i = curInd; i < n; i++){\n            curr.push_back(candidates[i]);\n            sum += candidates[i];\n            comSum(curr, i, sum, candidates, target, n);\n            sum -= candidates[i];\n            curr.pop_back();\n        }\n    }\n    \n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        vector<int> curr;\n        int sum = 0;\n        int n = candidates.size();\n        comSum(curr, 0, sum, candidates, target, n);\n        return result;\n    }\n};",
                "url": "https://leetcode.com/problems/combination-sum-ii/solutions/1277764/combination-sum-i-ii-and-iii-subsets-i-and-ii-permutations-i-and-ii-one-stop-c-solutions/",
                "vote_count": "142"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> result;\n    \n    void comsum(vector<int> &curr, int target, int sum, vector<int> &candidates, int curInd, int n){\n        if(target == sum){\n            result.push_back(curr);\n            return;\n        }\n        else if(sum>target){\n            return;\n        }\n        \n        for(int i = curInd; i < n; i++){\n            if(i != curInd && candidates[i]==candidates[i-1])               //to avoid picking up the same combnations i.e. we don't pick same element for certain kth position of a combination \n                continue;\n            sum += candidates[i];\n            curr.push_back(candidates[i]);\n            comsum(curr, target, sum, candidates, i+1, n);\n            sum -= candidates[i];\n            curr.pop_back();\n        }\n        \n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> curr;\n        int n = candidates.size();\n        sort(candidates.begin(), candidates.end());\n        comsum(curr, target, 0, candidates, 0, n);\n        return result;\n    }\n};",
                "url": "https://leetcode.com/problems/combination-sum-ii/solutions/1277764/combination-sum-i-ii-and-iii-subsets-i-and-ii-permutations-i-and-ii-one-stop-c-solutions/",
                "vote_count": "142"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> result;\n    void comsum(vector<int> &curr, int k, int n, int sum, int size, int index){\n        if(size==k && sum == n){\n            result.push_back(curr);\n            return;\n        }\n        else if(size>k || sum>n)\n            return;\n        \n        for(int i = index; i <= 9; i++){\n            sum += i;\n            curr.push_back(i);\n            comsum(curr, k, n, sum, size+1, i+1);\n            sum -= i;\n            curr.pop_back();\n        }\n    }\n    vector<vector<int>> combinationSum3(int k, int n) {\n        vector<int> curr;\n        comsum(curr, k, n, 0, 0, 1);\n        return result;\n    }\n};",
                "url": "https://leetcode.com/problems/combination-sum-ii/solutions/1277764/combination-sum-i-ii-and-iii-subsets-i-and-ii-permutations-i-and-ii-one-stop-c-solutions/",
                "vote_count": "142"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> ans;\n    void helper(vector<int> nums, int target, vector<int> temp, int k){\n        if(target==0){\n            ans.push_back(temp);\n            return;\n        }",
                "url": "https://leetcode.com/problems/combination-sum-ii/solutions/1277764/combination-sum-i-ii-and-iii-subsets-i-and-ii-permutations-i-and-ii-one-stop-c-solutions/",
                "vote_count": "142"
            },
            {
                "language": "cpp",
                "code": "void helper(vector<int>& candidates, set<vector<int>> &ans, int index, int &target, int &sum, vector<int> &res){\n        if(sum > target || index>=candidates.size()) return;\n        if(sum==target){\n            vector<int> temp(res);\n            sort(temp.begin(), temp.end());\n            ans.insert(temp);\n            return;",
                "url": "https://leetcode.com/problems/combination-sum-ii/solutions/1277764/combination-sum-i-ii-and-iii-subsets-i-and-ii-permutations-i-and-ii-one-stop-c-solutions/",
                "vote_count": "142"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time complexity : O(2^N*K), For every index, we make 2 recursion calls and there are N elements and for\n    every subset we are checking duplicates in output and in worst case it can contain K subset. so total time\n    complexity is O(2^N*K).\n\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \n    space on average so total space complexity is O(N*K).\n\n    Solved using Array + BackTracking.\n\n    Note : This approach will give TLE.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\nprivate: \n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\n        if(index == candidates.size()){\n            if(target == 0){\n                bool isPresent = find(output.begin(), output.end(), temp) != output.end();\n                if(!isPresent){\n                    output.push_back(temp);\n                }\n            }\n            return;\n        }\n        if(candidates[index] <= target){\n            temp.push_back(candidates[index]);\n            combinationSum2(candidates, target-candidates[index], output, temp, index+1);\n            temp.pop_back();\n        }\n        combinationSum2(candidates, target, output, temp, index+1);\n    }\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        vector<vector<int>> output;\n        vector<int> temp;\n        combinationSum2(candidates, target, output, temp, 0);\n        return output;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(2^N).\n\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \n    space on average so total space complexity is O(N*K).\n\n    Solved using Array + BackTracking.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\nprivate: \n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\n        if(target < 0){\n            return;\n        }\n        else if(target == 0){\n            output.push_back(temp);\n        }\n        else{\n            for(int i=index; i<candidates.size(); i++){\n                if(i>index && candidates[i] == candidates[i-1]){\n                    continue;\n                }\n                temp.push_back(candidates[i]);\n                combinationSum2(candidates, target-candidates[i], output, temp, i+1);\n                temp.pop_back();\n            }\n        }\n    }\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        vector<vector<int>> output;\n        vector<int> temp;\n        combinationSum2(candidates, target, output, temp, 0);\n        return output;\n    }\n};",
                "url": "https://leetcode.com/problems/combination-sum-ii/solutions/3211544/best-c-2-solution-ever-easy-solution-backtracking-one-stop-solution/",
                "vote_count": "10"
            }
        ]
    },
    "40": {
        "question_id": 41,
        "title": "First Missing Positive",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/first-missing-positive",
        "description": "Given an unsorted integer array nums, return the smallest missing positive integer.You must implement an algorithm that runs in O(n) time and uses constant extra space. ",
        "examples": [
            {
                "input": "nums = [1,2,0]",
                "output": "3",
                "explanation": "The numbers in the range [1,2] are all in the array."
            },
            {
                "input": "nums = [3,4,-1,1]",
                "output": "2",
                "explanation": "1 is in the array but 2 is missing."
            },
            {
                "input": "nums = [7,8,9,11,12]",
                "output": "1",
                "explanation": "The smallest positive integer 1 is missing."
            }
        ],
        "constraints": [
            "1 <= nums.length <= 10^5",
            "-2^31 <= nums[i] <= 2^31 - 1"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution\n{\npublic:\n    int firstMissingPositive(int A[], int n)\n    {\n        for(int i = 0; i < n; ++ i)\n            while(A[i] > 0 && A[i] <= n && A[A[i] - 1] != A[i])\n                swap(A[i], A[A[i] - 1]);\n        \n        for(int i = 0; i < n; ++ i)\n            if(A[i] != i + 1)\n                return i + 1;\n        \n        return n + 1;\n    }\n};",
                "url": "https://leetcode.com/problems/first-missing-positive/solutions/17071/my-short-c-solution-o-1-space-and-o-n-time/",
                "vote_count": "1928"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic: \n    int firstMissingPositive(vector<int>& nums) {\n        int n = nums.size(); \n        for (int i = 0; i < n; i++)\n            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\n                swap(nums[i], nums[nums[i] - 1]);",
                "url": "https://leetcode.com/problems/first-missing-positive/solutions/17071/my-short-c-solution-o-1-space-and-o-n-time/",
                "vote_count": "1928"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int i = 0;\n        int n = nums.size();\n        while (i < n)\n        {\n            if (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])",
                "url": "https://leetcode.com/problems/first-missing-positive/solutions/17071/my-short-c-solution-o-1-space-and-o-n-time/",
                "vote_count": "1928"
            },
            {
                "language": "java",
                "code": "public int firstMissingPositive(int[] nums) {\n        if(nums == null || nums.length == 0) return 1;          //case: nums == null or nums == [], return 1\n        for(int i = 0;i < nums.length;i++){                     //use nums array itself, the ideal array should be {1,2,3,4}\n            int curr = nums[i];                                 //swap if nums[index] != index + 1;\n            while(curr - 1 >= 0 && curr - 1 < nums.length && curr != nums[curr-1]){\n                int next = nums[curr-1];\n                nums[curr-1] = curr;",
                "url": "https://leetcode.com/problems/first-missing-positive/solutions/17071/my-short-c-solution-o-1-space-and-o-n-time/",
                "vote_count": "1928"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\npublic int firstMissingPositive(int[] nums) {\n    int n = nums.length;\n    for(int i = 0; i < n; i++) {\n        while(nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1])\n            swap(nums, i, nums[i] - 1);\n    }\n    for(int i = 0; i < n; i++)",
                "url": "https://leetcode.com/problems/first-missing-positive/solutions/17071/my-short-c-solution-o-1-space-and-o-n-time/",
                "vote_count": "1928"
            },
            {
                "language": "python",
                "code": " def firstMissingPositive(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n     Basic idea:\n    1. for any array whose length is l, the first missing positive must be in range [1,...,l+1], \n        so we only have to care about those elements in this range and remove the rest.\n    2. we can use the array index as the hash to restore the frequency of each number within \n         the range [1,...,l+1] \n    \"\"\"\n    nums.append(0)\n    n = len(nums)\n    for i in range(len(nums)): #delete those useless elements\n        if nums[i]<0 or nums[i]>=n:\n            nums[i]=0\n    for i in range(len(nums)): #use the index as the hash to record the frequency of each number\n        nums[nums[i]%n]+=n\n    for i in range(1,len(nums)):\n        if nums[i]/n==0:\n            return i\n    return n",
                "url": "https://leetcode.com/problems/first-missing-positive/solutions/17080/python-o-1-space-o-n-time-solution-with-explanation/",
                "vote_count": "954"
            },
            {
                "language": "csharp",
                "code": "    def firstMissingPositive(self, nums: List[int]) -> int:\n        \"\"\"\n        For nums with length n, the possible result is in the range of\n        [1 : n + 1], we want to know the smallest integer in the range \n        of [1 : n] that is not in nums, if [1 : n] are all in nums,\n        the result is n + 1\n        ",
                "url": "https://leetcode.com/problems/first-missing-positive/solutions/17080/python-o-1-space-o-n-time-solution-with-explanation/",
                "vote_count": "954"
            },
            {
                "language": "go",
                "code": " nums.append(0)",
                "url": "https://leetcode.com/problems/first-missing-positive/solutions/17080/python-o-1-space-o-n-time-solution-with-explanation/",
                "vote_count": "954"
            },
            {
                "language": "python",
                "code": "        nums = list(set(nums)) + [0]\n        n = len(nums)\n        for i in range(len(nums)):  # delete those useless elements\n            if nums[i] < 0 or nums[i] >= n:\n                nums[i] = 0\n        for i in range(len(nums)):  # use the index as the hash to record the frequency of each number\n            nums[nums[i] % n] += n\n        for i in range(1, len(nums)):",
                "url": "https://leetcode.com/problems/first-missing-positive/solutions/17080/python-o-1-space-o-n-time-solution-with-explanation/",
                "vote_count": "954"
            },
            {
                "language": "dart",
                "code": "public class Solution {\npublic int firstMissingPositive(int[] nums) {\n    int n = nums.length;\n    \n    // 1. mark numbers (num < 0) and (num > n) with a special marker number (n+1) \n    // (we can ignore those because if all number are > n then we'll simply return 1)\n    for (int i = 0; i < n; i++) {\n        if (nums[i] <= 0 || nums[i] > n) {\n            nums[i] = n + 1;\n        }\n    }\n    // note: all number in the array are now positive, and on the range 1..n+1\n    \n    // 2. mark each cell appearing in the array, by converting the index for that number to negative\n    for (int i = 0; i < n; i++) {\n        int num = Math.abs(nums[i]);\n        if (num > n) {\n            continue;\n        }\n        num--; // -1 for zero index based array (so the number 1 will be at pos 0)\n        if (nums[num] > 0) { // prevents double negative operations\n            nums[num] = -1 * nums[num];\n        }\n    }\n    \n    // 3. find the first cell which isn't negative (doesn't appear in the array)\n    for (int i = 0; i < n; i++) {\n        if (nums[i] >= 0) {\n            return i + 1;\n        }\n    }\n    \n    // 4. no positive numbers were found, which means the array contains all numbers 1..n\n    return n + 1;\n}\n}",
                "url": "https://leetcode.com/problems/first-missing-positive/solutions/17214/java-simple-solution-with-documentation/",
                "vote_count": "886"
            },
            {
                "language": "erlang",
                "code": "if (nums[i] >= 0) {",
                "url": "https://leetcode.com/problems/first-missing-positive/solutions/17214/java-simple-solution-with-documentation/",
                "vote_count": "886"
            }
        ]
    },
    "41": {
        "question_id": 42,
        "title": "Trapping Rain Water",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/trapping-rain-water",
        "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. ",
        "examples": [
            {
                "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
                "output": "6",
                "explanation": "The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped."
            },
            {
                "input": "height = [4,2,0,3,2,5]",
                "output": "9",
                "explanation": null
            }
        ],
        "constraints": [
            "n == height.length",
            "1 <= n <= 2 * 10^4",
            "0 <= height[i] <= 10^5"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        n = len(height)\n        l_max = [0] * n\n        r_max = [0] * n\n        for i in range(1, n):",
                "url": "https://leetcode.com/problems/trapping-rain-water/solutions/1374608/c-java-python-maxleft-maxright-so-far-with-picture-o-1-space-clean-concise/",
                "vote_count": "582"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/trapping-rain-water/solutions/1374608/c-java-python-maxleft-maxright-so-far-with-picture-o-1-space-clean-concise/",
                "vote_count": "582"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        leftMax, rightMax = 0, 0\n        rightMaxArr, leftMaxArr = [0] * len(height), [0] * len(height)\n        waterCanTrap = 0\n\n        for idx in range(len(height)):\n            leftMax = max(leftMax, height[idx])\n            leftMaxArr[idx] = leftMax",
                "url": "https://leetcode.com/problems/trapping-rain-water/solutions/1374608/c-java-python-maxleft-maxright-so-far-with-picture-o-1-space-clean-concise/",
                "vote_count": "582"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void damn(vector<int> &h, vector<int> &right, vector<int> &left){\n        int n = h.size();\n        int mx = -1;\n        for(int i=0; i<n; i++){\n            left[i] = mx;\n            mx = max(mx, h[i]);\n        }\n        mx = -1;\n        for(int i=n-1; i>=0; i--){\n            right[i] = mx;\n            mx = max(mx, h[i]);\n        }\n    }\n\n    int trap(vector<int>& height) {\n        int n = height.size();\n        vector<int> right(n), left(n);\n        damn(height, right, left);\n        int ans = 0;\n\n        for(int i=0; i<n; i++){\n            if(min(right[i], left[i])>height[i])\n            ans += min(right[i], left[i]) - height[i];\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/trapping-rain-water/solutions/3315604/simple-c-solution-easy-to-understand/",
                "vote_count": "13"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int trap(int[] h) {\n        int n=h.length;\n        int sum=0;\n        int l[]=new int[n];\n        int r[]=new int[n];\n        l[0]=h[0];\n        for(int i=1;i<n;i++)\n        l[i]=Math.max(h[i],l[i-1]);\n         r[n-1]=h[n-1];\n        for(int i=n-2;i>=0;i--)\n        r[i]=Math.max(h[i],r[i+1]);\n        for(int i=0;i<n;i++)\n        {\n            sum+=Math.min(l[i],r[i])-h[i];\n        }\n        return sum;\n        // PLEASE UPVOTE\n        // LOVE FOR YOU BY TRIPPY THE CODER  \u2764\ufe0f \u2764\ufe0f\n    }\n}",
                "url": "https://leetcode.com/problems/trapping-rain-water/solutions/3335736/most-jugadu-solution-by-trippy-the-coder-no-dp-no-stack-just-simple-array-and-for-loop/",
                "vote_count": "12"
            }
        ]
    },
    "42": {
        "question_id": 43,
        "title": "Multiply Strings",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/multiply-strings",
        "description": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.Note: You must not use any built-in BigInteger library or convert the inputs to integer directly. ",
        "examples": [
            {
                "input": "num1 = \"2\", num2 = \"3\"",
                "output": "\"6\"",
                "explanation": null
            }
        ],
        "constraints": [],
        "solutions": [
            {
                "language": "javascript",
                "code": " `num1[i] * num2[j]` will be placed at indices `[i + j`, `i + j + 1]` ",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/17605/easiest-java-solution-with-graph-explanation/",
                "vote_count": "2419"
            },
            {
                "language": "java",
                "code": "public String multiply(String num1, String num2) {\n    int m = num1.length(), n = num2.length();\n    int[] pos = new int[m + n];\n   \n    for(int i = m - 1; i >= 0; i--) {\n        for(int j = n - 1; j >= 0; j--) {\n            int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0'); \n            int p1 = i + j, p2 = i + j + 1;\n            int sum = mul + pos[p2];\n\n            pos[p1] += sum / 10;\n            pos[p2] = (sum) % 10;\n        }\n    }  \n    \n    StringBuilder sb = new StringBuilder();\n    for(int p : pos) if(!(sb.length() == 0 && p == 0)) sb.append(p);\n    return sb.length() == 0 ? \"0\" : sb.toString();\n}",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/17605/easiest-java-solution-with-graph-explanation/",
                "vote_count": "2419"
            },
            {
                "language": "csharp",
                "code": "public String multiply(String num1, String num2) {\n        if(num1.equals(\"0\") || num2.equals(\"0\")) return \"0\";\n        int[] nums = new int[num1.length() + num2.length()];\n        for(int i = 0;i<num1.length();i++){\n            for(int j = 0;j<num2.length();j++){             //scan from back to head and store in reverse order in nums.\n                nums[i+j] += (num1.charAt(num1.length()-1-i)-'0') * (num2.charAt(num2.length()-1-j)-'0');\n            }",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/17605/easiest-java-solution-with-graph-explanation/",
                "vote_count": "2419"
            },
            {
                "language": "python",
                "code": "pos[p1] += sum / 10;\npos[p2] = (sum) % 10;",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/17605/easiest-java-solution-with-graph-explanation/",
                "vote_count": "2419"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        ret = [0] * (len(num1) + len(num2))",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/17605/easiest-java-solution-with-graph-explanation/",
                "vote_count": "2419"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public String multiply(String num1, String num2) {\n        int n1 = num1.length(), n2 = num2.length();\n        int[] products = new int[n1 + n2];\n        for (int i = n1 - 1; i >= 0; i--) {\n            for (int j = n2 - 1; j >= 0; j--) {\n                int d1 = num1.charAt(i) - '0';\n                int d2 = num2.charAt(j) - '0';\n                products[i + j + 1] += d1 * d2;\n            }\n        }\n        int carry = 0;\n        for (int i = products.length - 1; i >= 0; i--) {\n            int tmp = (products[i] + carry) % 10;\n            carry = (products[i] + carry) / 10;\n            products[i] = tmp;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int num : products) sb.append(num);\n        while (sb.length() != 0 && sb.charAt(0) == '0') sb.deleteCharAt(0);\n        return sb.length() == 0 ? \"0\" : sb.toString();\n    }\n}",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/17608/ac-solution-in-java-with-explanation/",
                "vote_count": "485"
            },
            {
                "language": "python",
                "code": "int d1 = num1.charAt(i) - '0';",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/17608/ac-solution-in-java-with-explanation/",
                "vote_count": "485"
            },
            {
                "language": "python",
                "code": "int d2 = num2.charAt(j) - '0';\nproducts[i + j + 1] += d1 * d2;",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/17608/ac-solution-in-java-with-explanation/",
                "vote_count": "485"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\n        public String multiply(String num1, String num2) {\n            int[] arr = new int[num1.length()+num2.length()];\n            for(int i = num1.length()-1; i >= 0; i--) {\n                int carry = 0;\n                for(int j = num2.length()-1; j >= 0; j--) {\n                    arr[i+j+1] += carry + (num1.charAt(i)-'0') * (num2.charAt(j)-'0');\n                    carry = arr[i+j+1] / 10;",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/17608/ac-solution-in-java-with-explanation/",
                "vote_count": "485"
            },
            {
                "language": "javascript",
                "code": "num1 = \"12\"\nnum2 = \"19\"\n\n 19  j\nx12  i",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/17608/ac-solution-in-java-with-explanation/",
                "vote_count": "485"
            },
            {
                "language": "java",
                "code": "public String multiply(String num1, String num2) {\n        if (num1.equals(\"0\") || num2.equals(\"0\")) return \"0\";\n        int n1 = num1.length();\n        int n2 = num2.length();\n        int[] products = new int[n1 + n2];\n        for (int i = n1 - 1; i>= 0; i--) {\n            for (int j = n2 - 1; j >= 0; j--) {\n                products[i + j + 1] += ((int)num1.charAt(i) - '0')*((int)num2.charAt(j) - '0');",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/17608/ac-solution-in-java-with-explanation/",
                "vote_count": "485"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public String multiply(String num1, String num2) {\n        if (num1.equals (\"0\") || num2.equals (\"0\"))\n            return \"0\";\n        char[] chs1 = num1.toCharArray (), chs2 = num2.toCharArray ();\n        int len1 = chs1.length, len2 = chs2.length;\n        char[] res = new char[len1 + len2];\n\n : 0;",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/17608/ac-solution-in-java-with-explanation/",
                "vote_count": "485"
            },
            {
                "language": "csharp",
                "code": "for(int i=product.length-1; i>=0; i--){\n            if(product[i]>9){ // handle carries only if the element is double digit\n                int carry = product[i] / 10;\n                int base = product[i] % 10;\n                product[i] = base;\n                product[i-1] = product[i-1] + carry; // add carry to the next element",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/17608/ac-solution-in-java-with-explanation/",
                "vote_count": "485"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/17608/ac-solution-in-java-with-explanation/",
                "vote_count": "485"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        n1 = len(num1)\n        n2 = len(num2)\n        product =[0]*(n1+n2)\n        \n        for i in range(n1-1,-1,-1):\n            for j in range(n2-1,-1,-1):",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/17608/ac-solution-in-java-with-explanation/",
                "vote_count": "485"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if (num1 == \"0\" || num2 == \"0\") return \"0\";\n        \n        vector<int> res(num1.size()+num2.size(), 0);\n        \n        for (int i = num1.size()-1; i >= 0; i--) {\n            for (int j = num2.size()-1; j >= 0; j--) {\n                res[i + j + 1] += (num1[i]-'0') * (num2[j]-'0');\n                res[i + j] += res[i + j + 1] / 10;\n                res[i + j + 1] %= 10;\n            }\n        }\n        \n        int i = 0;\n        string ans = \"\";\n        while (res[i] == 0) i++;\n        while (i < res.size()) ans += to_string(res[i++]);\n        \n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/1563507/c-simple-easy-and-short-solution-brief-explanation/",
                "vote_count": "308"
            },
            {
                "language": "erlang",
                "code": "result[i+j+1] = (nums[i] * nums[j]) % 10\nresult[i+j] = (nums[i] * nums[j]) / 10",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/1563541/java-easy-clean-solution-w-detailed-example-basic-math-tc-o-mn-sc-o-m-n/",
                "vote_count": "77"
            },
            {
                "language": "lisp",
                "code": "           1  2  3             (num1)\n         X       4  5  6             (num2)\n    ==================\n              1  8             (3*6)\n           1  2                (2*6)\n        0  6                   (1*6)\n    ------------------\n           1  5                (3*5)\n        1  0                   (2*5)\n     0  5                      (1*5)\n    ------------------\n        1  2                   (3*4)\n     0  8                      (2*4)\n  0  4                         (1*4)\n    ==================\n  0  5  6  0  8  8             (Result)\n    ==================",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/1563541/java-easy-clean-solution-w-detailed-example-basic-math-tc-o-mn-sc-o-m-n/",
                "vote_count": "77"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public String multiply(String num1, String num2) {\n        // Check for valid input\n        if (num1 == null || num2 == null) {\n            throw new IllegalArgumentException(\"Input numbers are invalid\");\n        }\n\n        int m = num1.length();\n        int n = num2.length();\n\n        // Base Conditions\n        if (m == 0 || n == 0 || \"0\".equals(num1) || \"0\".equals(num2)) {\n            return \"0\";\n        }\n        if (\"1\".equals(num1)) {\n            return num2;\n        }\n        if (\"1\".equals(num2)) {\n            return num1;\n        }\n\n        // Result can be maximum of length M + N.\n        // For example 99 * 99 = 9801 (Result is of length 4)\n        int[] result = new int[m + n];\n\n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                int product = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');\n                // Adding previous values in result array into this product.\n                product += result[i + j + 1];\n\n                // Adding the new product into the result array\n                result[i + j + 1] = product % 10;\n                result[i + j] += product / 10;\n            }\n        }\n\n        // Generating the result String\n        StringBuilder sb = new StringBuilder();\n        for (int r : result) {\n            // Ignoring leading zeros\n            if (sb.length() == 0 && r == 0) {\n                continue;\n            }\n            sb.append(r);\n        }\n\n        return sb.toString();\n    }\n}",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/1563541/java-easy-clean-solution-w-detailed-example-basic-math-tc-o-mn-sc-o-m-n/",
                "vote_count": "77"
            },
            {
                "language": "cpp",
                "code": "    double n1 = 0, n2 = 0;\n    n1 = doubleVal(num1);\n    n2 = doubleVal(num2);",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/1563541/java-easy-clean-solution-w-detailed-example-basic-math-tc-o-mn-sc-o-m-n/",
                "vote_count": "77"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if(num1 == \"0\" || num2 ==\"0\" ) return \"0\";\n        int n1 = num1.size(), n2 = num2.size(); int n = n1+n2;\n        string ans(n, '0');\n        reverse(num1.begin(), num1.end());\n        reverse(num2.begin(), num2.end());",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/1563541/java-easy-clean-solution-w-detailed-example-basic-math-tc-o-mn-sc-o-m-n/",
                "vote_count": "77"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string multiply(string& A, string& B) {\n        if(A == \"0\" || B == \"0\") return \"0\";                  // if either is 0, final result will be 0\n  if(size(A) < size(B)) return multiply (B, A);\n        string ans = \"\";\n        for(int j = size(B)-1, pad = 0; j >= 0; j--) {\n            auto res = multiplyDigit(A, B[j], pad++);         // multiply each digit of B with A considering proper padding of 0 at end\n            ans = addStrings(ans, res);                       // keep adding intermediate result to final result\n        }\n        return ans;\n    }\n \n // multiply a string number with a char digit\n    string multiplyDigit(string& s, char c, int pad) {\n        int i = size(s)-1, carry = 0, digit1 = c-'0', digit2, res;\n  // the string is formed in reverse manner & then reversed at end\n  // This is because it's O(1) to push at the end instead of at the start\n        string ans = string(pad, '0');\n        while(i >= 0) {\n            digit2 = s[i--]-'0';                    // get digit of num1 to be multiplied with digit1\n            res = digit1 * digit2 + carry;          // multiplication of digits + carry from previous\n            carry = res / 10;                       // update carry\n            ans += res%10+'0';                      // only consider last digit & add it to result\n        }\n        if(carry) ans += carry+'0';                 // if there's leftover carry at end after multiplying all digits\n        reverse(begin(ans), end(ans));              // reverse back to get correct result\n        return ans;\n    }\n \n // adds two string numbers - https://leetcode.com/problems/add-strings/\n    string addStrings(string& A, string& B) {\n        if(size(A) < size(B)) return addStrings(B, A);   // we assume A is the bigger string\n        int i = size(A)-1, j = size(B)-1, carry = 0, digit1, digit2, res;\n        string ans = \"\";\n        while(i >= 0) {\n            digit1 = A[i--]-'0', digit2 = j >= 0 ? (B[j--]-'0') : 0;  // get digits from both numbers\n            res = digit1 + digit2 + carry;               // add both digit and carry from previous\n            carry = res / 10;                            // update carry\n            ans += res%10+'0';                           // only consider last digit & add it to result\n        }\n        if(carry) ans += carry+'0';                      // if there's leftover carry at end after multiplying all digits\n        reverse(begin(ans), end(ans));                   // We formed in reverse order. Reverse it back to get correct result\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/1563536/c-simple-solution-w-explanation-and-images-school-optimized-multiplication/",
                "vote_count": "72"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string multiply(string& A, string& B) {\n        if(A == \"0\" || B == \"0\") return \"0\";\n        string ans(size(A)+size(B), '0');\n        for(int i = size(A)-1; i >= 0; i--) {\n            for(int j = size(B)-1; j >= 0; j--) {\n                int res = (ans[i+j+1]-'0') + (A[i]-'0') * (B[j]-'0');\n                ans[i+j+1] = res%10 + '0';  // ones place of multiplication result\n                ans[i+j] += res/10;         // carry over to previous index if result >= 10\n            }\n        }\n        if(ans[0] == '0') return ans.substr(1);\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/multiply-strings/solutions/1563536/c-simple-solution-w-explanation-and-images-school-optimized-multiplication/",
                "vote_count": "72"
            }
        ]
    },
    "43": {
        "question_id": 44,
        "title": "Wildcard Matching",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/wildcard-matching",
        "description": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:'?' Matches any single character.'*' Matches any sequence of characters (including the empty sequence).The matching should cover the entire input string (not partial). ",
        "examples": [
            {
                "input": "s = \"aa\", p = \"a\"",
                "output": "false",
                "explanation": "\"a\" does not match the entire string \"aa\"."
            },
            {
                "input": "s = \"aa\", p = \"*\"",
                "output": "true\nExplanation:\u00a0'*' matches any sequence.",
                "explanation": null
            },
            {
                "input": "s = \"cb\", p = \"?a\"",
                "output": "false\nExplanation:\u00a0'?' matches 'c', but the second letter is 'a', which does not match 'b'.",
                "explanation": null
            }
        ],
        "constraints": [
            "0 <= s.length, p.length <= 2000",
            "s contains only lowercase English letters.",
            "p contains only lowercase English letters, '?' or '*'."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": " bool isMatch(const char *s, const char *p) {\n        const char* star=NULL;\n        const char* ss=s;\n        while (*s){\n            //advancing both pointers when (both characters match) or ('?' found in pattern)\n            //note that *p will not advance beyond its length \n            if ((*p=='?')||(*p==*s)){s++;p++;continue;} \n\n            // * found in pattern, track index of *, only advancing pattern pointer \n            if (*p=='*'){star=p++; ss=s;continue;} \n\n            //current characters didn't match, last pattern pointer was *, current pattern pointer is not *\n            //only advancing pattern pointer\n            if (star){ p = star+1; s=++ss;continue;} \n\n           //current pattern pointer is not star, last patter pointer was not *\n           //characters do not match\n            return false;\n        }\n\n       //check for remaining characters in pattern\n        while (*p=='*'){p++;}\n\n        return !*p;  \n    }",
                "url": "https://leetcode.com/problems/wildcard-matching/solutions/17810/linear-runtime-and-constant-space-solution/",
                "vote_count": "610"
            },
            {
                "language": "rust",
                "code": "boolean comparison(String str, String pattern) {\n        int s = 0, p = 0, match = 0, starIdx = -1;            \n        while (s < str.length()){\n            // advancing both pointers\n            if (p < pattern.length()  && (pattern.charAt(p) == '?' || str.charAt(s) == pattern.charAt(p))){\n                s++;\n                p++;\n            }\n            // * found, only advancing pattern pointer\n            else if (p < pattern.length() && pattern.charAt(p) == '*'){\n                starIdx = p;\n                match = s;\n                p++;\n            }\n           // last pattern pointer was *, advancing string pointer\n            else if (starIdx != -1){\n                p = starIdx + 1;\n                match++;\n                s = match;\n            }\n           //current pattern pointer is not star, last patter pointer was not *\n          //characters do not match\n            else return false;\n        }\n        \n        //check for remaining characters in pattern\n        while (p < pattern.length() && pattern.charAt(p) == '*')\n            p++;\n        \n        return p == pattern.length();\n}",
                "url": "https://leetcode.com/problems/wildcard-matching/solutions/17810/linear-runtime-and-constant-space-solution/",
                "vote_count": "610"
            },
            {
                "language": "csharp",
                "code": "// greedy solution with idea of DFS\n// starj stores the position of last * in p\n// last_match stores the position of the previous matched char in s after a *\n// e.g. \n// s: a c d s c d\n// p: * c d",
                "url": "https://leetcode.com/problems/wildcard-matching/solutions/17810/linear-runtime-and-constant-space-solution/",
                "vote_count": "610"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int m = s.length(), n = p.length();\n        int i = 0, j = 0, asterick = -1, match;\n        while (i < m) {\n            if (j < n && p[j] == '*') {",
                "url": "https://leetcode.com/problems/wildcard-matching/solutions/17810/linear-runtime-and-constant-space-solution/",
                "vote_count": "610"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        vector<vector<bool>> dp(s.size() + 1, vector(p.size() + 1, false));\n        dp[0][0] = true;\n        for (int j = 0; j < p.size() && p[j] == '*'; ++j) {\n            dp[0][j + 1] = true;\n        }\n        \n        for (int i = 1; i <= s.size(); ++i) {\n            for (int j = 1; j <= p.size(); ++j) {\n                if (p[j - 1] == '*') {\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n                } else {\n                    dp[i][j] = (s[i - 1] == p[j - 1] || p[j - 1] == '?') && dp[i - 1][j - 1];\n                }\n            }\n        }\n\n        return dp[s.size()][p.size()];\n    }\n};",
                "url": "https://leetcode.com/problems/wildcard-matching/solutions/1001130/c-clean-and-concise-bottom-up-dp-code-with-detailed-explanation-easy-to-understand/",
                "vote_count": "142"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        vector<bool> dp(p.size() + 1, false);\n        dp[0] = true;\n        for (int j = 0; j < p.size() && p[j] == '*'; ++j) {\n            dp[j + 1] = true;\n        }\n        \n        for (int i = 1; i <= s.size(); ++i) {\n            dp[0] = false;\n            bool neighborLastRow = i == 1;\n            for (int j = 1; j <= p.size(); ++j) {\n                bool currLastRow = dp[j];\n                if (p[j - 1] == '*') {\n                    dp[j] = currLastRow || dp[j - 1];\n                } else {\n                    dp[j] = (s[i - 1] == p[j - 1] || p[j - 1] == '?') && neighborLastRow;\n                }\n                neighborLastRow = currLastRow;\n            }\n        }\n\n        return dp[p.size()];\n    }\n};",
                "url": "https://leetcode.com/problems/wildcard-matching/solutions/1001130/c-clean-and-concise-bottom-up-dp-code-with-detailed-explanation-easy-to-understand/",
                "vote_count": "142"
            },
            {
                "language": "javascript",
                "code": "if (p[j - 1] == '*') {\n     dp[i][j] = dp[i - 1][j] || dp[i][j - 1] || dp[i - 1][j - 1];\n}",
                "url": "https://leetcode.com/problems/wildcard-matching/solutions/1001130/c-clean-and-concise-bottom-up-dp-code-with-detailed-explanation-easy-to-understand/",
                "vote_count": "142"
            },
            {
                "language": "python",
                "code": "for (int j = 1; j < =p.size() && p[j-1] == '*'; ++j) \n            dp[0][j] = dp[0][j -1];",
                "url": "https://leetcode.com/problems/wildcard-matching/solutions/1001130/c-clean-and-concise-bottom-up-dp-code-with-detailed-explanation-easy-to-understand/",
                "vote_count": "142"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        @lru_cache(None)\n        def dfs(i, j):\n            if j == len(p):  # Reach full pattern\n                return i == len(s)\n\n            if i < len(s) and (s[i] == p[j] or p[j] == '?'):  # Match Single character\n                return dfs(i + 1, j + 1)\n            \n            if p[j] == '*':\n                return dfs(i, j + 1) or i < len(s) and dfs(i + 1, j)  # Match zero or one or more character\n            \n            return False\n\n        return dfs(0, 0)",
                "url": "https://leetcode.com/problems/wildcard-matching/solutions/1336621/python-dfs-with-memoization-clean-concise/",
                "vote_count": "85"
            }
        ]
    },
    "44": {
        "question_id": 45,
        "title": "Jump Game II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/jump-game-ii",
        "description": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:0 <= j <= nums[i] andi + j < nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1]. ",
        "examples": [
            {
                "input": "nums = [2,3,1,1,4]",
                "output": "2",
                "explanation": "The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index."
            },
            {
                "input": "nums = [2,3,0,1,4]",
                "output": "2",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 10^4",
            "0 <= nums[i] <= 1000",
            "It's guaranteed that you can reach nums[n - 1]."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "int jump(vector<int>& nums, int pos = 0) {\n if(pos >= size(nums) - 1) return 0;        \n int minJumps = 10001;  // initialising to max possible jumps + 1\n for(int j = 1; j <= nums[pos]; j++)  // explore all possible jump sizes from current position\n  minJumps = min(minJumps, 1 + jump(nums, pos + j));        \n return minJumps;\n}",
                "url": "https://leetcode.com/problems/jump-game-ii/solutions/1192401/easy-solutions-w-explanation-optimizations-from-brute-force-to-dp-to-greedy-bfs/",
                "vote_count": "693"
            },
            {
                "language": "cpp",
                "code": "int jump(vector<int>& nums) {\n vector<int> dp(size(nums), 10001); // initialise all to max possible jumps + 1 denoting dp[i] hasn't been computed yet\n return solve(nums, dp, 0);\n}\n// recursive solver to find min jumps to reach end\nint solve(vector<int>& nums, vector<int>& dp, int pos) {\n if(pos >= size(nums) - 1) return 0;    // when we reach end, return 0 denoting no more jumps required\n if(dp[pos] != 10001) return dp[pos];    // number of jumps from pos to end is already calculated, so just return it\n // explore all possible jump sizes from current position. Store & return min jumps required\n for(int j = 1; j <= nums[pos]; j++)\n  dp[pos] = min(dp[pos], 1 + solve(nums, dp, pos + j));        \n return dp[pos];\n}",
                "url": "https://leetcode.com/problems/jump-game-ii/solutions/1192401/easy-solutions-w-explanation-optimizations-from-brute-force-to-dp-to-greedy-bfs/",
                "vote_count": "693"
            },
            {
                "language": "cpp",
                "code": "int jump(vector<int>& nums) {\n int n = size(nums);\n vector<int> dp(n, 10001);\n dp[n - 1] = 0;  // start from last index. No jumps required to reach end if we are already here\n // same as above. For each index, explore all jump sizes and use the one requiring minimum jumps to reach end\n for(int i = n - 2; i >= 0; i--) \n  for(int jumpLen = 1; jumpLen <= nums[i]; jumpLen++) \n   dp[i] = min(dp[i], 1 + dp[min(n - 1, i + jumpLen)]);  // min(n-1, i + jumpLen) for bounds handling\n return dp[0];\n}",
                "url": "https://leetcode.com/problems/jump-game-ii/solutions/1192401/easy-solutions-w-explanation-optimizations-from-brute-force-to-dp-to-greedy-bfs/",
                "vote_count": "693"
            },
            {
                "language": "cpp",
                "code": "int jump(vector<int>& nums) {\n int n = size(nums), i = 0, maxReachable = 0, lastJumpedPos = 0, jumps = 0;\n while(lastJumpedPos < n - 1) {  // loop till last jump hasn't taken us till the end\n  maxReachable = max(maxReachable, i + nums[i]);  // furthest index reachable on the next level from current level\n  if(i == lastJumpedPos) {     // current level has been iterated & maxReachable position on next level has been finalised\n   lastJumpedPos = maxReachable;     // so just move to that maxReachable position\n   jumps++;                          // and increment the level\n // NOTE: jump^ only gets updated after we iterate all possible jumps from previous level\n //       This ensures jumps will only store minimum jump required to reach lastJumpedPos\n  }            \n  i++;\n }\n return jumps;\n}",
                "url": "https://leetcode.com/problems/jump-game-ii/solutions/1192401/easy-solutions-w-explanation-optimizations-from-brute-force-to-dp-to-greedy-bfs/",
                "vote_count": "693"
            },
            {
                "language": "cpp",
                "code": "int minJump(vector<int> &A){\n    \n    int n = A.size();\n    \n    if (n <= 1)\n        return 0;",
                "url": "https://leetcode.com/problems/jump-game-ii/solutions/1192401/easy-solutions-w-explanation-optimizations-from-brute-force-to-dp-to-greedy-bfs/",
                "vote_count": "693"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n\n    int jump(vector<int>& nums) {\n\n      for(int i = 1; i < nums.size(); i++)\n      {\n        nums[i] = max(nums[i] + i, nums[i-1]);\n      }\n\n      int ind = 0;\n      int ans = 0;\n\n      while(ind < nums.size() - 1)\n      {\n        ans++;\n        ind = nums[ind];\n      }\n\n      return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/jump-game-ii/solutions/3158218/c-faster-than-75-straight-forward-method-clean-and-concise-code/",
                "vote_count": "107"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int minjump(int i,vector<int>& nums,vector<int>& dp){\n        if(i >= nums.size()-1){\n            return 0;\n        }\n        if (dp[i] != -1 ) return dp[i];\n        int mini= 1e9;\n        for(int k=i+1;k<=i+nums[i];k++){\n            mini = min(mini,1+minjump(k,nums,dp));\n        }\n        return dp[i]=mini;\n    }\n    int jump(vector<int>& nums) {\n        vector<int> dp(nums.size()+1,-1);\n        return minjump(0,nums,dp);\n    }\n};",
                "url": "https://leetcode.com/problems/jump-game-ii/solutions/3158214/putta-easy-solution-c-dp/",
                "vote_count": "14"
            }
        ]
    },
    "45": {
        "question_id": 46,
        "title": "Permutations",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/permutations",
        "description": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. ",
        "examples": [
            {
                "input": "nums = [1,2,3]",
                "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
                "explanation": null
            },
            {
                "input": "nums = [1]",
                "output": "[[1]]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 6",
            "-10 <= nums[i] <= 10",
            "All the integers of nums are unique."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "public List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n}",
                "url": "https://leetcode.com/problems/permutations/solutions/18239/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning/",
                "vote_count": "5023"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n        if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n} ",
                "url": "https://leetcode.com/problems/permutations/solutions/18239/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning/",
                "vote_count": "5023"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> permute(int[] nums) {\n   List<List<Integer>> list = new ArrayList<>();\n   // Arrays.sort(nums); // not necessary\n   backtrack(list, new ArrayList<>(), nums);\n   return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n   if(tempList.size() == nums.length){\n      list.add(new ArrayList<>(tempList));\n   } else{\n      for(int i = 0; i < nums.length; i++){ \n         if(tempList.contains(nums[i])) continue; // element already exists, skip\n         tempList.add(nums[i]);\n         backtrack(list, tempList, nums);\n         tempList.remove(tempList.size() - 1);\n      }\n   }\n} ",
                "url": "https://leetcode.com/problems/permutations/solutions/18239/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning/",
                "vote_count": "5023"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> permuteUnique(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\n    if(tempList.size() == nums.length){\n        list.add(new ArrayList<>(tempList));\n    } else{\n        for(int i = 0; i < nums.length; i++){\n            if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\n            used[i] = true; \n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, used);\n            used[i] = false; \n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/permutations/solutions/18239/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning/",
                "vote_count": "5023"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> combinationSum(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\n    if(remain < 0) return;\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\n    else{ \n        for(int i = start; i < nums.length; i++){\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/permutations/solutions/18239/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning/",
                "vote_count": "5023"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> combinationSum2(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n    \n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\n    if(remain < 0) return;\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\n    else{\n        for(int i = start; i < nums.length; i++){\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i + 1);\n            tempList.remove(tempList.size() - 1); \n        }\n    }\n} ",
                "url": "https://leetcode.com/problems/permutations/solutions/18239/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning/",
                "vote_count": "5023"
            },
            {
                "language": "typescript",
                "code": "public List<List<String>> partition(String s) {\n   List<List<String>> list = new ArrayList<>();\n   backtrack(list, new ArrayList<>(), s, 0);\n   return list;\n}\n\npublic void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\n   if(start == s.length())\n      list.add(new ArrayList<>(tempList));\n   else{\n      for(int i = start; i < s.length(); i++){\n         if(isPalindrome(s, start, i)){\n            tempList.add(s.substring(start, i + 1));\n            backtrack(list, tempList, s, i + 1);\n            tempList.remove(tempList.size() - 1);\n         }\n      }\n   }\n}\n\npublic boolean isPalindrome(String s, int low, int high){\n   while(low < high)\n      if(s.charAt(low++) != s.charAt(high--)) return false;\n   return true;\n} ",
                "url": "https://leetcode.com/problems/permutations/solutions/18239/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning/",
                "vote_count": "5023"
            },
            {
                "language": "csharp",
                "code": "    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> ret = new ArrayList<>();\n\nint[] nums) {",
                "url": "https://leetcode.com/problems/permutations/solutions/18239/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning/",
                "vote_count": "5023"
            },
            {
                "language": "lisp",
                "code": "if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;",
                "url": "https://leetcode.com/problems/permutations/solutions/18239/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning/",
                "vote_count": "5023"
            },
            {
                "language": "csharp",
                "code": "    public List<List<Integer>> permute(int[] nums) {",
                "url": "https://leetcode.com/problems/permutations/solutions/18239/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning/",
                "vote_count": "5023"
            },
            {
                "language": "csharp",
                "code": " list.add(new ArrayList<>(tempList));",
                "url": "https://leetcode.com/problems/permutations/solutions/18239/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning/",
                "vote_count": "5023"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> list=new ArrayList<List<Integer>>();\n        backtrack(list,new ArrayList<Integer>(),n,k,1);\n        return list;\n    }\n    public void backtrack(List<List<Integer>> list,ArrayList<Integer> templist,int n, int k,int start){\n        if(templist.size()==k)",
                "url": "https://leetcode.com/problems/permutations/solutions/18239/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning/",
                "vote_count": "5023"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int> > permute(vector<int> &num) {\n     vector<vector<int> > result;\n     \n     permuteRecursive(num, 0, result);\n     return result;\n    }\n    \n    // permute num[begin..end]\n    // invariant: num[0..begin-1] have been fixed/permuted\n void permuteRecursive(vector<int> &num, int begin, vector<vector<int> > &result) {\n  if (begin >= num.size()) {\n      // one permutation instance\n      result.push_back(num);\n      return;\n  }\n  \n  for (int i = begin; i < num.size(); i++) {\n      swap(num[begin], num[i]);\n      permuteRecursive(num, begin + 1, result);\n      // reset\n      swap(num[begin], num[i]);\n  }\n    }\n};",
                "url": "https://leetcode.com/problems/permutations/solutions/18247/my-elegant-recursive-c-solution-with-inline-explanation/",
                "vote_count": "795"
            },
            {
                "language": "dart",
                "code": "    void dfs(int pos, vector<int> &num, vector<vector<int>> &result){\n    if(pos == num.size()){\n        result.push_back(num);\n    }\n    else{\n        for(int i=pos; i<num.size(); i++){\n            swap(num[i], num[pos]);\n            dfs(pos+1, num, result);",
                "url": "https://leetcode.com/problems/permutations/solutions/18247/my-elegant-recursive-c-solution-with-inline-explanation/",
                "vote_count": "795"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> ans;\n        permute(ans, nums, 0);\n        return ans;\n    }",
                "url": "https://leetcode.com/problems/permutations/solutions/18247/my-elegant-recursive-c-solution-with-inline-explanation/",
                "vote_count": "795"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\npublic List<List<Integer>> permute(int[] num) {\n List<List<Integer>> result = new ArrayList<List<Integer>>(); \n permute(num,0,result);\n return result;}\n\n\n public void permute(int[] num, int begin, List<List<Integer>> result){",
                "url": "https://leetcode.com/problems/permutations/solutions/18247/my-elegant-recursive-c-solution-with-inline-explanation/",
                "vote_count": "795"
            },
            {
                "language": "python",
                "code": "def permute(self, nums):\n # helper\n def recursive(nums, perm=[], res=[]):\n  if not nums: # -- NOTE [1] \n   res.append(perm[::]) #  -- NOTE [2] - append a copy of the perm at the leaf before we start popping/backtracking\n\n  for i in range(len(nums)): # [1,2,3]\n   newNums = nums[:i] + nums[i+1:]\n   perm.append(nums[i])\n   recursive(newNums, perm, res) # - recursive call will make sure I reach the leaf\n   perm.pop() # -- NOTE [3] \n  return res\n\nreturn recursive(nums)\n\n# NOTE [1]:\n# --------\n# nums is empty at the leaf of the recursive tree\n\n# NOTE [2]:\n# --------\n# at the leaf -> we know we have exaushted one path/permutation (each path is a permutation in a recursive tree)\n# reason why we are copying here is because at lists are passed by reference and since we are maintaining only one path/perm variable throughput, we are gonna be modifiying that path variable (popping it to be precise) in order to revert the path to a previous state (aka parent node) in preperation to make a lateral/horizontal move to a sibling node. See explanation below for further understanding.\n\n# NOTE [3]:\n# ---------\n# See below",
                "url": "https://leetcode.com/problems/permutations/solutions/993970/python-4-approaches-visuals-time-complexity-analysis/",
                "vote_count": "411"
            },
            {
                "language": "python",
                "code": "for i in range(len(nums)): # [1,2,3]\n newNums = nums[:i] + nums[i+1:]\n perm.append(nums[i])\n recursive(newNums, perm, res) \n perm.pop() # -- BACKTRACK",
                "url": "https://leetcode.com/problems/permutations/solutions/993970/python-4-approaches-visuals-time-complexity-analysis/",
                "vote_count": "411"
            },
            {
                "language": "python",
                "code": "def sumPosNumLessThanN(N, res=0):\n if N == 0:\n  return res\n else:\n  res = 1 + sumPosNumLessThanN(N-1)\n return res",
                "url": "https://leetcode.com/problems/permutations/solutions/993970/python-4-approaches-visuals-time-complexity-analysis/",
                "vote_count": "411"
            },
            {
                "language": "python",
                "code": "def recursive(nums, perm=[], res=[]):\n        \n            if not nums: \n                res.append(perm) # --- no need to copy as we are not popping/backtracking. Instead we're passing a new variable each time \n\n            for i in range(len(nums)): \n                newNums = nums[:i] + nums[i+1:]\n                # perm.append(nums[i]) # --- instead of appending to the same variable\n                newPerm = perm + [nums[i]] # --- new copy of the data/variable\n                recursive(newNums, newPerm, res) \n                # perm.pop()  # --- no need to backtrack\n            return res\n        \n        return recursive(nums)",
                "url": "https://leetcode.com/problems/permutations/solutions/993970/python-4-approaches-visuals-time-complexity-analysis/",
                "vote_count": "411"
            },
            {
                "language": "python",
                "code": "def recursive(nums):\n  stack = [(nums, [])]   # -- nums, path (or perms)\n  res = []\n  while stack:\n   nums, path = stack.pop()\n   if not nums:\n    res.append(path)\n   for i in range(len(nums)):   # -- NOTE [4]\n    newNums = nums[:i] + nums[i+1:]\n    stack.append((newNums, path+[nums[i]]))  # --  just like we used to do (path + [node.val]) in tree traversal\n  return res\n\n# NOTE [4]\n# The difference between itertaive tree/graph traversal we did before and this one is that\n# in most tree/graph traversals we are given the DS (tree/graph/edges) whereas here we have to build the nodes before we # traverse them\n# Generating the nodes is very simple, we Each node will be (nums, pathSofar)",
                "url": "https://leetcode.com/problems/permutations/solutions/993970/python-4-approaches-visuals-time-complexity-analysis/",
                "vote_count": "411"
            },
            {
                "language": "python",
                "code": "def recursive(nums):\n from collections import deque\n q = deque()\n q.append((nums, []))  # -- nums, path (or perms)\n res = []\n while q:\n  nums, path = q.popleft()\n  if not nums:\n   res.append(path)\n  for i in range(len(nums)):\n   newNums = nums[:i] + nums[i+1:]\n   q.append((newNums, path+[nums[i]]))\n return res\n        ",
                "url": "https://leetcode.com/problems/permutations/solutions/993970/python-4-approaches-visuals-time-complexity-analysis/",
                "vote_count": "411"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        boolean [] visited = new boolean[nums.length];\n        FindAllPermutation(res,nums, new ArrayList(),visited);\n        return res;\n    }\n    void FindAllPermutation(List<List<Integer>> res, int[] nums, List<Integer> curr, boolean [] visited){\n        if(curr.size()==nums.length){\n            res.add(new ArrayList(curr));\n            return;\n        }\n\n        for(int i =0;i<nums.length;i++){\n            if(visited[i]==true)\n            continue;\n            curr.add(nums[i]);\n            visited[i]= true;\n            FindAllPermutation(res,nums,curr,visited);\n            curr.remove(curr.size()-1);\n            visited[i]=false;\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/permutations/solutions/2938018/simple-java-sol/",
                "vote_count": "37"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> ans;\n        sort(nums.begin(),nums.end());\n        do{\n            ans.emplace_back(nums);\n        }while(next_permutation(nums.begin(),nums.end()));\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/",
                "vote_count": "26"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void Permutations(vector<int> &nums, vector<vector<int>> &ans, vector<int> &ds, int freq[]){\n        if(ds.size() == nums.size()){\n            ans.emplace_back(ds);\n            return;\n        }\n        for(int i=0 ; i<nums.size() ; i++){\n            if(!freq[i]){\n                ds.emplace_back(nums[i]);\n                freq[i]++;\n                Permutations(nums, ans, ds, freq);\n                freq[i]--;\n                ds.pop_back();\n            }\n        }\n    }   \n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> ans;\n        vector<int> ds;\n        int freq[nums.size()];\n        for(int i=0 ; i<nums.size() ; i++) \n            freq[i]=0;\n        Permutations(nums, ans, ds, freq);\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/",
                "vote_count": "26"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void Permutations(int ind, vector<int> &nums, vector<vector<int>> &ans){\n        if(ind == nums.size()){\n            ans.emplace_back(nums);\n            return;\n        }\n        for(int i=ind ; i<nums.size() ; i++){\n            swap(nums[ind],nums[i]);\n            Permutations(ind+1, nums, ans);\n            swap(nums[ind],nums[i]);\n        }\n    }   \n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> ans;\n        Permutations(0, nums, ans);\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/",
                "vote_count": "26"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N!), Because there are N! permutations and N! function calls. Where N is the size of the\n    array(nums) and ! stands for factorial. \n\n    Space Complexity: O(N!*N), since we have to store all the possible solutions which are N! in size where N is\n    the size of the array and ! stands for factorial.\n\n    Solved using Array + BackTracking. \n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {   \nprivate :\n    void permute(vector<int> &nums, vector<vector<int>> &ans, vector<int> &temp, int index){\n        if(index == nums.size()){\n            ans.push_back(temp);\n            return;\n        }\n        for(int i=index; i<temp.size(); i++){\n            swap(temp[index] , temp[i]);\n            permute(nums, ans, temp, index+1);\n            swap(temp[index] , temp[i]);\n        }\n    }\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> ans;\n        vector<int> temp = nums;\n        permute(nums, ans, temp, 0);\n        return ans;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N!), Because there are N! permutations and N! function calls. Where N is the size of the\n    array(nums) and ! stands for factorial. \n\n    Space Complexity: O(N!*N), since we have to store all the possible solutions which are N! in size where N is\n    the size of the array and ! stands for factorial.\n\n    Solved using Array + BackTracking. \n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {    \nprivate :\n    void permute(vector<int> &nums, vector<vector<int>> &ans, vector<int> temp, int index){\n        if(index == nums.size()){\n            ans.push_back(temp);\n            return;\n        }\n        for(int i=index; i<temp.size(); i++){\n            swap(temp[index] , temp[i]);\n            permute(nums, ans, temp, index+1);\n        }\n    }\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> ans;\n        vector<int> temp = nums;\n        permute(nums, ans, temp, 0);\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/permutations/solutions/3214018/best-c-2-solution-ever-easy-solution-backtracking-one-stop-solution/",
                "vote_count": "20"
            }
        ]
    },
    "46": {
        "question_id": 47,
        "title": "Permutations II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/permutations-ii",
        "description": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order. ",
        "examples": [
            {
                "input": "nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]",
                "output": "ums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]",
                "explanation": null
            },
            {
                "input": "nums = [1,2,3]",
                "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 8",
            "-10 <= nums[i] <= 10"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "public class Solution {\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        if(nums==null || nums.length==0) return res;\n        boolean[] used = new boolean[nums.length];\n        List<Integer> list = new ArrayList<Integer>();\n        Arrays.sort(nums);\n        dfs(nums, used, list, res);\n        return res;\n    }\n\n    public void dfs(int[] nums, boolean[] used, List<Integer> list, List<List<Integer>> res){\n        if(list.size()==nums.length){\n            res.add(new ArrayList<Integer>(list));\n            return;\n        }\n        for(int i=0;i<nums.length;i++){\n            if(used[i]) continue;\n            if(i>0 &&nums[i-1]==nums[i] && !used[i-1]) continue;\n            used[i]=true;\n            list.add(nums[i]);\n            dfs(nums,used,list,res);\n            used[i]=false;\n            list.remove(list.size()-1);\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/permutations-ii/solutions/18594/really-easy-java-solution-much-easier-than-the-solutions-with-very-high-vote/",
                "vote_count": "624"
            },
            {
                "language": "csharp",
                "code": "",
                "url": "https://leetcode.com/problems/permutations-ii/solutions/18594/really-easy-java-solution-much-easier-than-the-solutions-with-very-high-vote/",
                "vote_count": "624"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) {\n        if (i == j-1) {\n            res.push_back(num);\n            return;\n        }\n        for (int k = i; k < j; k++) {\n            if (i != k && num[i] == num[k]) continue;\n            swap(num[i], num[k]);\n            recursion(num, i+1, j, res);\n        }\n    }\n    vector<vector<int> > permuteUnique(vector<int> &num) {\n        sort(num.begin(), num.end());\n        vector<vector<int> >res;\n        recursion(num, 0, num.size(), res);\n        return res;\n    }\n};",
                "url": "https://leetcode.com/problems/permutations-ii/solutions/18596/a-simple-c-solution-in-only-20-lines/",
                "vote_count": "406"
            },
            {
                "language": "cpp",
                "code": "    void helper(vector<vector<int>>& res, vector<int>& nums, int pos) {\n        \n        if (pos == nums.size()) {\n            res.push_back(nums);\n        } else {",
                "url": "https://leetcode.com/problems/permutations-ii/solutions/18596/a-simple-c-solution-in-only-20-lines/",
                "vote_count": "406"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> result;\n        dfs(nums, 0, result);\n        sort(result.begin(), result.end());\n        return result;",
                "url": "https://leetcode.com/problems/permutations-ii/solutions/18596/a-simple-c-solution-in-only-20-lines/",
                "vote_count": "406"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/permutations-ii/solutions/18596/a-simple-c-solution-in-only-20-lines/",
                "vote_count": "406"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> perms;\n        permute(nums, 0, perms);\n        return perms;\n    }",
                "url": "https://leetcode.com/problems/permutations-ii/solutions/18596/a-simple-c-solution-in-only-20-lines/",
                "vote_count": "406"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\nvoid helper(vector<vector<int>>& res, int pos, vector<int>& nums)//0...pos-1 already permutated\n{\n    if(pos == nums.size())\n    {",
                "url": "https://leetcode.com/problems/permutations-ii/solutions/18596/a-simple-c-solution-in-only-20-lines/",
                "vote_count": "406"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> res;\n    \n    void permuteRec(vector<int> nums, int pos) {\n        int n = nums.size();\n        if (pos == n) {\n            res.push_back(nums);\n            return;",
                "url": "https://leetcode.com/problems/permutations-ii/solutions/18596/a-simple-c-solution-in-only-20-lines/",
                "vote_count": "406"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int> > resList;\n    vector<vector<int>> permute(vector<int>& nums) {\n        sort(nums.begin(), nums.end());",
                "url": "https://leetcode.com/problems/permutations-ii/solutions/18596/a-simple-c-solution-in-only-20-lines/",
                "vote_count": "406"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        if(nums.size() == 0) return vector<vector<int>>() ;\n        //no need to sort nums to save time\n        vector<vector<int>> res ;",
                "url": "https://leetcode.com/problems/permutations-ii/solutions/18596/a-simple-c-solution-in-only-20-lines/",
                "vote_count": "406"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N!*KlogK), In worst case when all element of Array(nums) will different then there will\n    be N! permutations and N! function calls and for every permutation we have to check in Hash Table(set) for\n    inserting which take O(KlogK) time .Where N is the size of the array(nums) and ! stands for factorial. K is\n    the worst case size of Array(output). \n\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\n    factorial.\n\n    Solved using Array + BackTracking + Hash Table(set). \n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\nprivate: \n    void permuteUnique(vector<int>& nums, set<vector<int>>& set, vector<int> temp, int index){\n        if(index == nums.size()){\n            set.insert(temp);\n            return;\n        }\n        for(int i=index; i<temp.size(); i++){\n            swap(temp[index], temp[i]);\n            permuteUnique(nums, set, temp, index+1);\n        }\n    }\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        vector<vector<int>> output;\n        vector<int> temp = nums;\n        sort(temp.begin(), temp.end());\n        set<vector<int>> set;\n        permuteUnique(nums, set, temp, 0);\n        for(auto it : set){\n            output.push_back(it);\n        }\n        return output;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N!*K), In worst case when all element of Array(nums) will different then there will be N!\n    permutations and N! function calls and for every permutation we have to check in Array(output) for\n    duplicated which take O(K) time .Where N is the size of the array(nums) and ! stands for factorial. K is the\n    worst case size of Array(output). \n\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\n    factorial.\n\n    Solved using Array + BackTracking. \n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\nprivate: \n    void permuteUnique(vector<int>& nums, vector<vector<int>>& output, vector<int> temp, int index){\n        if(index == nums.size()){\n            output.push_back(temp);\n            return;\n        }\n        for(int i=index; i<temp.size(); i++){\n            swap(temp[index], temp[i]);\n            bool isPresent = find(output.begin(), output.end(), temp) != output.end();\n            if(isPresent){\n                continue;\n            }\n            permuteUnique(nums, output, temp, index+1);\n        }\n    }\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        vector<vector<int>> output;\n        vector<int> temp = nums;\n        sort(temp.begin(), temp.end());\n        permuteUnique(nums, output, temp, 0);\n        return output;\n    }\n};\n\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N!), In worst case when all element of Array(nums) will different then there will be N!\n    permutations and N! function calls. Where N is the size of the array(nums) and ! stands for factorial. \n\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\n    factorial.\n\n    Solved using Array + BackTracking. \n\n*/\n\n\n/***************************************** Approach 3 *****************************************/\n\nclass Solution {\nprivate: \n    void permuteUnique(vector<int>& nums, vector<vector<int>>& output, vector<int> temp, vector<bool>& visited){\n        if(temp.size() == nums.size()){\n            output.push_back(temp);\n            return;\n        }\n        for(int i=0; i<nums.size(); i++){\n            if(visited[i] || i>0 && nums[i] == nums[i-1] && !visited[i-1]) continue;\n            visited[i] = true;\n            temp.push_back(nums[i]);\n            permuteUnique(nums, output, temp, visited);\n            temp.pop_back();\n            visited[i] = false;\n        }\n    }\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> output;\n        vector<int> temp;\n        vector<bool> visited(nums.size(), 0); \n        permuteUnique(nums, output, temp, visited);\n        return output;\n    }\n};",
                "url": "https://leetcode.com/problems/permutations-ii/solutions/3214219/best-c-3-solution-ever-easy-solution-backtracking-one-stop-solution/",
                "vote_count": "13"
            }
        ]
    },
    "47": {
        "question_id": 48,
        "title": "Rotate Image",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/rotate-image",
        "description": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. ",
        "examples": [
            {
                "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
                "output": "[[7,4,1],[8,5,2],[9,6,3]]",
                "explanation": null
            },
            {
                "input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
                "output": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
                "explanation": null
            }
        ],
        "constraints": [
            "n == matrix.length == matrix[i].length",
            "1 <= n <= 20",
            "-1000 <= matrix[i][j] <= 1000"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "/*\n * clockwise rotate\n * first reverse up to down, then swap the symmetry \n * 1 2 3     7 8 9     7 4 1\n * 4 5 6  => 4 5 6  => 8 5 2\n * 7 8 9     1 2 3     9 6 3\n*/\nvoid rotate(vector<vector<int> > &matrix) {\n    reverse(matrix.begin(), matrix.end());\n    for (int i = 0; i < matrix.size(); ++i) {\n        for (int j = i + 1; j < matrix[i].size(); ++j)\n            swap(matrix[i][j], matrix[j][i]);\n    }\n}\n\n/*\n * anticlockwise rotate\n * first reverse left to right, then swap the symmetry\n * 1 2 3     3 2 1     3 6 9\n * 4 5 6  => 6 5 4  => 2 5 8\n * 7 8 9     9 8 7     1 4 7\n*/\nvoid anti_rotate(vector<vector<int> > &matrix) {\n    for (auto vi : matrix) reverse(vi.begin(), vi.end());\n    for (int i = 0; i < matrix.size(); ++i) {\n        for (int j = i + 1; j < matrix[i].size(); ++j)\n            swap(matrix[i][j], matrix[j][i]);\n    }\n}",
                "url": "https://leetcode.com/problems/rotate-image/solutions/18872/a-common-method-to-rotate-the-image/",
                "vote_count": "3606"
            },
            {
                "language": "cpp",
                "code": "public void rotate(int[][] matrix) {\n    int s = 0, e = matrix.length - 1;\n    while(s < e){\n        int[] temp = matrix[s];\n        matrix[s] = matrix[e];\n        matrix[e] = temp;\n        s++; e--;\n    }",
                "url": "https://leetcode.com/problems/rotate-image/solutions/18872/a-common-method-to-rotate-the-image/",
                "vote_count": "3606"
            },
            {
                "language": "javascript",
                "code": "/*\n * clockwise rotate\n * first swap the symmetry (i.e. transpose the matrix), then reverse each row\n * 1 2 3     1 4 7     7 4 1\n * 4 5 6  => 2 5 8  => 8 5 2\n * 7 8 9     3 6 9     9 6 3\n * \n * anti-clockwise rotate",
                "url": "https://leetcode.com/problems/rotate-image/solutions/18872/a-common-method-to-rotate-the-image/",
                "vote_count": "3606"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/rotate-image/solutions/18872/a-common-method-to-rotate-the-image/",
                "vote_count": "3606"
            },
            {
                "language": "python",
                "code": "for (int j = i + 1; j < matrix[i].size(); ++j)",
                "url": "https://leetcode.com/problems/rotate-image/solutions/18872/a-common-method-to-rotate-the-image/",
                "vote_count": "3606"
            },
            {
                "language": "python",
                "code": "for (int j = 0; j < i; ++j)",
                "url": "https://leetcode.com/problems/rotate-image/solutions/18872/a-common-method-to-rotate-the-image/",
                "vote_count": "3606"
            },
            {
                "language": "ruby",
                "code": "",
                "url": "https://leetcode.com/problems/rotate-image/solutions/18872/a-common-method-to-rotate-the-image/",
                "vote_count": "3606"
            },
            {
                "language": "java",
                "code": "/* Clockwise Rotate */\npublic void rotate(int[][] matrix) {\n    if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return;\n    int rows = matrix.length;\n    int cols = matrix[0].length;\n    for(int first=0, last=rows-1; first<last; first++,last--) {\n        int[] tmp = matrix[first];\n        matrix[first] = matrix[last];",
                "url": "https://leetcode.com/problems/rotate-image/solutions/18872/a-common-method-to-rotate-the-image/",
                "vote_count": "3606"
            },
            {
                "language": "cpp",
                "code": "void rotate(vector<vector<int>>& matrix) {\n  // complement of matrix \n        int n = matrix.size();\n        for(int i=0; i<n; ++i) {\n            for(int j=i; j<n; ++j) {\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n\n        for(int i=0; i<n; ++i) {\n  // 2 Pointer approach :  just like we do in 1D array we take left and right pointers\n  // and swap the values and then make those pointers intersect at some point.\n            int left = 0, right = n-1;\n            while(left < right) {\n                swap(matrix[i][left], matrix[i][right]);\n                ++left;\n                --right;\n            }\n        }\n    }",
                "url": "https://leetcode.com/problems/rotate-image/solutions/1449737/rotation-90-code-180-270-360-explanation-inplace-o-1-space/",
                "vote_count": "358"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        # first: transpose\n        n = len(matrix)\n        for i in range(n):",
                "url": "https://leetcode.com/problems/rotate-image/solutions/1449737/rotation-90-code-180-270-360-explanation-inplace-o-1-space/",
                "vote_count": "358"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N^2), Where N is the number of row and column of matrix. Here two nested loops creates\n    the time complexity.\n\n    Space Complexity : O(N^2), temp matrix space.\n\n    Solved using Matrix + Math.\n\n*/\n\n\n/***************************************** Approach 1 Code *****************************************/\n\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        vector<vector<int>> temp(n, vector<int>(m, 0));\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                temp[j][n-1-i] = matrix[i][j];\n\n            }\n        }\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                matrix[i][j] = temp[i][j];\n            }\n        }\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^2), Where N is the number of row and column of matrix. Here two nested loops creates\n    the time complexity.\n\n    Space Complexity : O(1), Constant space.\n\n    Solved using Matrix + Math.\n\n*/\n\n\n/***************************************** Approach 2 Code *****************************************/\n\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        vector<vector<int>> temp(n, vector<int>(m, 0));\n        for(int i=0; i<n; i++){\n            for(int j=0; j<i; j++){\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n        for(int i=0; i<n; i++){\n            reverse(matrix[i].begin(), matrix[i].end());\n        }\n    }\n};",
                "url": "https://leetcode.com/problems/rotate-image/solutions/3173266/best-c-2-solution-in-place-matrix-optimized-solution-one-stop-solution/",
                "vote_count": "55"
            },
            {
                "language": "dart",
                "code": "  1 2 3     1 4 7     7 4 1\n  4 5 6  => 2 5 8  => 8 5 2\n  7 8 9     3 6 9     9 6 3",
                "url": "https://leetcode.com/problems/rotate-image/solutions/2502288/daily-leetcoding-challenge-august-day-30/",
                "vote_count": "14"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        // round 1: \n        // -------------------\n        // tmp <- 1\n        // top left cell matrix[i][j] (1) <- bottom left 7 cell (matrix[n - j - 1][i])\n        // bottom left 7 cell (matrix[n - j - 1][i]) <- bottom right cell 9 (matrix[n - i - 1][n - j - 1])",
                "url": "https://leetcode.com/problems/rotate-image/solutions/2502288/daily-leetcoding-challenge-august-day-30/",
                "vote_count": "14"
            },
            {
                "language": "cpp",
                "code": "    //Taking transpose of matrix\n    \n    for(int i = 0; i<n; i++){\n        for(int j = i+1; j<m; j++){",
                "url": "https://leetcode.com/problems/rotate-image/solutions/2502288/daily-leetcoding-challenge-august-day-30/",
                "vote_count": "14"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        n = len(matrix)\n        for i in range(0, n // 2):\n            for j in range(i, n - i - 1):\n                matrix[i][j], matrix[j][~i], matrix[~i][~j], matrix[~j][i] = \\  # rotates four cells at once\n                matrix[~j][i], matrix[i][j], matrix[j][~i], matrix[~i][~j]      # note: ~i = -(i + 1)",
                "url": "https://leetcode.com/problems/rotate-image/solutions/2502288/daily-leetcoding-challenge-august-day-30/",
                "vote_count": "14"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public void rotate(int[][] m) {\n        int k=m.length;\n        for(int i=0;i<k/2;i++)\n        {\n            for(int j=i;j<k-i-1;j++)\n            {\n                int d=m[i][j];",
                "url": "https://leetcode.com/problems/rotate-image/solutions/2502288/daily-leetcoding-challenge-august-day-30/",
                "vote_count": "14"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        for(int r=0;r<matrix.length/2;r++)\n        {\n            for(int c=r;c<n-1-r;c++)\n            {\n                int tem = matrix[r][c];",
                "url": "https://leetcode.com/problems/rotate-image/solutions/2502288/daily-leetcoding-challenge-august-day-30/",
                "vote_count": "14"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n=matrix.size();\n        for(int i=0;i<matrix.size();i++){\n            for(int j=i+1;j<matrix.size();j++){\n                swap(matrix[i][j],matrix[j][i]);\n            }\n        }",
                "url": "https://leetcode.com/problems/rotate-image/solutions/2502288/daily-leetcoding-challenge-august-day-30/",
                "vote_count": "14"
            },
            {
                "language": "cpp",
                "code": "// 48. Rotate Image\n\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int i = 0, j = matrix.size();\n        int mt_sz = matrix.size();\n        while(i < j){\n            int n = i+(j-i);",
                "url": "https://leetcode.com/problems/rotate-image/solutions/2502288/daily-leetcoding-challenge-august-day-30/",
                "vote_count": "14"
            }
        ]
    },
    "48": {
        "question_id": 49,
        "title": "Group Anagrams",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/group-anagrams",
        "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. ",
        "examples": [
            {
                "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
                "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
                "explanation": null
            },
            {
                "input": "strs = [\"a\"]",
                "output": "[[\"a\"]]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= strs.length <= 10^4",
            "0 <= strs[i].length <= 100",
            "strs[i] consists of lowercase English letters."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": " \nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        \n       vector<vector<string>>ans;\n        \n       unordered_map<string, vector<string>>mp;\n        \n         /*\n                Consider example 1 : strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n                \n                After the below opeartion of for loop map will contain\n                \n                aet -- eat, tea, ate\n                ant -- tan, nat\n                abt -- bat\n        */\n        \n        for(int i = 0 ; i < strs.size() ; i++)\n        {\n            string s = strs[i];\n            sort(strs[i].begin(),strs[i].end());\n            mp[strs[i]].push_back(s);\n        }\n        \n        //now simply put the elements  of second column of map in ans\n        \n        for(auto i : mp)\n        {\n            ans.push_back(i.second);\n        }\n\n        return ans;\n        \n    }\n};",
                "url": "https://leetcode.com/problems/group-anagrams/solutions/2750590/simple-c-detailed-explanation-unordered-map-sorting/",
                "vote_count": "173"
            },
            {
                "language": "cpp",
                "code": "vector<vector<string> > Anagrams(vector<string>& str) {\n        vector<vector<string>> ans;\n        unordered_map<string,vector<string>> mp;\n        \n        for(auto x: str)\n        {\n            string temp = x;\n            sort(x.begin(),x.end());\n            mp[x].push_back(temp);\n        }\n        for(auto x: mp)\n        {\n            ans.push_back(x.second);\n        }\n        return ans;\n    }\n    \n    // for this example the map will be\n    // example:- N = 5\n    // words[] = {act,god,cat,dog,tac}\n    \n    // The map will be:- \n    // string     vector<string>\n    // act        cat tac\n    // god        dog",
                "url": "https://leetcode.com/problems/group-anagrams/solutions/2920518/solution/",
                "vote_count": "17"
            }
        ]
    },
    "49": {
        "question_id": 50,
        "title": "Pow(x, n)",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/powx-n",
        "description": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn). ",
        "examples": [
            {
                "input": "x = 2.00000, n = 10",
                "output": "1024.00000",
                "explanation": null
            },
            {
                "input": "x = 2.10000, n = 3",
                "output": "9.26100",
                "explanation": null
            },
            {
                "input": "x = 2.00000, n = -2",
                "output": "0.25000",
                "explanation": "2-2 = 1/22 = 1/4 = 0.25"
            }
        ],
        "constraints": [
            "-100.0 < x < 100.0",
            "-2^31 <= n <= 2^31-1",
            "n is an integer.",
            "-10^4 <= x^n <= 10^4"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "double pow = 1;\nwhile(n != 0){\n if((n & 1) != 0) // equivalent to if((n % 2) != 0) i.e. multiply only when the number is odd  \n pow *= x;\n\n x *= x;\n n >>>= 1; // equivalent to n = n / 2; i.e. keep dividing the number by 2\n\n}",
                "url": "https://leetcode.com/problems/powx-n/solutions/1337794/java-c-simple-o-log-n-easy-faster-than-100-explained/",
                "vote_count": "435"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N), because we call the recurtion until we multiply the base exponent times. Thus the\n    time complexity is linear.\n\n    Space Complexity : O(N), Recursion stack space.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\nprivate:\n    double power(double x, int n){\n        if(n==0){\n            return 1;\n        }\n        return x * power(x, n-1);\n    }\npublic:\n    double myPow(double x, int n) {\n        if (n == INT_MAX) return (x == 1) ? 1 : (x == -1) ? -1 : 0;\n        if (n == INT_MIN) return (x == 1 || x == -1) ? 1 : 0;\n        double num = 1;\n        if(n>=0){\n            num = power(x, n);\n        }\n        else{\n            n = -n;\n            num = power(x, n);\n            num = 1.0/num;\n        }\n        return num;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N), because we loop until we multiply the base exponent times. Thus the time complexity\n    is linear.\n\n    Space Complexity : O(1), Constant space.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        if (n == INT_MAX) return (x == 1) ? 1 : (x == -1) ? -1 : 0;\n        if (n == INT_MIN) return (x == 1 || x == -1) ? 1 : 0;\n        double num = 1;\n        if(n>=0){\n            while(n>0){\n                num *= x;\n                n--;\n            }\n        }\n        else{\n            n = -n;\n            while(n>0){\n                num *= x;\n                n--;\n            }\n            num = 1.0/num;\n        }\n        return num;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(logN).\n\n    Space Complexity : O(logN), Recursion stack space.\n\n*/\n\n\n/***************************************** Approach 3 *****************************************/\n\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        if(n==0) return 1;\n        if(n<0) {\n            n = abs(n);\n            x = 1/x;\n        }\n        if(n%2==0){\n            return myPow(x*x, n/2);\n        }\n        else{\n            return x*myPow(x, n-1);\n        }\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(logN).\n\n    Space Complexity : O(1), Constant space.\n\n*/\n\n\n/***************************************** Approach 4 *****************************************/\n\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        double num = 1;\n        long long nn = n;\n        if(nn < 0) nn = -nn;\n        while(nn>0){\n            if(nn%2==1){\n                num = num * x;\n                nn--;\n            }\n            else{\n                x = x*x;\n                nn/=2;\n            }\n        }\n        if(n < 0){\n            num = 1.0/num;\n        }\n        return num;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(logN).\n\n    Space Complexity : O(logN), Constant space.\n\n*/\n\n\n/***************************************** Approach 5 *****************************************/\n\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        return pow(x, n);\n    }\n};",
                "url": "https://leetcode.com/problems/powx-n/solutions/3206602/best-c-5-solution-math-recursion-brute-force-optimize-one-stop-solution/",
                "vote_count": "79"
            }
        ]
    },
    "50": {
        "question_id": 51,
        "title": "N-Queens",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/n-queens",
        "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively. ",
        "examples": [
            {
                "input": "n = 4",
                "output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]",
                "explanation": "There exist two distinct solutions to the 4-queens puzzle as shown above"
            },
            {
                "input": "n = 1",
                "output": "[[\"Q\"]]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= n <= 9"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<string> > sols; // 2D vector of strings to store the solutions\n    vector<vector<string>> solveNQueens(int n) {    \n     vector<string> board(n, string(n, '.'));  // creating an empty board\n     solve(board, 0); // calling the recursive function\n     return sols; \n    }\n    bool isSafe(vector<string>& board, int row, int col) {\n     int n = size(board);\n     for(int i = 0; i < n; i++) {\n   // checking if there is a queen in the same column\n      if(board[i][col] == 'Q') return false; \n      // checking if there is a queen in the same diagonal (left to right)\n      if(row - i >= 0 && col - i >= 0 && board[row - i][col - i] == 'Q') return false;\n      if(row - i >= 0 && col + i <  n && board[row - i][col + i] == 'Q') return false;\n      // No need to traverse more since the lower rows below current row attribute will always be safe.\n   /* if(row + i <  n && col - i >= 0 && board[row + i][col - i] == 'Q') return false;\n   if(row + i <  n && col + i <  n && board[row + i][col + i] == 'Q') return false; */\n     }\n     return true;\n    }\n    // Recursive Function (solve) - It basically tries all possible placement of queen for the current row & recurses for it's next row\n    void solve(vector<string>& board, int row) {\n // Base condition. \n    // We reached the last row, so we have a solution so we add it to the solution vector\n     if(row == size(board)) { \n      sols.push_back(board);\n      return;\n     }            \n     // Try placing a queen on each column for a given row. \n        // Explore next row by placing Q at each valid column for the current row\n     for(int col = 0; col < size(board); col++){\n      if(isSafe(board, row, col)) {\n       board[row][col] = 'Q';    // Queen placed on a valid cell\n       solve(board, row + 1);    // Exploring next row\n       board[row][col] = '.';    // Backtracking to get all possible solutions\n      }\n        }\n    }\n};",
                "url": "https://leetcode.com/problems/n-queens/solutions/2107948/c-easy-explanation-w-backtracking/",
                "vote_count": "140"
            },
            {
                "language": "kotlin",
                "code": "//for(int i = 0; i < n; i++) {\nfor(int i = 0; i <= row; i++) {\n // checking if there is a queen in the same column\n        if(board[i][col] == 'Q') return false; \n        // checking if there is a queen in the same diagonal (left to right)\n        if(row - i >= 0 && col - i >= 0 && board[row - i][col - i] == 'Q') return false;",
                "url": "https://leetcode.com/problems/n-queens/solutions/2107948/c-easy-explanation-w-backtracking/",
                "vote_count": "140"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N!), Where N is the size of chess board. For the first row, we check N columns; for the\n    second row, we check the N - 1 column and so on. Hence, the time complexity will be N * (N-1) * (N-2) \u2026. i.e.\n    O(N!).\n    \n    Space Complexity : O(N^2), Vector of string(nQueens) space. Extra space is allocated for the vector of vector\n    string(output), however the output does not count towards the space complexity.\n\n    Solved using Array + Backtracking.\n\n*/\n\nclass Solution {\nprivate: \n    bool isSafePlace(int n, vector<string>& nQueens, int row, int col){\n        for(int i=0; i<n; i++){\n            if(nQueens[i][col] == 'Q'){\n                return false;\n            }\n        }\n        for(int i=row-1, j=col-1; i>=0 && j>=0; i--, j--){\n            if(nQueens[i][j] == 'Q'){\n                return false;\n            }\n        }\n        for(int i=row-1, j=col+1; i>=0 && j<n; i--, j++){\n            if(nQueens[i][j] == 'Q'){\n                return false;\n            }\n        }\n        return true;\n    }\n    void solveNQueens(int n, vector<vector<string>>& output, vector<string>& nQueens, int row){\n        if(row == n){\n            output.push_back(nQueens);\n            return;\n        }\n        for(int col=0; col<n; col++){\n            if(isSafePlace(n, nQueens, row, col)){\n                nQueens[row][col] = 'Q';\n                solveNQueens(n, output, nQueens, row+1);\n                nQueens[row][col] = '.';\n            }\n        }\n    }\npublic:\n    vector<vector<string>> solveNQueens(int n) {\n        vector<vector<string>> output;\n        vector<string> nQueens(n , string(n, '.'));\n        solveNQueens(n, output, nQueens, 0);\n        return output;\n    }\n};",
                "url": "https://leetcode.com/problems/n-queens/solutions/3223270/best-c-solution-backtracking/",
                "vote_count": "18"
            }
        ]
    },
    "51": {
        "question_id": 52,
        "title": "N-Queens II",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/n-queens-ii",
        "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.Given an integer n, return the number of distinct solutions to the n-queens puzzle. ",
        "examples": [
            {
                "input": "n = 4",
                "output": "2",
                "explanation": "There are two distinct solutions to the 4-queens puzzle as shown."
            },
            {
                "input": "n = 1",
                "output": "1",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= n <= 9"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "int totalNQueens(int n) {\n vector<vector<bool>> board(n, vector<bool>(n, false));\n return solve(board, 0);\n}\nbool check(vector<vector<bool>>& board, int row, int col) {\n int n = size(board);\n for(int i = 0; i <= row; i++) {\n  if(board[i][col]) return false; // checking if any queen already placed on same column previously\n  // checking if all diagonals are safe -\n  if(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\n  if(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\n }\n return true;\n}    \nint solve(vector<vector<bool>>& board, int row) {\n if(row == size(board)) return 1;\n int count = 0;\n for(int col = 0; col < size(board); col++)           \n  if(check(board, row, col)){          // check if we can place at (row, col)\n   board[row][col] = true;          // place the queen at (row, col)\n   count += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\n   board[row][col] = false;         // backtrack - remove previously placed queen and try for different columns\n  }                                \n return count;\n}",
                "url": "https://leetcode.com/problems/n-queens-ii/solutions/1237811/short-easy-w-explanation-visualization-backtracking-explained/",
                "vote_count": "94"
            },
            {
                "language": "cpp",
                "code": "int totalNQueens(int n) {\n vector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\n return solve(col, diag, anti_diag, 0);\n}\n   \nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\n int n = size(col), count = 0;\n    if(row == n) return 1;\n for(int column = 0; column < n; column++)           \n  if(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\n   col[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\n   count += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\n   col[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\n  }                                \n return count;\n}",
                "url": "https://leetcode.com/problems/n-queens-ii/solutions/1237811/short-easy-w-explanation-visualization-backtracking-explained/",
                "vote_count": "94"
            },
            {
                "language": "cpp",
                "code": "int totalNQueens(int n) {\n bitset<17> col, diag, anti_diag;\n return solve(col, diag, anti_diag, 0, n);\n}  \nint solve(bitset<17>& col, bitset<17>& diag, bitset<17>& anti_diag, int row, int n) {\n    if(row == n) return 1;\n    int count = 0;\n for(int column = 0; column < n; column++)           \n  if(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){\n   col[column] = diag[row + column] = anti_diag[row - column + n - 1] = 1;    // place at (row, column)\n   count += solve(col, diag, anti_diag, row + 1, n);                          // explore for the next row. \n   col[column] = diag[row + column] = anti_diag[row - column + n - 1] = 0;    // backtrack\n  }                                \n return count;\n}",
                "url": "https://leetcode.com/problems/n-queens-ii/solutions/1237811/short-easy-w-explanation-visualization-backtracking-explained/",
                "vote_count": "94"
            },
            {
                "language": "java",
                "code": "int totalNQueens(int n, int row = 0, int col = 0, int diag = 0, int anti_diag = 0) {\n    if(row == n) return 1;\n    int count = 0;\n for(int column = 0; column < n; column++) {\n        int col_mask = 1 << column, diag_mask = 1 << row + column, anti_diag_mask = 1 << row - column + n - 1;\n        if(!(col & col_mask) && !(diag & diag_mask) && !(anti_diag & anti_diag_mask))\n   count += totalNQueens(n, row + 1, col | col_mask, diag | diag_mask, anti_diag | anti_diag_mask);\n    }\n return count;\n}",
                "url": "https://leetcode.com/problems/n-queens-ii/solutions/1237811/short-easy-w-explanation-visualization-backtracking-explained/",
                "vote_count": "94"
            },
            {
                "language": "csharp",
                "code": "Lets place the first Queen \nstarting states = rw = 00000, ld = 00000, rd = 00000;\n))` = `11111 & (~00000)` = `11111&11111` = `11111` (ie we can place the first queen at any row) \n, we jump on the set bits (set bits are the available cells) by doing",
                "url": "https://leetcode.com/problems/n-queens-ii/solutions/1237811/short-easy-w-explanation-visualization-backtracking-explained/",
                "vote_count": "94"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/n-queens-ii/solutions/1237811/short-easy-w-explanation-visualization-backtracking-explained/",
                "vote_count": "94"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int totalNQueens(int n) {\n vector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\n return solve(col, diag, anti_diag, 0);\n}\n   \nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\n int n = size(col), count = 0;\n    if(row == n) return 1;\n for(int column = 0; column < n; column++)           \n  if(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){ \n   col[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;\n   count += solve(col, diag, anti_diag, row + 1); \n   col[column] = diag[row + column] = anti_diag[row - column + n - 1] = false; \n  }                                \n return count;\n}\n};",
                "url": "https://leetcode.com/problems/n-queens-ii/solutions/2111583/cpp-explained-clean/",
                "vote_count": "70"
            },
            {
                "language": "",
                "code": "N-Quuens I",
                "url": "https://leetcode.com/problems/n-queens-ii/solutions/2111857/java-c-n-queens-1-2-almost-same-solution/",
                "vote_count": "42"
            },
            {
                "language": "",
                "code": "N-Quuens II",
                "url": "https://leetcode.com/problems/n-queens-ii/solutions/2111857/java-c-n-queens-1-2-almost-same-solution/",
                "vote_count": "42"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    int ans = 0;\n    void dfs(int col, vector<int>&left, vector<int>&updig, vector<int>&lowdig, int n){\n        if(col == n){\n            ans++;\n            return;\n        }",
                "url": "https://leetcode.com/problems/n-queens-ii/solutions/2111857/java-c-n-queens-1-2-almost-same-solution/",
                "vote_count": "42"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int totalNQueens(int n) {\n vector<vector<bool>> board(n, vector<bool>(n, false));\n return solve(board, 0);\n    }\n    bool isSafe(vector<vector<bool>>& board, int row, int col) {\n     int n = size(board);\n     for(int i = 0; i <= row; i++) {\n   // checking if any queen already placed on same column previously\n      if(board[i][col]) return false; \n      // checking if all diagonals are safe -\n      if(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\n      if(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\n     }\n     return true;\n    }    \n    int solve(vector<vector<bool>>& board, int row) {\n     if(row == size(board)) return 1;\n     int count = 0;\n     for(int col = 0; col < size(board); col++)           \n      if(isSafe(board, row, col)){          // check if we can place at (row, col)\n       board[row][col] = true;          // place the queen at (row, col)\n       count += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\n    // backtrack - remove previously placed queen and try for different columns\n       board[row][col] = false;         \n      }                                \n     return count;\n    }\n};",
                "url": "https://leetcode.com/problems/n-queens-ii/solutions/2111695/c-n-queens-variation/",
                "vote_count": "30"
            },
            {
                "language": "cpp",
                "code": "int totalNQueens(int n) {\n vector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\n return solve(col, diag, anti_diag, 0);\n}\n   \nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\n int n = size(col), count = 0;\n    if(row == n) return 1;\n for(int column = 0; column < n; column++)           \n  if(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\n   col[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\n   count += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\n   col[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\n  }                                \n return count;\n}",
                "url": "https://leetcode.com/problems/n-queens-ii/solutions/2111695/c-n-queens-variation/",
                "vote_count": "30"
            }
        ]
    },
    "52": {
        "question_id": 53,
        "title": "Maximum Subarray",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/maximum-subarray",
        "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum. ",
        "examples": [
            {
                "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
                "output": "6",
                "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
            },
            {
                "input": "nums = [1]",
                "output": "1",
                "explanation": "The subarray [1] has the largest sum 1."
            },
            {
                "input": "nums = [5,4,-1,7,8]",
                "output": "23",
                "explanation": "The subarray [5,4,-1,7,8] has the largest sum 23."
            }
        ],
        "constraints": [
            "1 <= nums.length <= 10^5",
            "-10^4 <= nums[i] <= 10^4"
        ],
        "solutions": [
            {
                "language": "",
                "code": "maxSubArray(A, i) = maxSubArray(A, i - 1) > 0 ? maxSubArray(A, i - 1) : 0 + A[i]; ",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/20193/dp-solution-some-thoughts/",
                "vote_count": "2561"
            },
            {
                "language": "cpp",
                "code": "public int maxSubArray(int[] A) {\n        int n = A.length;\n        int[] dp = new int[n];//dp[i] means the maximum subarray ending with A[i];\n        dp[0] = A[0];\n        int max = dp[0];\n        \n        for(int i = 1; i < n; i++){\n            dp[i] = A[i] + (dp[i - 1] > 0 ? dp[i - 1] : 0);\n            max = Math.max(max, dp[i]);\n        }\n        \n        return max;\n}",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/20193/dp-solution-some-thoughts/",
                "vote_count": "2561"
            },
            {
                "language": "erlang",
                "code": "sum(0,i) = a[i] + (sum(0,i-1) < 0 ? 0 : sum(0,i-1))",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/20193/dp-solution-some-thoughts/",
                "vote_count": "2561"
            },
            {
                "language": "python",
                "code": "public int maxSubArray(int[] nums) {",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/20193/dp-solution-some-thoughts/",
                "vote_count": "2561"
            },
            {
                "language": "",
                "code": "dp[i] = A[i] + (dp[i - 1] > 0 ? dp[i - 1] : 0);",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/20193/dp-solution-some-thoughts/",
                "vote_count": "2561"
            },
            {
                "language": "javascript",
                "code": "dp[i] = Math.max(A[i] + dp[i - 1] , A[i]);",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/20193/dp-solution-some-thoughts/",
                "vote_count": "2561"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/20193/dp-solution-some-thoughts/",
                "vote_count": "2561"
            },
            {
                "language": "ruby",
                "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        if(nums == null || nums.length ==0)\n            return 0;\n        int runSum = nums[0];\n        int result = runSum; \n        for(int end = 1; end < nums.length; end++) {\n            runSum = runSum+nums[end]>=nums[end] ?    runSum + nums[end] :  nums[end];",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/20193/dp-solution-some-thoughts/",
                "vote_count": "2561"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int n = size(nums), ans = INT_MIN;\n        for(int i = 0; i < n; i++) \n            for(int j = i, curSum = 0; j < n ; j++) \n                curSum += nums[j],\n                ans = max(ans, curSum);        \n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxSubArray(self, nums):\n        ans = -inf\n        for i in range(len(nums)):\n            cur_sum = 0\n            for j in range(i, len(nums)):\n                cur_sum += nums[j]\n                ans = max(ans, cur_sum)\n        return ans",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {    \n        return solve(nums, 0, false);\n    }\n    int solve(vector<int>& A, int i, bool mustPick) {\n  // our subarray must contain atleast 1 element. If mustPick is false at end means no element is picked and this is not valid case\n        if(i >= size(A)) return mustPick ? 0 : -1e5;       \n        if(mustPick)\n            return max(0, A[i] + solve(A, i+1, true));                  // either stop here or choose current element and recurse\n        return max(solve(A, i+1, false), A[i] + solve(A, i+1, true));   // try both choosing current element or not choosing\n    }\n};",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxSubArray(self, nums):\n        def solve(i, must_pick):\n            if i >= len(nums): return 0 if must_pick else -inf\n            return max(nums[i] + solve(i+1, True), 0 if must_pick else solve(i+1, False))\n        return solve(0, False)",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "erlang",
                "code": "                                                f(0, False)                       \ud83d\udd3d => repeated calculations\n                               /             \\ \n                                f(1, False)              f(1, True)\n                         /          \\       \ud83d\udd3d          \\      \ud83d\udd3d\n                    f(2, False)      f(2, True)           f(2, True)\n       /            \\  \ud83d\udd3d       \\   \ud83d\udd3d           \\  \ud83d\udd3d\n      f(3, False)   f(3,True)     f(3, True)           f(3, True)\n      /        \\            \\           \\                  \\\n          ...        ...          ...         ...                ...",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {    \n        vector<vector<int>> dp(2, vector<int>(size(nums), -1));\n        return solve(nums, 0, false, dp);\n    }\n    int solve(vector<int>& A, int i, bool mustPick, vector<vector<int>>& dp) {\n        if(i >= size(A)) return mustPick ? 0 : -1e5;\n        if(dp[mustPick][i] != -1) return dp[mustPick][i];\n        if(mustPick)\n            return dp[mustPick][i] = max(0, A[i] + solve(A, i+1, true, dp));\n        return dp[mustPick][i] = max(solve(A, i+1, false, dp), A[i] + solve(A, i+1, true, dp));\n    }\n};",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxSubArray(self, nums):\n        @cache\n        def solve(i, must_pick):\n            if i >= len(nums): return 0 if must_pick else -inf\n            return max(nums[i] + solve(i+1, True), 0 if must_pick else solve(i+1, False))\n        return solve(0, False)",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        vector<vector<int>> dp(2, vector<int>(size(nums)));\n        dp[0][0] = dp[1][0] = nums[0];\n        for(int i = 1; i < size(nums); i++) {\n            dp[1][i] = max(nums[i], nums[i] + dp[1][i-1]);\n            dp[0][i] = max(dp[0][i-1], dp[1][i]);\n        }\n        return dp[0].back();\n    }\n};",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxSubArray(self, nums):\n        dp = [[0]*len(nums) for i in range(2)]\n        dp[0][0], dp[1][0] = nums[0], nums[0]\n        for i in range(1, len(nums)):\n            dp[1][i] = max(nums[i], nums[i] + dp[1][i-1])\n            dp[0][i] = max(dp[0][i-1], dp[1][i])\n        return dp[0][-1]",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        vector<int> dp(nums);\n        for(int i = 1; i < size(nums); i++) \n            dp[i] = max(nums[i], nums[i] + dp[i-1]);        \n        return *max_element(begin(dp), end(dp));\n    }\n};",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxSubArray(self, nums):\n        dp = [*nums]\n        for i in range(1, len(nums)):\n            dp[i] = max(nums[i], nums[i] + dp[i-1])\n        return max(dp)",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int curMax = 0, maxTillNow = INT_MIN;\n        for(auto c : nums)\n            curMax = max(c, curMax + c),\n            maxTillNow = max(maxTillNow, curMax);\n        return maxTillNow;\n    }\n};",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxSubArray(self, nums):\n        cur_max, max_till_now = 0, -inf\n        for c in nums:\n            cur_max = max(c, cur_max + c)\n            max_till_now = max(max_till_now, cur_max)\n        return max_till_now",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        return maxSubArray(nums, 0, size(nums)-1);\n    }\n    int maxSubArray(vector<int>& A, int L, int R){\n        if(L > R) return INT_MIN;\n        int mid = (L + R) / 2, leftSum = 0, rightSum = 0;\n        // leftSum = max subarray sum in [L, mid-1] and starting from mid-1\n        for(int i = mid-1, curSum = 0; i >= L; i--)\n            curSum += A[i],\n            leftSum=max(leftSum, curSum);\n        // rightSum = max subarray sum in [mid+1, R] and starting from mid+1\n        for(int i = mid+1, curSum = 0; i <= R; i++)\n            curSum += A[i],\n            rightSum = max(rightSum, curSum);        \n  // return max of 3 cases \n        return max({ maxSubArray(A, L, mid-1), maxSubArray(A, mid+1, R), leftSum + A[mid] + rightSum });\n    } \n};",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxSubArray(self, nums):\n        def maxSubArray(A, L, R):\n            if L > R: return -inf\n            mid, left_sum, right_sum, cur_sum = (L + R) // 2, 0, 0, 0\n            for i in range(mid-1, L-1, -1):\n                left_sum = max(left_sum, cur_sum := cur_sum + A[i])\n            cur_sum = 0\n            for i in range(mid+1, R+1):\n                right_sum = max(right_sum, cur_sum := cur_sum + A[i])\n            return max(maxSubArray(A, L, mid-1), maxSubArray(A, mid+1, R), left_sum + A[mid] + right_sum)\n        return maxSubArray(nums, 0, len(nums)-1)",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> pre, suf;\n    int maxSubArray(vector<int>& nums) {\n        pre = suf = nums;\n        for(int i = 1; i < size(nums); i++)  pre[i] += max(0, pre[i-1]);\n        for(int i = size(nums)-2; ~i; i--)   suf[i] += max(0, suf[i+1]);\n        return maxSubArray(nums, 0, size(nums)-1);\n    }\n    int maxSubArray(vector<int>& A, int L, int R){\n        if(L == R) return A[L];\n        int mid = (L + R) / 2;\n        return max({ maxSubArray(A, L, mid), maxSubArray(A, mid+1, R), pre[mid] + suf[mid+1] });\n    } \n};",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxSubArray(self, nums):\n        pre, suf = [*nums], [*nums]\n        for i in range(1, len(nums)):       pre[i] += max(0, pre[i-1])\n        for i in range(len(nums)-2,-1,-1):  suf[i] += max(0, suf[i+1])\n        def maxSubArray(A, L, R):\n            if L == R: return A[L]\n            mid = (L + R) // 2\n            return max(maxSubArray(A, L, mid), maxSubArray(A, mid+1, R), pre[mid] + suf[mid+1])\n        return maxSubArray(nums, 0, len(nums)-1)",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n int maxSubArray(vector<int>& nums) {\n  vector<int> pre = nums;\n  for(int i = 1; i < size(nums); i++) pre[i] += max(0, pre[i-1]);\n  return *max_element(begin(pre), end(pre));\n }\n};",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "cpp",
                "code": "//And also print that subarray\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int n = nums.size();\n        \n        int maxi = nums[0];\n        int start = 0, end = 0; // the final start and end position of the maximum sum subarray\n\"] = \"<<nums[end]<<endl;",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int maxCount=INT_MIN, temp=0;",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595195/c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer/",
                "vote_count": "1682"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int n = nums.length;\n        int max = Integer.MIN_VALUE, sum = 0;\n        \n        for(int i=0;i<n;i++){\n            sum += nums[i];\n            max = Math.max(sum,max);\n            \n            if(sum<0) sum = 0;\n        }\n        \n        return max;\n    }\n}",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595097/java-kadane-s-algorithm-explanation-using-image/",
                "vote_count": "740"
            },
            {
                "language": "cpp",
                "code": "//And also print that subarray\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int n = nums.size();\n        \n        int maxi = nums[0];\n        int start = 0, end = 0; // the final start and end position of the maximum sum subarray\n\"] = \"<<nums[end]<<endl;",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/1595097/java-kadane-s-algorithm-explanation-using-image/",
                "vote_count": "740"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int n = nums.size();\n        //maximumSum will calculate our ans and currSumSubarray will calculate maximum sum subarray till ith position \n        int maximumSum = INT_MIN, currSumSubarray = 0;\n        for (int i = 0; i < n; i++) {\n            currSumSubarray += nums[i]; \n            maximumSum = max(maximumSum, currSumSubarray);\n            //here we are taking max with 0 bcz if currSumSubarray = -1 or any negative value then it again starts with currSumSubarray = 0\n            currSumSubarray = max(currSumSubarray, 0);\n        } \n        return maximumSum;\n    }\n};",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/3227063/kadane-s-algo-o-n-time-and-o-1-space-easiest-beginner-friendly-sol/",
                "vote_count": "75"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int sum = 0 , maxi = Integer.MIN_VALUE;;\n        int i = 0 , j = 0;\n        while(j<nums.length){\n           \n            if(sum < 0 && nums[j] >= sum){\n                sum = 0;\n                i = j;\n            }\n             sum += nums[j];\n            maxi = Math.max(maxi , sum);\n            j++;\n        }\n        return maxi;\n    }\n}",
                "url": "https://leetcode.com/problems/maximum-subarray/solutions/3336498/simple-java-1ms-beats-100-easy-to-understand-look-at-once/",
                "vote_count": "24"
            }
        ]
    },
    "53": {
        "question_id": 54,
        "title": "Spiral Matrix",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/spiral-matrix",
        "description": "Given an m x n matrix, return all elements of the matrix in spiral order. ",
        "examples": [
            {
                "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
                "output": "[1,2,3,6,9,8,7,4,5]",
                "explanation": null
            },
            {
                "input": "matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]",
                "output": "[1,2,3,4,8,12,11,10,9,5,6,7]",
                "explanation": null
            }
        ],
        "constraints": [
            "m == matrix.length",
            "n == matrix[i].length",
            "1 <= m, n <= 10",
            "-100 <= matrix[i][j] <= 100"
        ],
        "solutions": [
            {
                "language": "ruby",
                "code": "def spiralOrder(self, matrix):\n    return matrix and list(matrix.pop(0)) + self.spiralOrder(zip(*matrix)[::-1])",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/20571/1-liner-in-python-ruby/",
                "vote_count": "1521"
            },
            {
                "language": "ruby",
                "code": "def spiralOrder(self, matrix):\n    return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/20571/1-liner-in-python-ruby/",
                "vote_count": "1521"
            },
            {
                "language": "ruby",
                "code": "def spiral_order(matrix)\n  (row = matrix.shift) ? row + spiral_order(matrix.transpose.reverse) : []\nend",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/20571/1-liner-in-python-ruby/",
                "vote_count": "1521"
            },
            {
                "language": "ruby",
                "code": "def spiral_order(matrix)\n  matrix[0] ? matrix.shift + spiral_order(matrix.transpose.reverse) : []\nend",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/20571/1-liner-in-python-ruby/",
                "vote_count": "1521"
            },
            {
                "language": "dart",
                "code": "    |1 2 3|      |6 9|      |8 7|      |4|  =>  |5|  =>  ||\n    |4 5 6|  =>  |5 8|  =>  |5 4|  =>  |5|\n    |7 8 9|      |4 7|",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/20571/1-liner-in-python-ruby/",
                "vote_count": "1521"
            },
            {
                "language": "",
                "code": "    |1 2 3|      |6 9|      |8 7|      |4|      |5|",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/20571/1-liner-in-python-ruby/",
                "vote_count": "1521"
            },
            {
                "language": "csharp",
                "code": "  spiral_order([[1, 2, 3],\n                [4, 5, 6],\n                [7, 8, 9]])\n\n= [1, 2, 3] + spiral_order([[6, 9],\n                            [5, 8],\n                            [4, 7]])\n\n= [1, 2, 3] + [6, 9] + spiral_order([[8, 7],\n                                     [5, 4]])\n\n= [1, 2, 3] + [6, 9] + [8, 7] + spiral_order([[4],\n                                              [5]])\n\n= [1, 2, 3] + [6, 9] + [8, 7] + [4] + spiral_order([[5]])\n\n= [1, 2, 3] + [6, 9] + [8, 7] + [4] + [5] + spiral_order([])\n\n= [1, 2, 3] + [6, 9] + [8, 7] + [4] + [5] + []\n\n= [1, 2, 3, 6, 9, 8, 7, 4, 5]",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/20571/1-liner-in-python-ruby/",
                "vote_count": "1521"
            },
            {
                "language": "ruby",
                "code": "def spiralOrder(self, matrix):\n    return matrix and [*matrix.pop(0)] + self.spiralOrder([*zip(*matrix)][::-1])",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/20571/1-liner-in-python-ruby/",
                "vote_count": "1521"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        while matrix:",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/20571/1-liner-in-python-ruby/",
                "vote_count": "1521"
            },
            {
                "language": "python",
                "code": "    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if (len(matrix) == 0):\n            return []\n        ",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/20571/1-liner-in-python-ruby/",
                "vote_count": "1521"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        \n        List<Integer> res = new ArrayList<Integer>();\n        \n        if (matrix.length == 0) {\n            return res;\n        }\n        \n        int rowBegin = 0;\n        int rowEnd = matrix.length-1;\n        int colBegin = 0;\n        int colEnd = matrix[0].length - 1;\n        \n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\n            // Traverse Right\n            for (int j = colBegin; j <= colEnd; j ++) {\n                res.add(matrix[rowBegin][j]);\n            }\n            rowBegin++;\n            \n            // Traverse Down\n            for (int j = rowBegin; j <= rowEnd; j ++) {\n                res.add(matrix[j][colEnd]);\n            }\n            colEnd--;\n            \n            if (rowBegin <= rowEnd) {\n                // Traverse Left\n                for (int j = colEnd; j >= colBegin; j --) {\n                    res.add(matrix[rowEnd][j]);\n                }\n            }\n            rowEnd--;\n            \n            if (colBegin <= colEnd) {\n                // Traver Up\n                for (int j = rowEnd; j >= rowBegin; j --) {\n                    res.add(matrix[j][colBegin]);\n                }\n            }\n            colBegin ++;\n        }\n        \n        return res;\n    }\n}",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/20599/super-simple-and-easy-to-understand-solution/",
                "vote_count": "1387"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> res = new LinkedList<>(); \n        if (matrix == null || matrix.length == 0) return res;\n        int n = matrix.length, m = matrix[0].length;\n        int up = 0,  down = n - 1;",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/20599/super-simple-and-easy-to-understand-solution/",
                "vote_count": "1387"
            },
            {
                "language": "csharp",
                "code": "public List<Integer> spiralOrder(int[][] matrix) {\n    List<Integer> result = new LinkedList<Integer>();\n    if(matrix == null || matrix.length == 0) return result;\n    \n    int startRow = 0, endRow = matrix.length-1;\n    int startCol = 0, endCol = matrix[0].length - 1;\n    int dir = 0;\n    ",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/20599/super-simple-and-easy-to-understand-solution/",
                "vote_count": "1387"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>> &matrix) {\n        vector<int> result;\n        if (matrix.empty()) return result;\n        result = matrix[0];  // no need to check the first row\n        int dirs[4][2] = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};  // direction offsets",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/20599/super-simple-and-easy-to-understand-solution/",
                "vote_count": "1387"
            },
            {
                "language": "csharp",
                "code": "public List<Integer> spiralOrder(int[][] matrix) {\n    List<Integer> list = new ArrayList<>();\n    if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return list;\n    \n    int rowMin = 0, rowMax = matrix.length-1, colMin = 0, colMax = matrix[0].length-1;\n    while(rowMin <= rowMax && colMin <= colMax) {\n        for(int i=colMin; i<=colMax; i++) list.add(matrix[rowMin][i]);\n        rowMin++;",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/20599/super-simple-and-easy-to-understand-solution/",
                "vote_count": "1387"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> result = new LinkedList<>();\n        if (matrix.length == 0) {\n            return result;\n        }\n        \n        int leftBound = 0;",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/20599/super-simple-and-easy-to-understand-solution/",
                "vote_count": "1387"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not matrix: return []\n        \n        row_start = 0",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/20599/super-simple-and-easy-to-understand-solution/",
                "vote_count": "1387"
            },
            {
                "language": "cpp",
                "code": "vector<int> spiralOrder(vector<vector<int> > &matrix) {\n        vector<int> ans;\n        if (matrix.size() <= 0 || matrix[0].size() <= 0)\n            return ans;\n            \n        int m = matrix.size(), n = matrix[0].size();\n        int x0 = 0, x1 = m - 1; // vertical\n        int y0 = 0, y1 = n - 1; // horizon",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/20599/super-simple-and-easy-to-understand-solution/",
                "vote_count": "1387"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        int n=matrix.size();\n        int m=matrix[0].size();\n        int left=0,right=m-1,bottom=n-1,top=0;\n        int direction=1;\n        vector<int> v;\n        while(left<=right && top<=bottom)\n        {\n            if(direction==1)\n            {\n                for(int i=left;i<=right;i++) v.push_back(matrix[top][i]);\n                direction=2;\n                top++;\n            }\n            \n            else if(direction==2)\n            {\n                for(int i=top;i<=bottom;i++) v.push_back(matrix[i][right]);\n                direction=3;\n                right--;\n            }\n            \n            else if(direction==3)\n            {\n                for(int i=right;i>=left;i--) v.push_back(matrix[bottom][i]);\n                direction=4;\n                bottom--;\n            }\n            \n            else if(direction==4)\n            {\n                for(int i=bottom;i>=top;i--) v.push_back(matrix[i][left]);\n                direction=1;\n                left++;\n            }\n        }\n        return v;\n        \n    }\n};",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/978853/c-0ms-faster-than-100-easy-solution-with-proper-explanation/",
                "vote_count": "368"
            },
            {
                "language": "cpp",
                "code": "public:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int top = 0, left = 0;\n        int bottom = m-1, right = n-1;\n        vector<int> result; \n        while (top<=bottom && left<=right) {",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/978853/c-0ms-faster-than-100-easy-solution-with-proper-explanation/",
                "vote_count": "368"
            },
            {
                "language": "ruby",
                "code": "class Solution(object):\n    def spiralOrder(self, matrix):\n        result = []\n        while matrix:\n            result += matrix.pop(0) # 1\n\n            if matrix and matrix[0]: # 2 \n                for line in matrix:\n                    result.append(line.pop())\n\n            if matrix: # 3\n                result += matrix.pop()[::-1]\n\n            if matrix and matrix[0]: # 4\n                for line in matrix[::-1]:\n                    result.append(line.pop(0))\n        return result",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/3039684/python-solution-explained-step-by-step-with-illustrations/",
                "vote_count": "67"
            },
            {
                "language": "",
                "code": "result += matrix.pop(0)",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/3039684/python-solution-explained-step-by-step-with-illustrations/",
                "vote_count": "67"
            },
            {
                "language": "go",
                "code": "for line in matrix:\n    result.append(line.pop())",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/3039684/python-solution-explained-step-by-step-with-illustrations/",
                "vote_count": "67"
            },
            {
                "language": "ruby",
                "code": "result += matrix.pop()[::-1]",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/3039684/python-solution-explained-step-by-step-with-illustrations/",
                "vote_count": "67"
            },
            {
                "language": "ruby",
                "code": "for line in matrix[::-1]:\n    result.append(line.pop(0))",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/3039684/python-solution-explained-step-by-step-with-illustrations/",
                "vote_count": "67"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        elements = []\n        while matrix:\n            elements += matrix.pop(0) ## top\n            elements += [row.pop() for row in matrix] ## right\n            if not matrix or not matrix[0]: break\n            elements += matrix.pop()[::-1] ## bottom",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/3039684/python-solution-explained-step-by-step-with-illustrations/",
                "vote_count": "67"
            },
            {
                "language": "ruby",
                "code": "      while Arr:\n          result += Arr.pop(0)\n    \n          if Arr:\n              for value in Arr:\n                  result.append(value.pop())",
                "url": "https://leetcode.com/problems/spiral-matrix/solutions/3039684/python-solution-explained-step-by-step-with-illustrations/",
                "vote_count": "67"
            }
        ]
    },
    "54": {
        "question_id": 55,
        "title": "Jump Game",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/jump-game",
        "description": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.Return true if you can reach the last index, or false otherwise. ",
        "examples": [
            {
                "input": "nums = [2,3,1,1,4]",
                "output": "true",
                "explanation": "Jump 1 step from index 0 to 1, then 3 steps to the last index."
            },
            {
                "input": "nums = [3,2,1,0,4]",
                "output": "false",
                "explanation": "You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index."
            }
        ],
        "constraints": [
            "1 <= nums.length <= 10^4",
            "0 <= nums[i] <= 10^5"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution {\n    public boolean canJump(int[] nums) {\n     int boundary = 0;\n     for(int i =0;i<=boundary;i++){\n         boundary = Math.max(boundary,i+nums[i]);\n         if(boundary >=nums.length-1)\n         return true;\n     } \n     return false;\n    }\n}",
                "url": "https://leetcode.com/problems/jump-game/solutions/2951773/java-easy-time-o-n-space-o-1/",
                "vote_count": "57"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        dp[n-1]=0;\n        for (int i = n - 2; i >= 0; i--) {\n   if (nums[i] == 0) {\n    dp[i] = Integer.MAX_VALUE;\n   }\n   if (nums[i] > 0) {\n    int min = Integer.MAX_VALUE;\n    for (int j = 1; j <= nums[i] ;j++) {\n     if (i + j < dp.length) {\n      if (dp[i + j] != Integer.MAX_VALUE)\n                            min = Math.min(min, dp[i + j]);\n      else \n                            dp[i]=Integer.MAX_VALUE;\n      \n     }else{\n                        dp[i] = 1;\n                        break;\n                    }\n    }\n    if(min != Integer.MAX_VALUE)dp[i]=min+1;\n            }\n        }\n         return dp[0]!=Integer.MAX_VALUE;\n    }\n}",
                "url": "https://leetcode.com/problems/jump-game/solutions/2951773/java-easy-time-o-n-space-o-1/",
                "vote_count": "57"
            },
            {
                "language": "go",
                "code": "class Solution {\n    public boolean canJump(int[] nums) {\n        int len = nums.length;\n        boolean [] dp = new boolean[len];\n        dp[len-1] = true;\n        for(int i=len-1; i>=0; i--){\n            for(int j = 1; j<=nums[i]; j++){\n                System.out.println(j+\"||\"+i);\n                dp[i]=(i+j<len-1)?dp[i+j]: true;\n                if(dp[i])break;\n            }\n        }\n        return dp[0];\n    }\n}",
                "url": "https://leetcode.com/problems/jump-game/solutions/2951773/java-easy-time-o-n-space-o-1/",
                "vote_count": "57"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean canJump(int[] nums) {\n       return helper(nums,0);\n    }\n    public boolean helper(int []nums,int currIndex){\n        int len = nums.length-1;\n        if(currIndex>=len)return true;\n        boolean ans = false;\n        for(int i = nums[currIndex]; i>=1;i--){\n            System.out.println(i+\"||\"+currIndex);\n           ans = helper(nums,currIndex+i);\n           if(ans)break;\n        }\n            System.out.println(\"||\"+currIndex);\n        return ans;\n    }\n}",
                "url": "https://leetcode.com/problems/jump-game/solutions/2951773/java-easy-time-o-n-space-o-1/",
                "vote_count": "57"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def canJump(self, nums, m = 0):\n        return all(i <= m and 1+(m:=max(m,i+n)) for i,n in enumerate(nums))",
                "url": "https://leetcode.com/problems/jump-game/solutions/2833942/python-a-walrus-approved-one-liner/",
                "vote_count": "11"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def canJump_(self, nums: List[int]) -> bool:\n        m = 0\n        for i,n in enumerate(nums):\n            if i > m : return False\n            m = max(m,i+n)\n        return True",
                "url": "https://leetcode.com/problems/jump-game/solutions/2833942/python-a-walrus-approved-one-liner/",
                "vote_count": "11"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean canJump(int[] nums) {\n        int goal = nums.length-1;\n       for(int i = goal-1; i >= 0; i--){\n           if(nums[i]+i >= goal){\n               goal = i;\n           }\n       }\n       return goal == 0;\n    }\n}",
                "url": "https://leetcode.com/problems/jump-game/solutions/3321112/java-solution-1ms-runtime-greedy-approach/",
                "vote_count": "10"
            }
        ]
    },
    "55": {
        "question_id": 56,
        "title": "Merge Intervals",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/merge-intervals",
        "description": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. ",
        "examples": [
            {
                "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
                "output": "[[1,6],[8,10],[15,18]]",
                "explanation": "Since intervals [1,3] and [2,6] overlap, merge them into [1,6]."
            },
            {
                "input": "intervals = [[1,4],[4,5]]",
                "output": "[[1,5]]",
                "explanation": "Intervals [1,4] and [4,5] are considered overlapping."
            }
        ],
        "constraints": [
            "1 <= intervals.length <= 10^4",
            "intervals[i].length == 2",
            "0 <= starti <= endi <= 10^4"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(NlogN), Sorting the array(intervals) costs O(NlogN). Where N is the size of\n    the Vector(intervals).\n\n    Space Complexity : O(1), Constant Space. Extra space is only allocated for the Vector(output)\n    which can go upto size N , however the output does not count towards the space complexity.\n\n    Solved using Array + Sorting.\n\n*/\n\nclass Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        int n = intervals.size();\n        sort(intervals.begin(), intervals.end());\n        vector<vector<int>> output;\n        for(auto interval : intervals){\n            if(output.empty() || output.back()[1] < interval[0]){\n                output.push_back(interval);\n            }\n            else{\n                output.back()[1] = max(output.back()[1], interval[1]);\n            }\n        }\n        return output;\n    }\n};",
                "url": "https://leetcode.com/problems/merge-intervals/solutions/3186112/best-c-solution-ever-sorting-one-stop-solution/",
                "vote_count": "67"
            }
        ]
    },
    "56": {
        "question_id": 57,
        "title": "Insert Interval",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/insert-interval",
        "description": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).Return intervals after the insertion. ",
        "examples": [
            {
                "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
                "output": "[[1,5],[6,9]]",
                "explanation": null
            },
            {
                "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
                "output": "[[1,2],[3,10],[12,16]]",
                "explanation": "Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]."
            }
        ],
        "constraints": [
            "0 <= intervals.length <= 10^4",
            "intervals[i].length == 2",
            "0 <= starti <= endi <= 10^5",
            "intervals is sorted by starti in ascending order.",
            "newInterval.length == 2",
            "0 <= start <= end <= 10^5"
        ],
        "solutions": []
    },
    "57": {
        "question_id": 58,
        "title": "Length of Last Word",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/length-of-last-word",
        "description": "Given a string s consisting of words and spaces, return the length of the last word in the string.A word is a maximal substring consisting of non-space characters only. ",
        "examples": [
            {
                "input": "s = \"Hello World\"",
                "output": "5",
                "explanation": "The last word is \"World\" with length 5."
            },
            {
                "input": "s = \"   fly me   to   the moon  \"",
                "output": "4",
                "explanation": "The last word is \"moon\" with length 4."
            },
            {
                "input": "s = \"luffy is still joyboy\"",
                "output": "6",
                "explanation": "The last word is \"joyboy\" with length 6."
            }
        ],
        "constraints": [
            "1 <= s.length <= 10^4",
            "s consists of only English letters and spaces ' '.",
            "There will be at least one word in s."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int lengthOfLastWord(string s) {\n      stack<char> s1;\n      int count=0;\n      for(int i=0;i<s.size();i++){\n          s1.push(s[i]);\n      }\n//here we push all the element of the string to stack\n\n/*\nnow we will pop() all the blank spaces from the top of stack so \nthat we reach the last later of the last word.\n*/\n\n    while(s1.top()==' ')s1.pop();\n\n/*\nnow we run the while loop util the stack is empty in the case of \nonly one word is there or the blank space comes which seperate the two words.\n\n*/\n\n      while(!s1.empty()&&s1.top()!=' '){\n        count++;\n        s1.pop();\n          \n    }\n// now we itterate the count to count the length of the last word and return  it.\n\n    return count;\n\n    }\n};",
                "url": "https://leetcode.com/problems/length-of-last-word/solutions/3169609/100-beat-0ms-run-time-step-by-step-explanation/",
                "vote_count": "18"
            },
            {
                "language": "cpp",
                "code": "    int lengthOfLastWord(string s) {\n        size_t s_len {s.length()};\n        int length{0};\n        if(s_len == 1){\n            return ++length;\n        }\n        for(size_t i{s_len -1}; i >= 0; --i){\n            if(isalpha(s[i])){",
                "url": "https://leetcode.com/problems/length-of-last-word/solutions/3169609/100-beat-0ms-run-time-step-by-step-explanation/",
                "vote_count": "18"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int lengthOfLastWord(String s) {\n        int length = 0;\n\n        for(int i=s.length()-1 ; i>=0 ; i--)\n        {\n            if(s.charAt(i)!= ' ')\n                length++;\n            else\n                if(length>0) return length;\n        }\n        return length;\n    }\n}",
                "url": "https://leetcode.com/problems/length-of-last-word/solutions/3276701/easy-java-solution-runtime-0ms-reverse-loop/",
                "vote_count": "10"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public int lengthOfLastWord(String s) {\n        if(s.length()==1 && s.charAt(0)!=' '){\n            return 1;\n        }\n        int n=s.length()-1;\n        for(int i=s.length()-1;i>=0;i--){\n            if(s.charAt(i)==' '){\n                if(n-i!=0 && s.charAt(i+1)!=' '){\n                    \n                    return n-i;\n                } \n                else n=i-1;    \n            }\n        }\n        if(s.charAt(0)!=' '){\n            \n            return n+1;\n        }\n        return 0;\n    }\n    \n}",
                "url": "https://leetcode.com/problems/length-of-last-word/solutions/3228879/java-0ms-100-faster-solution/",
                "vote_count": "10"
            }
        ]
    },
    "58": {
        "question_id": 59,
        "title": "Spiral Matrix II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/spiral-matrix-ii",
        "description": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order. ",
        "examples": [
            {
                "input": "n = 3",
                "output": "[[1,2,3],[8,9,4],[7,6,5]]",
                "explanation": null
            },
            {
                "input": "n = 1",
                "output": "[[1]]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= n <= 20"
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "1. Easy C++\n2. Line by Line Explanation with Comments.\n3. Detailed Explanation \u2705\n4. Please Upvote if it helps\u2b06\ufe0f\n5. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \u2b07\ufe0f\n //\ud83d\ude09If you Like the repository don't foget to star & fork the repository\ud83d\ude09",
                "url": "https://leetcode.com/problems/spiral-matrix-ii/solutions/1941068/c-0ms-100-easy-to-understand/",
                "vote_count": "119"
            },
            {
                "language": "cpp",
                "code": "    // \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09Please upvote if it helps \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09\nclass Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        int r1 = 0, r2 = n-1;\n        int c1 = 0, c2 = n-1;\n        int val = 0;\n  \n  // result matrix\n        vector<vector<int>> v(n, vector<int> (n));\n        while(r1 <= r2 && c1 <= c2)\n        {\n            // left to right (row will be fixed)\n            for(int i = c1; i <= c2; ++i)\n                v[r1][i] = ++val;\n    \n    // move down(col will be fixed)\n            for(int i = r1+1; i <= r2; ++i)\n                v[i][c2] = ++val;\n    \n            // move right to left\n            // move  up\n            if(r1 < r2 && c1 < c2)\n            {\n                // move right to left (row will be fixed)\n                for(int i = c2-1; i>c1; --i)\n                    v[r2][i] = ++val;\n     \n     // move up (col will be fixed)\n     for(int i = r2; i>r1; --i) \n                    v[i][c1] = ++val;\n            }\n            ++r1;\n            --r2;\n            ++c1;\n            --c2;\n        }\n        return v;\n    }\n // for github repository link go to my profile.\n};",
                "url": "https://leetcode.com/problems/spiral-matrix-ii/solutions/1941068/c-0ms-100-easy-to-understand/",
                "vote_count": "119"
            },
            {
                "language": "cpp",
                "code": "    int r1=0,r2=n-1;\n    int c1=0,c2=n-1;\n    int val=0;\n    ",
                "url": "https://leetcode.com/problems/spiral-matrix-ii/solutions/1941068/c-0ms-100-easy-to-understand/",
                "vote_count": "119"
            },
            {
                "language": "java",
                "code": "public int[][] generateMatrix(int n) {\n  int[][] matrix = new int[n][n];\n  int rs = 0;\n  int re = matrix.length - 1;\n  int cs = 0;\n  int ce = matrix[0].length - 1;\n  int num = 1;\n  while (rs <= re && cs <= ce) {",
                "url": "https://leetcode.com/problems/spiral-matrix-ii/solutions/1941068/c-0ms-100-easy-to-understand/",
                "vote_count": "119"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    #define vvi vector<vector<int>>\n    #define vi vector<int>\n    \n    vvi generateMatrix(int n) {\n        ",
                "url": "https://leetcode.com/problems/spiral-matrix-ii/solutions/1941068/c-0ms-100-easy-to-understand/",
                "vote_count": "119"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/spiral-matrix-ii/solutions/1941068/c-0ms-100-easy-to-understand/",
                "vote_count": "119"
            },
            {
                "language": "cpp",
                "code": "    int x = 0 ;\n    vector<vector<int>> ans(n,vector<int>(n,0));\n    while(x<n*n){",
                "url": "https://leetcode.com/problems/spiral-matrix-ii/solutions/1941068/c-0ms-100-easy-to-understand/",
                "vote_count": "119"
            }
        ]
    },
    "59": {
        "question_id": 60,
        "title": "Permutation Sequence",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/permutation-sequence",
        "description": "The set [1, 2, 3, ..., n] contains a total of n! unique permutations.By listing and labeling all of the permutations in order, we get the following sequence for n = 3:\"123\"\"132\"\"213\"\"231\"\"312\"\"321\"Given n and k, return the kth permutation sequence. ",
        "examples": [
            {
                "input": "n = 3, k = 3",
                "output": "\"213\"",
                "explanation": null
            },
            {
                "input": "n = 3, k = 1",
                "output": "\"123\"",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= n <= 9",
            "1 <= k <= n!"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "public class Solution {\npublic String getPermutation(int n, int k) {\n    int pos = 0;\n    List<Integer> numbers = new ArrayList<>();\n    int[] factorial = new int[n+1];\n    StringBuilder sb = new StringBuilder();\n    \n    // create an array of factorial lookup\n    int sum = 1;\n    factorial[0] = 1;\n    for(int i=1; i<=n; i++){\n        sum *= i;\n        factorial[i] = sum;\n    }\n    // factorial[] = {1, 1, 2, 6, 24, ... n!}\n    \n    // create a list of numbers to get indices\n    for(int i=1; i<=n; i++){\n        numbers.add(i);\n    }\n    // numbers = {1, 2, 3, 4}\n    \n    k--;\n    \n    for(int i = 1; i <= n; i++){\n        int index = k/factorial[n-i];\n        sb.append(String.valueOf(numbers.get(index)));\n        numbers.remove(index);\n        k-=index*factorial[n-i];\n    }\n    \n    return String.valueOf(sb);\n}",
                "url": "https://leetcode.com/problems/permutation-sequence/solutions/22507/explain-like-i-m-five-java-solution-in-o-n/",
                "vote_count": "1358"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public String getPermutation(int n, int k) {\n        StringBuilder sb = new StringBuilder();\n        ArrayList<Integer> num = new ArrayList<Integer>();\n        int fact = 1;\n        for (int i = 1; i <= n; i++) {\n            fact *= i;\n            num.add(i);",
                "url": "https://leetcode.com/problems/permutation-sequence/solutions/22507/explain-like-i-m-five-java-solution-in-o-n/",
                "vote_count": "1358"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    string getPermutation(int n, int k) {\n        vector<int> v={0};\n        int tmp=1;\n        for(int i=1;i<=n;i++){\n            v.push_back(i);\n            tmp*=i;\n        }\n        string s;\n        cout<<tmp<<\" \";\n        for(int i=n;i>=2;i--){\n            tmp/=i;\n            int fl=(k+tmp-1)/tmp;\n            s.push_back(v[fl]+'0');\n            k-=(fl-1)*tmp;\n            for(int j=fl;j<v.size()-1;j++){\n                v[j]=v[j+1];\n            }\n        }\n        s.push_back(v[1]+'0');   \n        return s;\n    }\n};",
                "url": "https://leetcode.com/problems/permutation-sequence/solutions/2992652/solution/",
                "vote_count": "21"
            }
        ]
    },
    "60": {
        "question_id": 61,
        "title": "Rotate List",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/rotate-list",
        "description": "Given the head of a linked list, rotate the list to the right by k places. ",
        "examples": [
            {
                "input": "head = [1,2,3,4,5], k = 2",
                "output": "[4,5,1,2,3]",
                "explanation": null
            },
            {
                "input": "head = [0,1,2], k = 4",
                "output": "[2,0,1]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is in the range [0, 500].",
            "-100 <= Node.val <= 100",
            "0 <= k <= 2 * 10^9"
        ],
        "solutions": [
            {
                "language": "ruby",
                "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        \n        if not head:\n            return None\n        \n        lastElement = head\n        length = 1\n        # get the length of the list and the last node in the list\n        while ( lastElement.next ):\n            lastElement = lastElement.next\n            length += 1\n\n        # If k is equal to the length of the list then k == 0\n        # ElIf k is greater than the length of the list then k = k % length\n        k = k % length\n            \n        # Set the last node to point to head node\n        # The list is now a circular linked list with last node pointing to first node\n        lastElement.next = head\n        \n        # Traverse the list to get to the node just before the ( length - k )th node.\n        # Example: In 1->2->3->4->5, and k = 2\n        #          we need to get to the Node(3)\n        tempNode = head\n        for _ in range( length - k - 1 ):\n            tempNode = tempNode.next\n        \n        # Get the next node from the tempNode and then set the tempNode.next as None\n        # Example: In 1->2->3->4->5, and k = 2\n        #          tempNode = Node(3)\n        #          answer = Node(3).next => Node(4)\n        #          Node(3).next = None ( cut the linked list from here )\n        answer = tempNode.next\n        tempNode.next = None\n        \n        return answer",
                "url": "https://leetcode.com/problems/rotate-list/solutions/348197/96-faster-simple-python-solution-with-explanation/",
                "vote_count": "273"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if not head or not k: return head\n        \n        last, L = head, 1\n        while last.next:\n            last = last.next\n            L += 1",
                "url": "https://leetcode.com/problems/rotate-list/solutions/348197/96-faster-simple-python-solution-with-explanation/",
                "vote_count": "273"
            },
            {
                "language": "python",
                "code": "        tempNode.next = None`",
                "url": "https://leetcode.com/problems/rotate-list/solutions/348197/96-faster-simple-python-solution-with-explanation/",
                "vote_count": "273"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if(head is None):\n            return\n        start1=head\n        c=0\n        while(start1):\n            c+=1",
                "url": "https://leetcode.com/problems/rotate-list/solutions/348197/96-faster-simple-python-solution-with-explanation/",
                "vote_count": "273"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n       if(!head)\n           return NULL;\n        int n = 1;\n        ListNode* tail = head;\n        while(tail->next){\n            n++;\n            tail = tail->next;\n        }\n        tail->next = head;\n        int sz = n - k % n;\n        for(int i = 0; i < sz; i++){\n            tail = tail->next;\n        }  \n        head = tail->next;\n        tail->next = NULL;\n        return head;\n    }\n};",
                "url": "https://leetcode.com/problems/rotate-list/solutions/3066492/accepted-easy-solution-short-simple-best-method/",
                "vote_count": "11"
            }
        ]
    },
    "61": {
        "question_id": 62,
        "title": "Unique Paths",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/unique-paths",
        "description": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.The test cases are generated so that the answer will be less than or equal to 2 * 109. ",
        "examples": [
            {
                "input": "m = 3, n = 7",
                "output": "28",
                "explanation": null
            },
            {
                "input": "m = 3, n = 2",
                "output": "3",
                "explanation": "From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down"
            }
        ],
        "constraints": [
            "1 <= m, n <= 100"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n, int i = 0, int j = 0) {\n        if(i >= m || j >= n) return 0;                                    // reached out of bounds - invalid\n        if(i == m-1 && j == n-1) return 1;                                // reached the destination - valid solution\n        return uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);     // try both down and right\n    }\n};",
                "url": "https://leetcode.com/problems/unique-paths/solutions/1581998/c-python-5-simple-solutions-w-explanation-optimization-from-brute-force-to-dp-to-math/",
                "vote_count": "668"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def uniquePaths(self, m, n, i=0, j=0):\n        if i >= m or j >= n:      return 0\n        if i == m-1 and j == n-1: return 1\n        return self.uniquePaths(m, n, i+1, j) + self.uniquePaths(m, n, i, j+1)",
                "url": "https://leetcode.com/problems/unique-paths/solutions/1581998/c-python-5-simple-solutions-w-explanation-optimization-from-brute-force-to-dp-to-math/",
                "vote_count": "668"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int dp[101][101]{};\n    int uniquePaths(int m, int n, int i = 0, int j = 0) {\n        if(i >= m || j >= n) return 0;\n        if(i == m-1 && j == n-1) return 1;\n        if(dp[i][j]) return dp[i][j];\n        return dp[i][j] = uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);\n    }\n};",
                "url": "https://leetcode.com/problems/unique-paths/solutions/1581998/c-python-5-simple-solutions-w-explanation-optimization-from-brute-force-to-dp-to-math/",
                "vote_count": "668"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m, vector<int>(n));\n        return dfs(dp, 0, 0);\n    }\n    int dfs(vector<vector<int>>& dp, int i, int j) {\n        if(i >= size(dp)   || j >= size(dp[0]))   return 0;     // out of bounds - invalid\n        if(i == size(dp)-1 && j == size(dp[0])-1) return 1;     // reached end - valid path\n        if(dp[i][j]) return dp[i][j];                           // directly return if already calculated\n        return dp[i][j] = dfs(dp, i+1, j) + dfs(dp, i, j+1);    // store the result in dp[i][j] and then return\n    }\n};",
                "url": "https://leetcode.com/problems/unique-paths/solutions/1581998/c-python-5-simple-solutions-w-explanation-optimization-from-brute-force-to-dp-to-math/",
                "vote_count": "668"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def uniquePaths(self, m, n):\n        @cache\n        def dfs(i, j):\n            if i >= m or j >= n:      return 0\n            if i == m-1 and j == n-1: return 1\n            return dfs(i+1, j) + dfs(i, j+1)\n        return dfs(0, 0)",
                "url": "https://leetcode.com/problems/unique-paths/solutions/1581998/c-python-5-simple-solutions-w-explanation-optimization-from-brute-force-to-dp-to-math/",
                "vote_count": "668"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m, vector<int>(n, 1));\n        for(int i = 1; i < m; i++)\n            for(int j = 1; j < n; j++)\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];   // sum of unique paths ending at adjacent top and left cells\n        return dp[m-1][n-1];         // return unique paths ending at cell (m-1, n-1)\n    }\n};",
                "url": "https://leetcode.com/problems/unique-paths/solutions/1581998/c-python-5-simple-solutions-w-explanation-optimization-from-brute-force-to-dp-to-math/",
                "vote_count": "668"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def uniquePaths(self, m, n):\n        dp = [[1]*n for i in range(m)]\n        for i, j in product(range(1, m), range(1, n)):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[-1][-1]",
                "url": "https://leetcode.com/problems/unique-paths/solutions/1581998/c-python-5-simple-solutions-w-explanation-optimization-from-brute-force-to-dp-to-math/",
                "vote_count": "668"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(2, vector<int>(n,1));\n        for(int i = 1; i < m; i++)\n            for(int j = 1; j < n; j++)\n                dp[i & 1][j] = dp[(i-1) & 1][j] + dp[i & 1][j-1];   // <- &  used to alternate between rows\n        return dp[(m-1) & 1][n-1];\n    }\n};",
                "url": "https://leetcode.com/problems/unique-paths/solutions/1581998/c-python-5-simple-solutions-w-explanation-optimization-from-brute-force-to-dp-to-math/",
                "vote_count": "668"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def uniquePaths(self, m, n):\n        dp = [[1]*n for i in range(2)]\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i&1][j] = dp[(i-1)&1][j] + dp[i&1][j-1]\n        return dp[(m-1)&1][-1]",
                "url": "https://leetcode.com/problems/unique-paths/solutions/1581998/c-python-5-simple-solutions-w-explanation-optimization-from-brute-force-to-dp-to-math/",
                "vote_count": "668"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<int> dp(n, 1);\n        for(int i = 1; i < m; i++)\n            for(int j = 1; j < n; j++)\n                dp[j] += dp[j-1];   \n        return dp[n-1];\n    }\n};",
                "url": "https://leetcode.com/problems/unique-paths/solutions/1581998/c-python-5-simple-solutions-w-explanation-optimization-from-brute-force-to-dp-to-math/",
                "vote_count": "668"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def uniquePaths(self, m, n):\n        dp = [1]*n\n        for _, j in product(range(1, m), range(1, n)):\n            dp[j] += dp[j-1]\n        return dp[-1]",
                "url": "https://leetcode.com/problems/unique-paths/solutions/1581998/c-python-5-simple-solutions-w-explanation-optimization-from-brute-force-to-dp-to-math/",
                "vote_count": "668"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        long ans = 1;\n        for(int i = m+n-2, j = 1; i >= max(m, n); i--, j++) \n            ans = (ans * i) / j;\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/unique-paths/solutions/1581998/c-python-5-simple-solutions-w-explanation-optimization-from-brute-force-to-dp-to-math/",
                "vote_count": "668"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def uniquePaths(self, m, n):\n        return factorial(m+n-2) // factorial(m-1) // factorial(n-1)",
                "url": "https://leetcode.com/problems/unique-paths/solutions/1581998/c-python-5-simple-solutions-w-explanation-optimization-from-brute-force-to-dp-to-math/",
                "vote_count": "668"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def uniquePaths(self,m,n):\n        ans = 1\n        for i, j in enumerate(range(m + n - 2, max(m,n) - 1, -1)):\n            ans = (ans * j) // (i+1)\n        return ans",
                "url": "https://leetcode.com/problems/unique-paths/solutions/1581998/c-python-5-simple-solutions-w-explanation-optimization-from-brute-force-to-dp-to-math/",
                "vote_count": "668"
            }
        ]
    },
    "62": {
        "question_id": 63,
        "title": "Unique Paths II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/unique-paths-ii",
        "description": "You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.Return the number of possible unique paths that the robot can take to reach the bottom-right corner.The testcases are generated so that the answer will be less than or equal to 2 * 109. ",
        "examples": [
            {
                "input": "obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]",
                "output": "2",
                "explanation": "There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right"
            },
            {
                "input": "obstacleGrid = [[0,1],[0,0]]",
                "output": "1",
                "explanation": null
            }
        ],
        "constraints": [
            "m == obstacleGrid.length",
            "n == obstacleGrid[i].length",
            "1 <= m, n <= 100",
            "obstacleGrid[i][j] is 0 or 1."
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0\n        for i in range(1, m):\n            if obstacleGrid[i][0] == 0:\n                dp[i][0] = dp[i-1][0]\n        for j in range(1, n):\n            if obstacleGrid[0][j] == 0:\n                dp[0][j] = dp[0][j-1]\n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[m-1][n-1]",
                "url": "https://leetcode.com/problems/unique-paths-ii/solutions/3225310/finding-unique-paths-in-a-grid-with-obstacles-a-dynamic-programming-approach/",
                "vote_count": "11"
            }
        ]
    },
    "63": {
        "question_id": 64,
        "title": "Minimum Path Sum",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/minimum-path-sum",
        "description": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.Note: You can only move either down or right at any point in time. ",
        "examples": [
            {
                "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
                "output": "7",
                "explanation": "Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum."
            },
            {
                "input": "grid = [[1,2,3],[4,5,6]]",
                "output": "12",
                "explanation": null
            }
        ],
        "constraints": [
            "m == grid.length",
            "n == grid[i].length",
            "1 <= m, n <= 200",
            "0 <= grid[i][j] <= 100"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n            \n        \n        m, n = len(grid), len(grid[0])\n        \n        for i in range(1, m):\n            grid[i][0] += grid[i-1][0]\n        \n        for i in range(1, n):\n            grid[0][i] += grid[0][i-1]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n        \n        return grid[-1][-1]\n    \n        # An Upvote will be encouraging",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345656/python-java-c-simple-solution-easy-to-understand/",
                "vote_count": "150"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        n=len(grid)\n        m=len(grid[0])\n        for i in range(n):\n            for j in range(m):\n                if i==0:\n                    if j!=0:\n                        grid[i][j]+=grid[i][j-1]\n                elif j==0:\n                    if i!=0:\n                        grid[i][j]+=grid[i-1][j]\n                else:\n                    grid[i][j]+=min(grid[i-1][j],grid[i][j-1])\n        return grid[n-1][m-1]",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345999/python3-c-dp-91-ms-beats-94-21/",
                "vote_count": "47"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int n=grid.size(),m=grid[0].size();\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(i==0 and j!=0) grid[i][j]+=grid[i][j-1];\n                if(j==0 and i!=0) grid[i][j]+=grid[i-1][j];\n                if(i!=0 and j!=0) grid[i][j]+=min(grid[i-1][j],grid[i][j-1]);\n            }\n        }\n        return grid[n-1][m-1];\n    }\n};",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345999/python3-c-dp-91-ms-beats-94-21/",
                "vote_count": "47"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345999/python3-c-dp-91-ms-beats-94-21/",
                "vote_count": "47"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345999/python3-c-dp-91-ms-beats-94-21/",
                "vote_count": "47"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345999/python3-c-dp-91-ms-beats-94-21/",
                "vote_count": "47"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345999/python3-c-dp-91-ms-beats-94-21/",
                "vote_count": "47"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        \n        for (int i = 1; i < m; i++) grid[i][0] += grid[i-1][0];\n        \n        for (int j = 1; j < n; j++) grid[0][j] += grid[0][j-1];\n        \n        for (int i = 1; i < m; i++)\n            for (int j = 1; j < n; j++)\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1]);\n        \n        return grid[m-1][n-1];\n    }\n};",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345863/image-explanation-recursion-dp-4-methods-c-java-python/",
                "vote_count": "32"
            },
            {
                "language": "rust",
                "code": "Thanks for visiting my solution.\ud83d\ude0a Keep Learning\nPlease give my solution an upvote! \ud83d\udc4d\nIt's a simple way to show your appreciation and\nkeep me motivated. Thank you! \ud83d\ude0a",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345894/easy-solutions-in-java-python-and-c-look-at-once/",
                "vote_count": "27"
            },
            {
                "language": "rust",
                "code": "<!-- Assume we need to reach ar[i][j]  -->\n<!-- always check minimum possiblle rach value near by it -->\nar[i][j] = ar[i][j] + min(ar[i-1][j],ar[i][j-1])",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345882/6-ways-to-solve-4-lines-of-codes-c-dp-tle-to-90-beat/",
                "vote_count": "17"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    int fun(vector<vector<int>>& gr, int i, int j ){\n        if(i==gr.size()-1 && j==gr[0].size()-1){\n            return gr[i][j];\n        }\n        if(i==gr.size() || j==gr[0].size()){\n            return 1e8;\n        }\n        int a = fun(gr,i+1,j);\n        int b = fun(gr,i,j+1);\n        return gr[i][j] + min(a,b);\n    }\n\n    int minPathSum(vector<vector<int>>& gr) {\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\n        return fun(gr,0,0);\n    }\n};",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345882/6-ways-to-solve-4-lines-of-codes-c-dp-tle-to-90-beat/",
                "vote_count": "17"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    int fun(vector<vector<int>>& gr, int i, int j  ){\n        if(i==0 && j==0) return gr[i][j];\n        if(i<0 || j<0) return 1e8;\n        return gr[i][j] + min(fun(gr,i-1,j),fun(gr,i,j-1));\n    }\n    int minPathSum(vector<vector<int>>& gr) {\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\n        return fun(gr,gr.size()-1,gr[0].size()-1);\n    }\n};",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345882/6-ways-to-solve-4-lines-of-codes-c-dp-tle-to-90-beat/",
                "vote_count": "17"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    int fun(vector<vector<int>>& gr, int i, int j ,vector<vector<int>> &dp ){\n        if(i==0 && j==0) return gr[i][j];\n\n        if(i<0 || j<0)  return 1e8;\n\n        if(dp[i][j] != -1) return dp[i][j];\n        \n        return dp[i][j] = gr[i][j] + min(fun(gr,i-1,j,dp),fun(gr,i,j-1,dp));\n    }\n\n    int minPathSum(vector<vector<int>>& gr) {\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\n        return fun(gr,gr.size()-1,gr[0].size()-1,dp);\n    }\n};",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345882/6-ways-to-solve-4-lines-of-codes-c-dp-tle-to-90-beat/",
                "vote_count": "17"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    int fun(vector<vector<int>>& gr, int i, int j, vector<vector<int>> &dp){\n        if(i==gr.size()-1 && j==gr[0].size()-1){\n            return gr[i][j];\n        }\n        if(i==gr.size() || j==gr[0].size()){\n            return 1e8;\n        }\n        if(dp[i][j] != -1) return dp[i][j];\n        int a = fun(gr,i+1,j,dp);\n        int b = fun(gr,i,j+1,dp);\n        return dp[i][j] = gr[i][j] + min(a,b);\n    }\n\n    int minPathSum(vector<vector<int>>& gr) {\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\n        return fun(gr,0,0,dp);\n    }\n};",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345882/6-ways-to-solve-4-lines-of-codes-c-dp-tle-to-90-beat/",
                "vote_count": "17"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n\n    int minPathSum(vector<vector<int>>& gr) {\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\n        for(int i=0;i<gr.size();i++){\n            for(int j=0; j<gr[0].size();j++){\n                if(i==0 && j==0) dp[i][j] = gr[i][j];\n                else{\n                    int a=1e7,b=1e7;\n                    if(i>0)\n                        a= dp[i-1][j];\n                    if(j>0)\n                        b = dp[i][j-1];\n                    dp[i][j] = gr[i][j] + min(a,b);\n                }\n            }\n        }\n        return dp[gr.size()-1][gr[0].size()-1];\n    }\n};",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345882/6-ways-to-solve-4-lines-of-codes-c-dp-tle-to-90-beat/",
                "vote_count": "17"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& gr) {\n        vector<vector<int>> dp(gr.size(),vector<int>(gr[0].size(),-1));\n        for(int i = gr.size()-1; i>=0;i--){\n            for(int j= gr[0].size()-1;j>=0;j--){\n                if(i==gr.size()-1 && j==gr[0].size()-1) dp[i][j] = gr[i][j];\n                else{\n                    int a= 1e8, b= 1e8;\n                    if(i < gr.size()-1)\n                        a = dp[i+1][j];\n                    if(j < gr[0].size()-1)\n                        b= dp[i][j+1];\n                    dp[i][j]=gr[i][j] + min(a,b);\n                }\n            }\n        }\n        return dp[0][0];\n    }\n};",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345882/6-ways-to-solve-4-lines-of-codes-c-dp-tle-to-90-beat/",
                "vote_count": "17"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int m, n;\n    int solve(vector<vector<int>>&grid, int currRow, int currCol)\n    {\n        if (currRow >= m || currCol >= n) return INT_MAX; //when cell is out of bounds\n        if (currRow == m - 1 && currCol == n - 1) return grid[m - 1][n - 1]; //reached the target\n        \n        int rightMin = solve(grid, currRow, currCol + 1);\n        int downMin = solve(grid, currRow + 1, currCol);\n        int bestChoice = min(rightMin, downMin);\n        \n        return (grid[currRow][currCol] + bestChoice);\n    }\n    int minPathSum(vector<vector<int>>& grid) \n    {\n        m = grid.size(); n = grid[0].size();\n        return solve(grid, 0, 0);\n    }\n};",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345712/complete-intuition-explained-recursion-memoization-tabulation-dp/",
                "vote_count": "12"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int m, n;\n    int solve(vector<vector<int>>&grid, vector<vector<int>>&dp, int currRow, int currCol)\n    {\n        if (currRow >= m || currCol >= n) return INT_MAX; //when cell is out of bounds\n        if (currRow == m - 1 && currCol == n - 1) return grid[m - 1][n - 1]; //reached the target\n        \n        if (dp[currRow][currCol] !=  -1) return dp[currRow][currCol]; //use the already computed result\n        int rightMin = solve(grid, dp, currRow, currCol + 1);\n        int downMin = solve(grid, dp, currRow + 1, currCol);\n        int bestChoice = min(rightMin, downMin);\n        \n        return dp[currRow][currCol] = (grid[currRow][currCol] + bestChoice); //store the result \n    }\n    int minPathSum(vector<vector<int>>& grid) \n    {\n        m = grid.size(); n = grid[0].size();\n        vector<vector<int>>dp(m, vector<int>(n, -1)); \n        //'-1' to denote that subproblem result for that cell is not computed and not stored\n        return solve(grid, dp, 0, 0);\n    }\n};",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345712/complete-intuition-explained-recursion-memoization-tabulation-dp/",
                "vote_count": "12"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) \n    {\n        int m = grid.size(), n = grid[0].size();\n        //traverse from 'bottom->top' and 'right->left'\n        //as for any cell we need computed result from 'down' and 'right'\n        for (int i = m - 1; i >= 0; i--)\n        {\n            for (int j = n - 1; j >= 0; j--)\n            {\n                if (i == m - 1 && j == n - 1) continue;\n                \n                //grid[i][j + 1] and grid[i + 1][j] will already have stored the result of subproblem\n                int rightMin = (j + 1 >= n)? INT_MAX : grid[i][j + 1]; //\n                int downMin = (i + 1 >= m)? INT_MAX : grid[i + 1][j];\n                grid[i][j] = grid[i][j] + (min(rightMin, downMin)); \n                //rather than making a new 'DP' grid store results of subproblems in the same grid\n            }\n        }\n        return grid[0][0];\n        \n    }\n};",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345712/complete-intuition-explained-recursion-memoization-tabulation-dp/",
                "vote_count": "12"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345712/complete-intuition-explained-recursion-memoization-tabulation-dp/",
                "vote_count": "12"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345712/complete-intuition-explained-recursion-memoization-tabulation-dp/",
                "vote_count": "12"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345712/complete-intuition-explained-recursion-memoization-tabulation-dp/",
                "vote_count": "12"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/minimum-path-sum/solutions/3345712/complete-intuition-explained-recursion-memoization-tabulation-dp/",
                "vote_count": "12"
            }
        ]
    },
    "64": {
        "question_id": 65,
        "title": "Valid Number",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/valid-number",
        "description": "A valid number can be split up into these components (in order):A decimal number or an integer.(Optional) An 'e' or 'E', followed by an integer.A decimal number can be split up into these components (in order):(Optional) A sign character (either '+' or '-').One of the following formats:\tOne or more digits, followed by a dot '.'.One or more digits, followed by a dot '.', followed by one or more digits.A dot '.', followed by one or more digits.An integer can be split up into these components (in order):(Optional) A sign character (either '+' or '-').One or more digits.For example, all the following are valid numbers: [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"].Given a string s, return true if s is a valid number. ",
        "examples": [
            {
                "input": "s = \"0\"",
                "output": "true",
                "explanation": null
            },
            {
                "input": "s = \"e\"",
                "output": "false",
                "explanation": null
            },
            {
                "input": "s = \".\"",
                "output": "false",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= s.length <= 20",
            "s consists of only English letters (both uppercase and lowercase), digits (0-9), plus '+', minus '-', or dot '.'."
        ],
        "solutions": [
            {
                "language": "typescript",
                "code": "public boolean isNumber(String s) {\n    s = s.trim();\n    \n    boolean pointSeen = false;\n    boolean eSeen = false;\n    boolean numberSeen = false;\n    boolean numberAfterE = true;\n    for(int i=0; i<s.length(); i++) {\n        if('0' <= s.charAt(i) && s.charAt(i) <= '9') {\n            numberSeen = true;\n            numberAfterE = true;\n        } else if(s.charAt(i) == '.') {\n            if(eSeen || pointSeen) {\n                return false;\n            }\n            pointSeen = true;\n        } else if(s.charAt(i) == 'e') {\n            if(eSeen || !numberSeen) {\n                return false;\n            }\n            numberAfterE = false;\n            eSeen = true;\n        } else if(s.charAt(i) == '-' || s.charAt(i) == '+') {\n            if(i != 0 && s.charAt(i-1) != 'e') {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n    \n    return numberSeen && numberAfterE;\n}",
                "url": "https://leetcode.com/problems/valid-number/solutions/23738/clear-java-solution-with-ifs/",
                "vote_count": "621"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public boolean isNumber(String s) {\n        s = s.trim();\n        boolean pointSeen = false;\n        boolean eSeen = false;\n        boolean numberSeen = false;\n        for(int i=0; i<s.length(); i++) {",
                "url": "https://leetcode.com/problems/valid-number/solutions/23738/clear-java-solution-with-ifs/",
                "vote_count": "621"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public boolean isNumber(String s) {\n        s = s.toLowerCase().trim();\n        boolean dotSeen = false;\n        boolean eSeen   = false;\n        boolean numberBeforeE = false;\n        boolean numberAfterE  = false;\n        for (int i = 0; i < s.length(); i++) {",
                "url": "https://leetcode.com/problems/valid-number/solutions/23738/clear-java-solution-with-ifs/",
                "vote_count": "621"
            },
            {
                "language": "java",
                "code": "public boolean isNumber(String s) {\n        \n        if (s == null || s.trim().length() == 0) return false;\n        \n        boolean seenNum = false;\n        boolean seenE = false;\n        boolean seenD = false;\n        ",
                "url": "https://leetcode.com/problems/valid-number/solutions/23738/clear-java-solution-with-ifs/",
                "vote_count": "621"
            },
            {
                "language": "swift",
                "code": "class Solution {\n    public boolean isNumber(String s) {\n        return s.trim().matches(\"[-+]?(\\\\d+\\\\.?|\\\\.\\\\d+)\\\\d*(e[-+]?\\\\d+)?\");\n    }\n}",
                "url": "https://leetcode.com/problems/valid-number/solutions/23738/clear-java-solution-with-ifs/",
                "vote_count": "621"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        s = s.strip()\n        has_point, has_e, has_number = False, False, False\n        for i in range(len(s)):\n            if s[i].isdigit(): has_number = True\n            elif s[i] == '.':\n                if has_point or has_e: return False",
                "url": "https://leetcode.com/problems/valid-number/solutions/23738/clear-java-solution-with-ifs/",
                "vote_count": "621"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    bool isNumber(string s) {\n        bool dot = false, e = false, numBeforeE = false, numAfterE = false;\n        s = trim(s);\n        for(int i = 0; i < s.size(); i++) {\n            char c = s[i];\n            if(c >= '0' && c <= '9') {",
                "url": "https://leetcode.com/problems/valid-number/solutions/23738/clear-java-solution-with-ifs/",
                "vote_count": "621"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public boolean isNumber(String s) {\n        s = s.trim();\n\n        boolean pointSeen = false;\n        boolean eSeen = false;\n        boolean numberSeen = false;\n        boolean numberAfterE = false;",
                "url": "https://leetcode.com/problems/valid-number/solutions/23738/clear-java-solution-with-ifs/",
                "vote_count": "621"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n  def isNumber(self, s):\n      \"\"\"\n      :type s: str\n      :rtype: bool\n      \"\"\"\n      #define a DFA\n      state = [{}, \n              {'blank': 1, 'sign': 2, 'digit':3, '.':4}, \n              {'digit':3, '.':4},\n              {'digit':3, '.':5, 'e':6, 'blank':9},\n              {'digit':5},\n              {'digit':5, 'e':6, 'blank':9},\n              {'sign':7, 'digit':8},\n              {'digit':8},\n              {'digit':8, 'blank':9},\n              {'blank':9}]\n      currentState = 1\n      for c in s:\n          if c >= '0' and c <= '9':\n              c = 'digit'\n          if c == ' ':\n              c = 'blank'\n          if c in ['+', '-']:\n              c = 'sign'\n          if c not in state[currentState].keys():\n              return False\n          currentState = state[currentState][c]\n      if currentState not in [3,5,8,9]:\n          return False\n      return True",
                "url": "https://leetcode.com/problems/valid-number/solutions/23728/a-simple-solution-in-python-based-on-dfa/",
                "vote_count": "510"
            },
            {
                "language": "",
                "code": "if c not in stat[curretState].keys()",
                "url": "https://leetcode.com/problems/valid-number/solutions/23728/a-simple-solution-in-python-based-on-dfa/",
                "vote_count": "510"
            },
            {
                "language": "",
                "code": "if c not in state[currentState]",
                "url": "https://leetcode.com/problems/valid-number/solutions/23728/a-simple-solution-in-python-based-on-dfa/",
                "vote_count": "510"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        #define DFA state transition tables\n        states = [{},",
                "url": "https://leetcode.com/problems/valid-number/solutions/23728/a-simple-solution-in-python-based-on-dfa/",
                "vote_count": "510"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public boolean isNumber(String s) {\n        Map<Integer,Map<Character,Integer>> state = new HashMap<>();\n        for(int i=0;i<=10;i++) state.put(i,new HashMap<>());        \n        state.get(0).put('-',1); state.get(0).put('+',2); state.get(0).put('d',3); state.get(0).put('.',4); state.get(0).put('.',10);        \n        state.get(1).put('d',3); state.get(1).put('.',10);        \n        state.get(2).put('d',3); state.get(2).put('.',10);        \n        state.get(3).put('d',3); state.get(3).put('.',4); state.get(3).put('e',5);         ",
                "url": "https://leetcode.com/problems/valid-number/solutions/23728/a-simple-solution-in-python-based-on-dfa/",
                "vote_count": "510"
            },
            {
                "language": "cpp",
                "code": "// States\n// 0: initial\n// 1: only dot\n// 2: number\n// 3: sign\n// 4: dot number\n// 5: e\n// 6: e sign",
                "url": "https://leetcode.com/problems/valid-number/solutions/23728/a-simple-solution-in-python-based-on-dfa/",
                "vote_count": "510"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        s = s.strip()\n        met_dot = met_e = met_digit = False\n        for i, char in enumerate(s):\n            if char in ['+', '-']:\n                if i > 0 and s[i-1] != 'e':\n                    return False\n            elif char == '.':\n                if met_dot or met_e: return False\n                met_dot = True\n            elif char == 'e':\n                if met_e or not met_digit:\n                    return False\n                met_e, met_digit = True, False\n            elif char.isdigit():\n                met_digit = True\n            else:\n                return False\n        return met_digit",
                "url": "https://leetcode.com/problems/valid-number/solutions/173977/python-with-simple-explanation/",
                "vote_count": "185"
            },
            {
                "language": "rust",
                "code": "elif char == 'e':  -->  elif char.lower() == 'e':",
                "url": "https://leetcode.com/problems/valid-number/solutions/173977/python-with-simple-explanation/",
                "vote_count": "185"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        n = s.strip()\n        if not n:\n            return False\n        if self.is_an_int(n):",
                "url": "https://leetcode.com/problems/valid-number/solutions/173977/python-with-simple-explanation/",
                "vote_count": "185"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        dot_seen = False\n        digits_seen = False\n        e_seen = False\n        sign_seen = False\n        \n        # O(n)",
                "url": "https://leetcode.com/problems/valid-number/solutions/173977/python-with-simple-explanation/",
                "vote_count": "185"
            },
            {
                "language": "csharp",
                "code": "var isNumber = function(S) {\n    let exp = false, sign = false, num = false, dec = false\n    for (let c of S)\n        if (c >= '0' && c <= '9') num = true     \n        else if (c === 'e' || c === 'E')\n            if (exp || !num) return false\n            else exp = true, sign = false, num = false, dec = false\n        else if (c === '+' || c === '-')\n            if (sign || num || dec) return false\n            else sign = true\n        else if (c === '.')\n            if (dec || exp) return false\n            else dec = true\n        else return false\n    return num\n};",
                "url": "https://leetcode.com/problems/valid-number/solutions/1209315/js-python-java-c-easy-character-conditional-solution-w-explanation/",
                "vote_count": "57"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isNumber(self, S: str) -> bool:    \n        num, exp, sign, dec = False, False, False, False\n        for c in S:\n            if c >= '0' and c <= '9': num = True     \n            elif c == 'e' or c == 'E':\n                if exp or not num: return False\n                else: exp, num, sign, dec = True, False, False, False\n            elif c == '+' or c == '-':\n                if sign or num or dec: return False\n                else: sign = True\n            elif c == '.':\n                if dec or exp: return False\n                else: dec = True\n            else: return False\n        return num",
                "url": "https://leetcode.com/problems/valid-number/solutions/1209315/js-python-java-c-easy-character-conditional-solution-w-explanation/",
                "vote_count": "57"
            },
            {
                "language": "dart",
                "code": "class Solution {\n    public boolean isNumber(String S) {\n        boolean num = false, exp = false, sign = false, dec = false;\n        for (int i = 0; i < S.length(); i++) {\n            char c = S.charAt(i);\n            if (c >= '0' && c <= '9') num = true ;    \n            else if (c == 'e' || c == 'E')\n                if (exp || !num) return false;\n                else {\n                    exp = true;\n                    sign = false;\n                    num = false;\n                    dec = false;\n                }\n            else if (c == '+' || c == '-')\n                if (sign || num || dec) return false;\n                else sign = true;\n            else if (c == '.')\n                if (dec || exp) return false;\n                else dec = true;\n            else return false;\n        }\n        return num;\n    }\n}",
                "url": "https://leetcode.com/problems/valid-number/solutions/1209315/js-python-java-c-easy-character-conditional-solution-w-explanation/",
                "vote_count": "57"
            },
            {
                "language": "dart",
                "code": "class Solution {\npublic:\n    bool isNumber(string S) {\n        bool num = false, exp = false, sign = false, dec = false;\n        for (auto c : S)\n            if (c >= '0' && c <= '9') num = true ;    \n            else if (c == 'e' || c == 'E')\n                if (exp || !num) return false;\n                else exp = true, sign = false, num = false, dec = false;\n            else if (c == '+' || c == '-')\n                if (sign || num || dec) return false;\n                else sign = true;\n            else if (c == '.')\n                if (dec || exp) return false;\n                else dec = true;\n            else return false;\n        return num;\n    }\n};",
                "url": "https://leetcode.com/problems/valid-number/solutions/1209315/js-python-java-c-easy-character-conditional-solution-w-explanation/",
                "vote_count": "57"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    bool isNumber(string s) {\n        int i=0, n=s.size();\n\n        // iterate over sign\n        if(s[i]=='+' || s[i]=='-') i++;\n\n        // checking ending condition\n        if(i>=n) return false;\n        \n        bool beforeInt = false;\n\n        // iterating digits\n        while(s[i]>='0' && s[i]<='9' && i<n){\n            i++;\n            beforeInt = true;\n        }\n\n        // checking ending condition\n        if(i>=n) return true;\n\n        // Passing dot\n        bool dot = false;\n        if(s[i] == '.') {i++; dot = true;}\n\n        // check dot ending condition\n        if(i>=n)\n            if(dot==true && beforeInt==false) return false;\n            else return true;\n        \n        // bool afterInt = false;\n\n        // check digit after dot\n        if(dot) \n        if(beforeInt) {if((s[i]<'0' || s[i]>'9') && (s[i]!='e' && s[i]!='E') ) return false; }\n        else {if(s[i]<'0' || s[i]>'9') return false; }\n\n        // iterate decimals until we reach last indext or e\n        while(i<n && s[i]!='e' && s[i]!='E'){\n            if(s[i]<'0' || s[i]>'9') return false;\n            i++;\n        }\n        if(!dot)\n        if((s[i]=='e' || s[i]=='E') && beforeInt==false) return false;\n        // checking ending condition\n        if(i>=n) return true;\n        \n        i++; // next ot e\n        \n        // iterate sign\n        if(s[i]=='+' || s[i]=='-') i++;\n\n        // checking ending condition\n        if(i>=n) return false;\n\n        bool lastInt = false;\n        // iterate over digits\n        while(s[i]>='0' && s[i]<='9' && i<n){\n            i++;\n            lastInt = true;\n        }\n\n        if(!lastInt) return false;\n\n        if(i>=n) return true;\n        return false;\n    }\n};",
                "url": "https://leetcode.com/problems/valid-number/solutions/3310814/beats-100-c-solution-using-for-loop-only-super-fast-easy-to-understand/",
                "vote_count": "14"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isNumber(string s) {\n        return is_valid_number(s);\n    }\n\nbool is_valid_number(const std::string& s) {\n    if (s.empty()) return false;\n\n    size_t i = 0;\n    if (s[i] == '+' || s[i] == '-') i++;\n\n    bool has_integer_part = false;\n    while (i < s.size() && isdigit(s[i])) {\n        has_integer_part = true;\n        i++;\n    }\n\n    bool has_decimal_part = false;\n    if (i < s.size() && s[i] == '.') {\n        i++;\n        while (i < s.size() && isdigit(s[i])) {\n            has_decimal_part = true;\n            i++;\n        }\n    }\n\n    if (i < s.size() && (s[i] == 'e' || s[i] == 'E')) {\n        i++;\n\n        if (i < s.size() && (s[i] == '+' || s[i] == '-')) i++;\n\n        if (i == s.size() || !isdigit(s[i])) {\n            return false;\n        }\n        while (i < s.size() && isdigit(s[i])) {\n            i++;\n        }\n    }\n    return i == s.size() && (has_integer_part || has_decimal_part);\n}\n};",
                "url": "https://leetcode.com/problems/valid-number/solutions/2992660/solution/",
                "vote_count": "12"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public boolean isNumber(String s) {\n        try{\n            int l=s.length();\n            if(s.equals(\"Infinity\")||s.equals(\"-Infinity\")||s.equals(\"+Infinity\")||s.charAt(l-1)=='f'||s.charAt(l-1)=='d'||s.charAt(l-1)=='D'||s.charAt(l-1)=='F')\n            return false;\n            double x=Double.parseDouble(s);\n            return true;\n        }\n        catch(Exception e){\n            return false;\n        }\n        \n    }\n}",
                "url": "https://leetcode.com/problems/valid-number/solutions/3263628/valid-number-java-super-easy-solution/",
                "vote_count": "11"
            }
        ]
    },
    "65": {
        "question_id": 66,
        "title": "Plus One",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/plus-one",
        "description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.Increment the large integer by one and return the resulting array of digits. ",
        "examples": [
            {
                "input": "digits = [1,2,3]",
                "output": "[1,2,4]",
                "explanation": "The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4]."
            },
            {
                "input": "digits = [4,3,2,1]",
                "output": "[4,3,2,2]",
                "explanation": "The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2]."
            },
            {
                "input": "digits = [9]",
                "output": "[1,0]",
                "explanation": "The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0]."
            }
        ],
        "constraints": [
            "1 <= digits.length <= 100",
            "0 <= digits[i] <= 9",
            "digits does not contain any leading 0's."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "public int[] plusOne(int[] digits) {\n        \n    int n = digits.length;\n    for(int i=n-1; i>=0; i--) {\n        if(digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        }\n        \n        digits[i] = 0;\n    }\n    \n    int[] newNumber = new int [n+1];\n    newNumber[0] = 1;\n    \n    return newNumber;\n}",
                "url": "https://leetcode.com/problems/plus-one/solutions/24082/my-simple-java-solution/",
                "vote_count": "2486"
            },
            {
                "language": "csharp",
                "code": "    public int[] PlusOne(int[] digits) \n    {\n        int carry = 1;\n        int index = digits.Length - 1;\n        while (index >= 0 && carry > 0)\n        {\n            digits[index] = (digits[index] + carry) % 10;\n            carry = digits[index] == 0 ? 1 : 0;",
                "url": "https://leetcode.com/problems/plus-one/solutions/24082/my-simple-java-solution/",
                "vote_count": "2486"
            },
            {
                "language": "cpp",
                "code": "for (int i = digits.length - 1; i >= 0; i--) {\n if (digits[i] < 9) {\n  digits[i]++;\n  return digits;\n }\n digits[i] = 0;\n}\n\ndigits = new int[digits.length + 1];\ndigits[0] = 1;\nreturn digits;",
                "url": "https://leetcode.com/problems/plus-one/solutions/2706861/java-fastest-0ms-runtime-easy-and-elegant-solution/",
                "vote_count": "552"
            },
            {
                "language": "cpp",
                "code": "for (int i = digits.length - 1; i >= 0; i--) {\n if (digits[i] < 9) {\n  digits[i]++;\n  return digits;\n  // starting from extreme right--> if array[i] is less than 9 means can be added with 1\n  // i.e. [ 5,8 ]-->[ 5,9 ] or\n  //      [ 9,4 ]-->[ 9,5 ] or\n  //      [ 6,0 ]-->[ 6,1 ]\n  // and will directly return array\n }\n digits[i] = 0;\n // if array[i] is not less than 9, means it have to be 9 only then digit is changed to 0,\n // and we again revolve around loop to check for number if less than 9 or not\n // i.e. [ 5,9 ]-->[ 5,0 ]-loop->[ 6,0 ] or\n //      [ 1,9,9 ]-->[ 1,9,0 ]-loop->[ 1,0,0 ]-loop->[ 2,0,0 ]\n // and will directly return array\n}\n\n// if all number inside array are 9\n// i.e. [ 9,9,9,9 ] than according to above loop it will become [ 0,0,0,0 ]\n// but we have to make it like this [ 9,9,9,9 ]-->[ 1,0,0,0,0 ]\n\n\n// to make like above we need to make new array of length--> n+1\n// by default new array values are set to -->0 only\n// thus just changed first value of array to 1 and return the array\n\ndigits = new int[digits.length + 1];\ndigits[0] = 1;\nreturn digits;",
                "url": "https://leetcode.com/problems/plus-one/solutions/2706861/java-fastest-0ms-runtime-easy-and-elegant-solution/",
                "vote_count": "552"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& v) {\n        int n = v.size();\n        for(int i = n-1; i >= 0; i--){\n            if(i == n-1)\n                v[i]++;\n            if(v[i] == 10){\n                v[i] = 0;\n                if(i != 0){\n                    v[i-1]++;\n                }\n                else{\n                    v.push_back(0);\n                    v[i] = 1;\n                }\n            }\n        }\n        return v;\n    }\n};",
                "url": "https://leetcode.com/problems/plus-one/solutions/3054321/simple-c-solution-with-good-explanation/",
                "vote_count": "328"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n       int n = digits.size() - 1;\n      \n      for (int i = n; i >= 0; --i)\n      { \n        if (digits[i] == 9)\n            digits[i] = 0;\n      else\n      {  \n          digits[i] += 1;\n          return digits;\n        }\n      }\n      digits.push_back(0);\n      digits[0] = 1;\n      return digits;\n    } \n    \n};",
                "url": "https://leetcode.com/problems/plus-one/solutions/3090372/accepted-easy-solution-short-simple-best-method/",
                "vote_count": "44"
            }
        ]
    },
    "66": {
        "question_id": 67,
        "title": "Add Binary",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/add-binary",
        "description": "Given two binary strings a and b, return their sum as a binary string. ",
        "examples": [
            {
                "input": "a = \"11\", b = \"1\"",
                "output": "\"100\"",
                "explanation": null
            }
        ],
        "constraints": [],
        "solutions": [
            {
                "language": "python",
                "code": "             # IMPORTANT INFO FOR YOU",
                "url": "https://leetcode.com/problems/add-binary/solutions/1679423/well-detailed-explaination-java-c-python-easy-for-mind-to-accept-it/",
                "vote_count": "708"
            },
            {
                "language": "java",
                "code": "{\n// First, create result name string and intially it is empty & in the end we gonna return it as our aswer\n        StringBuilder res = new StringBuilder(); \n        int i = a.length() - 1; // we crete i pointer for string a and we have to start adding from right to left \n        int j = b.length() - 1; // similar pointer j for string b\n        int carry = 0; // we create a carry, as we have to consider it as well",
                "url": "https://leetcode.com/problems/add-binary/solutions/1679423/well-detailed-explaination-java-c-python-easy-for-mind-to-accept-it/",
                "vote_count": "708"
            },
            {
                "language": "cpp",
                "code": "// iterate over the loop until the both condition become false\n        while(i >= 0 || j >= 0){ \n            int sum = carry; // intialise our sum with carry;\n            \n            // Now, we subtract by '0' to convert the numbers from a char type into an int, so we can perform operations on the numbers\n            if(i >= 0) sum += a.charAt(i--) - '0';\n            if(j >= 0) sum += b.charAt(j--) - '0';\n            // taking carry;\n            carry = sum > 1 ? 1 : 0; // getting carry depend on the quotient we get by dividing sum / 2 that will be our carry. Carry could be either 1 or 0 \n   // if sum is 0 res is 1 & then carry would be 0;\n            // if sum is 1 res is 1 & carry would be 0\n            // if sum is 2 res is 0 & carry would be 1\n            // if sum is 3 res is 1 & carry would be 1\n            res.append(sum % 2); // just moduling the sum so, we can get remainder and add it into our result\n        }",
                "url": "https://leetcode.com/problems/add-binary/solutions/1679423/well-detailed-explaination-java-c-python-easy-for-mind-to-accept-it/",
                "vote_count": "708"
            },
            {
                "language": "go",
                "code": "if(carry != 0) res.append(carry); // we gonna add it into res until carry becomes 0;\n        return res.reverse().toString(); // revese the answer we get & convt to string and return by the help of result;",
                "url": "https://leetcode.com/problems/add-binary/solutions/1679423/well-detailed-explaination-java-c-python-easy-for-mind-to-accept-it/",
                "vote_count": "708"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public String addBinary(String a, String b) {\n        StringBuilder res = new StringBuilder();\n        int i = a.length() - 1;\n        int j = b.length() - 1;\n        int carry = 0;\n        while(i >= 0 || j >= 0){\n            int sum = carry;\n            if(i >= 0) sum += a.charAt(i--) - '0';\n            if(j >= 0) sum += b.charAt(j--) - '0';\n            carry = sum > 1 ? 1 : 0;\n            res.append(sum % 2);\n        }\n        if(carry != 0) res.append(carry);\n        return res.reverse().toString();\n    }\n}",
                "url": "https://leetcode.com/problems/add-binary/solutions/1679423/well-detailed-explaination-java-c-python-easy-for-mind-to-accept-it/",
                "vote_count": "708"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string res;\n        int i = a.length() - 1;\n        int j = b.length() - 1;\n        int carry = 0;\n        while(i >= 0 || j >= 0){\n            int sum = carry;\n            if(i >= 0) sum += a[i--] - '0';\n            if(j >= 0) sum += b[j--] - '0';\n            carry = sum > 1 ? 1 : 0;\n            res += to_string(sum % 2);\n        }\n        if(carry) res += to_string(carry);\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};",
                "url": "https://leetcode.com/problems/add-binary/solutions/1679423/well-detailed-explaination-java-c-python-easy-for-mind-to-accept-it/",
                "vote_count": "708"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        res = \"\"\n        i, j, carry = len(a) - 1, len(b) - 1, 0\n        while i >= 0 or j >= 0:\n            sum = carry;\n            if i >= 0 : sum += ord(a[i]) - ord('0') # ord is use to get value of ASCII character\n            if j >= 0 : sum += ord(b[j]) - ord('0')\n            i, j = i - 1, j - 1\n            carry = 1 if sum > 1 else 0;\n            res += str(sum % 2)\n\n        if carry != 0 : res += str(carry);\n        return res[::-1]",
                "url": "https://leetcode.com/problems/add-binary/solutions/1679423/well-detailed-explaination-java-c-python-easy-for-mind-to-accept-it/",
                "vote_count": "708"
            },
            {
                "language": "go",
                "code": "def addBinary(self, a: str, b: str) -> str:\n    # Make a and b in equal length by appding 0 to the start of small string so traversing will be easier\n    diff = abs(len(a)-len(b))\n    a = \"0\"*diff*(len(a)<len(b)) + a\n    b = \"0\"*diff*(len(b)<len(a)) + b\n    \n    n = len(a)\n    res = []",
                "url": "https://leetcode.com/problems/add-binary/solutions/1679423/well-detailed-explaination-java-c-python-easy-for-mind-to-accept-it/",
                "vote_count": "708"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public String addBinary(String a, String b) {\n         int i = a.length() - 1, j = b.length() - 1, c = 0;\n StringBuilder sb = new StringBuilder();\n\n while (i >= 0 || j >= 0 || c == 1) {",
                "url": "https://leetcode.com/problems/add-binary/solutions/1679423/well-detailed-explaination-java-c-python-easy-for-mind-to-accept-it/",
                "vote_count": "708"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n\n    string addBinary(string a, string b) {\n        \n        \n        if(b.size() > a.size()) swap(a,b);\n        \n        \n        while(b.size() < a.size()) b = \"0\" + b;\n\n        int carry = 0;\n\n        string res = \"\";\n\n        for(int i = b.size()-1; i >= 0 ; --i)\n        {\n             \n             if(b[i] == '1' && a[i]=='1')\n             {\n\n                if(carry == 0) res = \"0\" + res;\n                \n                else res = \"1\" + res;\n                    \n                carry = 1;\n             }\n\n             else if(b[i] =='0' && a[i] =='0')\n             {\n\n                if(carry == 0) res = \"0\" + res;\n                 \n                else\n                {\n                    res = \"1\" + res;\n                    carry = 0;\n                }\n             }\n\n             else if((b[i]=='0' && a[i]=='1') || (b[i]=='1' && a[i] == '0'))\n             {\n                 \n                if(carry == 0) res = \"1\" + res;\n                 \n                else res = \"0\" + res;\n                 \n             }\n             \n        }\n        \n        if(carry == 1) res = \"1\" + res;\n        \n        return res;\n    }\n};",
                "url": "https://leetcode.com/problems/add-binary/solutions/3183091/c-explained-beginner-friendly-approach-self-explanatory-clean-code/",
                "vote_count": "115"
            },
            {
                "language": "java",
                "code": "StringBuilder sb = new StringBuilder();\nint carry = 0;\nint i = a.length() - 1;\nint j = b.length() - 1;",
                "url": "https://leetcode.com/problems/add-binary/solutions/3183205/1ms-beats-100-full-explanation-append-reverse-c-java-python3/",
                "vote_count": "85"
            },
            {
                "language": "",
                "code": "                    Please Upvote If You Find It Helpful",
                "url": "https://leetcode.com/problems/add-binary/solutions/3182882/super-easy-solution-full-explanation-c-python3-java-commented/",
                "vote_count": "62"
            }
        ]
    },
    "67": {
        "question_id": 68,
        "title": "Text Justification",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/text-justification",
        "description": "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.For the last line of text, it should be left-justified, and no extra space is inserted between words.Note:A word is defined as a character sequence consisting of non-space characters only.Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.The input array words contains at least one word. ",
        "examples": [
            {
                "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\nOutput:\n[\n\u00a0 \u00a0\"This \u00a0 \u00a0is \u00a0 \u00a0an\",\n\u00a0 \u00a0\"example \u00a0of text\",\n\u00a0 \u00a0\"justification. \u00a0\"\n",
                "output": "ords = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\nOutput:\n[\n\u00a0 \u00a0\"This \u00a0 \u00a0is \u00a0 \u00a0an\",\n\u00a0 \u00a0\"example \u00a0of text\",\n\u00a0 \u00a0\"justification. \u00a0\"\n",
                "explanation": null
            },
            {
                "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\nOutput:\n[\n\u00a0 \"What \u00a0 must \u00a0 be\",\n\u00a0 \"acknowledgment \u00a0\",\n\u00a0 \"shall be \u00a0 \u00a0 \u00a0 \u00a0\"\n]\nExplanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word",
                "output": "ords = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\nOutput:\n[\n\u00a0 \"What \u00a0 must \u00a0 be\",\n\u00a0 \"acknowledgment \u00a0\",\n\u00a0 \"shall be \u00a0 \u00a0 \u00a0 \u00a0\"\n]",
                "explanation": "Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word"
            },
            {
                "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\nOutput:\n[\n\u00a0 \"Science \u00a0is \u00a0what we\",\n  \"understand \u00a0 \u00a0 \u00a0well\",\n\u00a0 \"enough to explain to\",\n\u00a0 \"a \u00a0computer. \u00a0Art is\",\n\u00a0 \"everything \u00a0else \u00a0we\",\n\u00a0 \"do \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"\n",
                "output": "ords = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\nOutput:\n[\n\u00a0 \"Science \u00a0is \u00a0what we\",\n  \"understand \u00a0 \u00a0 \u00a0well\",\n\u00a0 \"enough to explain to\",\n\u00a0 \"a \u00a0computer. \u00a0Art is\",\n\u00a0 \"everything \u00a0else \u00a0we\",\n\u00a0 \"do \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"\n",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= words.length <= 300",
            "1 <= words[i].length <= 20",
            "words[i] consists of only English letters and symbols.",
            "1 <= maxWidth <= 100",
            "words[i].length <= maxWidth"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "    public List<String> fullJustify(String[] words, int maxWidth) {\n        int left = 0; List<String> result = new ArrayList<>();\n        \n        while (left < words.length) {\n            int right = findRight(left, words, maxWidth);\n            result.add(justify(left, right, words, maxWidth));\n            left = right + 1;\n        }\n        \n        return result;\n    }\n    \n    private int findRight(int left, String[] words, int maxWidth) {\n        int right = left;\n        int sum = words[right++].length();\n        \n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\n            sum += 1 + words[right++].length();\n            \n        return right - 1;\n    }\n    \n    private String justify(int left, int right, String[] words, int maxWidth) {\n        if (right - left == 0) return padResult(words[left], maxWidth);\n        \n        boolean isLastLine = right == words.length - 1;\n        int numSpaces = right - left;\n        int totalSpace = maxWidth - wordsLength(left, right, words);\n        \n        String space = isLastLine ? \" \" : blank(totalSpace / numSpaces);\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\n        \n        StringBuilder result = new StringBuilder();\n        for (int i = left; i <= right; i++)\n            result.append(words[i])\n                .append(space)\n                .append(remainder-- > 0 ? \" \" : \"\");\n        \n        return padResult(result.toString().trim(), maxWidth);\n    }\n    \n    private int wordsLength(int left, int right, String[] words) {\n        int wordsLength = 0;\n        for (int i = left; i <= right; i++) wordsLength += words[i].length();\n        return wordsLength;\n    }\n    \n    private String padResult(String result, int maxWidth) {\n        return result + blank(maxWidth - result.length());\n    }\n    \n    private String blank(int length) {\n        return new String(new char[length]).replace('\\0', ' ');\n    }",
                "url": "https://leetcode.com/problems/text-justification/solutions/24902/java-easy-to-understand-broken-into-several-functions/",
                "vote_count": "699"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        int left = 0; List<String> result = new ArrayList<>();\n        \n        while (left < words.length) {\n            int right = findRight(left, words, maxWidth);",
                "url": "https://leetcode.com/problems/text-justification/solutions/24902/java-easy-to-understand-broken-into-several-functions/",
                "vote_count": "699"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> ans = new ArrayList<>();\n        int begin = 0;\n        while(begin < words.length){\n            int end = findWordsForLine(begin, maxWidth, words);\n            ans.add(justifyLine(begin, end, maxWidth, words));\n();\n();",
                "url": "https://leetcode.com/problems/text-justification/solutions/24902/java-easy-to-understand-broken-into-several-functions/",
                "vote_count": "699"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> result = new ArrayList<>();\n        \n        int start = 0;\n        int end = 0;\n        while (start < words.length) {\n            end = findLastWordIndex(words, start, maxWidth);",
                "url": "https://leetcode.com/problems/text-justification/solutions/24902/java-easy-to-understand-broken-into-several-functions/",
                "vote_count": "699"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\n        int n=words.size(), left=0, right=0, size=0;\n        vector<string> result;\n        \n        while(left<n){\n            right=findRight(words, maxWidth, left, size);",
                "url": "https://leetcode.com/problems/text-justification/solutions/24902/java-easy-to-understand-broken-into-several-functions/",
                "vote_count": "699"
            },
            {
                "language": "python",
                "code": "def fullJustify(self, words, maxWidth):\n    res, cur, num_of_letters = [], [], 0\n    for w in words:\n        if num_of_letters + len(w) + len(cur) > maxWidth:\n            for i in range(maxWidth - num_of_letters):\n                cur[i%(len(cur)-1 or 1)] += ' '\n            res.append(''.join(cur))\n            cur, num_of_letters = [], 0\n        cur += [w]\n        num_of_letters += len(w)\n    return res + [' '.join(cur).ljust(maxWidth)]",
                "url": "https://leetcode.com/problems/text-justification/solutions/24891/concise-python-solution-10-lines/",
                "vote_count": "516"
            },
            {
                "language": "python",
                "code": "for i in range(maxWidth - num_of_letters):\n                cur[i%(len(cur)-1 or 1)] += ' '",
                "url": "https://leetcode.com/problems/text-justification/solutions/24891/concise-python-solution-10-lines/",
                "vote_count": "516"
            },
            {
                "language": "python",
                "code": "def fullJustify(self, words, maxWidth):\n    res, cur, num_of_letters = [], [], 0\n    for w in words:\n        if num_of_letters + len(w) + len(cur) > maxWidth:\n            if len(cur) == 1:\n                res.append( cur[0] + ' '*(maxWidth - num_of_letters) )\n            else:\n                num_spaces = maxWidth - num_of_letters\n                space_between_words, num_extra_spaces = divmod( num_spaces, len(cur)-1)\n                for i in range(num_extra_spaces):\n                    cur[i] += ' '\n                res.append( (' '*space_between_words).join(cur) )\n            cur, num_of_letters = [], 0\n        cur += [w]\n        num_of_letters += len(w)\n    res.append( ' '.join(cur) + ' '*(maxWidth - num_of_letters - len(cur) + 1) )\n    return res",
                "url": "https://leetcode.com/problems/text-justification/solutions/24891/concise-python-solution-10-lines/",
                "vote_count": "516"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n            \n        result, current_list, num_of_letters = [],[], 0\n        # result -> stores final result output\n        # current_list -> stores list of words which are traversed but not yet added to result\n        # num_of_letters -> stores number of chars corresponding to words in current_list",
                "url": "https://leetcode.com/problems/text-justification/solutions/24891/concise-python-solution-10-lines/",
                "vote_count": "516"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> result = new ArrayList();\n        List<StringBuilder> current = new ArrayList();\n        int numOfLetters = 0;\n        \n        for(String word : words) {\n            StringBuilder w = new StringBuilder(word);",
                "url": "https://leetcode.com/problems/text-justification/solutions/24891/concise-python-solution-10-lines/",
                "vote_count": "516"
            },
            {
                "language": "python",
                "code": "# can put spaces only between letters\nidx = 0 if len(curr_line) == 1 else i % (len(curr_line)-1)\ncurr_line[idx] += ' '",
                "url": "https://leetcode.com/problems/text-justification/solutions/24891/concise-python-solution-10-lines/",
                "vote_count": "516"
            },
            {
                "language": "python",
                "code": "    def fullJustify(self, words, max_wid: int):\n        res, tmp = [], []\n        char_len = 0\n        for word in words:\n            len_word = len(word)\n            if char_len + len_word + len(tmp) - 1 >= max_wid:\n                st_res = self.make_str(tmp, char_len, max_wid)\n                res.append(st_res)",
                "url": "https://leetcode.com/problems/text-justification/solutions/24891/concise-python-solution-10-lines/",
                "vote_count": "516"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    # round robin for distributing spaces\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        res, cur = [], []\n        num_letters = 0\n        for w in words:\n            # if there isn't enough space this word\n            # num_letters + num_spaces + len_w",
                "url": "https://leetcode.com/problems/text-justification/solutions/24891/concise-python-solution-10-lines/",
                "vote_count": "516"
            },
            {
                "language": "python",
                "code": "if num_of_letters + len(w) + len(cur) > maxWidth:",
                "url": "https://leetcode.com/problems/text-justification/solutions/24891/concise-python-solution-10-lines/",
                "vote_count": "516"
            },
            {
                "language": "csharp",
                "code": "vector<string> fullJustify(vector<string> &words, int L) {\n    vector<string> res;\n    for(int i = 0, k, l; i < words.size(); i += k) {\n        for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\n            l += words[i+k].size();\n        }\n        string tmp = words[i];\n        for(int j = 0; j < k - 1; j++) {\n            if(i + k >= words.size()) tmp += \" \";\n            else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), ' ');\n            tmp += words[i+j+1];\n        }\n        tmp += string(L - tmp.size(), ' ');\n        res.push_back(tmp);\n    }\n    return res;\n}",
                "url": "https://leetcode.com/problems/text-justification/solutions/24873/share-my-concise-c-solution-less-than-20-lines/",
                "vote_count": "189"
            },
            {
                "language": "go",
                "code": "public class Solution {\n    public List<String> fullJustify(String[] words, int L) {\n        List<String> list = new LinkedList<String>();\n        \n        for (int i = 0, w; i < words.length; i = w) {\n            int len = -1;",
                "url": "https://leetcode.com/problems/text-justification/solutions/24873/share-my-concise-c-solution-less-than-20-lines/",
                "vote_count": "189"
            },
            {
                "language": "go",
                "code": "public class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> ret = new ArrayList<>();\n        if(words.length == 0 || maxWidth == 0) {\n            ret.add(\"\"); //for some reason OJ expects list with empty string for empty array input\n            return ret;\n        }",
                "url": "https://leetcode.com/problems/text-justification/solutions/24873/share-my-concise-c-solution-less-than-20-lines/",
                "vote_count": "189"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\n        vector<string> result;\n        for(int i = 0, j; i < words.size(); i = j) {\n            int width = 0;\n            for(j = i; j < words.size() && width + words[j].size() + j - i <= maxWidth; j++) {\n                width += words[j].size();",
                "url": "https://leetcode.com/problems/text-justification/solutions/24873/share-my-concise-c-solution-less-than-20-lines/",
                "vote_count": "189"
            },
            {
                "language": "cpp",
                "code": "vector<string> fullJustify(vector<string>& words, int maxWidth)\n{\n    vector<string> justifiedText;\n\n    for (unsigned i = 0, j, lineWordsLength = 0; i < words.size(); i = j, lineWordsLength = 0)\n    {\n        for (j = i; j < words.size() && lineWordsLength + words[j].size() + (j - i) <= maxWidth; lineWordsLength += words[j++].size());\n\n) % (j - k) != 0 ? 1 : 0);",
                "url": "https://leetcode.com/problems/text-justification/solutions/24873/share-my-concise-c-solution-less-than-20-lines/",
                "vote_count": "189"
            },
            {
                "language": "csharp",
                "code": "we have the same idea but your code beats the shit out of mine",
                "url": "https://leetcode.com/problems/text-justification/solutions/24873/share-my-concise-c-solution-less-than-20-lines/",
                "vote_count": "189"
            },
            {
                "language": "java",
                "code": "class Solution { \n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> result = new ArrayList();\n        for(int i=0; i< words.length;){\n            int end = i, lenLine = 0;\n            while(end<words.length && lenLine+words[end].length()<=maxWidth){  //find the no of words for one line\n                lenLine += words[end].length()+1; //1 for space after word, for the last word in the line this space is not needed make sure to subtract it later on\n                end++;",
                "url": "https://leetcode.com/problems/text-justification/solutions/24873/share-my-concise-c-solution-less-than-20-lines/",
                "vote_count": "189"
            },
            {
                "language": "dart",
                "code": "    public List<String> fullJustify(String[] words, int maxWidth) {\n        int l=0, curLength=0, n=words.length;\n        List<String> res = new ArrayList<String>();  \n        \n        for(int i=0;i<=n;i++){                  \n            /* If end of input or adding a new word to the line exceeds maxWidth */\n            if(i == n || curLength+words[i].length()+i-l > maxWidth){ \n                int rs = maxWidth - curLength; // Number of remaining spaces                ",
                "url": "https://leetcode.com/problems/text-justification/solutions/24873/share-my-concise-c-solution-less-than-20-lines/",
                "vote_count": "189"
            },
            {
                "language": "go",
                "code": "public List<String> fullJustify(String[] words, int L) {\n        List<String> res = new ArrayList();\n        for (int i = 0, k; i < words.length; i = k) {\n            // i: the index of word \n            // k: the current index of words in the line",
                "url": "https://leetcode.com/problems/text-justification/solutions/24873/share-my-concise-c-solution-less-than-20-lines/",
                "vote_count": "189"
            },
            {
                "language": "cpp",
                "code": "    vector<string> fullJustify(vector<string>& words, int maxWidth) {\n        vector<string> result; //result vector which will store each line\n        string output = words[0]; //add first word to output string\n        for (int i = 1; i<words.size(); i++){\n            if(output.length() + words[i].length() + 1 <= maxWidth) //+1 for space \n   \n     output += \" \"+words[i]; //add space before adding word\n            \n            else{ \n      //this else will be executed when current line can't add current words \n                output = spaceJustifier(output, maxWidth, 0); //formatting space before adding it to result \n                result.push_back(output);\n                //now we added output to result vector now we can start a new line \n                output = words[i]; //add current word to output(start of new line)\n            }\n        }\n        //the above loop will not add last line to result because last line to will always satify (output.length()+words[i].length()+1<=maxWidth) condition\n        output = spaceJustifier(output, maxWidth, 1); //justifying spaces in last line\n        result.push_back(output); //adding last line to result array\n        return result;\n    }",
                "url": "https://leetcode.com/problems/text-justification/solutions/1243483/intuitive-code-with-explanation/",
                "vote_count": "48"
            },
            {
                "language": "java",
                "code": "string spaceJustifier(string str, int maxWidth, int isLast){\n    //condition if line length is equal to maxWidth so return line as it is.\n    if(str.length() == maxWidth)\n        return str;\n    \n    int spacesInString = 0; //count total spaces in the line \n    for(int i = 0; i<str.length(); i++){\n        if(str[i] == ' ')\n            spacesInString++;\n    }\n    int spacesToBeInserted = maxWidth - str.length(); //spaces to be inserted will be maxWidth - line length\n    //Left Justifier \n    //if line has only 1 word(number of spaces in one word is 0 ex \"hi\") || it's last line then left justify the line\n    if(spacesInString == 0 || isLast == 1){ \n        str.insert(str.length(), spacesToBeInserted,' '); //insert required spaces in right of line ex \"do                  \"\n        return str;\n    }\n    int eachSlot = spacesToBeInserted / spacesInString; \n    int leftOverSpace = spacesToBeInserted % spacesInString; \n    //EXPLANATION FOR EACH SLOT\n    //(spacesToBeInserted / spacesInString) will tell us how much space should we insert at eachSlot\n    //ex - (spacesToBeInserted = 6)/(spaces in string = 2) then each slot will get 3 extra spaces ex - \"hi_hi\" => \"hi_ _ _ _hi_ _ _ _\" will be output\n    \n    //EXPLANATION FOR LEFT OVER SPACE\n    //when the spacesToBeInserted is not divisibe by spacesInString \n    //EX if we spacesToBeInserted = 5 and spaces in string = 2.\n    //since 5/2 is not fully Divisble we will find remainder 5%2 to get left overspace.\n    \n    \n    //EX - so_fine_That_all_the. and maxWidth is 25\n    //      in above case spacesToBeInserted = 5 and spaces in stirng = 4.\n    //      eachSlot will be 5/4 is 1. ie increase spaces by 1 \n    \n    //output will be -> so_ _fine_ _That_ _all_ _the\n    \n    //      since 5/4 is not fully divisible. we will find leftOverSpaces = 5%4 = 1;\n    //      this leftOverSpace will be distributed from left to right ie each slot will get 1,1,1 from left to right\n    \n    //output will be -> so_ _ _fine_ _That_ _all_ _the\n    //                        \u2191\n    //                    leftOverSpace added \n    \n    //if we had more leftoverspaces then it will be added to next slot.\n    \n    for(int i = 0; i<str.length(); i++){\n        if(str[i] == ' ' && (eachSlot > 0 || leftOverSpace >0 )){ //we add spaces till (eachSlot > 0 || leftOverSpace >0)\n            //required noOfSpaces = eachSlot + (leftOverSpace-- > 0 ? 1:0)\n            //((leftOverSpace--) > 0 ? 1:0) will return 1 if leftoverspace>0.\n            //(leftOverSpace--) post decrement\n            int noOfSpaces = eachSlot + ((leftOverSpace--) > 0 ? 1:0);\n            str.insert(i, noOfSpaces , ' '); //inserting spaces\n            i+=noOfSpaces;   //increament count with no of spaces inserted each time \n        }\n        \n    }\n    return str;\n}",
                "url": "https://leetcode.com/problems/text-justification/solutions/1243483/intuitive-code-with-explanation/",
                "vote_count": "48"
            },
            {
                "language": "",
                "code": "",
                "url": "https://leetcode.com/problems/text-justification/solutions/1243483/intuitive-code-with-explanation/",
                "vote_count": "48"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n # Why slots: https://docs.python.org/3/reference/datamodel.html#slots\n    # TLDR: 1. faster attribute access. 2. space savings in memory.\n    # For letcode problems this can save ~ 0.1MB of memory <insert is something meme>\n    __slots__ = ()\n \n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n     # Init return array in which, we'll store justified lines\n        lines = []\n  # current line width\n        width = 0\n  # current line words\n        line = []\n        \n        for word in words:\n   # Gather as many words that will fit under maxWidth restrictions.\n   # Line length is a sum of:\n   # 1) Current word length\n   # 2) Sum of words already in the current line\n   # 3) Number of spaces (each word needs to be separated by at least one space)\n            if (len(word) + width + len(line)) <= maxWidth:\n                width += len(word)\n                line.append(word)\n                continue\n            \n   # If the current line only contains one word, fill the remaining string with spaces.\n            if len(line) == 1:\n    # Use the format function to fill the remaining string with spaces easily and readable.\n    # For letcode police, yes you could do something like:\n    #     line = \" \".join(line)\n    #     line += \" \" * (maxWidth - len(line))\n    #     lines.append(line)\n    # to be more \"raw\", but I see no point in that.\n                lines.append(\n                    \"{0: <{width}}\".format( \" \".join(line), width=maxWidth)\n                )\n            else:\n       # Else calculate how many common spaces and extra spaces are there for the current line.\n    # Example:\n                #  line = ['a', 'computer.', 'Art', 'is']\n    # width left in line equals to: maxWidth - width: 20 - 15 = 5\n    # len(line) - 1 because to the last word, we aren't adding any spaces\n    # Now divmod will give us how many spaces are for all words and how many extra to distribute.\n    # divmod(5, 3) = 1, 2\n    # This means there should be one common space for each word, and for the first two, add one extra space.\n                space, extra = divmod(\n                    maxWidth - width,\n                    len(line) - 1\n                )\n                \n                i = 0\n    # Distribute extra spaces first\n    # There cannot be a case where extra spaces count is greater or equal to number words in the current line.\n                while extra > 0:\n                    line[i] += \" \"\n                    extra -= 1\n                    i += 1\n                \n    # Join line array into a string by common spaces, and append to justified lines.\n                lines.append(\n                    (\" \" * space).join(line)\n                )\n            \n   # Create new line array with the current word in iteration, and reset current line width as well.\n            line = [word]\n            width = len(word)\n        \n  # Last but not least format last line to be left-justified with no extra space inserted between words.\n  # No matter the input, there always be the last line at the end of for loop, which makes things even easier considering the requirement.\n        lines.append(\n            \"{0: <{width}}\".format(\" \".join(line), width=maxWidth)\n        )\n        \n        return lines",
                "url": "https://leetcode.com/problems/text-justification/solutions/1572814/one-pass-easy-to-understand-with-comments-o-n/",
                "vote_count": "37"
            },
            {
                "language": "python",
                "code": "if len(words) == 1:\n      return [words[0].ljust(maxWidth)]",
                "url": "https://leetcode.com/problems/text-justification/solutions/1572814/one-pass-easy-to-understand-with-comments-o-n/",
                "vote_count": "37"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\n        vector<string> res;\n        const int n = words.size();\n        int begin = 0, len = 0;\n        for (int i = 0; i < n; ++i) {\n            if (len + words[i].size() + (i - begin) > maxWidth) {\n                res.emplace_back(connect(words, maxWidth, begin, i, len, false));\n                begin = i;\n                len = 0;\n            }\n            len += words[i].size();\n        }\n        res.emplace_back(connect(words, maxWidth, begin, n, len, true));\n        return res;\n    }\nprivate:\n    string connect(const vector<string>& words, int maxWidth,\n                   int begin, int end, int len,\n                   bool is_last) {\n        string s;\n        int n = end - begin;\n        for (int i = 0; i < n; ++i) {\n            s += words[begin + i];\n            addSpaces(i, n - 1, maxWidth - len, is_last, &s);\n        }\n        if (s.size() < maxWidth) {\n            s.append(maxWidth - s.size(), ' ');\n        }\n        return s;\n    }\n    void addSpaces(int i, int spaceCnt, int maxWidth, bool is_last, string *s) {\n        if (i < spaceCnt) {\n            int spaces = is_last ? 1 : maxWidth / spaceCnt + (i < maxWidth % spaceCnt);\n            s->append(spaces, ' ');\n        }\n    }\n};",
                "url": "https://leetcode.com/problems/text-justification/solutions/2992661/solution/",
                "vote_count": "28"
            },
            {
                "language": "swift",
                "code": "class Solution {\n    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {\n        var res: [String] = []\n        var i = 0\n        \n        while i < words.count {\n            var j = i\n            var tmpLength = 0\n            \n            while j < words.count {\n                tmpLength += words[j].count + ((j > i) ? 1 : 0)\n                \n                if tmpLength <= maxWidth { j += 1 } \n                else {\n                    res.append(stringWithWords(words, maxWidth, i, j))\n                    break\n                }\n            }\n            \n            if j == words.count {\n                res.append(stringWithWords(words, maxWidth, i, j))\n            }\n            i = j\n        }\n        \n        return res\n    }\n\n\n    func stringWithWords(_ words: [String], _ maxWidth: Int, _ i: Int, _ j: Int) -> String {\n        var length = 0\n        var string = \"\"\n        \n        func space(_ n: Int) -> String {\n            var string = \"\"\n            for _ in 0..<n { string += \" \" }\n            return string\n        }\n        \n        func space(_ index: Int, _ count: Int, _ length: Int, _ maxWidth: Int, _ isLast: Bool) -> String {\n            if isLast { return index == count - 1 ? space(maxWidth - length - count + 1) : \" \" }\n            if count == 1 { return space(maxWidth - length) }\n            if index == count - 1 { return \"\" }\n            return space((maxWidth - length) / (count - 1)) + (index < ((maxWidth - length) % (count - 1)) ? \" \" : \"\")\n        }\n\n        for k in i..<j { length += words[k].count }\n        \n        for k in i..<j {\n            string += words[k] + space(k - i, j - i, length, maxWidth, j == words.count)\n        }\n        \n        return string\n    }\n\n}",
                "url": "https://leetcode.com/problems/text-justification/solutions/1915710/100-fastest-swift-solution/",
                "vote_count": "10"
            }
        ]
    },
    "68": {
        "question_id": 69,
        "title": "Sqrt(x)",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/sqrtx",
        "description": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.You must not use any built-in exponent function or operator.For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python. ",
        "examples": [
            {
                "input": "x = 4",
                "output": "2",
                "explanation": "The square root of 4 is 2, so we return 2."
            },
            {
                "input": "x = 8",
                "output": "2",
                "explanation": "The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned."
            }
        ],
        "constraints": [
            "0 <= x <= 2^31 - 1"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int mySqrt(int x) {\n        if (x == 0)\n            return x;\n        int first = 1, last = x;\n        while (first <= last) {\n            int mid = first + (last - first) / 2;\n            // mid * mid == x gives runtime error\n            if (mid  == x / mid)\n                return mid;\n            else if (mid > x / mid) {\n                last = mid - 1;\n            }\n            else {\n                first = mid + 1;\n            }\n        }\n        return last;\n    }\n};",
                "url": "https://leetcode.com/problems/sqrtx/solutions/3212506/c-binary-search-easiest-beginner-friendly-sol/",
                "vote_count": "129"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int mySqrt(int x) {\n        if(x==0) return 0;\n        int i=1;\n        for(;i<=x/i;i++) //using division instead of multiplication to avoid integer overflow\n            if(x/i==i)  return i;\n        return i-1; //returning (i-1) because at some point (i*i) became greater than x and loop stopped!!!\n    }\n}",
                "url": "https://leetcode.com/problems/sqrtx/solutions/3093338/2-approaches-using-linear-search-and-binary-search/",
                "vote_count": "75"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int mySqrt(int x) {\n        if(x==0) return 0;\n        int low = 1,high = x,ans =0;\n        while(low<=high){\n            int mid =low + (high-low)/2;\n            if(x/mid==mid)  return mid;\n            else if(x/mid<mid)   high=mid-1;\n            else {low = mid+1; ans = mid;}\n        }\n        return ans;\n    }\n}",
                "url": "https://leetcode.com/problems/sqrtx/solutions/3093338/2-approaches-using-linear-search-and-binary-search/",
                "vote_count": "75"
            }
        ]
    },
    "69": {
        "question_id": 70,
        "title": "Climbing Stairs",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/climbing-stairs",
        "description": "You are climbing a staircase. It takes n steps to reach the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? ",
        "examples": [
            {
                "input": "n = 2",
                "output": "2",
                "explanation": "There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps"
            },
            {
                "input": "n = 3",
                "output": "3",
                "explanation": "There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step"
            }
        ],
        "constraints": [
            "1 <= n <= 45"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n         def climb(n):\n             if n==1: #only one step option is availble\n                 return 1\n             if n ==2: # two options are possible : to take two 1-stpes or to only take one 2-steps\n                 return 2\n             return climb(n-1) + climb(n-2)\n         return climb(n)\n    ",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/1531764/python-detail-explanation-3-solutions-easy-to-difficult-recursion-dictionary-dp/",
                "vote_count": "474"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        memo ={}\n        memo[1] = 1\n        memo[2] = 2\n        \n        def climb(n):\n            if n in memo: # if the recurssion already done before first take a look-up in the look-up table\n                return memo[n]\n            else:   # Store the recurssion function in the look-up table and reuturn the stored look-up table function\n                memo[n] =  climb(n-1) + climb(n-2)\n                return memo[n]\n        \n        return climb(n)",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/1531764/python-detail-explanation-3-solutions-easy-to-difficult-recursion-dictionary-dp/",
                "vote_count": "474"
            },
            {
                "language": "python",
                "code": "def climb(n):\n    #edge cases\n    if n==0: return 0\n    if n==1: return 1\n    if n==2: return 2\n    dp = [0]*(n+1) # considering zero steps we need n+1 places\n    dp[1]= 1\n    dp[2] = 2\n    for i in range(3,n+1):\n        dp[i] = dp[i-1] +dp[i-2]\n    print(dp)\n    return dp[n]\n  ",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/1531764/python-detail-explanation-3-solutions-easy-to-difficult-recursion-dictionary-dp/",
                "vote_count": "474"
            },
            {
                "language": "kotlin",
                "code": "if n==0: return 0\nif n==1: return  1\nif n==2: return 2",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/1531764/python-detail-explanation-3-solutions-easy-to-difficult-recursion-dictionary-dp/",
                "vote_count": "474"
            },
            {
                "language": "java",
                "code": "    def climbStairs(self, n: int) -> int:\n        if n <= 3: return n\n        a = (1, 2)\n        for i in range(3, n+1):\n            a = (a[1], a[0]+a[1])\n        return a[-1]",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/1531764/python-detail-explanation-3-solutions-easy-to-difficult-recursion-dictionary-dp/",
                "vote_count": "474"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void solve(int n,vector<int> &dp){\n        //base case\n        if(n<=2)\n          return n;\n        \n        if(dp[n]!=-1) \n          return dp[n]; \n        \n        dp[n]=solve(n-1)+solve(n-2);\n        return dp[n];\n    }\n    int climbStairs(int n) {\n        if(n<=2)\n         return n;\n        vector<int> dp(n+1);\n        for(int i=0;i<=n;i++)\n         dp[i]=-1;\n        \n        return solve(n,dp);\n    }\n};",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/3213547/c-beats-100-using-dp-2-ways-recursion-memorization-tabulation/",
                "vote_count": "136"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int climbStairs(int n) {\n        if(n<=2)\n         return n;\n        vector<int> dp(n+1);\n        dp[0]=0;\n        dp[1]=1;\n        dp[2]=2;\n        for(int i=3;i<=n;i++)\n         dp[i]=dp[i-1]+dp[i-2];\n        \n        return dp[n];\n    }\n};",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/3213547/c-beats-100-using-dp-2-ways-recursion-memorization-tabulation/",
                "vote_count": "136"
            },
            {
                "language": "java",
                "code": "def climbStairs(self, n):\n        prev = 1\n        prev2 = 0\n        for i in range(1, n+1):\n            curi = prev + prev2\n            prev2 = prev\n            prev = curi\n        return prev ",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/3213547/c-beats-100-using-dp-2-ways-recursion-memorization-tabulation/",
                "vote_count": "136"
            },
            {
                "language": "java",
                "code": "    def climbStairs(self, n):\n        prev = 1\n        prev2 = 0\n        for i in range(1, n+1):\n            curi = prev + prev2\n            prev2 = prev\n            prev = curi",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/3213547/c-beats-100-using-dp-2-ways-recursion-memorization-tabulation/",
                "vote_count": "136"
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function(n) {\n\n    if (n < 2) {\n\n        return 1;\n    }\n\n    let firstStep = 1;\n\n    let secondStep = 1;\n\n    let thirdStep = 0;\n\n    for (let i=2; i<=n; i++) {\n\n        thirdStep = firstStep + secondStep;\n\n        firstStep = secondStep;\n\n        secondStep = thirdStep;\n    }\n\n    return thirdStep;\n};",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/3137892/easy-js-sol-approachable-code/",
                "vote_count": "65"
            },
            {
                "language": "kotlin",
                "code": "if(n==0 or n==1) {\n    return 1\n}\nreturn f(n-1)+f(n-2)",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/3147963/4-solutions-recursion-memoization-dp-space-optimization/",
                "vote_count": "61"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int findWays(int n){\n        if(n<=1) return 1; //base case\n        return findWays(n-1)+findWays(n-2);\n    }\n\n    int climbStairs(int n) {\n        return findWays(n);\n    }\n};",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/3147963/4-solutions-recursion-memoization-dp-space-optimization/",
                "vote_count": "61"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int findWays(int n, vector<int> &dp)\n    {\n        if (n <= 1) return 1;\n        if (dp[n] != -1) return dp[n];//already solved subproblems\n        return dp[n]=findWays(n - 1, dp) + findWays(n - 2, dp); //store the result of subproblem in dp array\n    }\n    int climbStairs(int n) {\n        vector<int>dp(n+1,-1); //fill all values with -1\n        return findWays(n,dp);\n    }\n};",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/3147963/4-solutions-recursion-memoization-dp-space-optimization/",
                "vote_count": "61"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int climbStairs(int n) {\n         vector<int>dp(n+1,-1);\n         dp[0]=1,dp[1]=1; //base cases\n         for(int i=2;i<=n;++i){\n             dp[i]=dp[i-1]+dp[i-2];\n         }\n        return dp[n];\n    }\n};",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/3147963/4-solutions-recursion-memoization-dp-space-optimization/",
                "vote_count": "61"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int climbStairs(int n) {\n        int prev2=1,prev1=1; //initally at 0th and 1st index\n        \n        for(int i=2;i<=n;i++){\n            int curr=prev1+prev2;\n            prev2=prev1; //update pointers\n            prev1=curr;\n        }\n        return prev1;\n    }\n};",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/3147963/4-solutions-recursion-memoization-dp-space-optimization/",
                "vote_count": "61"
            },
            {
                "language": "cpp",
                "code": "public int climbStairs(int n) {\n        if(n==1) return 1;\n        if(n==2) return 2;\n        return climbStairs(n-2)+climbStairs(n-1);\n    }",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/3091065/java-no-recursion-100-faster/",
                "vote_count": "56"
            },
            {
                "language": "",
                "code": "please upvote, if you found it useful",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/3091065/java-no-recursion-100-faster/",
                "vote_count": "56"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int climbStairs(int n) {\n        if(n==1) return 1;\n        if(n==2) return 2;\n\n        int[] a =  new int[n];\n        a[0]=1;\n        a[1]=2;\n\n        for(int i=2;i<n;i++){\n            a[i]=a[i-1]+a[i-2];\n        }\n        return a[n-1];\n    }\n}",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/3091065/java-no-recursion-100-faster/",
                "vote_count": "56"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/3091065/java-no-recursion-100-faster/",
                "vote_count": "56"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        one,two=1,1\n        for i in range(n-1):\n            temp=one+two\n            one=two\n            two=temp\n        return two\n    #please upvote me it would encourage me alot",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/3306307/dynamic-programming-python3/",
                "vote_count": "28"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int climbStairs(int n) {\n        long fast[] = {1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073};\n\n        return (int)fast[n-1];\n    }\n};",
                "url": "https://leetcode.com/problems/climbing-stairs/solutions/3302571/fastest-possible-solution-c-professors-hate-him/",
                "vote_count": "13"
            }
        ]
    },
    "70": {
        "question_id": 71,
        "title": "Simplify Path",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/simplify-path",
        "description": "Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.The canonical path should have the following format:The path starts with a single slash '/'.Any two directories are separated by a single slash '/'.The path does not end with a trailing '/'.The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')Return the simplified canonical path. ",
        "examples": [
            {
                "input": "path = \"/home/\"",
                "output": "\"/home\"",
                "explanation": "Note that there is no trailing slash after the last directory name."
            },
            {
                "input": "path = \"/../\"",
                "output": "\"/\"",
                "explanation": "Going one level up from the root directory is a no-op, as the root level is the highest level you can go."
            },
            {
                "input": "path = \"/home//foo/\"",
                "output": "\"/home/foo\"",
                "explanation": "In the canonical path, multiple consecutive slashes are replaced by a single one."
            }
        ],
        "constraints": [
            "1 <= path.length <= 3000",
            "path consists of English letters, digits, period '.', slash '/' or '_'.",
            "path is a valid absolute Unix path."
        ],
        "solutions": [
            {
                "language": "typescript",
                "code": "public String simplifyPath(String path) {\n    Deque<String> stack = new LinkedList<>();\n    Set<String> skip = new HashSet<>(Arrays.asList(\"..\",\".\",\"\"));\n    for (String dir : path.split(\"/\")) {\n        if (dir.equals(\"..\") && !stack.isEmpty()) stack.pop();\n        else if (!skip.contains(dir)) stack.push(dir);\n    }\n    String res = \"\";\n    for (String dir : stack) res = \"/\" + dir + res;\n    return res.isEmpty() ? \"/\" : res;\n}",
                "url": "https://leetcode.com/problems/simplify-path/solutions/25686/java-10-lines-solution-with-stack/",
                "vote_count": "408"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public String simplifyPath(String path) {",
                "url": "https://leetcode.com/problems/simplify-path/solutions/25686/java-10-lines-solution-with-stack/",
                "vote_count": "408"
            },
            {
                "language": "typescript",
                "code": "public class Solution {\npublic String simplifyPath(String path) {\n StringBuilder sb = new StringBuilder(\"/\");\n    LinkedList<String> stack = new LinkedList<String>();\n for(String s: path.split(\"/\")){\n  if(s.equals(\"..\")){\n      if(!stack.isEmpty())\n       stack.removeLast();",
                "url": "https://leetcode.com/problems/simplify-path/solutions/25686/java-10-lines-solution-with-stack/",
                "vote_count": "408"
            },
            {
                "language": "typescript",
                "code": "public String simplifyPath(String path) {\n    Stack<String> stack = new Stack();\n    for(String cur: path.split(\"/\")){\n        if(cur.equals(\"..\")) {\n            if(!stack.empty()) stack.pop();\n        }\n        else if(cur.length()>0 && !cur.equals(\".\")) stack.push(cur);\n    }",
                "url": "https://leetcode.com/problems/simplify-path/solutions/25686/java-10-lines-solution-with-stack/",
                "vote_count": "408"
            },
            {
                "language": "java",
                "code": "StringBuilder sb = new StringBuilder();\n        while (path.peekLast() != null) {\n            sb.append('/');\n            sb.append(path.pollLast());\n        }",
                "url": "https://leetcode.com/problems/simplify-path/solutions/25686/java-10-lines-solution-with-stack/",
                "vote_count": "408"
            },
            {
                "language": "typescript",
                "code": "    public String simplifyPath(String path) {\n        Stack<String> s = new Stack<>();\n        for (String p : path.split(\"/\")) {\n            if (p.isEmpty() || \".\".equals(p)) continue;",
                "url": "https://leetcode.com/problems/simplify-path/solutions/25686/java-10-lines-solution-with-stack/",
                "vote_count": "408"
            },
            {
                "language": "cpp",
                "code": "string simplifyPath(string path) {\n    string res, tmp;\n    vector<string> stk;\n    stringstream ss(path);\n    while(getline(ss,tmp,'/')) {\n        if (tmp == \"\" or tmp == \".\") continue;\n        if (tmp == \"..\" and !stk.empty()) stk.pop_back();\n        else if (tmp != \"..\") stk.push_back(tmp);\n    }\n    for(auto str : stk) res += \"/\"+str;\n    return res.empty() ? \"/\" : res;\n}",
                "url": "https://leetcode.com/problems/simplify-path/solutions/25680/c-10-lines-solution/",
                "vote_count": "365"
            },
            {
                "language": "php",
                "code": "if (tmp == \"..\" and !stk.empty()) stk.pop_back();\nelse if (tmp != \"..\") stk.push_back(tmp);",
                "url": "https://leetcode.com/problems/simplify-path/solutions/25680/c-10-lines-solution/",
                "vote_count": "365"
            },
            {
                "language": "php",
                "code": "if (tmp != \"..\") stk.push_back(tmp);\nelse if (!stk.empty()) stk.pop_back();",
                "url": "https://leetcode.com/problems/simplify-path/solutions/25680/c-10-lines-solution/",
                "vote_count": "365"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string simplifyPath(string path) {\n        string result=\"\", token;\n        stringstream ss(path);\n        vector<string> tokens;\n        while(getline(ss, token, '/')){\n            if(token==\".\" || token==\"\") continue;",
                "url": "https://leetcode.com/problems/simplify-path/solutions/25680/c-10-lines-solution/",
                "vote_count": "365"
            },
            {
                "language": "php",
                "code": "string simplifyPath(string path) {\n        istringstream ss(path);\n        deque<string>sub_path_stack;\n        string sub_path;\n        string result;\n        while (getline(ss, sub_path, '/')) {\n            if (sub_path == \".\" || sub_path == \"\") {",
                "url": "https://leetcode.com/problems/simplify-path/solutions/25680/c-10-lines-solution/",
                "vote_count": "365"
            },
            {
                "language": "cpp",
                "code": "public String simplifyPath(String path) {\n    Deque<String> stack = new ArrayDeque<String>();\n   \n    for(String token : path.split(\"/\")) {\n        if(token.equals(\"..\")) {\n           if(!stack.isEmpty()) stack.pop();\n       \n        } else if(!token.isEmpty() && !token.equals(\".\")) {",
                "url": "https://leetcode.com/problems/simplify-path/solutions/25680/c-10-lines-solution/",
                "vote_count": "365"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public String simplifyPath(String path) {\n        Stack<String> s = new Stack<>();\n        StringBuilder res = new StringBuilder();\n        String[] p =path.split(\"/\");\n        \n        for(int i=0;i<p.length;i++){\n            if(!s.isEmpty()  && p[i].equals(\"..\")) s.pop();\n            else if(!p[i].equals(\"\") && !p[i].equals(\".\") && !p[i].equals(\"..\"))\n                s.push(p[i]);\n        }\n        \n        \n        if(s.isEmpty()) return \"/\";\n        while(!s.isEmpty()){\n            res.insert(0,s.pop()).insert(0,\"/\");\n        }\n        \n        return res.toString();\n    }\n}",
                "url": "https://leetcode.com/problems/simplify-path/solutions/1847526/best-explanation-ever-possible-not-a-clickbait/",
                "vote_count": "341"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public String simplifyPath(String path) {\n        Deque<String> q = new ArrayDeque<>();\n        // iterate over string and add path to q\n        for(String in : path.split(\"/\")) {",
                "url": "https://leetcode.com/problems/simplify-path/solutions/1847526/best-explanation-ever-possible-not-a-clickbait/",
                "vote_count": "341"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public String simplifyPath(String path) {\n        Stack<String>  stack=new Stack<>();\n        \n        for(int i=0;i<path.length();i++){\n            if(path.charAt(i)!='/'){\n                int a=i;\n                while(i<path.length() && path.charAt(i)!='/') i++;                        ",
                "url": "https://leetcode.com/problems/simplify-path/solutions/1847526/best-explanation-ever-possible-not-a-clickbait/",
                "vote_count": "341"
            },
            {
                "language": "csharp",
                "code": "1. Easy C++\n2. Line by Line Explanation with Comments.\n3. Detailed Explanation \u2705\n4. Stack Problem with Initution.\n5. Please Upvote if it helps\u2b06\ufe0f\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \u2b07\ufe0f\n // \ud83d\ude09If you Like the repository don't foget to star & fork the repository\ud83d\ude09",
                "url": "https://leetcode.com/problems/simplify-path/solutions/1847357/c-easy-stack-simple-explained-algorithm/",
                "vote_count": "291"
            },
            {
                "language": "javascript",
                "code": "Input: path = \"/../\"\nOutput: \"/\"\nInput: path = \"/home//foo/\"\nOutput: \"/home/foo\"",
                "url": "https://leetcode.com/problems/simplify-path/solutions/1847357/c-easy-stack-simple-explained-algorithm/",
                "vote_count": "291"
            },
            {
                "language": "php",
                "code": "     // \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09Please upvote if it helps \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        \n        stack<string> st;\n        string res;\n        \n        for(int i = 0;  i<path.size(); ++i)\n        {\n            if(path[i] == '/')    \n                continue;\n            string temp;\n   // iterate till we doesn't traverse the whole string and doesn't encounter the last /\n            while(i < path.size() && path[i] != '/')\n            {\n    // add path to temp string\n                temp += path[i];\n                ++i;\n            }\n            if(temp == \".\")\n                continue;\n   // pop the top element from stack if exists\n            else if(temp == \"..\")\n            {\n                if(!st.empty())\n                    st.pop();\n            }\n            else\n   // push the directory file name to stack\n                st.push(temp);\n        }\n        \n  // adding all the stack elements to res\n        while(!st.empty())\n        {\n            res = \"/\" + st.top() + res;\n            st.pop();\n        }\n        \n  // if no directory or file is present\n        if(res.size() == 0)\n            return \"/\";\n        \n        return res;\n    }\n};",
                "url": "https://leetcode.com/problems/simplify-path/solutions/1847357/c-easy-stack-simple-explained-algorithm/",
                "vote_count": "291"
            },
            {
                "language": "cpp",
                "code": "class Solution:\n    def simplifyPath(self, path):\n        stack = []\n        for elem in path.split(\"/\"):\n            if stack and elem == \"..\":\n                stack.pop()\n            elif elem not in [\".\", \"\", \"..\"]:\n                stack.append(elem)\n                \n        return \"/\" + \"/\".join(stack)",
                "url": "https://leetcode.com/problems/simplify-path/solutions/1050573/python-short-stack-solution-explained/",
                "vote_count": "127"
            },
            {
                "language": "php",
                "code": "class Solution {\npublic:\n    string simplifyPath(string path) {\n        int n=path.length();\n        stack<string>s;\n                \n        if(path[n-1]!='/') // so that initially path always ends with '/'\n            path+=\"/\", ++n;\n            \n        int i=1; // since path always starts from '/'\n        string ans=\"\";\n        string temp=\"\";\n        while(i<n){\n            \n            if(path[i]=='/'){ // check only if we encounter '/'\n                \n                if(temp==\"\" || temp==\".\"){\n                    // ignore\n                }\n                else if(temp==\"..\"){\n                    if(!s.empty()) s.pop(); // pop the top element from stack if exists\n                }\n                else{\n                    s.push(temp); //push the directory or file name to stack\n                }\n                \n                temp=\"\"; // reset temp\n            }\n            else{\n                temp.push_back(path[i]); // else append to temp\n            }\n            \n            ++i; // increment index\n        }\n        \n        while(!s.empty()){ // add all the stack elements\n            ans=\"/\"+s.top()+ans;\n            s.pop();\n        }\n        \n        if(ans.length()==0) // if no directory or file is present\n            ans=\"/\"; // minimum root directory must be present in ans\n        \n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/simplify-path/solutions/1050620/c-stack-o-n-0ms-beats-100-easy-explanation/",
                "vote_count": "61"
            },
            {
                "language": "php",
                "code": "ans=\"/\";\n\nstack<string>reversed_stack;\n\nif(s.empty()){\n    return ans;\n}\n\nwhile(!s.empty()){ // reverse the stack elements\n    reversed_stack.push(s.top());\n    s.pop();\n}\n\nwhile(!reversed_stack.empty()){\n    ans+=reversed_stack.top()+\"/\";\n    reversed_stack.pop();\n}\n\nreturn ans.substr(0,ans.length()-1);",
                "url": "https://leetcode.com/problems/simplify-path/solutions/1050620/c-stack-o-n-0ms-beats-100-easy-explanation/",
                "vote_count": "61"
            },
            {
                "language": "php",
                "code": "ans=\"/\";\n\nstack<string>reversed_stack;\n\nif(s.empty()){\n    return ans;",
                "url": "https://leetcode.com/problems/simplify-path/solutions/1050620/c-stack-o-n-0ms-beats-100-easy-explanation/",
                "vote_count": "61"
            },
            {
                "language": "php",
                "code": "class Solution {\npublic:\n    string simplifyPath(string path) {\n        path += \"/\";\n        \n        vector<string> dirs;\n        string curr_dir;\n        for (int i = 0; i < path.size(); ++i) {",
                "url": "https://leetcode.com/problems/simplify-path/solutions/1050620/c-stack-o-n-0ms-beats-100-easy-explanation/",
                "vote_count": "61"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n\n    public String simplifyPath(String path) {\n        String[] x = path.split(\"/\");\n        StringBuilder sb = new StringBuilder();\n        for (int i = x.length - 1, sk = 0; i >= 0; i--) {\n            if (x[i].equals(\".\") || x[i].length() == 0) continue;\n            if (x[i].equals(\"..\")) sk++;  // increment skip count \n            else if (sk > 0) sk--;  // skip it\n            else sb.insert(0, \"/\" + x[i]);  // skip = 0? then add it.\n        }\n        if (sb.length() == 0) sb.append(\"/\");\n        return sb.toString();\n    }\n}",
                "url": "https://leetcode.com/problems/simplify-path/solutions/1847706/easy-java-solution-without-stack/",
                "vote_count": "14"
            }
        ]
    },
    "71": {
        "question_id": 72,
        "title": "Edit Distance",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/edit-distance",
        "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.You have the following three operations permitted on a word:Insert a characterDelete a characterReplace a character ",
        "examples": [
            {
                "input": "word1 = \"horse\", word2 = \"ros\"",
                "output": "3",
                "explanation": "\nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')"
            },
            {
                "input": "word1 = \"intention\", word2 = \"execution\"",
                "output": "5",
                "explanation": "\nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')"
            }
        ],
        "constraints": [
            "0 <= word1.length, word2.length <= 500",
            "word1 and word2 consist of lowercase English letters."
        ],
        "solutions": [
            {
                "language": "rust",
                "code": "Thanks for visiting my solution.\ud83d\ude0a",
                "url": "https://leetcode.com/problems/edit-distance/solutions/3230662/clean-codes-full-explanation-dynamic-programming-c-java-python3/",
                "vote_count": "146"
            },
            {
                "language": "",
                "code": "                    Please Upvote If You Find It Helpful",
                "url": "https://leetcode.com/problems/edit-distance/solutions/3230707/memoization-tabulation-space-optimization-dp-c-commented/",
                "vote_count": "16"
            },
            {
                "language": "javascript",
                "code": "In this question we have to find the **Minimum Operations** to convert `word1` to `word2`.\nSo, what are the posibilities : \n    If both letters are equal then simply decrease index\n    Otherwise there are three posibilities:\n        We can `Insert` a letter\n        We can `Delete` a letter\n        We can `Replace` a letter",
                "url": "https://leetcode.com/problems/edit-distance/solutions/3230707/memoization-tabulation-space-optimization-dp-c-commented/",
                "vote_count": "16"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    // Space Optimization - TC: O(n * m), SC: O(m)\n    int minDistance(string word1, string word2) {\n    int n = word1.size(), m = word2.size();\n    // We make dp array 1 indexed\n    // Initialize two vectors to store the values of the previous and current rows of the dp array\n    vector<int> prev(m+1, 0), curr(m+1, 0);\n    // Initialize the first row of the dp array to the numbers 0, 1, 2, ..., m\n    for(int j=0;j<=m;j++) prev[j] = j;\n    // Iterate through each row of the dp array\n    for(int i=1;i<=n;i++){\n        // Set the first element of the current row to i\n        curr[0] = i;\n        // Iterate through each column of the dp array\n        for(int j=1;j<=m;j++){\n            // If the two characters are equal, no operation is needed\n            if(word1[i-1] == word2[j-1])\n                curr[j] = prev[j-1];\n            else {\n                // If the two characters are different, consider three possible operations:\n                // Insertion: add 1 to the minimum value among prev[j], curr[j-1], and prev[j-1]\n                curr[j] = 1 + min(prev[j], min(curr[j-1], prev[j-1]));\n            }\n        }\n        // Update the previous row to be equal to the current row\n        prev = curr;\n    }\n    // Return the value of the last element of the dp array, which represents the minimum edit distance\n    return prev[m];\n}\n};",
                "url": "https://leetcode.com/problems/edit-distance/solutions/3230707/memoization-tabulation-space-optimization-dp-c-commented/",
                "vote_count": "16"
            },
            {
                "language": "cpp",
                "code": "// Tabulation - TC: O(n * m), SC: O(n * m)\n    int minDistance(string word1, string word2) {\n        int n = word1.size(), m = word2.size();\n        // We make dp array 1 indexed\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\n        for(int i=0;i<=n;i++) dp[i][0] = i;\n        for(int j=0;j<=m;j++) dp[0][j] = j;\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=m;j++){\n                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1];\n                else\n// Delete - dp[i-1][j], Insert - dp[i][j-1], Replace - dp[i-1][j-1]\n                    dp[i][j] = 1 + min(dp[i-1][j], \n        min(dp[i][j-1], dp[i-1][j-1]));\n            }\n        }\n        return dp[n][m];\n    }",
                "url": "https://leetcode.com/problems/edit-distance/solutions/3230707/memoization-tabulation-space-optimization-dp-c-commented/",
                "vote_count": "16"
            },
            {
                "language": "cpp",
                "code": "//Memoization - TC: O(n * m), SC: O(n * m) + O(n + m)\n    int find(string word1, string word2, int i, int j, vector<vector<int>>& dp){\n        if(j < 0) return i+1;\n        if(i < 0) return j+1;\n        if(dp[i][j] != -1) return dp[i][j];\n        if(word1[i] == word2[j]) return find(word1, word2, i-1, j-1, dp);\n        return dp[i][j] = 1 + min(find(word1, word2, i-1, j, dp), \n        min(find(word1, word2, i, j-1, dp), find(word1, word2, i-1, j-1, dp)));\n    }\n    int minDistance(string word1, string word2) {\n        int n = word1.size(), m = word2.size();\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\n        return find(word1, word2, n-1, m-1, dp);\n    }",
                "url": "https://leetcode.com/problems/edit-distance/solutions/3230707/memoization-tabulation-space-optimization-dp-c-commented/",
                "vote_count": "16"
            },
            {
                "language": "",
                "code": "            Give a \ud83d\udc4d. It motivates me alot",
                "url": "https://leetcode.com/problems/edit-distance/solutions/3230707/memoization-tabulation-space-optimization-dp-c-commented/",
                "vote_count": "16"
            },
            {
                "language": "cpp",
                "code": "// Note the & operator!\nint find(string word1, string word2, int i, int j, vector<vector<int>> &dp)",
                "url": "https://leetcode.com/problems/edit-distance/solutions/3230707/memoization-tabulation-space-optimization-dp-c-commented/",
                "vote_count": "16"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n\n        w1, w2 = len(word1), len(word2)\n        \n        @lru_cache(None)\n        def dp(i, j):\n\n            if i >= w1             : return w2-j                # word1 used up, so all inserts\n            if j >= w2             : return w1-i                # word2 used up, so all deletes\n            if word1[i] == word2[j]: return dp(i+1, j+1)        # letters match, so no operation\n\n            return min(dp(i,j+1), dp(i+1,j), dp(i+1,j+1)) + 1   # insert, delete, replace\n\n        return dp(0,0)",
                "url": "https://leetcode.com/problems/edit-distance/solutions/3231367/python-3-8-lines-w-comments-t-m-100-78/",
                "vote_count": "13"
            },
            {
                "language": "javascript",
                "code": "var minDistance = function(word1, word2) {\n    let len1 = word1.length, len2 = word2.length;\n    let dp = _.memoize((idx1, idx2) => {\n        if (idx1 >= len1) return len2 - idx2;\n        if (idx2 >= len2) return len1 - idx1;",
                "url": "https://leetcode.com/problems/edit-distance/solutions/3231367/python-3-8-lines-w-comments-t-m-100-78/",
                "vote_count": "13"
            },
            {
                "language": "typescript",
                "code": "",
                "url": "https://leetcode.com/problems/edit-distance/solutions/3231367/python-3-8-lines-w-comments-t-m-100-78/",
                "vote_count": "13"
            }
        ]
    },
    "72": {
        "question_id": 73,
        "title": "Set Matrix Zeroes",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/set-matrix-zeroes",
        "description": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.You must do it in place. ",
        "examples": [
            {
                "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
                "output": "[[1,0,1],[0,0,0],[1,0,1]]",
                "explanation": null
            },
            {
                "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
                "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
                "explanation": null
            }
        ],
        "constraints": [
            "m == matrix.length",
            "n == matrix[0].length",
            "1 <= m, n <= 200",
            "-2^31 <= matrix[i][j] <= 2^31 - 1",
            "A straightforward solution using O(mn) space is probably a bad idea.",
            "A simple improvement uses O(m + n) space, but still not the best solution.",
            "Could you devise a constant space solution?"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "void setZeroes(vector<vector<int> > &matrix) {\n    int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\n\n    for (int i = 0; i < rows; i++) {\n        if (matrix[i][0] == 0) col0 = 0;\n        for (int j = 1; j < cols; j++)\n            if (matrix[i][j] == 0)\n                matrix[i][0] = matrix[0][j] = 0;\n    }\n\n    for (int i = rows - 1; i >= 0; i--) {\n        for (int j = cols - 1; j >= 1; j--)\n            if (matrix[i][0] == 0 || matrix[0][j] == 0)\n                matrix[i][j] = 0;\n        if (col0 == 0) matrix[i][0] = 0;\n    }\n}",
                "url": "https://leetcode.com/problems/set-matrix-zeroes/solutions/26014/any-shorter-o-1-space-solution/",
                "vote_count": "1703"
            },
            {
                "language": "cpp",
                "code": "void setZeroes(vector<vector<int>>& matrix) {\n        bool isZeroCol = false;\n        bool isZeroRow = false;\n        for (int i = 0; i < matrix.size(); i++) { //check the first column\n            if (matrix[i][0] == 0) {\n                isZeroCol = true;\n                break;\n            } ",
                "url": "https://leetcode.com/problems/set-matrix-zeroes/solutions/26014/any-shorter-o-1-space-solution/",
                "vote_count": "1703"
            },
            {
                "language": "java",
                "code": "class Solution {\n    private int rowLen;\n    private int colLen;\n    private int change;\n    public void setZeroes(int[][] matrix) {\n        rowLen = matrix.length;\n        colLen = matrix[0].length;",
                "url": "https://leetcode.com/problems/set-matrix-zeroes/solutions/26014/any-shorter-o-1-space-solution/",
                "vote_count": "1703"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        col0, rows, cols = 1, len(matrix), len(matrix[0])",
                "url": "https://leetcode.com/problems/set-matrix-zeroes/solutions/26014/any-shorter-o-1-space-solution/",
                "vote_count": "1703"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public void setZeroes(int[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return;\n        }\n        int col0 = 1, rows = matrix.length, cols = matrix[0].length;\n        for (int i = 0; i < rows; ++i) {\n            if (matrix[i][0] == 0) {",
                "url": "https://leetcode.com/problems/set-matrix-zeroes/solutions/26014/any-shorter-o-1-space-solution/",
                "vote_count": "1703"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/set-matrix-zeroes/solutions/26014/any-shorter-o-1-space-solution/",
                "vote_count": "1703"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public void setZeroes(int[][] matrix) {\n        int col0=1;\n        int row=matrix.length;\n        int col=matrix[0].length;\n        \n        for (int i=0;i<row;i++){\n            if (matrix[i][0]==0) col0=0;",
                "url": "https://leetcode.com/problems/set-matrix-zeroes/solutions/26014/any-shorter-o-1-space-solution/",
                "vote_count": "1703"
            },
            {
                "language": "cpp",
                "code": "public void setZeroes(int[][] matrix){\n\n  int m= matrix.length, n= matrix[0].length;\n        int matrix2[][]= new int[m][n];\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++)\n                matrix2[i][j]=matrix[i][j];\n        }\n        \n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(matrix[i][j]==0){\n                    for(int k=0;k<n;k++)\n                        matrix2[i][k]=0;\n\n                    for(int k=0;k<m;k++)\n                        matrix2[k][j]=0;\n                }\n            }\n        }\n    \n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++)\n                matrix[i][j]=matrix2[i][j];\n        }\n    }",
                "url": "https://leetcode.com/problems/set-matrix-zeroes/solutions/2525398/all-approaches-from-brute-force-to-optimal-with-easy-explanation/",
                "vote_count": "143"
            },
            {
                "language": "cpp",
                "code": "public void setZeroes(int[][] matrix){\n\n  int m=matrix.length, n=matrix[0].length;\n        int rowsArray[]= new int[m];\n        int colsArray[]= new int[n];\n        \n        Arrays.fill(rowsArray,1);\n        Arrays.fill(colsArray,1);\n        \n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(matrix[i][j]==0){\n                    rowsArray[i]=0;\n                    colsArray[j]=0;\n                }\n            }\n        }\n        \n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(rowsArray[i]==0 || colsArray[j]==0)\n                    matrix[i][j]=0;\n            }\n        }\n    }",
                "url": "https://leetcode.com/problems/set-matrix-zeroes/solutions/2525398/all-approaches-from-brute-force-to-optimal-with-easy-explanation/",
                "vote_count": "143"
            },
            {
                "language": "java",
                "code": "public void setZeroes(int[][] matrix){\n\n  int m=matrix.length, n=matrix[0].length;\n        boolean isRow0=false, isCol0=false;\n        \n        for(int j=0;j<n;j++){\n            if(matrix[0][j]==0)\n                isRow0=true;\n        }\n        \n        for(int i=0;i<m;i++){\n            if(matrix[i][0]==0)\n                isCol0=true;\n        }\n        \n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                if(matrix[i][j]==0){\n                    matrix[i][0]=0;\n                    matrix[0][j]=0;\n                }\n            }\n        }\n        \n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                if(matrix[0][j]==0 || matrix[i][0]==0)\n                    matrix[i][j]=0;\n            }\n        }\n        \n        if(isRow0){\n            for(int j=0;j<n;j++)\n                matrix[0][j]=0;\n        }\n        \n        if(isCol0){\n            for(int i=0;i<m;i++)\n                matrix[i][0]=0;\n        }\n    }",
                "url": "https://leetcode.com/problems/set-matrix-zeroes/solutions/2525398/all-approaches-from-brute-force-to-optimal-with-easy-explanation/",
                "vote_count": "143"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O((N*M)*(N+M)), Where N is the number of row and M is number of column of matrix. Here\n    nested loops creates the time complexity. O(N*M) for traversing through each element and (N+M) for traversing\n    to row and column of elements having value 0.\n\n    Space Complexity : O(N*M), visited matrix space.\n\n    Solved using Matrix with Extra space.\n\n*/\n\n\n/***************************************** Approach 1 Code *****************************************/\n\nclass Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        vector<vector<int>> visited = matrix;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(matrix[i][j] == 0){\n                    for(int k=0; k<m; k++){\n                        visited[i][k] = 0;\n                    }\n                }\n            }\n        }\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(matrix[i][j] == 0){\n                    for(int k=0; k<n; k++){\n                        visited[k][j] = 0;\n                    }\n                }\n            }\n        }\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                matrix[i][j] = visited[i][j];\n            }\n        }\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O((N*M)*(N+M)), Where N is the number of row and M is number of column of matrix. Here\n    nested loops creates the time complexity. O(N*M) for traversing through each element and (N+M)for traversing\n    to row and column of elements having value 0.\n\n    Space Complexity : O(1), Constant space.\n\n    Solved using Matrix.\n\n*/\n\n\n/***************************************** Approach 2 Code *****************************************/\n\nclass Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(matrix[i][j] == 0){\n                    for(int k=0; k<m; k++){\n                        if(matrix[i][k] != 0){\n                            matrix[i][k] = -9999;\n                        }\n                    }\n                }\n            }\n        }\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(matrix[i][j] == 0){\n                    for(int k=0; k<n; k++){\n                        if(matrix[k][j] != 0){\n                            matrix[k][j] = -9999;\n                        }\n                    }\n                }\n            }\n        }\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(matrix[i][j] == -9999){\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here two nested \n    loops creates the time complexity.\n\n    Space Complexity : O(N+M), Here Unordered set(setRows and setColumn) creates the space complexity. O(N) for\n    storing the row indexs and O(M) for storing the column indexs.\n\n    Solved using Matrix + Hash Table.\n\n*/\n\n\n/***************************************** Approach 3 Code *****************************************/\n\nclass Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        unordered_set<int> setRows; \n        unordered_set<int> setColumns; \n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(matrix[i][j] == 0){\n                    setRows.insert(i);\n                    setColumns.insert(j);\n                }\n            }\n        }\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(setRows.count(i) > 0 || setColumns.count(j) > 0){\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here two nested \n    loops creates the time complexity.\n\n    Space Complexity : O(1), Constant space.\n\n    Solved using Matrix.\n\n*/\n\n\n/***************************************** Approach 4 Code *****************************************/\n\nclass Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        bool flag1 = false, flag2 = false;\n        for(int i=0; i<n; i++){\n            if(matrix[i][0] == 0){\n                flag1 = true;\n            }\n        }\n        for(int j=0; j<m; j++){\n            if(matrix[0][j] == 0){\n                flag2 = true;\n            }\n        }\n        for(int i=1; i<n; i++){\n            for(int j=1; j<m; j++){\n                if(matrix[i][j] == 0){\n                    matrix[i][0] = matrix[0][j] = 0;\n                }\n            }\n        }\n        for(int i=1; i<n; i++){\n            for(int j=1; j<m; j++){\n                if(matrix[i][0] == 0 || matrix[0][j] == 0){\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        if(flag1 == true){\n            for(int i=0; i<n; i++){\n                matrix[i][0] = 0;\n            }\n        }\n        if(flag2 == true){\n            for(int j=0; j<m; j++){\n                matrix[0][j] = 0;\n            }\n        }\n    }\n};",
                "url": "https://leetcode.com/problems/set-matrix-zeroes/solutions/3172908/best-c-4-solution-hash-table-matrix-brute-force-optimize-one-stop-solution/",
                "vote_count": "95"
            }
        ]
    },
    "73": {
        "question_id": 74,
        "title": "Search a 2D Matrix",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/search-a-2d-matrix",
        "description": "You are given an m x n integer matrix matrix with the following two properties:Each row is sorted in non-decreasing order.The first integer of each row is greater than the last integer of the previous row.Given an integer target, return true if target is in matrix or false otherwise.You must write a solution in O(log(m * n)) time complexity. ",
        "examples": [
            {
                "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3",
                "output": "true",
                "explanation": null
            },
            {
                "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13",
                "output": "false",
                "explanation": null
            }
        ],
        "constraints": [
            "m == matrix.length",
            "n == matrix[i].length",
            "1 <= m, n <= 100",
            "-10^4 <= matrix[i][j], target <= 10^4"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int rows = matrix.size(),\n   cols = matrix[0].size(),\n            row = 0, col = cols - 1;\n   \n        while (row < rows && col > -1) {\n            int cur = matrix[row][col];\n            if (cur == target) return true;\n            if (target > cur) row++;\n            else col--;\n        }\n        \n        return false;\n    }\n};",
                "url": "https://leetcode.com/problems/search-a-2d-matrix/solutions/1895837/c-binary-search-tree-explained-with-img/",
                "vote_count": "736"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> \n      row,col=len(matrix),len(matrix[0])\n        left,right=0,row*col-1\n        while left<=right:\n            mid=(left+right)//2\n            num=matrix[mid//col][mid%col]\n            if num==target:\n                return True\n            if num>target:\n                right=mid-1\n            else:\n                left=mid+1\n        return False",
                "url": "https://leetcode.com/problems/search-a-2d-matrix/solutions/3321240/binary-search-logic-easy/",
                "vote_count": "11"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        list1=[]\n        for row in matrix:\n            if row[-1]>=target:\n                list1=row\n                break\n        left,right=0,len(list1)-1\n        while left<=right:\n            mid=(right+left)//2\n            if list1[mid]==target:\n                return True\n            elif list1[mid]>target:\n                right=mid-1\n            else:\n                left=mid+1\n        return False\n    //please upvote me it would encourage me alot\n                ",
                "url": "https://leetcode.com/problems/search-a-2d-matrix/solutions/3321240/binary-search-logic-easy/",
                "vote_count": "11"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        for row in matrix:\n            if row[-1] >= target:\n                return target in row\n\n# please upvote me it would encourage me alot",
                "url": "https://leetcode.com/problems/search-a-2d-matrix/solutions/3321240/binary-search-logic-easy/",
                "vote_count": "11"
            }
        ]
    },
    "74": {
        "question_id": 75,
        "title": "Sort Colors",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/sort-colors",
        "description": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.You must solve this problem without using the library's sort function. ",
        "examples": [
            {
                "input": "nums = [2,0,2,1,1,0]",
                "output": "[0,0,1,1,2,2]",
                "explanation": null
            },
            {
                "input": "nums = [2,0,1]",
                "output": "[0,1,2]",
                "explanation": null
            }
        ],
        "constraints": [
            "n == nums.length",
            "1 <= n <= 300",
            "nums[i] is either 0, 1, or 2."
        ],
        "solutions": [
            {
                "language": "python",
                "code": "def sortColors(self, nums):\n    red, white, blue = 0, 0, len(nums)-1\n    \n    while white <= blue:\n        if nums[white] == 0:\n            nums[red], nums[white] = nums[white], nums[red]\n            white += 1\n            red += 1\n        elif nums[white] == 1:\n            white += 1\n        else:\n            nums[white], nums[blue] = nums[blue], nums[white]\n            blue -= 1\n            \n            ",
                "url": "https://leetcode.com/problems/sort-colors/solutions/26481/python-o-n-1-pass-in-place-solution-with-explanation/",
                "vote_count": "1246"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        p1, p2 = 0, len(nums) - 1",
                "url": "https://leetcode.com/problems/sort-colors/solutions/26481/python-o-n-1-pass-in-place-solution-with-explanation/",
                "vote_count": "1246"
            },
            {
                "language": "",
                "code": "nums[red], nums[white] = nums[white], nums[red]",
                "url": "https://leetcode.com/problems/sort-colors/solutions/26481/python-o-n-1-pass-in-place-solution-with-explanation/",
                "vote_count": "1246"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public void sortColors(int[] nums) {\n        int n = nums.length;\n        int i = 0; // to the left of i, the objects with red color\n        int k = n - 1; // to the right of k, the objects with blue color\n        int j = 0; // between i and j are the object with white color\n        // between j and k are the objects with unknown colors, we have to check\n        ",
                "url": "https://leetcode.com/problems/sort-colors/solutions/26481/python-o-n-1-pass-in-place-solution-with-explanation/",
                "vote_count": "1246"
            },
            {
                "language": "cpp",
                "code": "    void sortColors(vector<int>& nums) {\n        \n        // initialize variables:\n        int low = 0, mid = 0, high = nums.size() - 1;\n        \n        // logic:\n        while(mid <= high)\n        {\n            switch(nums[mid])\n            {\n                case 0: swap(nums[low++], nums[mid++]); break;\n                \n                case 1: mid++; break;\n                \n                case 2: swap(nums[mid], nums[high--]); break;\n            }\n        }\n    }",
                "url": "https://leetcode.com/problems/sort-colors/solutions/1256365/c-easy-to-understand-full-explanation/",
                "vote_count": "234"
            }
        ]
    },
    "75": {
        "question_id": 76,
        "title": "Minimum Window Substring",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/minimum-window-substring",
        "description": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".The testcases will be generated such that the answer is unique. ",
        "examples": [
            {
                "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
                "output": "\"BANC\"",
                "explanation": "The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t."
            },
            {
                "input": "s = \"a\", t = \"a\"",
                "output": "\"a\"",
                "explanation": "The entire string s is the minimum window."
            },
            {
                "input": "s = \"a\", t = \"aa\"",
                "output": "\"\"",
                "explanation": "Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string."
            }
        ],
        "constraints": [
            "m == s.length",
            "n == t.length",
            "1 <= m, n <= 10^5",
            "s and t consist of uppercase and lowercase English letters."
        ],
        "solutions": [
            {
                "language": "ruby",
                "code": "string minWindow(string s, string t) {\n        vector<int> map(128,0);\n        for(auto c: t) map[c]++;\n        int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0;\n        while(end<s.size()){\n            if(map[s[end++]]-->0) counter--; //in t\n            while(counter==0){ //valid\n                if(end-begin<d)  d=end-(head=begin);\n                if(map[s[begin++]]++==0) counter++;  //make it invalid\n            }  \n        }\n        return d==INT_MAX? \"\":s.substr(head, d);\n    }",
                "url": "https://leetcode.com/problems/minimum-window-substring/solutions/26808/here-is-a-10-line-template-that-can-solve-most-substring-problems/",
                "vote_count": "5727"
            },
            {
                "language": "cpp",
                "code": "int findSubstring(string s){\n        vector<int> map(128,0);\n        int counter; // check whether the substring is valid\n        int begin=0, end=0; //two pointers, one point to tail and one  head\n        int d; //the length of substring\n\n        for() { /* initialize the hash map here */ }\n\n        while(end<s.size()){\n\n            if(map[s[end++]]-- ?){  /* modify counter here */ }\n\n            while(/* counter condition */){ \n                 \n                 /* update d here if finding minimum*/\n\n                //increase begin to make it invalid/valid again\n                \n                if(map[s[begin++]]++ ?){ /*modify counter here*/ }\n            }  \n\n            /* update d here if finding maximum*/\n        }\n        return d;\n  }",
                "url": "https://leetcode.com/problems/minimum-window-substring/solutions/26808/here-is-a-10-line-template-that-can-solve-most-substring-problems/",
                "vote_count": "5727"
            },
            {
                "language": "python",
                "code": "int lengthOfLongestSubstringTwoDistinct(string s) {\n        vector<int> map(128, 0);\n        int counter=0, begin=0, end=0, d=0; \n        while(end<s.size()){\n            if(map[s[end++]]++==0) counter++;\n            while(counter>2) if(map[s[begin++]]--==1) counter--;\n            d=max(d, end-begin);\n        }\n        return d;\n    }",
                "url": "https://leetcode.com/problems/minimum-window-substring/solutions/26808/here-is-a-10-line-template-that-can-solve-most-substring-problems/",
                "vote_count": "5727"
            },
            {
                "language": "ruby",
                "code": "int lengthOfLongestSubstring(string s) {\n        vector<int> map(128,0);\n        int counter=0, begin=0, end=0, d=0; \n        while(end<s.size()){\n            if(map[s[end++]]++>0) counter++; \n            while(counter>0) if(map[s[begin++]]-->1) counter--;\n            d=max(d, end-begin); //while valid, update d\n        }\n        return d;\n    }",
                "url": "https://leetcode.com/problems/minimum-window-substring/solutions/26808/here-is-a-10-line-template-that-can-solve-most-substring-problems/",
                "vote_count": "5727"
            },
            {
                "language": "erlang",
                "code": "1. Use two pointers: start and end to represent a window.\n2. Move end to find a valid window.\n3. When a valid window is found, move start to find a smaller window.",
                "url": "https://leetcode.com/problems/minimum-window-substring/solutions/26808/here-is-a-10-line-template-that-can-solve-most-substring-problems/",
                "vote_count": "5727"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/minimum-window-substring/solutions/26808/here-is-a-10-line-template-that-can-solve-most-substring-problems/",
                "vote_count": "5727"
            },
            {
                "language": "cpp",
                "code": "  public String minWindow(String s, String t) {\n    int [] map = new int[128];\n    for (char c : t.toCharArray()) {\n      map[c]++;\n    }",
                "url": "https://leetcode.com/problems/minimum-window-substring/solutions/26808/here-is-a-10-line-template-that-can-solve-most-substring-problems/",
                "vote_count": "5727"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/minimum-window-substring/solutions/26808/here-is-a-10-line-template-that-can-solve-most-substring-problems/",
                "vote_count": "5727"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/minimum-window-substring/solutions/26808/here-is-a-10-line-template-that-can-solve-most-substring-problems/",
                "vote_count": "5727"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/minimum-window-substring/solutions/26808/here-is-a-10-line-template-that-can-solve-most-substring-problems/",
                "vote_count": "5727"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def min_window(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        # Struggled with this problem for a long while.",
                "url": "https://leetcode.com/problems/minimum-window-substring/solutions/26808/here-is-a-10-line-template-that-can-solve-most-substring-problems/",
                "vote_count": "5727"
            },
            {
                "language": "csharp",
                "code": "public String minWindow(String s, String t) {\n    HashMap<Character,Integer> map = new HashMap();\n    for(char c : s.toCharArray())\n        map.put(c,0);\n    for(char c : t.toCharArray())\n    {\n        if(map.containsKey(c))\n            map.put(c,map.get(c)+1);",
                "url": "https://leetcode.com/problems/minimum-window-substring/solutions/26808/here-is-a-10-line-template-that-can-solve-most-substring-problems/",
                "vote_count": "5727"
            },
            {
                "language": "ruby",
                "code": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"",
                "url": "https://leetcode.com/problems/minimum-window-substring/solutions/26808/here-is-a-10-line-template-that-can-solve-most-substring-problems/",
                "vote_count": "5727"
            },
            {
                "language": "python",
                "code": "class Solution {\npublic:\n\n    string minWindow(string str, string pat) {\n           \n    int len1 = str.length();\n    int len2 = pat.length();\n        \n     const int no_of_chars = 256;\n\n    if (len1 < len2) {\n        return \"\";\n    }\n\n    int hash_pat[no_of_chars] = { 0 };\n    int hash_str[no_of_chars] = { 0 };\n\n    \n    for (int i = 0; i < len2; i++)\n        hash_pat[pat[i]]++;\n\n    int start = 0, start_index = -1, min_len = INT_MAX;\n\n   \n    int count = 0; \n    for (int j = 0; j < len1; j++) {\n      \n        \n        hash_str[str[j]]++;\n\n        \n        if (hash_str[str[j]] <= hash_pat[str[j]])\n            count++;\n\n        if (count == len2) {\n          \n            while (hash_str[str[start]]\n                       > hash_pat[str[start]]\n                   || hash_pat[str[start]] == 0) {\n\n                if (hash_str[str[start]]\n                    > hash_pat[str[start]])\n                    hash_str[str[start]]--;\n                start++;\n            }\n\n            int len_window = j - start + 1;\n            if (min_len > len_window) {\n                min_len = len_window;\n                start_index = start;\n            }\n        }\n    }\n\n\n    if (start_index == -1) {\n     \n        return \"\";\n    }\n\n    \n    return str.substr(start_index, min_len);\n    }\n};",
                "url": "https://leetcode.com/problems/minimum-window-substring/solutions/2730839/c-advance-sliding-window-fast/",
                "vote_count": "35"
            },
            {
                "language": "typescript",
                "code": "class Solution {\npublic:\n    bool check(int charMap[58], int window[58]) {\n        for (int i=0; i<58; i++) if (charMap[i] > window[i]) return false;\n        return true;\n    }\n    string minWindow(string s, string t) {\n        if (s.size() < t.size()) return \"\";",
                "url": "https://leetcode.com/problems/minimum-window-substring/solutions/2730839/c-advance-sliding-window-fast/",
                "vote_count": "35"
            }
        ]
    },
    "76": {
        "question_id": 77,
        "title": "Combinations",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/combinations",
        "description": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].You may return the answer in any order. ",
        "examples": [
            {
                "input": "n = 4, k = 2",
                "output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
                "explanation": "There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination."
            },
            {
                "input": "n = 1, k = 1",
                "output": "[[1]]",
                "explanation": "There is 1 choose 1 = 1 total combination."
            }
        ],
        "constraints": [
            "1 <= n <= 20",
            "1 <= k <= n"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "def backtrack(candidate):\n    if find_solution(candidate):\n        output(candidate)\n        return\n    \n    # iterate all possible candidates.\n    for next_candidate in list_of_candidates:\n        if is_valid(next_candidate):\n            # try this partial candidate solution\n            place(next_candidate)\n            # given the candidate, explore further.\n            backtrack(next_candidate)\n            # backtrack\n            remove(next_candidate)",
                "url": "https://leetcode.com/problems/combinations/solutions/844096/backtracking-cheatsheet-simple-solution/",
                "vote_count": "167"
            },
            {
                "language": "python",
                "code": "def combine(self, n, k):   \n  sol=[]\n        def backtrack(remain,comb,nex):\n   # solution found\n            if remain==0:\n                sol.append(comb.copy())\n            else:\n    # iterate through all possible candidates\n                for i in range(nex,n+1):\n     # add candidate\n                    comb.append(i)\n     #backtrack\n                    backtrack(remain-1,comb,i+1)\n     # remove candidate\n                    comb.pop()\n            \n        backtrack(k,[],1)\n        return sol",
                "url": "https://leetcode.com/problems/combinations/solutions/844096/backtracking-cheatsheet-simple-solution/",
                "vote_count": "167"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> ans;\n    \n    void helper(int idx, int k,vector<int>&current,int n)\n    {\n        if(current.size()==k)    // base case\n        {\n            ans.push_back(current);\n            return;\n        }\n        \n        for(int i=idx;i<n+1;i++)\n        {\n            current.push_back(i);  //consider the current element i\n            helper(i+1,k,current,n); // generate combinations\n            current.pop_back(); //proceed to next element\n        }\n    }\n    \n    vector<vector<int>> combine(int n, int k) {\n        vector<int>current;\n        helper(1,k,current,n);\n        return ans; //return answer\n    }\n};",
                "url": "https://leetcode.com/problems/combinations/solutions/1141903/clear-and-simple-explanation-with-intuition-100-faster/",
                "vote_count": "147"
            },
            {
                "language": "cpp",
                "code": "void getSubsets(int n,int k, int idx, vector<int>res){\n    if(idx >= n && res.size() < k)\n        return;\n    if(res.size()==k){\n        result.push_back(res);\n        return;",
                "url": "https://leetcode.com/problems/combinations/solutions/1141903/clear-and-simple-explanation-with-intuition-100-faster/",
                "vote_count": "147"
            },
            {
                "language": "cpp",
                "code": "vector<vector<int>> ans; \nvoid solve(int n,int k,int i,vector<int> &v)\n{\n    if(v.size() == k)\n    {\n        ans.push_back(v);\n        return;\n    }\n    ",
                "url": "https://leetcode.com/problems/combinations/solutions/1141903/clear-and-simple-explanation-with-intuition-100-faster/",
                "vote_count": "147"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(k*nCk), here nCk means the binomial coefficient of picking k elements out of n elements.\n    where nCk = C(n,k) = n!/(n\u2212k)!\u00d7k!.\n\n    Space Complexity : O(nCk), as stated above the nCk here refers to the binomial coefficient.\n\n    Solved using Array + Backtracking.\n\n*/\n\nclass Solution { \nprivate: \n    void combine(int n, int k, vector<vector<int>> &output, vector<int> &temp, int start){\n        if(temp.size() == k){\n            output.push_back(temp);\n            return;\n        }\n        for(int i=start; i<=n; i++){\n            temp.push_back(i);\n            combine(n, k, output, temp, i+1);\n            temp.pop_back();\n        }\n    }     \npublic:\n    vector<vector<int>> combine(int n, int k) {\n        vector<vector<int>> output;\n        vector<int> temp;\n        combine(n, k, output, temp, 1);\n        return output;\n    }\n};",
                "url": "https://leetcode.com/problems/combinations/solutions/3214276/best-c-solution-ever-easy-solution-backtracking-one-stop-solution/",
                "vote_count": "24"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>>ans;\n    void backtrack(int n,int start,vector<int>&temp,int k){\n        if(temp.size()>k)return;\n        if(temp.size()==k)ans.push_back(temp);\n\n          for(int i=start;i<=n;i++){\n              temp.push_back(i);\n              backtrack(n,i+1,temp,k);\n              temp.pop_back();\n          }\n    }\n    vector<vector<int>> combine(int n, int k) {\n        vector<int>temp;\n         backtrack(n,1,temp,k);\n         return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/combinations/solutions/3097270/simple-c-backtracking-solution-90/",
                "vote_count": "10"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n //declaring new list of list for storing results\n        List<List<Integer>> res = new ArrayList<>();\n  //calling the helper function\n        helper(n, k, 1,  res, new ArrayList<>());\n        return res;\n    }\n    private void helper(int n, int k, int idex, List<List<Integer>> res, List<Integer> temp){\n //when size of the temp list equals to k it is added to the final list 'res'\n        if(temp.size()==k){\n            res.add(new ArrayList<>(temp));\n   //after adding the temp to res just return \n            return;\n        }\n  //for loop for iterating over the range [1,n]\n        for(int i = idex; i<=n;i++){\n            temp.add(i);\n            helper(n, k, i+1, res, temp);\n   //backtracking to the previous numeber\n            temp.remove(temp.size()-1);\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/combinations/solutions/3112007/simple-java-code-with-the-best-explanation/",
                "vote_count": "10"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n \n        List<List<Integer>> res = new ArrayList<>();\n        helper(n, k, 1,  res, new ArrayList<>());\n        return res;\n    }\n    private void helper(int n, int k, int idex, List<List<Integer>> res, List<Integer> temp){\n \n        if(temp.size()==k){\n            res.add(new ArrayList<>(temp));\n            return;\n        }\n  \n        for(int i = idex; i<=n;i++){\n            temp.add(i);\n            helper(n, k, i+1, res, temp);\n            temp.remove(temp.size()-1);\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/combinations/solutions/3112007/simple-java-code-with-the-best-explanation/",
                "vote_count": "10"
            }
        ]
    },
    "77": {
        "question_id": 78,
        "title": "Subsets",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/subsets",
        "description": "Given an integer array nums of unique elements, return all possible subsets (the power set).The solution set must not contain duplicate subsets. Return the solution in any order. ",
        "examples": [
            {
                "input": "nums = [1,2,3]",
                "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
                "explanation": null
            },
            {
                "input": "nums = [0]",
                "output": "[[],[0]]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 10",
            "-10 <= nums[i] <= 10",
            "All the numbers of\u00a0nums are unique."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "public List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n}",
                "url": "https://leetcode.com/problems/subsets/solutions/27281/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "3008"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n        if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n} ",
                "url": "https://leetcode.com/problems/subsets/solutions/27281/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "3008"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> permute(int[] nums) {\n   List<List<Integer>> list = new ArrayList<>();\n   // Arrays.sort(nums); // not necessary\n   backtrack(list, new ArrayList<>(), nums);\n   return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n   if(tempList.size() == nums.length){\n      list.add(new ArrayList<>(tempList));\n   } else{\n      for(int i = 0; i < nums.length; i++){ \n         if(tempList.contains(nums[i])) continue; // element already exists, skip\n         tempList.add(nums[i]);\n         backtrack(list, tempList, nums);\n         tempList.remove(tempList.size() - 1);\n      }\n   }\n} ",
                "url": "https://leetcode.com/problems/subsets/solutions/27281/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "3008"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> permuteUnique(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\n    if(tempList.size() == nums.length){\n        list.add(new ArrayList<>(tempList));\n    } else{\n        for(int i = 0; i < nums.length; i++){\n            if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\n            used[i] = true; \n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, used);\n            used[i] = false; \n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/subsets/solutions/27281/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "3008"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> combinationSum(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\n    if(remain < 0) return;\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\n    else{ \n        for(int i = start; i < nums.length; i++){\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/subsets/solutions/27281/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "3008"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> combinationSum2(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n    \n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\n    if(remain < 0) return;\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\n    else{\n        for(int i = start; i < nums.length; i++){\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i + 1);\n            tempList.remove(tempList.size() - 1); \n        }\n    }\n} ",
                "url": "https://leetcode.com/problems/subsets/solutions/27281/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "3008"
            },
            {
                "language": "typescript",
                "code": "public List<List<String>> partition(String s) {\n   List<List<String>> list = new ArrayList<>();\n   backtrack(list, new ArrayList<>(), s, 0);\n   return list;\n}\n\npublic void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\n   if(start == s.length())\n      list.add(new ArrayList<>(tempList));\n   else{\n      for(int i = start; i < s.length(); i++){\n         if(isPalindrome(s, start, i)){\n            tempList.add(s.substring(start, i + 1));\n            backtrack(list, tempList, s, i + 1);\n            tempList.remove(tempList.size() - 1);\n         }\n      }\n   }\n}\n\npublic boolean isPalindrome(String s, int low, int high){\n   while(low < high)\n      if(s.charAt(low++) != s.charAt(high--)) return false;\n   return true;\n} ",
                "url": "https://leetcode.com/problems/subsets/solutions/27281/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "3008"
            },
            {
                "language": "csharp",
                "code": "Pick a starting point.\nwhile(Problem is not solved)\n    For each path from the starting point.\n        check if selected path is safe, if yes select it\n        and make recursive call to rest of the problem\n        before which undo the current move.\n    End For\nIf none of the move works out, return false, NO SOLUTON.",
                "url": "https://leetcode.com/problems/subsets/solutions/27281/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "3008"
            },
            {
                "language": "csharp",
                "code": "public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrack(result, new ArrayList<Integer>(), nums, 0);\n        return result;\n    }\n    void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums, int start){\n        if(nums.length == start){",
                "url": "https://leetcode.com/problems/subsets/solutions/27281/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "3008"
            },
            {
                "language": "lisp",
                "code": "    for(int i = start; i < nums.length; i++){\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }",
                "url": "https://leetcode.com/problems/subsets/solutions/27281/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "3008"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/subsets/solutions/27281/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/",
                "vote_count": "3008"
            }
        ]
    },
    "78": {
        "question_id": 79,
        "title": "Word Search",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/word-search",
        "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. ",
        "examples": [
            {
                "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
                "output": "true",
                "explanation": null
            },
            {
                "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"",
                "output": "true",
                "explanation": null
            },
            {
                "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"",
                "output": "false",
                "explanation": null
            }
        ],
        "constraints": [
            "m == board.length",
            "n = board[i].length",
            "1 <= m, n <= 6",
            "1 <= word.length <= 15",
            "board and word consists of only lowercase and uppercase English letters."
        ],
        "solutions": [
            {
                "language": "ruby",
                "code": "def exist(self, board: List[List[str]], word: str) -> bool:\n # Count number of letters in board and store it in a dictionary\n boardDic = defaultdict(int)\n for i in range(len(board)):\n  for j in range(len(board[0])):\n   boardDic[board[i][j]] += 1\n\n # Count number of letters in word\n # Check if board has all the letters in the word and they are atleast same count from word\n wordDic = Counter(word)\n for c in wordDic:\n  if c not in boardDic or boardDic[c] < wordDic[c]:\n   return False\n\n # Traverse through board and if word[0] == board[i][j], call the DFS function\n for i in range(len(board)):\n  for j in range(len(board[0])):\n   if board[i][j] == word[0]:\n    if self.dfs(i, j, 0, board, word):\n     return True\n\n return False\n\ndef dfs(self, i, j, k, board, word):\n # Recursion will return False if (i,j) is out of bounds or board[i][j] != word[k] which is current letter we need\n if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or \\\n    k >= len(word) or word[k] != board[i][j]:\n  return False\n\n # If this statement is true then it means we have reach the last letter in the word so we can return True\n if k == len(word) - 1:\n  return True\n\n directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n for x, y in directions:\n  # Since we can't use the same letter twice, I'm changing current board[i][j] to -1 before traversing further\n  tmp = board[i][j]\n  board[i][j] = -1\n\n  # If dfs returns True then return True so there will be no further dfs\n  if self.dfs(i + x, j + y, k + 1, board, word): \n   return True\n\n  board[i][j] = tmp",
                "url": "https://leetcode.com/problems/word-search/solutions/2439953/python-faster-than-98-w-proof-easy-to-understand/",
                "vote_count": "137"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        \n        m, n = len(board), len(board[0])\n        \n        if len(word) > m * n: return False                            # [a] trivial case to discard\n\n        if not (cnt := Counter(word)) <= Counter(chain(*board)):      # [b] there are not enough\n            return False                                              #     letters on the board\n        \n        if cnt[word[0]] > cnt[word[-1]]:                              # [c] inverse word if it's better\n             word = word[::-1]                                        #     to start from the end\n        \n        def dfs(i, j, s):                                             # recursive postfix search\n            \n            if s == len(word) : return True                           # [1] found the word\n            \n            if 0 <= i < m and 0 <= j < n and board[i][j] == word[s]:  # [2] found a letter\n                board[i][j] = \"#\"                                     # [3] mark as visited\n                adj = [(i,j+1),(i,j-1),(i+1,j),(i-1,j)]               # [4] iterate over adjacent cells...\n                dp = any(dfs(ii,jj,s+1) for ii,jj in adj)             # [5] ...and try next letter\n                board[i][j] = word[s]                                 # [6] remove mark\n                return dp                                             # [7] return search result\n\n            return False                                              # [8] this DFS branch failed\n                \n        return any(dfs(i,j,0) for i,j in product(range(m),range(n)))  # search starting from each position",
                "url": "https://leetcode.com/problems/word-search/solutions/2843501/python-c-faster-than-99-dfs-explained/",
                "vote_count": "65"
            },
            {
                "language": "cpp",
                "code": "class Solution \n{\npublic:\n    bool exist(vector<vector<char>>& board, string word) \n    {\n        int dirs[5] = {0, -1, 0, 1, 0};\n        map<char,int> cnt;\n        int m = board.size(), n = board[0].size(), l = word.size();\n        \n        for (char c : word) cnt[c] += 1;\n        \n        if (cnt[word[0]] > cnt[word[l-1]])\n            reverse(word.begin(), word.end());\n        \n        function<bool(int,int,int)> dfs;\n        dfs = [&] (int i, int j, int s) -> bool\n        {\n            if (s == l) return true;\n            \n            if (i < 0 or i >= m or j < 0 or j >= n) return false;\n            if (board[i][j] != word[s])             return false;\n            \n            board[i][j] = '#';\n            for (int d = 0; d < 4; ++d)\n                if (dfs(i + dirs[d], j + dirs[d+1], s+1)) return true;\n            board[i][j] = word[s];\n            \n            return false;\n        };\n        \n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                if (dfs(i, j, 0)) return true;\n        \n        return false;\n    }\n};",
                "url": "https://leetcode.com/problems/word-search/solutions/2843501/python-c-faster-than-99-dfs-explained/",
                "vote_count": "65"
            },
            {
                "language": "python",
                "code": "        if not (cnt := Counter(word)) <= Counter(chain(*board)):      # [b] there are not enough\n            return False                                              #     letters on the board\n        \n        if cnt[word[0]] > cnt[word[-1]]:                              # [c] inverse word if it's better\n             word = word[::-1]                                        #     to start from the end",
                "url": "https://leetcode.com/problems/word-search/solutions/2843501/python-c-faster-than-99-dfs-explained/",
                "vote_count": "65"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/word-search/solutions/2843501/python-c-faster-than-99-dfs-explained/",
                "vote_count": "65"
            },
            {
                "language": "ruby",
                "code": "if cnt[word[0]] > cnt[word[-1]]:                              # [c] inverse word if it's better\n    word = word[::-1]                                        #     to start from the end",
                "url": "https://leetcode.com/problems/word-search/solutions/2843501/python-c-faster-than-99-dfs-explained/",
                "vote_count": "65"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/word-search/solutions/2843501/python-c-faster-than-99-dfs-explained/",
                "vote_count": "65"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/word-search/solutions/2843501/python-c-faster-than-99-dfs-explained/",
                "vote_count": "65"
            },
            {
                "language": "kotlin",
                "code": "",
                "url": "https://leetcode.com/problems/word-search/solutions/2843501/python-c-faster-than-99-dfs-explained/",
                "vote_count": "65"
            },
            {
                "language": "python",
                "code": "def backtrack(state):\n(1) if there are no more states that can be generated from the current state, return.\n\nFor loop\n    (2) change the current state to its neighboring state\n    (3) backtrack(state)\n    (4) restore the state (backtrack)",
                "url": "https://leetcode.com/problems/word-search/solutions/2843530/python3-backtracking-not-tle-for-beginners-only/",
                "vote_count": "56"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        \n        directions = [[0,1],[1,0],[0,-1],[-1,0]]\n        m,n = len(board),len(board[0])\n        \n        def backtrack(i,j,k,visited):\n            if board[i][j] == word[k]:\n                if k==len(word)-1:\n                    return True\n                \n                for xn,yn in directions:\n                    x,y = i+xn,j+yn\n                    if 0<=x<m and 0<=y<n and (x,y) not in visited:\n                        visited.add((x,y))                      # Change the state\n                        if backtrack(x,y,k+1,visited)==True:    # Recursive call\n                            return True\n                        visited.remove((x,y))                   # Restore the state\n            return False\n        \n        # start from each cell in the grid.\n        for i in range(m):\n            for j in range(n):\n                if backtrack(i,j,0,{(i,j)}):\n                    return True\n        return False",
                "url": "https://leetcode.com/problems/word-search/solutions/2843530/python3-backtracking-not-tle-for-beginners-only/",
                "vote_count": "56"
            },
            {
                "language": "javascript",
                "code": "[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],\n[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\n\n\"AAAAAAAAAAAAABB\"",
                "url": "https://leetcode.com/problems/word-search/solutions/2843530/python3-backtracking-not-tle-for-beginners-only/",
                "vote_count": "56"
            },
            {
                "language": "javascript",
                "code": "[[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"A\"],\n[\"A\",\"A\",\"A\",\"A\",\"A\",\"B\"],\n[\"A\",\"A\",\"A\",\"A\",\"B\",\"A\"]]\n\n\"AAAAAAAAAAAAABBA\"",
                "url": "https://leetcode.com/problems/word-search/solutions/2843530/python3-backtracking-not-tle-for-beginners-only/",
                "vote_count": "56"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        \n        directions = [[0,1],[1,0],[0,-1],[-1,0]]\n        m,n = len(board),len(board[0])\n        \n        # (1) fewer elements in the board than the word.\n        if m*n<len(word): return False\n        \n        # (2) fewer characters in the board than the word.\n        countB = Counter()\n        for i in range(m):\n            for j in range(n):\n                countB[board[i][j]] += 1\n        countW = Counter(word)\n        for key in countW.keys():\n            if countW[key] - countB[key] > 0:\n                return False\n        \n        # (3) Inverse word if it's better\n        # If we find the right duplicates are less than the left duplicates, reverse the word.\n        left,right = 1,len(word)-2\n        leftDup = rightDup = 1\n        while left<right:\n            if word[left]==word[left-1]:\n                leftDup += 1\n            if word[right]==word[right+1]:\n                rightDup += 1\n                \n            if rightDup<leftDup:\n                word = word[::-1]\n                break\n                \n            if word[left]!=word[left-1]:\n                leftDup = 1\n            if word[right]!=word[right+1]:\n                rightDup = 1\n            left += 1\n            right -= 1\n            \n        def backtrack(i,j,k,visited):\n            if board[i][j] == word[k]:\n                if k==len(word)-1:\n                    return True\n                for xn,yn in directions:\n                    x,y = i+xn,j+yn\n                    if 0<=x<m and 0<=y<n and (x,y) not in visited:\n                        if backtrack(x,y,k+1,visited.union({(x,y)}))==True:\n                            return True\n            return False\n        \n        for i, j in product(range(m), range(n)):\n            if backtrack(i,j,0,{(i,j)}):\n                return True\n        return False",
                "url": "https://leetcode.com/problems/word-search/solutions/2843530/python3-backtracking-not-tle-for-beginners-only/",
                "vote_count": "56"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        m,n = len(board),len(board[0])\n        directions = [(0,1),(1,0),(-1,0),(0,-1)]\n\n        def dfs(i,j,k):\n            if k == len(word): return True",
                "url": "https://leetcode.com/problems/word-search/solutions/2843530/python3-backtracking-not-tle-for-beginners-only/",
                "vote_count": "56"
            }
        ]
    },
    "79": {
        "question_id": 80,
        "title": "Remove Duplicates from Sorted Array II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii",
        "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.Return k after placing the final result in the first k slots of nums.Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.Custom Judge:The judge will test your solution with the following code:int[] nums = [...]; // Input arrayint[] expectedNums = [...]; // The expected answer with correct lengthint k = removeDuplicates(nums); // Calls your implementationassert k == expectedNums.length;for (int i = 0; i < k; i++) {    assert nums[i] == expectedNums[i];}If all assertions pass, then your solution will be accepted. ",
        "examples": [
            {
                "input": "nums = [1,1,1,2,2,3]",
                "output": "5, nums = [1,1,2,2,3,_]",
                "explanation": "Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            },
            {
                "input": "nums = [0,0,1,1,1,1,2,3,3]",
                "output": "7, nums = [0,0,1,1,2,3,3,_,_]",
                "explanation": "Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            }
        ],
        "constraints": [
            "1 <= nums.length <= 3 * 10^4",
            "-10^4 <= nums[i] <= 10^4",
            "nums is sorted in non-decreasing order."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "int removeDuplicates(vector<int>& nums) {\n    int i = 0;\n    for (int n : nums)\n        if (i < 2 || n > nums[i-2])\n            nums[i++] = n;\n    return i;\n}",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/27976/3-6-easy-lines-c-java-python-ruby/",
                "vote_count": "1639"
            },
            {
                "language": "cpp",
                "code": "public int removeDuplicates(int[] nums) {\n    int i = 0;\n    for (int n : nums)\n        if (i < 2 || n > nums[i-2])\n            nums[i++] = n;\n    return i;\n}",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/27976/3-6-easy-lines-c-java-python-ruby/",
                "vote_count": "1639"
            },
            {
                "language": "ruby",
                "code": "def removeDuplicates(self, nums):\n    i = 0\n    for n in nums:\n        if i < 2 or n > nums[i-2]:\n            nums[i] = n\n            i += 1\n    return i",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/27976/3-6-easy-lines-c-java-python-ruby/",
                "vote_count": "1639"
            },
            {
                "language": "ruby",
                "code": "def remove_duplicates(nums)\n    i = 0\n    nums.each { |n| nums[(i+=1)-1] = n if i < 2 || n > nums[i-2] }\n    i\nend",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/27976/3-6-easy-lines-c-java-python-ruby/",
                "vote_count": "1639"
            },
            {
                "language": "cpp",
                "code": "int removeDuplicates(vector<int>& nums, int k) {\n    int i = 0;\n    for (int n : nums)\n        if (i < k || n > nums[i-k])\n            nums[i++] = n;\n    return i;\n}",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/27976/3-6-easy-lines-c-java-python-ruby/",
                "vote_count": "1639"
            },
            {
                "language": "cpp",
                "code": "int removeDuplicates(vector<int>& nums) {\n    if(nums.size()<3)\n        return nums.size();\n        \n    int idx = 2;\n    for(int i=2;i<nums.size();++i)\n    {",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/27976/3-6-easy-lines-c-java-python-ruby/",
                "vote_count": "1639"
            },
            {
                "language": "cpp",
                "code": "public int removeDuplicates(int[] nums) {\n    int i = 0;\n    for(int n : nums)\n        if(i < 1 || n > nums[i - 1]) \n            nums[i++] = n;\n    return i;\n}",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/27987/short-and-simple-java-solution-easy-to-understand/",
                "vote_count": "354"
            },
            {
                "language": "cpp",
                "code": "public int removeDuplicates(int[] nums) {\n   int i = 0;\n   for (int n : nums)\n      if (i < 2 || n > nums[i - 2])\n         nums[i++] = n;\n   return i;\n}",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/27987/short-and-simple-java-solution-easy-to-understand/",
                "vote_count": "354"
            },
            {
                "language": "cpp",
                "code": "    public int removeDuplicates(int[] A) {\n        int i = 2;\n        for (int j = 2; j < A.length; j++)\n            if (A[j] != A[i-2])\n                A[i++] = A[j];\n        return i;\n    }",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/27987/short-and-simple-java-solution-easy-to-understand/",
                "vote_count": "354"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def removeDuplicates(self, nums):\n  if len(nums) < 2: return len(nums)\n        slow, fast = 2, 2\n\n        while fast < len(nums):\n            if nums[slow - 2] != nums[fast]:\n                nums[slow] = nums[fast]\n                slow += 1\n            fast += 1\n        return slow",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/967951/python-two-pointers-approach-explained/",
                "vote_count": "179"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n       \"\"\"\n        [1,1,1,1,1,2,2,2,3]\n             sf                : nums[f] == nums[s-2] ; f is at a dupe ; s is at first dupe >2 \n             s f               : nums[f] == nums[s-2] ; f is at a dupe ; s is at first dupe >2\n             s   f             : nums[f] == nums[s-2] ; f is at a dupe ; s is at first dupe >2\n             s    f            : nums[f] != nums[s-2] ; f is at next val; swap and move s ahead",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/967951/python-two-pointers-approach-explained/",
                "vote_count": "179"
            },
            {
                "language": "go",
                "code": "    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) <= 2:\n            return len(nums)\n        \n        pointer = 1\n        for i in range(2,len(nums)):\n            if nums[i] != nums[pointer-1]:\n                pointer += 1",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/967951/python-two-pointers-approach-explained/",
                "vote_count": "179"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        low, i = 0, 0\n        for curr, num in enumerate(nums):\n            if num != nums[low]:\n                low = curr\n            if curr - low < 2:\n                nums[i] = num",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/967951/python-two-pointers-approach-explained/",
                "vote_count": "179"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        # each unique element appears at most x times, nums[:k+1] is the array without duplicates\n        k = x = 2\n        for i in range(x, len(nums)):\n            if nums[i] != nums[k-x]:\n                nums[k] = nums[i]\n                k += 1",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/967951/python-two-pointers-approach-explained/",
                "vote_count": "179"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        // the intution behind this ->  go through all the elements, along with that check if the \n  // current element has been included previously or not\n  // if included skip it, else add it\n    int ind = 0;\n    for (auto it : nums) \n    {\n        if (ind < 2 or it > nums[ind-2]) \n        {\n            nums[ind++] = it;\n        }\n    }\n    return ind; // this will contain the no of unique elements in the array\n    }\n};",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/1748592/0ms-100-faster-c-solution-short-and-simple/",
                "vote_count": "87"
            },
            {
                "language": "cpp",
                "code": "class Solution\n{\npublic:\n    int removeDuplicates(vector<int> &nums)\n    {\n        int prev = nums[0], count = 1, pos = 1;\n        for (int i = 1; i < nums.size(); i++)\n            if (prev != nums[i])",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/1748592/0ms-100-faster-c-solution-short-and-simple/",
                "vote_count": "87"
            },
            {
                "language": "java",
                "code": "public int removeDuplicates(int[] nums) {\n var n = nums.length;\n if (n < 3)\n  return n;\n  \n var i = 2;\n for (var j = i; j < n; j++)\n  if (nums[j] != nums[i - 2])\n   nums[i++] = nums[j];\n   \n return i;\n}",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/1748197/java-simple-any-repetitions-explained/",
                "vote_count": "68"
            },
            {
                "language": "java",
                "code": "public int removeDuplicates(int[] nums, int k) {\n var n = nums.length;\n if (n < k + 1)\n  return n;\n  \n var i = k;\n for (var j = i; j < n; j++)\n  if (nums[i - k] != nums[j])\n   nums[i++] = nums[j];\n   \n return i;\n}",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/1748197/java-simple-any-repetitions-explained/",
                "vote_count": "68"
            },
            {
                "language": "cpp",
                "code": "class Solution\n{\npublic:\n    int removeDuplicates(vector<int> &nums)\n    {\n        int prev = nums[0], count = 1, pos = 1;\n        for (int i = 1; i < nums.size(); i++)\n            if (prev != nums[i])",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solutions/1748197/java-simple-any-repetitions-explained/",
                "vote_count": "68"
            }
        ]
    },
    "80": {
        "question_id": 81,
        "title": "Search in Rotated Sorted Array II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii",
        "description": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).Before being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.You must decrease the overall operation steps as much as possible. ",
        "examples": [
            {
                "input": "nums = [2,5,6,0,0,1,2], target = 0",
                "output": "true",
                "explanation": null
            }
        ],
        "constraints": [],
        "solutions": [
            {
                "language": "java",
                "code": "1) everytime check if targe == nums[mid], if so, we find it.\n2) otherwise, we check if the first half is in order (i.e. nums[left]<=nums[mid]) \n  and if so, go to step 3), otherwise, the second half is in order,   go to step 4)\n3) check if target in the range of [left, mid-1] (i.e. nums[left]<=target < nums[mid]), if so, do search in the first half, i.e. right = mid-1; otherwise, search in the second half left = mid+1;\n4)  check if target in the range of [mid+1, right] (i.e. nums[mid]<target <= nums[right]), if so, do search in the second half, i.e. left = mid+1; otherwise search in the first half right = mid-1;",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/28218/my-8ms-c-solution-o-logn-on-average-o-n-worst-case/",
                "vote_count": "578"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        int left = 0, right =  nums.size()-1, mid;\n        \n        while(left<=right)\n        {\n            mid = (left + right) >> 1;\n            if(nums[mid] == target) return true;\n\n            // the only difference from the first one, trickly case, just updat left and right\n            if( (nums[left] == nums[mid]) && (nums[right] == nums[mid]) ) {++left; --right;}\n\n            else if(nums[left] <= nums[mid])\n            {\n                if( (nums[left]<=target) && (nums[mid] > target) ) right = mid-1;\n                else left = mid + 1; \n            }\n            else\n            {\n                if((nums[mid] < target) &&  (nums[right] >= target) ) left = mid+1;\n                else right = mid-1;\n            }\n        }\n        return false;\n    }\n};",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/28218/my-8ms-c-solution-o-logn-on-average-o-n-worst-case/",
                "vote_count": "578"
            },
            {
                "language": "java",
                "code": "public boolean search(int[] nums, int target) {\n    int left= 0;\n    int right= nums.length - 1;\n    while (left<= right) {\n        int mid = (left+ right) / 2;\n        if (target == nums[mid]) {\n            return true;\n        } ",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/28218/my-8ms-c-solution-o-logn-on-average-o-n-worst-case/",
                "vote_count": "578"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool search(vector<int>& A, int t) {\n        if (A.empty()) \n            return false;\n        ",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/28218/my-8ms-c-solution-o-logn-on-average-o-n-worst-case/",
                "vote_count": "578"
            },
            {
                "language": "python",
                "code": "        pivot = nums[0]\n        if target == pivot: return True\n\n        lo, hi = 0, len(nums) - 1\n        while hi >= 0 and nums[hi] == pivot:\n            hi -= 1",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/28218/my-8ms-c-solution-o-logn-on-average-o-n-worst-case/",
                "vote_count": "578"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/28218/my-8ms-c-solution-o-logn-on-average-o-n-worst-case/",
                "vote_count": "578"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int l = 0, r = nums.size()-1;\n        \n        while (l <= r) ",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/28218/my-8ms-c-solution-o-logn-on-average-o-n-worst-case/",
                "vote_count": "578"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/28218/my-8ms-c-solution-o-logn-on-average-o-n-worst-case/",
                "vote_count": "578"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        if(nums.size() == 0) return false;\n        // Find the non-duplicated head: h\n        int h = 0;\n        while(h != nums.size()-1 && nums[h] == nums[nums.size()-1]) h++;\n        // Previous algorithm can deal with duplicated items if the head of array is not a duplicated item",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/28218/my-8ms-c-solution-o-logn-on-average-o-n-worst-case/",
                "vote_count": "578"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        low, high = 0, len(nums) - 1\n        while low <= high:\n            mid = low + (high - low) // 2\n            if nums[mid] == target:\n                return True\n            ",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/28218/my-8ms-c-solution-o-logn-on-average-o-n-worst-case/",
                "vote_count": "578"
            },
            {
                "language": "csharp",
                "code": "1. Easy C++\n2. Line by Line Explanation with Comments.\n3. Detailed Explanation \u2705\n4. Initution is to use Binary Search\n5. Please Upvote if it helps\u2b06\ufe0f\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \u2b07\ufe0f\n // \ud83d\ude09If you Like the repository don't foget to star & fork the repository\ud83d\ude09",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/1890199/c-algorithm-binary-search/",
                "vote_count": "285"
            },
            {
                "language": "cpp",
                "code": "   // \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09Please upvote if it helps \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09\nclass Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        int l = 0;\n        int r = nums.size() - 1;\n        \n        while(l <= r)\n        {\n            int mid = l + (r-l) / 2;\n            if (nums[mid] == target)\n                return true;\n   // with duplicates we can have this contdition, just update left & right\n            if((nums[l] == nums[mid]) && (nums[r] == nums[mid]))\n            {\n                l++;\n                r--;\n            }\n   // first half\n   // first half is in order\n            else if(nums[l] <= nums[mid])\n            {\n    // target is in first  half\n                if((nums[l] <= target) && (nums[mid] > target))\n                    r = mid - 1;\n                else\n                    l = mid + 1;\n            }\n   // second half\n   // second half is order\n   // target is in second half\n            else\n            {\n                if((nums[mid] < target) && (nums[r]>= target))\n                    l = mid + 1;\n                else\n                    r = mid - 1;\n            }\n        }\n        return false;\n    }\n // for github repository link go to my profile.\n};",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/1890199/c-algorithm-binary-search/",
                "vote_count": "285"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        for(int i = 0; i < nums.size(); i++)\n            if(nums[i] == target) return true;\n        return false;\n    }\n};",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/1890199/c-algorithm-binary-search/",
                "vote_count": "285"
            },
            {
                "language": "dart",
                "code": "",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/1890199/c-algorithm-binary-search/",
                "vote_count": "285"
            },
            {
                "language": "",
                "code": "if((nums[l] == nums[mid]) && (nums[r] == nums[mid]))\n {\n          l++;\n          r--;",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/1890199/c-algorithm-binary-search/",
                "vote_count": "285"
            },
            {
                "language": "python",
                "code": "# If the length of the given array list is 1, then check the first element and return accordingly\nif len(nums)==1:\n    if nums[0]!=target:\n        return False\n    else:\n        return True\n\nleft=0\nright=len(nums)-1\n# binary search \nwhile(left<=right):\n\n    # shifting to remove duplicate elements\n    while left<right and nums[left] == nums[left+1]:\n        left+=1\n    while left<right and nums[right] == nums[right-1]:\n        right-=1\n\n    # step 1 calculate the mid    \n    mid=(left+right)//2\n\n    #step 2\n    if nums[mid]==target:\n        return True\n\n    #step 3\n    elif nums[left]<=nums[mid]:\n        if nums[mid]>=target and nums[left]<=target:\n            right=mid-1\n        else:\n            left=mid+1\n\n    # step 4\n    else:\n        if target>=nums[mid] and target<=nums[right]:\n            left=mid+1\n        else:\n            right=mid-1\n\n# step 5\nreturn False",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/1890363/python-binary-search-explained/",
                "vote_count": "59"
            },
            {
                "language": "cpp",
                "code": "bool search(vector<int>& nums, int target) {\n    int n = nums.size();\n    int min_index = 0;",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/1890363/python-binary-search-explained/",
                "vote_count": "59"
            },
            {
                "language": "java",
                "code": "class Solution {\n  int findRotation(int [] nums, int first, int count) {\n    while(count > 0) {\n      int steps = count >> 1;\n      int it = first + steps;\n      if(nums[it] > nums[0]) {\n        first = it+1;\n        count -= (steps+1);",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/1890363/python-binary-search-explained/",
                "vote_count": "59"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        \n        if( nums[0] == target or nums.back() == target ) return true; \n        // this line is redundant it reduces only the worst case when all elements are same to O(1)\n        \n        const int n = nums.size();\n        int l = 0 , h = n-1;\n        while( l+1 < n and nums[l] == nums[l+1]) l++;\n\n        // if all elements are same\n        if( l == n-1){\n            if( nums[0] == target ) return true;\n            else return false;\n        }\n        \n        // while last element is equal to 1st element\n        while( h >= 0 and nums[h] == nums[0] ) h--;\n        int start = l , end = h;\n        \n        // find the point of pivot ie from where the rotation starts\n        int pivot = -1;\n        while( l <= h ){\n            int mid = l + (h-l)/2;\n            if( nums[mid] >= nums[0] ) l = mid+1;\n            else {\n                pivot = mid;\n                h = mid-1;\n            }\n        }\n        \n        \n        if( pivot == -1 ) l = start , h = end; // if no pivot exits then search space is from start -e end\n        else {\n            if( target > nums[end] ) l = start , h = pivot-1; // search space second half\n            else l = pivot , h = end; // search space first half\n        }\n        \n        // normal binary search\n        while ( l <= h ){\n            int mid = l + (h-l)/2;\n            if( nums[mid] > target ) h = mid-1;\n            else if( nums[mid] < target ) l = mid+1;\n            else return true;\n        }\n        \n        return false;\n        \n    }\n};",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/1890619/an-unique-intuitive-approach-logn/",
                "vote_count": "34"
            },
            {
                "language": "javascript",
                "code": "if( target > nums[end] ) l = start , h = pivot-1; // search space second half\n            else l = pivot , h = end; // search space first half",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/1890619/an-unique-intuitive-approach-logn/",
                "vote_count": "34"
            },
            {
                "language": "ruby",
                "code": "for(int i = 1 ; i<n; i++)",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/1890619/an-unique-intuitive-approach-logn/",
                "vote_count": "34"
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {boolean}\n */",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/1890619/an-unique-intuitive-approach-logn/",
                "vote_count": "34"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean search(int[] nums, int target) {\n      int start = 0, end = nums.length - 1;\n      while(start <= end) {\n          int mid = start + (end - start) / 2;\n          if(nums[mid] == target) return true;\n          \n          //if there are duplicates\n          if(nums[start] == nums[mid] && nums[mid] == nums[end]) {\n                start ++;\n                end --;\n            }\n          \n          //left half is sorted\n          else if(nums[start] <= nums[mid]) {\n              if(target >= nums[start] && target <= nums[mid])\n              end = mid - 1;\n\n              else\n              start = mid + 1;\n          }\n\n          //right half is sorted\n          else {\n              if(target <= nums[end] && target >= nums[mid])\n              start = mid + 1;\n\n              else\n              end = mid - 1; \n          }\n      }\n      return false;\n    }\n}",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/2689441/java-best-solution-for-understanding/",
                "vote_count": "26"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public boolean search(int[] nums, int target) {\n        int peak = findPivotWithDuplicates(nums);\n\n        if (peak == -1){\n            return binarySearch(nums, target, 0, nums.length-1);\n        }",
                "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/2689441/java-best-solution-for-understanding/",
                "vote_count": "26"
            }
        ]
    },
    "81": {
        "question_id": 82,
        "title": "Remove Duplicates from Sorted List II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii",
        "description": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well. ",
        "examples": [
            {
                "input": "head = [1,2,3,3,4,4,5]",
                "output": "[1,2,5]",
                "explanation": null
            },
            {
                "input": "head = [1,1,1,2,3]",
                "output": "[2,3]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is in the range [0, 300].",
            "-100 <= Node.val <= 100",
            "The list is guaranteed to be sorted in ascending order."
        ],
        "solutions": [
            {
                "language": "kotlin",
                "code": "public ListNode deleteDuplicates(ListNode head) {\n        if(head==null) return null;\n        ListNode FakeHead=new ListNode(0);\n        FakeHead.next=head;\n        ListNode pre=FakeHead;\n        ListNode cur=head;\n        while(cur!=null){\n            while(cur.next!=null&&cur.val==cur.next.val){\n                cur=cur.next;\n            }\n            if(pre.next==cur){\n                pre=pre.next;\n            }\n            else{\n                pre.next=cur.next;\n            }\n            cur=cur.next;\n        }\n        return FakeHead.next;\n    }",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/28335/my-accepted-java-code/",
                "vote_count": "500"
            },
            {
                "language": "kotlin",
                "code": "public class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head==null||head.next==null) return head;\n        \n        if(head.val!=head.next.val){\n            head.next=deleteDuplicates(head.next);\n            return head;\n        }",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/28335/my-accepted-java-code/",
                "vote_count": "500"
            },
            {
                "language": "ruby",
                "code": "        add some comment:)\n        if (pre.next == cur) { \n            pre = pre.next;// cur.val is distinct, move pre to next node\n        } else {\n            pre.next = cur.next;// skip duplicates, but pre shouldn't move now\n        }",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/28335/my-accepted-java-code/",
                "vote_count": "500"
            },
            {
                "language": "kotlin",
                "code": "public ListNode deleteDuplicates(ListNode head) {\n    if (head == null) {\n        return null;\n    }",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/28335/my-accepted-java-code/",
                "vote_count": "500"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/28335/my-accepted-java-code/",
                "vote_count": "500"
            },
            {
                "language": "python",
                "code": " while(cur.next!=null&&cur.val==cur.next.val){\n                cur=cur.next;\n            }",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/28335/my-accepted-java-code/",
                "vote_count": "500"
            },
            {
                "language": "rust",
                "code": "    ListNode *dummy=new ListNode(0,head);\n       ListNode *prev=dummy;\n        \n        while(head!=NULL){\n       \n        if(head->next!=NULL && head->val==head->next->val){\n                \nwhile(head->next!=NULL && head->val==head->next->val)head=head->next;\n                     \n                   \n                        prev->next=head->next;\n                }\n                \n                else prev=prev->next;\n                       \n               \n                head=head->next;\n        }\n        \n        return dummy->next;\n            \n    }\n \n \n //if(you_like_and_understand_my_solution)\n //{\n //  please_upvote++;\n // }\n \n /*Guys plz plz plz upvote my solution if you really like and understand it.and if you stuck at any point then feel free to comment*/.",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/1395724/8-lines-c-solution-faster-than-100-submissions-for-beginners-explanation-of-approach/",
                "vote_count": "230"
            },
            {
                "language": "ruby",
                "code": "ListNode* deleteDuplicates(ListNode* head) {\n    ListNode dummy(0, head);\n    ListNode *previous = &dummy, *current = head;\n    \n    while(current) {\n        ListNode *next_node = current->next;\n        while(next_node && current->val == next_node->val) {\n            ListNode *temp = next_node->next;",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/1395724/8-lines-c-solution-faster-than-100-submissions-for-beginners-explanation-of-approach/",
                "vote_count": "230"
            }
        ]
    },
    "82": {
        "question_id": 83,
        "title": "Remove Duplicates from Sorted List",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list",
        "description": "Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. ",
        "examples": [
            {
                "input": "head = [1,1,2]",
                "output": "[1,2]",
                "explanation": null
            },
            {
                "input": "head = [1,1,2,3,3]",
                "output": "[1,2,3]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is in the range [0, 300].",
            "-100 <= Node.val <= 100",
            "The list is guaranteed to be sorted in ascending order."
        ],
        "solutions": [
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* temp=head;\n        while (temp&&temp->next)\n        {\n            if (temp->next->val==temp->val)\n            {\n                temp->next=temp->next->next;\n                continue;\n            }\n            temp=temp->next;\n        }\n        return head;\n    }\n};",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3257316/c-python-c-java-easiest-solution-o-n-time/",
                "vote_count": "35"
            },
            {
                "language": "ruby",
                "code": "class Solution(object):\n    def deleteDuplicates(self, head):\n        temp = head\n        while (temp and temp.next):\n            if (temp.next.val == temp.val):\n                temp.next = temp.next.next\n                continue\n            temp = temp.next\n        return head\n        ",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3257316/c-python-c-java-easiest-solution-o-n-time/",
                "vote_count": "35"
            },
            {
                "language": "rust",
                "code": "struct ListNode* deleteDuplicates(struct ListNode* head) {\n    struct ListNode* temp=head;\n    while (temp&&temp->next)\n    {\n        if (temp->next->val==temp->val)\n        {\n            temp->next=temp->next->next;\n            continue;\n        }\n        temp=temp->next;\n    }\n    return head;\n}",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3257316/c-python-c-java-easiest-solution-o-n-time/",
                "vote_count": "35"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode temp = head;\n        while (temp != null && temp.next != null)\n        {\n            if (temp.next.val==temp.val)\n            {\n                temp.next=temp.next.next;\n                continue;\n            }\n            temp=temp.next;\n        }\n        return head;\n    }\n}",
                "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/solutions/3257316/c-python-c-java-easiest-solution-o-n-time/",
                "vote_count": "35"
            }
        ]
    },
    "83": {
        "question_id": 84,
        "title": "Largest Rectangle in Histogram",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/largest-rectangle-in-histogram",
        "description": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram. ",
        "examples": [
            {
                "input": "heights = [2,1,5,6,2,3]",
                "output": "10",
                "explanation": "The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units."
            },
            {
                "input": "heights = [2,4]",
                "output": "4",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= heights.length <= 10^5",
            "0 <= heights[i] <= 10^4"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "int maxArea = 0;\nfor (int i = 0; i < height.length; i++) {\n    maxArea = Math.max(maxArea, height[i] * (lessFromRight[i] - lessFromLeft[i] - 1));\n}",
                "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/28902/5ms-o-n-java-solution-explained-beats-96/",
                "vote_count": "1167"
            },
            {
                "language": "python",
                "code": "for (int i = 1; i < height.length; i++) {              \n    int p = i - 1;\n    while (p >= 0 && height[p] >= height[i]) {\n        p--;\n    }\n    lessFromLeft[i] = p;              \n}",
                "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/28902/5ms-o-n-java-solution-explained-beats-96/",
                "vote_count": "1167"
            },
            {
                "language": "javascript",
                "code": "while (p >= 0 && height[p] >= height[i]) {\n      p = lessFromLeft[p];\n}",
                "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/28902/5ms-o-n-java-solution-explained-beats-96/",
                "vote_count": "1167"
            },
            {
                "language": "java",
                "code": "public static int largestRectangleArea(int[] height) {\n    if (height == null || height.length == 0) {\n        return 0;\n    }\n    int[] lessFromLeft = new int[height.length]; // idx of the first bar the left that is lower than current\n    int[] lessFromRight = new int[height.length]; // idx of the first bar the right that is lower than current\n    lessFromRight[height.length - 1] = height.length;\n    lessFromLeft[0] = -1;\n\n    for (int i = 1; i < height.length; i++) {\n        int p = i - 1;\n\n        while (p >= 0 && height[p] >= height[i]) {\n            p = lessFromLeft[p];\n        }\n        lessFromLeft[i] = p;\n    }\n\n    for (int i = height.length - 2; i >= 0; i--) {\n        int p = i + 1;\n\n        while (p < height.length && height[p] >= height[i]) {\n            p = lessFromRight[p];\n        }\n        lessFromRight[i] = p;\n    }\n\n    int maxArea = 0;\n    for (int i = 0; i < height.length; i++) {\n        maxArea = Math.max(maxArea, height[i] * (lessFromRight[i] - lessFromLeft[i] - 1));\n    }\n\n    return maxArea;\n}",
                "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/28902/5ms-o-n-java-solution-explained-beats-96/",
                "vote_count": "1167"
            },
            {
                "language": "",
                "code": "p = lessFromLeft[p];",
                "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/28902/5ms-o-n-java-solution-explained-beats-96/",
                "vote_count": "1167"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public int largestRectangleArea(int[] h) {\n        int n = h.length;\n        int max = 0;\n        int[] stack = new int[n + 1];\n        int is = -1;\n        for (int i = 0; i <= n; i++) {",
                "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/28902/5ms-o-n-java-solution-explained-beats-96/",
                "vote_count": "1167"
            },
            {
                "language": "python",
                "code": "def largestRectangleArea(self, height):\n    height.append(0)\n    stack = [-1]\n    ans = 0\n    for i in xrange(len(height)):\n        while height[i] < height[stack[-1]]:\n            h = height[stack.pop()]\n            w = i - stack[-1] - 1\n            ans = max(ans, h * w)\n        stack.append(i)\n    height.pop()\n    return ans\n\n\n\n# 94 / 94 test cases passed.\n# Status: Accepted\n# Runtime: 76 ms\n# 97.34%",
                "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/28917/ac-python-clean-solution-using-stack-76ms/",
                "vote_count": "562"
            },
            {
                "language": "ruby",
                "code": "def largestRectangleArea(self, heights):\n    heights.append(0)\n    stack = [-1]\n    ans = 0",
                "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/28917/ac-python-clean-solution-using-stack-76ms/",
                "vote_count": "562"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/28917/ac-python-clean-solution-using-stack-76ms/",
                "vote_count": "562"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/28917/ac-python-clean-solution-using-stack-76ms/",
                "vote_count": "562"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/28917/ac-python-clean-solution-using-stack-76ms/",
                "vote_count": "562"
            },
            {
                "language": "swift",
                "code": "What the Question is saying, \nGiven an array of integers heights representing the histogram's bar height where the width of each bar is 1, \nreturn the area of the largest rectangle in the histogram.",
                "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/1727776/java-c-explanation-going-from-brute-to-optimal-approach/",
                "vote_count": "139"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int n = heights.length;\n        if(n == 0) return 0; // Base Condition\n        int maxArea = 0;\n        int left[] = new int[n]; //fill left boundary\n        int right[] = new int[n]; // fill right boundary\n        \n        left[0] = -1;\n        right[n - 1] = n;\n        \n        for(int i = 1; i < n; i++){\n            int prev = i - 1; // previous for comparing the heights\n            while(prev >= 0 && heights[prev] >= heights[i]){\n                prev = left[prev]; // we have done this to minimise the jumps we make to the left\n            }\n            left[i] = prev;\n        }\n        // Similarly we do for right\n        for(int i = n - 2; i >= 0; i--){\n            int prev = i + 1; \n            while(prev < n && heights[prev] >= heights[i]){\n                prev = right[prev]; \n            }\n            right[i] = prev;\n        }\n        // once we have these two arrays fill we need width & area\n        for(int i = 0; i < n; i++){\n            int width = right[i] - left[i] - 1;\n            maxArea = Math.max(maxArea, heights[i] * width);\n        }\n        return maxArea;\n        \n    }\n}",
                "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/1727776/java-c-explanation-going-from-brute-to-optimal-approach/",
                "vote_count": "139"
            },
            {
                "language": "java",
                "code": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        if(n == 0) return 0; // Base Condition\n        int maxArea = 0;\n        vector<int> left(n); //fill left boundary\n        vector<int> right(n); // fill right boundary\n        \n        left[0] = -1;\n        right[n - 1] = n;\n        \n        for(int i = 1; i < n; i++){\n            int prev = i - 1; // previous for comparing the heights\n            while(prev >= 0 && heights[prev] >= heights[i]){\n                prev = left[prev]; // we have done this to minimise the jumps we make to the left\n            }\n            left[i] = prev;\n        }\n        // Similarly we do for right\n        for(int i = n - 2; i >= 0; i--){\n            int prev = i + 1; \n            while(prev < n && heights[prev] >= heights[i]){\n                prev = right[prev]; \n            }\n            right[i] = prev;\n        }\n        // once we have these two arrays fill we need width & area\n        for(int i = 0; i < n; i++){\n            int width = right[i] - left[i] - 1;\n            maxArea = max(maxArea, heights[i] * width);\n        }\n        return maxArea;\n    }\n};",
                "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/1727776/java-c-explanation-going-from-brute-to-optimal-approach/",
                "vote_count": "139"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int n = heights.length;\n        int maxArea = 0;\n        Stack<Integer> st = new Stack<>();\n        \n        for(int i = 0; i <= n; i++){\n            int currHeight = i == n ? 0 : heights[i];\n            // check if currHeight becomes greater then height[top] element of stack. we do a push because it's an increasing sequence\n            // otherwise we do pop and find area, so for that we write a while loop\n            while(!st.isEmpty() && currHeight < heights[st.peek()]){\n                int top = st.pop(); // current element on which we are working\n                // now we need width & area\n                int width = st.isEmpty() ? i : i - st.peek() - 1; // width differ, if stack is empty or not empty after we pop the element\n                int area = heights[top] * width; // current height * width\n                maxArea = Math.max(area, maxArea);\n            }\n            // if it doesn't enter in while loop, it means it's an increasing sequence & we need to push index\n            st.push(i);\n        }\n        return maxArea;\n    }\n}",
                "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/1727776/java-c-explanation-going-from-brute-to-optimal-approach/",
                "vote_count": "139"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        int maxArea = 0;\n        stack<int> st;\n        \n        for(int i = 0; i <= n; i++){\n            int currHeight = i == n ? 0 : heights[i];\n            // check if currHeight becomes greater then height[top] element of stack. we do a push because it's an increasing sequence\n            // otherwise we do pop and find area, so for that we write a while loop\n            while(!st.empty() && currHeight < heights[st.top()]){\n                int top = st.top(); st.pop(); // current element on which we are working\n                // now we need width & area\n                int width = st.empty() ? i : i - st.top() - 1; // width differ if we stack is empty or not empty after we pop the element\n                int area = heights[top] * width; // current height * width\n                maxArea = max(area, maxArea);\n            }\n            // if it doesn't enter in while loop, it means it's an increasing sequence & we need to push index\n            st.push(i);\n        }\n        return maxArea;\n    }\n};",
                "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/1727776/java-c-explanation-going-from-brute-to-optimal-approach/",
                "vote_count": "139"
            },
            {
                "language": "php",
                "code": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& hts) {\n        int size=hts.size();\n        int to_right[size];\n        stack<int> st;",
                "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/1727776/java-c-explanation-going-from-brute-to-optimal-approach/",
                "vote_count": "139"
            },
            {
                "language": "cpp",
                "code": "int largestRectangleArea(vector<int> &height) {\n\nint maxArea = 0;\nheight.push_back(0); //why? coz 0 will always be lesser than than previous non zero stack element so we can calculate area of all previous element w.r.t it.\nstack<int> index; //store index of previous smaller index\n\nfor(int i = 0; i < height.size(); i++)\n{",
                "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/1727776/java-c-explanation-going-from-brute-to-optimal-approach/",
                "vote_count": "139"
            }
        ]
    },
    "84": {
        "question_id": 85,
        "title": "Maximal Rectangle",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/maximal-rectangle",
        "description": "Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. ",
        "examples": [
            {
                "input": "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
                "output": "6",
                "explanation": "The maximal rectangle is shown in the above picture."
            },
            {
                "input": "matrix = [[\"0\"]]",
                "output": "0",
                "explanation": null
            },
            {
                "input": "matrix = [[\"1\"]]",
                "output": "1",
                "explanation": null
            }
        ],
        "constraints": [
            "rows == matrix.length",
            "cols == matrix[i].length",
            "1 <= row, cols <= 200",
            "matrix[i][j] is '0' or '1'."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {public:\nint maximalRectangle(vector<vector<char> > &matrix) {\n    if(matrix.empty()) return 0;\n    const int m = matrix.size();\n    const int n = matrix[0].size();\n    int left[n], right[n], height[n];\n    fill_n(left,n,0); fill_n(right,n,n); fill_n(height,n,0);\n    int maxA = 0;\n    for(int i=0; i<m; i++) {\n        int cur_left=0, cur_right=n; \n        for(int j=0; j<n; j++) { // compute height (can do this from either side)\n            if(matrix[i][j]=='1') height[j]++; \n            else height[j]=0;\n        }\n        for(int j=0; j<n; j++) { // compute left (from left to right)\n            if(matrix[i][j]=='1') left[j]=max(left[j],cur_left);\n            else {left[j]=0; cur_left=j+1;}\n        }\n        // compute right (from right to left)\n        for(int j=n-1; j>=0; j--) {\n            if(matrix[i][j]=='1') right[j]=min(right[j],cur_right);\n            else {right[j]=n; cur_right=j;}    \n        }\n        // compute the area of rectangle (can do this from either side)\n        for(int j=0; j<n; j++)\n            maxA = max(maxA,(right[j]-left[j])*height[j]);\n    }\n    return maxA;\n}",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29054/share-my-dp-solution/",
                "vote_count": "1316"
            },
            {
                "language": "",
                "code": "0 0 0 1 0 0 0 \n0 0 1 1 1 0 0 \n0 1 1 1 1 1 0",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29054/share-my-dp-solution/",
                "vote_count": "1316"
            },
            {
                "language": "",
                "code": "l: 0 0 0 3 0 0 0\nr: 7 7 7 4 7 7 7",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29054/share-my-dp-solution/",
                "vote_count": "1316"
            },
            {
                "language": "",
                "code": "l: 0 0 2 3 2 0 0\nr: 7 7 5 4 5 7 7 ",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29054/share-my-dp-solution/",
                "vote_count": "1316"
            },
            {
                "language": "",
                "code": "l: 0 1 2 3 2 1 0\nr: 7 6 5 4 5 6 7",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29054/share-my-dp-solution/",
                "vote_count": "1316"
            },
            {
                "language": "java",
                "code": "/* we start from the first row, and move downward;\n * height[i] record the current number of countinous '1' in column i;\n * left[i] record the left most index j which satisfies that for any index k from j to  i, height[k] >= height[i];\n * right[i] record the right most index j which satifies that for any index k from i to  j, height[k] >= height[i];\n * by understanding the definition, we can easily figure out we need to update maxArea with value (height[i] * (right[i] - left[i] + 1));\n * \n * Then the question is how to update the array of height, left, and right\nreturn 0;",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29054/share-my-dp-solution/",
                "vote_count": "1316"
            },
            {
                "language": "",
                "code": "height: 0 0 0 1 0 0 0\nleft: 0 0 0 3 0 0 0\nright 7 7 7 4 7 7 7",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29054/share-my-dp-solution/",
                "vote_count": "1316"
            },
            {
                "language": "",
                "code": "",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29054/share-my-dp-solution/",
                "vote_count": "1316"
            },
            {
                "language": "",
                "code": "",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29054/share-my-dp-solution/",
                "vote_count": "1316"
            },
            {
                "language": "",
                "code": "matrix\n0 0 0 1 0 0 0\n0 0 1 1 1 0 0\n0 1 1 1 1 1 0",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29054/share-my-dp-solution/",
                "vote_count": "1316"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29054/share-my-dp-solution/",
                "vote_count": "1316"
            },
            {
                "language": "cpp",
                "code": "public int maximalRectangle(char[][] matrix) {\n        if(matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0) return 0;\n        int[] heights = new int[matrix[0].length];\n        int ans = 0;\n        for(int i = 0;i<matrix.length;i++){\n            for(int j = 0;j<matrix[0].length;j++){\n                if(matrix[i][j] == '0') heights[j] = 0;\n                else heights[j]++;\n){",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29054/share-my-dp-solution/",
                "vote_count": "1316"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public int maximalRectangle(char[][] matrix) {\n        if (matrix==null||matrix.length==0||matrix[0].length==0)\n            return 0;\n        int cLen = matrix[0].length;    // column length\n        int rLen = matrix.length;       // row length\n        // height array \n        int[] h = new int[cLen+1];\n        h[cLen]=0;\n        int max = 0;\n        \n        \n        for (int row=0;row<rLen;row++) {\n            Stack<Integer> s = new Stack<Integer>();\n            for (int i=0;i<cLen+1;i++) {\n                if (i<cLen)\n                    if(matrix[row][i]=='1')\n                        h[i]+=1;\n                    else h[i]=0;\n                \n                if (s.isEmpty()||h[s.peek()]<=h[i])\n                    s.push(i);\n                else {\n                    while(!s.isEmpty()&&h[i]<h[s.peek()]){\n                        int top = s.pop();\n                        int area = h[top]*(s.isEmpty()?i:(i-s.peek()-1));\n                        if (area>max)\n                            max = area;\n                    }\n                    s.push(i);\n                }\n            }\n        }\n        return max;\n    }\n}",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29064/a-o-n-2-solution-based-on-largest-rectangle-in-histogram/",
                "vote_count": "422"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    \n    public int maximalRectangle(char[][] matrix) {\n        if(matrix.length==0) return 0;\n\n        int[][] dp = new int[matrix.length][matrix[0].length];\n        for (int i = 0; i < dp.length; i++) {\n            for (int j = 0; j < dp[0].length; j++) {",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29064/a-o-n-2-solution-based-on-largest-rectangle-in-histogram/",
                "vote_count": "422"
            },
            {
                "language": "cpp",
                "code": "the same idea, but more concise    \n\nint maximalRectangle(vector<vector<char> > &matrix) {\n    if (matrix.size() <= 0 || matrix[0].size() <= 0)\n        return 0;\n        \n    int m = matrix.size();\n    int n = matrix[0].size() + 1;\n    int h = 0, w = 0, ret = 0;",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29064/a-o-n-2-solution-based-on-largest-rectangle-in-histogram/",
                "vote_count": "422"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int maximalRectangle(char[][] matrix) {\n       int rLen = matrix.length, cLen = rLen == 0 ? 0 : matrix[0].length, max = 0;\n        int[] h = new int[cLen+1];\n   \n        for (int row = 0; row < rLen; row++) {\n            Stack<Integer> s = new Stack<Integer>();\n            s.push(-1);",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29064/a-o-n-2-solution-based-on-largest-rectangle-in-histogram/",
                "vote_count": "422"
            },
            {
                "language": "java",
                "code": "class Solution {\n    //optimized according to the version below\n    public int maximalRectangle(char[][] matrix) {\n        if(matrix.length==0)  return 0;\n        \n        int row = matrix.length;\n        int col = matrix[0].length;\n        ",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29064/a-o-n-2-solution-based-on-largest-rectangle-in-histogram/",
                "vote_count": "422"
            },
            {
                "language": "cpp",
                "code": "public int maximalRectangle(char[][] matrix) {\n    if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;\n    int max = Integer.MIN_VALUE;\n    int[] height = new int[matrix[0].length + 1];\n    for(int r = 0; r < matrix.length; r++) {\n        Stack<Integer> stack = new Stack<Integer>();\n        for(int c = 0; c < height.length; c++) {\n            if(c < matrix[0].length) {\n),",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29064/a-o-n-2-solution-based-on-largest-rectangle-in-histogram/",
                "vote_count": "422"
            },
            {
                "language": "java",
                "code": "public class Solution {\npublic int maximalRectangle(char[][] matrix) {\n    if (matrix==null||matrix.length==0)\n        return 0;\n    if (matrix[0]==null||matrix[0].length==0)\n        return 0;\n        \n    int[] record = new int[matrix[0].length];",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29064/a-o-n-2-solution-based-on-largest-rectangle-in-histogram/",
                "vote_count": "422"
            },
            {
                "language": "cpp",
                "code": "int maximalRectangle(vector<vector<char>>& matrix)\n{\n    int maxRect = 0;\n    vector<int> packed(matrix.empty() ? 0 : matrix[0].size(), 0);\n    for (vector<char>& row : matrix) // given row[i], packed[] = row[0] + row[1] + row[2] + ... + row[i]\n    {\n        for (unsigned j = 0; j < row.size(); packed[j] = row[j] == '1' ? packed[j] + 1 : 0, ++j);",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29064/a-o-n-2-solution-based-on-largest-rectangle-in-histogram/",
                "vote_count": "422"
            },
            {
                "language": "python",
                "code": "def maximalRectangle(self, matrix):\n    if not matrix or not matrix[0]:\n        return 0\n    n = len(matrix[0])\n    height = [0] * (n + 1)\n    ans = 0\n    for row in matrix:\n        for i in xrange(n):\n            height[i] = height[i] + 1 if row[i] == '1' else 0\n        stack = [-1]\n        for i in xrange(n + 1):\n            while height[i] < height[stack[-1]]:\n                h = height[stack.pop()]\n                w = i - 1 - stack[-1]\n                ans = max(ans, h * w)\n            stack.append(i)\n    return ans\n\n# 65 / 65 test cases passed.\n# Status: Accepted\n# Runtime: 120 ms\n# 100%",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29065/ac-python-dp-solutioin-120ms-based-on-largest-rectangle-in-histogram/",
                "vote_count": "405"
            },
            {
                "language": "cpp",
                "code": "        for i in xrange(n + 1):\n            while height[i] < height[stack[-1]]:\n                h = height[stack.pop()]\n                w = i - 1 - stack[-1]\n                ans = max(ans, h * w)\n            stack.append(i)",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29065/ac-python-dp-solutioin-120ms-based-on-largest-rectangle-in-histogram/",
                "vote_count": "405"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29065/ac-python-dp-solutioin-120ms-based-on-largest-rectangle-in-histogram/",
                "vote_count": "405"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29065/ac-python-dp-solutioin-120ms-based-on-largest-rectangle-in-histogram/",
                "vote_count": "405"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/29065/ac-python-dp-solutioin-120ms-based-on-largest-rectangle-in-histogram/",
                "vote_count": "405"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& M) {\n        if(!size(M)) return 0;\n        int ans = 0, m = size(M), n = size(M[0]);\n        for(int start_i = 0; start_i < m; start_i++) \n            for(int start_j = 0; start_j < n; start_j++) \n                for(int end_i = start_i; end_i < m; end_i++) \n                    for(int end_j = start_j; end_j < n; end_j++) {\n                        bool allOnes = true;\n                        for(int i = start_i; i <= end_i && allOnes; i++) \n                            for(int j = start_j; j <= end_j && allOnes; j++) \n                                if(M[i][j] != '1') allOnes = false;                           \n                        ans = max(ans, allOnes * (end_i - start_i + 1) * (end_j - start_j + 1));\n                    }\n\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/1604254/c-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "163"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& M) {\n        if(!size(M)) return 0;\n        int ans = 0, m = size(M), n = size(M[0]);\n        for(int i = 0; i < m; i++) \n            for(int j = 0; j < n; j++) \n                for(int row = i, colLen = n, col; row < m && M[row][j] == '1'; row++) {\n                    for(col = j; col < n && M[row][col] == '1'; col++);\n                    colLen = min(colLen, col-j);\n                    ans = max(ans, (row-i+1) * colLen);\n                }\n            \n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/1604254/c-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "163"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& M) {\n        if(!size(M)) return 0;\n        int ans = 0, m = size(M), n = size(M[0]);\n        vector<vector<short>> dp(m+1, vector<short>(n+1));\n        for(int i = m-1; ~i; i--) \n            for(int j = n-1; ~j; j--) \n                dp[i][j] = M[i][j] == '1' ? dp[i][j+1] + 1 : 0;\n                    \n        for(int i = 0; i < m; i++) \n            for(int j = 0; j < n; j++) \n                for(int row = i, colLen = n; row < m && M[row][j] == '1'; row++)\n                    ans = max(ans, (row-i+1) * (colLen = min(colLen, dp[row][j]*1)));\n                    \n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/1604254/c-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "163"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& M) {\n        if(!size(M)) return 0;\n        int ans = 0, m = size(M), n = size(M[0]);\n        vector<vector<short>> dp(m+1, vector<short>(n+1)), up(m, vector<short>(n,1)), down(up);\n        for(int i = m-1; ~i; i--) \n            for(int j = n-1; ~j; j--) \n                dp[i][j] = M[i][j] == '1' ? dp[i][j+1] + 1 : 0;\n        \n        stack<int> s;\n        for(int j = 0; j < n; j++) {\n            s = stack<int>();\n            for(int i = 0; i < m; i++) {\n                while(size(s) && dp[s.top()][j] >= dp[i][j]) s.pop();\n                up[i][j] = i - (size(s) ? s.top() : -1);\n                s.push(i);\n            }\n            s = stack<int>();\n            for(int i = m-1; ~i; i--) {\n                while(size(s) && dp[s.top()][j] >= dp[i][j]) s.pop();\n                down[i][j] = (size(s) ? s.top() : m) - i;\n                s.push(i);\n            }            \n        }\n\n        for(int i = 0; i < m; i++) \n            for(int j = 0; j < n; j++) \n                ans = max(ans, dp[i][j] * (up[i][j]+down[i][j]-1));\n                    \n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/1604254/c-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "163"
            },
            {
                "language": "cpp",
                "code": "public int maximalRectangle(char[][] matrix) {\n        if(matrix.length==0) return 0;\n        // for each cell with value=1, we look upward (north), the number of continuous '1' is the height of cell\n        int[] heights = new int[matrix[0].length];\n        int maxArea=-1;\n        for(int i=0; i<matrix.length; i++){\n            for(int j=0; j<matrix[0].length; j++){\n                if(matrix[i][j]=='0'){\n                    heights[j] = 0;\n                } else {\n                    heights[j] ++;\n                }\n            }            \n            int area = yourLeetCode84Method(heights);\n            maxArea = Math.max(maxArea, area);\n        }\n        return maxArea;\n    }",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/122456/easiest-solution-build-on-top-of-leetcode84/",
                "vote_count": "148"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maximalRectangle(self, matrix):\n        def hist(heights):\n            stack, ans = [], 0\n            for i, h in enumerate(heights + [0]):\n                while stack and heights[stack[-1]] >= h:\n                    H = heights[stack.pop()]\n                    W = i if not stack else i-stack[-1]-1\n                    ans = max(ans, H*W)\n                stack.append(i)\n            return ans\n        \n        if not matrix or not matrix[0]: return 0\n        m, n, ans = len(matrix[0]), len(matrix), 0\n        row = [0]*m\n        for i in range(n):\n            for j in range(m):\n                row[j] = 0 if matrix[i][j] == \"0\" else row[j] + 1\n            ans = max(ans, hist(row))\n            \n        return ans",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/1603766/python-o-mn-solution-explained/",
                "vote_count": "47"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if len(matrix) == 0: return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [0] * n\n        maxArea = 0\n        for r in range(m):\n            for c in range(n):\n                if matrix[r][c] == \"1\":\n                    dp[c] += 1\n                else:\n                    dp[c] = 0\n            maxArea = max(maxArea, self.maxRectangleInHistogram(dp))\n        return maxArea\n\n    def maxRectangleInHistogram(self, heights):  # O(N)\n        n = len(heights)\n        st = [-1]\n        maxArea = 0\n        for i in range(n):\n            while st[-1] != -1 and heights[st[-1]] >= heights[i]:\n                currentHeight = heights[st.pop()]\n                currentWidth = i - st[-1] - 1\n                maxArea = max(maxArea, currentWidth * currentHeight)\n            st.append(i)\n        while st[-1] != -1:\n            currentHeight = heights[st.pop()]\n            currentWidth = n - st[-1] - 1\n            maxArea = max(maxArea, currentWidth * currentHeight)\n        return maxArea",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/1255410/python-based-on-maximum-rectangle-in-histogram-clean-concise/",
                "vote_count": "46"
            },
            {
                "language": "swift",
                "code": "Intuition :\n1) Pick one row\n2) Do summation of each index till that row\n  i) if any index value is 0 then put 0 else previous summation + 1 \n3) Pass this array to get max area (84. Largest Rectangle in Historgram)\n4) Update max area\n\n84. Largest Rectangle in Histogram\nIntuition :\n1) Max area will always have atleast one full bar height on any index\n2) Find largest rectangle including each bar one by one.\n a) For each bar, We have to find it's left limit & right limit (to know the maximum width)\n b) Find it's left limit (where we find any index's value is smaller than current index in left side array of curr index)\n c) Find it's right limit (where we find any index's value is smaller than current index in right side array of curr index\n3) Take the maximum of all the max area found by each bar.\n4) calculate area\n  width * height\nwhere width = right limit - left limit + 1\nheight = curr index's value\n5) Update max area & return it",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/1603593/java-detailed-explanation-easy-approach-o-row-col/",
                "vote_count": "37"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int maximalRectangle(char[][] matrix) {\n        if(matrix.length == 0)  return 0;\n        int maxArea = 0;\n        int row = matrix.length;\n        int col = matrix[0].length;\n        int[] dp = new int[col];\n        for(int i=0;i<row;i++){\n            for(int j=0;j<col;j++){\n                dp[j] = matrix[i][j] == '1' ? dp[j]+1 : 0;\n            }\n            //treating dp[j] as histogram, solving max area problem there and updating the max area\n            maxArea = Math.max(maxArea, findMaxAreaInHistogram(dp));\n        }\n        return maxArea;\n    }\n //84. Largest Rectangle in Histogram code\n    public int findMaxAreaInHistogram(int[] dp){\n        int len = dp.length;\n        int maxArea = 0;\n        int[] left = new int[len];\n        int[] right = new int[len];\n        Stack<Integer> stack = new Stack<>();\n        //traversing left to right, finding left limit\n        for(int i=0;i<len;i++){\n            if(stack.isEmpty()){\n                stack.push(i);\n                left[i] = 0;\n            }else{\n                while(!stack.isEmpty() && dp[stack.peek()] >= dp[i])\n                    stack.pop();\n                left[i] = stack.isEmpty() ? 0 : stack.peek()+1;\n                stack.push(i);\n            }\n        }\n        //doing empty to stack\n        while(!stack.isEmpty())\n            stack.pop();\n        \n        //traversing right to left, find right limit\n        for(int i=len-1;i>=0;i--){\n            if(stack.isEmpty()){\n                stack.push(len-1);\n                right[i] = len - 1;\n            }else{\n                while(!stack.isEmpty() && dp[stack.peek()] >= dp[i])\n                    stack.pop();\n                right[i] = stack.isEmpty() ? len-1 : stack.peek()-1;\n                stack.push(i);\n            }\n        }\n        //traversing the array , caculating area\n        int[] area = new int[len];\n        for(int i=0;i<len;i++){\n            area[i] = (right[i] - left[i] + 1) * dp[i];\n            maxArea = Math.max(maxArea, area[i]);\n        }\n        return maxArea;\n    }\n}",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/1603593/java-detailed-explanation-easy-approach-o-row-col/",
                "vote_count": "37"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def maximalRectangle(self, mat: List[List[str]]) -> int:\n        # using 84: Largest Rectangle in Histogram solution\n        \n        def LRIH(hist):\n            n = len(hist)\n            left = [0]*n",
                "url": "https://leetcode.com/problems/maximal-rectangle/solutions/1603593/java-detailed-explanation-easy-approach-o-row-col/",
                "vote_count": "37"
            }
        ]
    },
    "85": {
        "question_id": 86,
        "title": "Partition List",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/partition-list",
        "description": "Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.You should preserve the original relative order of the nodes in each of the two partitions. ",
        "examples": [
            {
                "input": "head = [1,4,3,2,5,2], x = 3",
                "output": "[1,2,2,4,3,5]",
                "explanation": null
            },
            {
                "input": "head = [2,1], x = 2",
                "output": "[1,2]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is in the range [0, 200].",
            "-100 <= Node.val <= 100",
            "-200 <= x <= 200"
        ],
        "solutions": [
            {
                "language": "ruby",
                "code": "ListNode *partition(ListNode *head, int x) {\n    ListNode node1(0), node2(0);\n    ListNode *p1 = &node1, *p2 = &node2;\n    while (head) {\n        if (head->val < x)\n            p1 = p1->next = head;\n        else\n            p2 = p2->next = head;\n        head = head->next;\n    }\n    p2->next = NULL;\n    p1->next = node2.next;\n    return node1.next;\n}",
                "url": "https://leetcode.com/problems/partition-list/solutions/29185/very-concise-one-pass-solution/",
                "vote_count": "456"
            },
            {
                "language": "java",
                "code": "public ListNode partition(ListNode head, int x) {\n    ListNode smallerHead = new ListNode(0), biggerHead = new ListNode(0);\n    ListNode smaller = smallerHead, bigger = biggerHead;\n    while (head != null) {\n        if (head.val < x) {\n            smaller = smaller.next = head;\n        } else {\n            bigger = bigger.next = head;",
                "url": "https://leetcode.com/problems/partition-list/solutions/29185/very-concise-one-pass-solution/",
                "vote_count": "456"
            },
            {
                "language": "python",
                "code": "def partition(self, head, x):\n    # separate the list into 2 distinct lists and link them afterwards.\n    # p1, p2 traverses the list and hd1 and hd2 are the heads of two lists\n    hd1=p1=ListNode(0)\n    hd2=p2=ListNode(0)\n    while head:\n        if head.val<x:\n            p1.next=head",
                "url": "https://leetcode.com/problems/partition-list/solutions/29185/very-concise-one-pass-solution/",
                "vote_count": "456"
            },
            {
                "language": "cpp",
                "code": "p2->next = NULL;",
                "url": "https://leetcode.com/problems/partition-list/solutions/29185/very-concise-one-pass-solution/",
                "vote_count": "456"
            },
            {
                "language": "java",
                "code": "public ListNode partition(ListNode head, int x) {\n        ListNode dummyhead = new ListNode(-1);\n        ListNode small = dummyhead;\n        ListNode greatHead = new ListNode(0);\n        ListNode great = greatHead;\n        ListNode point = head;\n        dummyhead.next = head;\n        while(point != null){",
                "url": "https://leetcode.com/problems/partition-list/solutions/29185/very-concise-one-pass-solution/",
                "vote_count": "456"
            },
            {
                "language": "rust",
                "code": "Anyways, Ladies-N-Gentlemen let's understand this problem",
                "url": "https://leetcode.com/problems/partition-list/solutions/2315494/java-c-detailed-explanation/",
                "vote_count": "143"
            },
            {
                "language": "",
                "code": "Input: head = [1,4,3,2,5,2], x = 3\nOutput: [1,2,2,4,3,5]",
                "url": "https://leetcode.com/problems/partition-list/solutions/2315494/java-c-detailed-explanation/",
                "vote_count": "143"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public ListNode partition(ListNode head, int x) {\n        ListNode left = new ListNode(0);\n        ListNode right = new ListNode(0);\n        \n        ListNode leftTail = left;\n        ListNode rightTail = right;\n        \n        while(head != null){\n            if(head.val < x){\n                leftTail.next = head;\n                leftTail = leftTail.next;\n            }\n            else{\n                rightTail.next = head;\n                rightTail = rightTail.next;\n            }\n            head = head.next;\n        }\n        \n        leftTail.next = right.next;\n        rightTail.next = null;\n        \n        return left.next;\n    }\n}",
                "url": "https://leetcode.com/problems/partition-list/solutions/2315494/java-c-detailed-explanation/",
                "vote_count": "143"
            },
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        ListNode *left = new ListNode(0);\n        ListNode *right = new ListNode(0);\n        \n        ListNode *leftTail = left;\n        ListNode *rightTail = right;\n        \n        while(head != NULL){\n            if(head->val < x){\n                leftTail->next = head;\n                leftTail = leftTail->next;\n            }\n            else{\n                rightTail->next = head;\n                rightTail = rightTail->next;\n            }\n            head = head->next;\n        }\n        \n        leftTail->next = right->next;\n        rightTail->next = NULL;\n        \n        return left->next;\n    }\n};",
                "url": "https://leetcode.com/problems/partition-list/solutions/2315494/java-c-detailed-explanation/",
                "vote_count": "143"
            },
            {
                "language": "rust",
                "code": "ListNode* partition(ListNode* head, int x) {\n        ListNode* left=new ListNode(0);\n        ListNode* right=new ListNode(0);\n        ListNode* leftTail = left;\n        ListNode* rightTail = right;\n        while(head!=NULL)\n        {",
                "url": "https://leetcode.com/problems/partition-list/solutions/2315494/java-c-detailed-explanation/",
                "vote_count": "143"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    \n    ListNode* partition(ListNode* head, int x) {\n        \n        ListNode* small = new ListNode(-1);\n        ListNode* large = new ListNode(-1);\n        ListNode* small_head = small;\n        ListNode* large_head = large;\n        \n        while (head){\n            if (head->val < x){\n                small->next = head;\n                small = small -> next;\n                head = head -> next;\n                small->next = NULL;\n            }\n            else{\n                large->next = head;\n                large = large -> next;\n                head = head -> next;\n                large -> next = NULL;\n            }\n        }\n        small -> next = large_head -> next;\n\n        return small_head -> next;\n    }\n};",
                "url": "https://leetcode.com/problems/partition-list/solutions/2315305/c-single-pass-o-1-space-explained/",
                "vote_count": "44"
            },
            {
                "language": "rust",
                "code": "    ListNode* front, *back = head;\n    ListNode* lesser = new ListNode(0), *greater = new ListNode(0);\n    ListNode  *lcurr = lesser, * gcurr = greater;\n    \n    while(back != nullptr){",
                "url": "https://leetcode.com/problems/partition-list/solutions/2315305/c-single-pass-o-1-space-explained/",
                "vote_count": "44"
            }
        ]
    },
    "86": {
        "question_id": 87,
        "title": "Scramble String",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/scramble-string",
        "description": "We can scramble a string s to get a string t using the following algorithm:If the length of the string is 1, stop.If the length of the string is > 1, do the following:\tSplit the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.Apply step 1 recursively on each of the two substrings x and y.Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false. ",
        "examples": [
            {
                "input": "s1 = \"great\", s2 = \"rgeat\"",
                "output": "true",
                "explanation": "One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true."
            },
            {
                "input": "s1 = \"abcde\", s2 = \"caebd\"",
                "output": "false",
                "explanation": null
            },
            {
                "input": "s1 = \"a\", s2 = \"a\"",
                "output": "true",
                "explanation": null
            }
        ],
        "constraints": [
            "s1.length == s2.length",
            "1 <= s1.length <= 30",
            "s1 and s2 consist of lowercase English letters."
        ],
        "solutions": [
            {
                "language": "rust",
                "code": "Thanks for visiting my solution.\ud83d\ude0a Keep Learning\nPlease give my solution an upvote! \ud83d\udc4d\nIt's a simple way to show your appreciation and\nkeep me motivated. Thank you! \ud83d\ude0a",
                "url": "https://leetcode.com/problems/scramble-string/solutions/3357439/easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation/",
                "vote_count": "119"
            },
            {
                "language": "javascript",
                "code": "isScramble(\"great\", \"rgeat\")\n           /           |           |           |           \\\nisScramble(\"g\", \"r\")  isScramble(\"g\", \"at\")  isScramble(\"gr\", \"ra\")  isScramble(\"gr\", \"eat\")  isScramble(\"gre\", \"rge\")\n           |           /           |           |           |           \\           |           /           |\nisScramble(\"\", \"\")  isScramble(\"g\", \"a\")  isScramble(\"g\", \"r\")  isScramble(\"g\", \"e\")  isScramble(\"g\", \"r\")  isScramble(\"g\", \"r\")  isScramble(\"gr\", \"e\")  isScramble(\"gr\", \"g\")  isScramble(\"gr\", \"er\")  isScramble(\"gr\", \"gea\")  isScramble(\"gre\", \"rg\")  isScramble(\"gre\", \"er\")\n      /      \\           /      \\           /      \\           /      \\           /      \\           /      \\           /      \\           /      \\           /      \\           /      \\           /      \\\nfalse  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  true",
                "url": "https://leetcode.com/problems/scramble-string/solutions/3357574/day-364-100-java-c-python-explained-intution-dry-run-proof/",
                "vote_count": "83"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def isScramble(self,s1, s2):\n        m ={}\n        def func(s1, s2):\n            if (s1, s2) in m:\n                return m[(s1, s2)]\n            if not sorted(s1) == sorted(s2):\n                return False\n            if len(s1) == 1:\n                return True\n            \n\n            for i in range(1, len(s1)):\n                if func(s1[:i], s2[-i:]) and func(s1[i:], s2[:-i]) or func(s1[:i], s2[:i]) and func(s1[i:], s2[i:]):\n                    m[(s1, s2)] = True\n                    return True\n            m[(s1, s2)] = False\n            return False\n        return func(s1, s2)",
                "url": "https://leetcode.com/problems/scramble-string/solutions/3357546/python3-35ms-beats-99-38-recursion-with-memoization/",
                "vote_count": "68"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/scramble-string/solutions/3357546/python3-35ms-beats-99-38-recursion-with-memoization/",
                "vote_count": "68"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/scramble-string/solutions/3357546/python3-35ms-beats-99-38-recursion-with-memoization/",
                "vote_count": "68"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/scramble-string/solutions/3357546/python3-35ms-beats-99-38-recursion-with-memoization/",
                "vote_count": "68"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/scramble-string/solutions/3357546/python3-35ms-beats-99-38-recursion-with-memoization/",
                "vote_count": "68"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/scramble-string/solutions/3357546/python3-35ms-beats-99-38-recursion-with-memoization/",
                "vote_count": "68"
            },
            {
                "language": "python",
                "code": "   @lru_cache(None)\n    def isScramble(s1, s2):\n            if not sorted(s1) == sorted(s2):\n                return False\n            if len(s1) == 1:\n                return True\n            \n            for i in range(1, len(s1)):\n:i], s2[:i]) and isScramble(s1[i:], s2[i:]):",
                "url": "https://leetcode.com/problems/scramble-string/solutions/3357546/python3-35ms-beats-99-38-recursion-with-memoization/",
                "vote_count": "68"
            },
            {
                "language": "python",
                "code": "@cache\ndef func(s1, s2):",
                "url": "https://leetcode.com/problems/scramble-string/solutions/3357546/python3-35ms-beats-99-38-recursion-with-memoization/",
                "vote_count": "68"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if s1 == s2:\n            return True\n        if sorted(s1) != sorted(s2):\n            return False\n        \n        n = len(s1)\n        dp = [[[False] * (n+1) for _ in range(n)] for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(n):\n                dp[i][j][1] = (s1[i] == s2[j])\n        \n        for length in range(2, n+1):\n            for i in range(n-length+1):\n                for j in range(n-length+1):\n                    for k in range(1, length):\n                        if (dp[i][j][k] and dp[i+k][j+k][length-k]) or (dp[i][j+length-k][k] and dp[i+k][j][length-k]):\n                            dp[i][j][length] = True\n                            break\n        \n        return dp[0][0][n]\n\n    \n        # An Upvote will be encouraging",
                "url": "https://leetcode.com/problems/scramble-string/solutions/3357490/python-java-c-simple-solution-easy-to-understand/",
                "vote_count": "28"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    bool isScramble(string s1, string s2) {\n        int n = (int) s1.size();\n        bool vis[n][n][n][n];\n        bool dp[n][n][n][n];\n        memset(vis, false, sizeof(vis));\n        memset(dp, false, sizeof(dp));\n\n        // we are always calling the function such that, the substring we are checking on both the\n        // substrings are of same length, i.e. (r1 - l1 + 1 == r2 - l2 + 1)\n\n        // helper takes in two substrings of both string\n        // and returns whether they are scamble of each other\n        function<bool(int, int, int, int)> helper = [&] (int l1, int r1, int l2, int r2) {\n            if (vis[l1][r1][l2][r2]) return dp[l1][r1][l2][r2];\n            vis[l1][r1][l2][r2] = true;\n\n            bool isSame = true;\n            for (int i = l1, j = l2; i <= r1 && j <= r2; i++, j++)\n                if (s1[i] != s2[j]) isSame = false;\n            \n            // is already same, simply return true\n            if (isSame) {\n                dp[l1][r1][l2][r2] = true;\n                return true;\n            }\n\n            bool res = false;\n            for (int i = l1; i < r1; i++) {\n                // opt1: prefix1 matches to prefix2 and suffix1 matches to suffix2\n                res |= (helper(l1, i, l2, l2 + (i - l1)) && helper(i + 1, r1, l2 + (i - l1) + 1, r2));\n\n                // opt2: prefix1 matches to suffix2 and prefix2 matches to suffix1\n                res |= (helper(l1, i, r2 - (i - l1), r2) && helper(i + 1, r1, l2, r2 - (i - l1) - 1));\n            }\n\n            dp[l1][r1][l2][r2] = res;\n            return res;\n        };\n\n        return helper(0, n - 1, 0, n - 1);\n    }\n};",
                "url": "https://leetcode.com/problems/scramble-string/solutions/3357954/clean-c-code-with-great-explanation/",
                "vote_count": "20"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isScramble(self, first: str, second: str) -> bool:\n        @cache\n        def dp(a: str, b: str) -> bool:\n            if a == b:\n                return True\n\n            if Counter(a) != Counter(b):\n                return False\n\n            return any(\n                dp(a[:i], b[:i]) and dp(a[i:], b[i:]) or \\\n                dp(a[:i], b[-i:]) and dp(a[i:], b[:-i])\n                for i in range(1, len(a))\n            )\n\n        return dp(first, second)",
                "url": "https://leetcode.com/problems/scramble-string/solutions/3358542/python-elegant-short-top-down-dp-memoization/",
                "vote_count": "11"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    Map<String, Boolean> mp = new HashMap<>();\n    \n    public boolean helper(String a, String b)\n    {\n        if(a.equals(b) == true) return true;\n        \n        if(a.length() <= 1) return false;\n        \n        int n = a.length();\n        boolean check = false;\n        \n        String key = a;\n        \n        key += ' ' + b;\n        \n        if(mp.containsKey(key))\n             return mp.get(key);\n        \n        for(int i = 1; i < n; i++)\n        {\n            boolean swap = helper(a.substring(0, i), b.substring(n - i)) && helper(a.substring(i), b.substring(0, n - i));\n            boolean unswap = helper(a.substring(0,i), b.substring(0,i)) && helper(a.substring(i), b.substring(i));\n            \n            if(swap || unswap){\n                check = true;\n                break;\n            }\n        }\n        \n        mp.put(key, check);\n        \n        return check;\n    }\n    \n    public boolean isScramble(String a, String b)\n    {\n        if(a.equals(b) == true) return true;\n        \n        if(a.length() != b.length()) return false;\n        \n        if(a.isEmpty() == true) return true;\n        \n        return helper(a, b);\n    }\n}",
                "url": "https://leetcode.com/problems/scramble-string/solutions/3357479/java-easy-solution-using-hashmap-beginner-friendly/",
                "vote_count": "10"
            }
        ]
    },
    "87": {
        "question_id": 88,
        "title": "Merge Sorted Array",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/merge-sorted-array",
        "description": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.Merge nums1 and nums2 into a single array sorted in non-decreasing order.The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. ",
        "examples": [
            {
                "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
                "output": "[1,2,2,3,5,6]",
                "explanation": "The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1."
            },
            {
                "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
                "output": "[1]",
                "explanation": "The arrays we are merging are [1] and [].\nThe result of the merge is [1]."
            },
            {
                "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
                "output": "[1]",
                "explanation": "The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1."
            }
        ],
        "constraints": [
            "nums1.length == m + n",
            "nums2.length == n",
            "0 <= m, n <= 200",
            "1 <= m + n <= 200",
            "-10^9 <= nums1[i], nums2[j] <= 10^9"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "public void merge(int[] A, int m, int[] B, int n) {\n for (int i = m+n-1, a = m-1, b = n-1; b>=0; i--) {\n  if (a >= 0 && A[a] > B[b]) A[i] = A[a--]; \n  else A[i] = B[b--];\n }        \n}",
                "url": "https://leetcode.com/problems/merge-sorted-array/solutions/2120234/visual-explanation-o-1-space-java/",
                "vote_count": "231"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int index=m+n-1,bp1=m-1,bp2=n-1;  //bp-->back-pointer\n        while(bp1>=0 && bp2>=0){\n            if(nums1[bp1] > nums2[bp2]) nums1[index] = nums1[bp1--];\n            else nums1[index] = nums2[bp2--];\n            index--;\n        }",
                "url": "https://leetcode.com/problems/merge-sorted-array/solutions/2120234/visual-explanation-o-1-space-java/",
                "vote_count": "231"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(MlogM), Sorting the array(nums1) costs O(MlogM). Where M is the size of the\n    Array(nums1).\n\n    Space Complexity : O(1), Constant Space. \n\n    Solved using Array + Sorting.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        for(int i=0; i<n; i++){\n            nums1[m+i] = nums2[i];\n        }\n        sort(nums1.begin(), nums1.end());\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N+M), Because we iterate N+M times for both the Array(nums1 and nums2). Where\n    M is the number of elements in Array(nums1) and N is the number of elements in Array(nums2).\n\n    Space Complexity : O(1), Constant Space. \n\n    Solved using Array + Two Pointers. \n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int i = m-1;\n        int j = n-1;\n        int k = m+n-1;\n        while(i>=0 && j>=0){\n            if(nums1[i] > nums2[j]){\n                nums1[k] = nums1[i];\n                i--; k--;\n            }\n            else{\n                nums1[k] = nums2[j];\n                j--; k--;\n            }\n        }\n        while(j>=0){\n            nums1[k] = nums2[j];\n            j--; k--;\n        }\n    }\n};",
                "url": "https://leetcode.com/problems/merge-sorted-array/solutions/3186051/best-c-2-solution-two-pointers-sorting-brute-force-optimize-one-stop-solution/",
                "vote_count": "211"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i=m-1 , j=n-1 ;\n        while(i>=0 && j>=0 ){\n            if(nums1[i]>=nums2[j]){\n                nums1[i+j+1]=nums1[i] ;\n                i-- ;\n                }else{\n                    nums1[i+j+1]=nums2[j];\n                    j-- ;\n                }\n        }\n        while(j>=0){\n                    nums1[j]=nums2[j];\n                    j-- ;\n                }\n    }\n}",
                "url": "https://leetcode.com/problems/merge-sorted-array/solutions/2847423/runtime-0-ms-beats-100-c-java/",
                "vote_count": "146"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        //variables to work as pointers\n        int i=m-1; // will point at m-1 index of nums1 array\n        int j=n-1; // will point at n-1 index of nums2 array\n        int k=nums1.length-1; //will point at the last position of the nums1 array\n\n        // Now traversing the nums2 array\n        while(j>=0){\n            // If element at i index of nums1 > element at j index of nums2\n            // then it is largest among two arrays and will be stored at k position of nums1\n            // using i>=0 to make sure we have elements to compare in nums1 array\n            if(i>=0 && nums1[i]>nums2[j]){\n                nums1[k]=nums1[i];\n                k--; \n                i--; //updating pointer for further comparisons\n            }else{\n                // element at j index of nums2 array is greater than the element at i index of nums1 array \n                // or there is no element left to compare with the nums1 array \n                // and we just have to push the elements of nums2 array in the nums1 array.\n                nums1[k] = nums2[j];\n                k--; \n                j--; //updating pointer for further comparisons\n            }\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/merge-sorted-array/solutions/3037315/fully-explained-java-code-with-approach-in-o-m-n-time/",
                "vote_count": "135"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int i=m-1,j=n-1;\n        int ind=m+n-1;\n        while(i>=0 && j>=0)\n        {\n            if(nums1[i]>nums2[j])\n            {\n                nums1[ind]=nums1[i];\n                i--;\n            }\n            else\n            {\n                nums1[ind]=nums2[j];\n                j--;\n            }\n            ind--;\n        }\n        while(i>=0)\n        {\n            nums1[ind]=nums1[i];\n            i--;\n            ind--;\n        }\n        while(j>=0)\n        {\n            nums1[ind]=nums2[j];\n            j--;\n            ind--;\n        }\n    }\n};",
                "url": "https://leetcode.com/problems/merge-sorted-array/solutions/3044429/accepted-easy-solution-short-simple-best-method/",
                "vote_count": "41"
            },
            {
                "language": "cpp",
                "code": "void merge(vector<int>& arr, int m, vector<int>& arr2, int n) {\n        int i=0,j=0;\n        vector<int>v(m+n);\n        int k=0;\n        while(i<m and j<n){\n            \n           if(arr[i]<arr2[j])v[k++]=arr[i],i++;\n           else {\n               v[k++]=arr2[j],j++;\n           }\n        }\n        while(i<m)v[k++]=arr[i++];\n          while(j<n)v[k++]=arr2[j++];\n        \n        for(int i=0;i<m+n;i++)arr[i]=v[i];\n    }",
                "url": "https://leetcode.com/problems/merge-sorted-array/solutions/3109283/beats-100-c-simple-two-pointer/",
                "vote_count": "39"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void merge(vector<int>& arr, int m, vector<int>& arr2, int n) {\n      int i=m-1,j=n-1;\n      int k=m+n-1;\n      while(j>=0 and i>=0){\n          if(arr[i]<arr2[j])arr[k--]=arr2[j--];\n          else arr[k--]=arr[i--];\n      }\n      while(j>=0)arr[k--]=arr2[j--];\n    }\n};",
                "url": "https://leetcode.com/problems/merge-sorted-array/solutions/3109283/beats-100-c-simple-two-pointer/",
                "vote_count": "39"
            },
            {
                "language": "cpp",
                "code": " void merge(vector<int>& arr, int m, vector<int>& arr2, int n) {\n      int i=m-1,j=n-1,k=m+n-1;\n      while(j>=0 ){\n         arr[k--]=(i<0 || arr[i]<arr2[j])?arr2[j--]:arr[i--];\n      }\n    }",
                "url": "https://leetcode.com/problems/merge-sorted-array/solutions/3109283/beats-100-c-simple-two-pointer/",
                "vote_count": "39"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        for i in range(m,m+n):\n            nums1[i]=nums2[i-m]\n        nums1.sort()\n    #please upvote me it would encourage me alot",
                "url": "https://leetcode.com/problems/merge-sorted-array/solutions/3307658/3-lines-of-code-python3/",
                "vote_count": "25"
            }
        ]
    },
    "88": {
        "question_id": 89,
        "title": "Gray Code",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/gray-code",
        "description": "An n-bit gray code sequence is a sequence of 2n integers where:Every integer is in the inclusive range [0, 2n - 1],The first integer is 0,An integer appears no more than once in the sequence,The binary representation of every pair of adjacent integers differs by exactly one bit, andThe binary representation of the first and last integers differs by exactly one bit.Given an integer n, return any valid n-bit gray code sequence. ",
        "examples": [
            {
                "input": "n = 2",
                "output": "[0,1,3,2]\nExplanation:\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit",
                "explanation": null
            },
            {
                "input": "n = 1",
                "output": "[0,1]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= n <= 16"
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "public List<Integer> grayCode(int n) {\n    List<Integer> rs=new ArrayList<Integer>();\n    rs.add(0);\n    for(int i=0;i<n;i++){\n        int size=rs.size();\n        for(int k=size-1;k>=0;k--)\n            rs.add(rs.get(k) | 1<<i);\n    }\n    return rs;\n}",
                "url": "https://leetcode.com/problems/gray-code/solutions/29891/share-my-solution/",
                "vote_count": "544"
            },
            {
                "language": "cpp",
                "code": "    vector<int> grayCode(int n) {\n        vector<int>res(1,0);\n        for(int i=0;i<n;i++){\n            int size=res.size();\n            for(int j=size-1;j>=0;j--){\n                res.push_back(res[j]|1<<i);\n            }\n        }",
                "url": "https://leetcode.com/problems/gray-code/solutions/29891/share-my-solution/",
                "vote_count": "544"
            },
            {
                "language": "csharp",
                "code": "public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        if(n == 0) return list;\n        list.add(1);\n        int curr = 1;",
                "url": "https://leetcode.com/problems/gray-code/solutions/29891/share-my-solution/",
                "vote_count": "544"
            },
            {
                "language": "csharp",
                "code": "",
                "url": "https://leetcode.com/problems/gray-code/solutions/29891/share-my-solution/",
                "vote_count": "544"
            },
            {
                "language": "python",
                "code": "class Solution1:\n    def grayCode(self, n): \n        \"\"\" \n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        res = [0] \n        for i in range(n):",
                "url": "https://leetcode.com/problems/gray-code/solutions/29891/share-my-solution/",
                "vote_count": "544"
            },
            {
                "language": "csharp",
                "code": "public List<Integer> grayCode(int n) {\n    List<Integer> result = new LinkedList<>();\n    for (int i = 0; i < 1<<n; i++) result.add(i ^ i>>1);\n    return result;\n}",
                "url": "https://leetcode.com/problems/gray-code/solutions/29881/an-accepted-three-line-solution-in-java/",
                "vote_count": "285"
            },
            {
                "language": "csharp",
                "code": "",
                "url": "https://leetcode.com/problems/gray-code/solutions/29881/an-accepted-three-line-solution-in-java/",
                "vote_count": "285"
            },
            {
                "language": "cpp",
                "code": "/*\n        The purpose of this function is to convert an unsigned\n        binary number to reflected binary Gray code.\n \n        The operator >> is shift right. The operator ^ is exclusive or.\n*/\nunsigned int binaryToGray(unsigned int num)\n{",
                "url": "https://leetcode.com/problems/gray-code/solutions/29881/an-accepted-three-line-solution-in-java/",
                "vote_count": "285"
            },
            {
                "language": "csharp",
                "code": "public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);                                //n=0 {0}\n        if(n == 0) return list;\n        int increase = 1;\n        for(int i = 0;i<n;i++){                     //              n=2\n            int len = list.size();                  //              len = 2",
                "url": "https://leetcode.com/problems/gray-code/solutions/29881/an-accepted-three-line-solution-in-java/",
                "vote_count": "285"
            },
            {
                "language": "cpp",
                "code": "public List<Integer> grayCode(int n) {\n        List<Integer> result = new LinkedList<>();\n        for (int i = 0; i < Math.pow(2,n); i++) \n            result.add(i ^ i/2);\n        return result;\n    }",
                "url": "https://leetcode.com/problems/gray-code/solutions/29881/an-accepted-three-line-solution-in-java/",
                "vote_count": "285"
            },
            {
                "language": "python",
                "code": "class Solution:\n    # @return a list of integers\n    '''\n    from up to down, then left to right\n    \n    0   1   11  110\n            10  111\n                101\n                100\n                \n    start:      [0]\n    i = 0:      [0, 1]\n    i = 1:      [0, 1, 3, 2]\n    i = 2:      [0, 1, 3, 2, 6, 7, 5, 4]\n    '''\n    def grayCode(self, n):\n        results = [0]\n        for i in range(n):\n            results += [x + pow(2, i) for x in reversed(results)]\n        return results",
                "url": "https://leetcode.com/problems/gray-code/solutions/29893/one-liner-python-solution-with-demo-in-comments/",
                "vote_count": "183"
            },
            {
                "language": "elixir",
                "code": "start: [0]\ni = 0:          [0]\ni = 1:          [0, 1]\n                  nums[1] = nums[0] + 1\ni = 2:          [0, 1, 3, 2]\n                  nums[2:4] = nums[1: : -1] + 2",
                "url": "https://leetcode.com/problems/gray-code/solutions/29893/one-liner-python-solution-with-demo-in-comments/",
                "vote_count": "183"
            },
            {
                "language": "python",
                "code": "results += [x | (1 << i) for x in reversed(results)]",
                "url": "https://leetcode.com/problems/gray-code/solutions/29893/one-liner-python-solution-with-demo-in-comments/",
                "vote_count": "183"
            },
            {
                "language": "cpp",
                "code": "class Solution(object):\n    def grayCode(self, n):\n        res = [0]\n        for i in range(n):\n            res += [x|(1<<i) for x in res[::-1]]\n        return res",
                "url": "https://leetcode.com/problems/gray-code/solutions/29893/one-liner-python-solution-with-demo-in-comments/",
                "vote_count": "183"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    void utils(bitset<32>& bits, vector<int>& result, int k){\n        if (k==0) {\n            result.push_back(bits.to_ulong());\n        }\n        else {\n            utils(bits, result, k-1);\n            bits.flip(k-1);\n            utils(bits, result, k-1);\n        }\n    }\npublic:\n    vector<int> grayCode(int n) {\n        bitset<32> bits;\n        vector<int> result;\n        utils(bits, result, n);\n        return result;\n    }\n};",
                "url": "https://leetcode.com/problems/gray-code/solutions/29880/backtracking-c-solution/",
                "vote_count": "130"
            },
            {
                "language": "csharp",
                "code": "    int nums = 0;\n    public List<Integer> grayCode(int n) {\n        List<Integer> ret = new ArrayList<>();\n        backTrack(n, ret);\n        return ret;\n    }\n    \n    private void backTrack(int n, List<Integer> ret) {",
                "url": "https://leetcode.com/problems/gray-code/solutions/29880/backtracking-c-solution/",
                "vote_count": "130"
            },
            {
                "language": "csharp",
                "code": "   public List<Integer> grayCode(int n) {\n        List<Integer> res = new ArrayList<>();\n        return helper(res, n, new BitSet());\n    }\n\n    private List<Integer> helper(List<Integer> res, int n, BitSet chosen) {\n        if (n == 0) { // all bits of chosen have been selected\n            res.add(convert(chosen));",
                "url": "https://leetcode.com/problems/gray-code/solutions/29880/backtracking-c-solution/",
                "vote_count": "130"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def grayCode(self, n):\n        if n == 0: return [0]\n        t = self.grayCode(n-1)\n        return t + [i+(1<<(n-1)) for i in t][::-1]",
                "url": "https://leetcode.com/problems/gray-code/solutions/1308570/python-short-recursive-solution-explained/",
                "vote_count": "50"
            },
            {
                "language": "java",
                "code": "def grayCode(self, n: int) -> List[int]:\n    ans = [0]\n    for i in range(n):\n        ans += [(1<<i) ^ c for c in reversed(ans)]\n    return ans",
                "url": "https://leetcode.com/problems/gray-code/solutions/1308570/python-short-recursive-solution-explained/",
                "vote_count": "50"
            },
            {
                "language": "go",
                "code": "import collections\nfrom collections import defaultdict\n\ndef func(n):\n    if dp[n]!=[]:\n        return dp[n]\n    if n==1:\n        return ['0','1']",
                "url": "https://leetcode.com/problems/gray-code/solutions/1308570/python-short-recursive-solution-explained/",
                "vote_count": "50"
            },
            {
                "language": "ruby",
                "code": "def grayCode(self, n: int) -> List[int]:\n        if n==1:\n            return [0,1]\n        if n==2:\n            return [0,1,3,2]\n        base = [0,1,3,2]\n        for i in range(3,n+1):\n            multiplier = pow(2,i-1)\n            temp = []",
                "url": "https://leetcode.com/problems/gray-code/solutions/1308570/python-short-recursive-solution-explained/",
                "vote_count": "50"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> result;\n        result.push_back(0);\n        \n        for (int i = 1; i <= n; i++) {\n            int prevLength = result.size();\n            int mask = 1 << (i - 1);\n            for (int j = prevLength - 1; j >= 0; j--) {\n                result.push_back(mask + result[j]);\n            }\n        }\n        return result;\n    }\n};",
                "url": "https://leetcode.com/problems/gray-code/solutions/1308562/gray-code-c-python-iterative-solution-explained/",
                "vote_count": "29"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def grayCode(self, n: int) -> List[int]:\n        arr = []\n        arr.append(0)\n        for i in range(1,n+1):\n            prevLength = len(arr)\n            mask = 1 << (i-1)\n            for j in range(prevLength, 0, -1):\n                arr.append(mask + arr[j-1])\n        return arr",
                "url": "https://leetcode.com/problems/gray-code/solutions/1308562/gray-code-c-python-iterative-solution-explained/",
                "vote_count": "29"
            },
            {
                "language": "swift",
                "code": "class Solution {\n    func grayCode(_ n: Int) -> [Int] {\n        var arr: [Int] = [0]\n        var e = -1\n        \n        func povv(_ n: Int, _ e: Int) -> Int { return Int(pow(Double(n), Double(e))) }\n        \n        for i in 1..<povv(2, n) {\n            if i == povv(2, e + 1) { e += 1 }\n            \n            let index = povv(2, e + 1) - i - 1\n            let num = povv(2, e) + arr[index]\n            arr.append(num)\n        }\n        \n        return arr\n    }\n    \n}",
                "url": "https://leetcode.com/problems/gray-code/solutions/1921930/100-fastest-swift-solution/",
                "vote_count": "10"
            }
        ]
    },
    "89": {
        "question_id": 90,
        "title": "Subsets II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/subsets-ii",
        "description": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set).The solution set must not contain duplicate subsets. Return the solution in any order. ",
        "examples": [
            {
                "input": "nums = [1,2,2]",
                "output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
                "explanation": null
            }
        ],
        "constraints": [],
        "solutions": [
            {
                "language": "ruby",
                "code": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        def backtrack(index, curSubset):\n            ans.append(curSubset[::])\n\n            for i in range(index, len(nums)):\n                if i > index and nums[i] == nums[i - 1]: continue  # Skip duplicates\n                curSubset.append(nums[i])\n                backtrack(i + 1, curSubset)\n                curSubset.pop()\n\n        nums.sort()\n        ans = []\n        backtrack(0, [])\n        return ans",
                "url": "https://leetcode.com/problems/subsets-ii/solutions/1380237/c-python-bitmasking-backtracking-iterative-solutions-with-picture-clean-concise/",
                "vote_count": "120"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        def backtrack(i, curSubset):\n            if i == len(nums):\n                ans.append(curSubset[::])\n                return\n\n            curSubset.append(nums[i])\n            backtrack(i + 1, curSubset)  # Pick\n            curSubset.pop()\n\n            if not curSubset or curSubset[-1] != nums[i]:\n                backtrack(i + 1, curSubset)  # Don't pick\n\n        nums.sort()\n        ans = []\n        backtrack(0, [])\n        return ans",
                "url": "https://leetcode.com/problems/subsets-ii/solutions/1380237/c-python-bitmasking-backtracking-iterative-solutions-with-picture-clean-concise/",
                "vote_count": "120"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        ans = set()\n        ans.add(tuple())\n        \n        for num in nums:\n            newSubsets = set()\n            for subset in ans:  # Iterate previous subsets from ans\n                newSubsets.add(tuple(list(subset) + [num]))\n            ans.update(newSubsets)  # Add new subsets to ans\n   \n        return ans",
                "url": "https://leetcode.com/problems/subsets-ii/solutions/1380237/c-python-bitmasking-backtracking-iterative-solutions-with-picture-clean-concise/",
                "vote_count": "120"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        \n        def backtrack(i, res, cur):\n            if i == len(nums):\n                res.append(cur)\n            else:",
                "url": "https://leetcode.com/problems/subsets-ii/solutions/1380237/c-python-bitmasking-backtracking-iterative-solutions-with-picture-clean-concise/",
                "vote_count": "120"
            },
            {
                "language": "python",
                "code": "            h = tuple(subset)\n            if h not in seen:\n                seen.add(h)",
                "url": "https://leetcode.com/problems/subsets-ii/solutions/1380237/c-python-bitmasking-backtracking-iterative-solutions-with-picture-clean-concise/",
                "vote_count": "120"
            }
        ]
    },
    "90": {
        "question_id": 91,
        "title": "Decode Ways",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/decode-ways",
        "description": "A message containing letters from A-Z can be encoded into numbers using the following mapping:'A' -> \"1\"'B' -> \"2\"...'Z' -> \"26\"To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into:\"AAJF\" with the grouping (1 1 10 6)\"KJF\" with the grouping (11 10 6)Note that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\".Given a string s containing only digits, return the number of ways to decode it.The test cases are generated so that the answer fits in a 32-bit integer. ",
        "examples": [
            {
                "input": "s = \"12\"",
                "output": "2",
                "explanation": "\"12\" could be decoded as \"AB\" (1 2) or \"L\" (12)."
            },
            {
                "input": "s = \"226\"",
                "output": "3",
                "explanation": "\"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6)."
            },
            {
                "input": "s = \"06\"",
                "output": "0",
                "explanation": "\"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\")."
            }
        ],
        "constraints": [
            "1 <= s.length <= 100",
            "s contains only digits and may contain leading zero(s)."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "    int numDecodings(string s) {\n        return s.empty() ? 0: numDecodings(0,s);    \n    }\n    int numDecodings(int p, string& s) {\n        int n = s.size();\n        if(p == n) return 1;\n        if(s[p] == '0') return 0; // sub string starting with 0 is not a valid encoding\n        int res = numDecodings(p+1,s);\n        if( p < n-1 && (s[p]=='1'|| (s[p]=='2'&& s[p+1]<'7'))) res += numDecodings(p+2,s);\n        return res;\n    }",
                "url": "https://leetcode.com/problems/decode-ways/solutions/30451/evolve-from-recursion-to-dp/",
                "vote_count": "1532"
            },
            {
                "language": "cpp",
                "code": " public int numDecodings(String s) {\n        return s.length()==0?0:numDecodings(0,s);      \n    }\n    private int numDecodings(int p, String s) {\n        int n=s.length();\n        if(p==n) return 1;\n        if(s.charAt(p)=='0') return 0;\n        int res=numDecodings(p+1,s);\n        if(p<n-1&&(s.charAt(p)=='1'||s.charAt(p)=='2'&&s.charAt(p+1)<'7')) \n   res+=numDecodings(p+2,s);\n        return res;\n    }",
                "url": "https://leetcode.com/problems/decode-ways/solutions/30451/evolve-from-recursion-to-dp/",
                "vote_count": "1532"
            },
            {
                "language": "cpp",
                "code": "    int numDecodings(string s) {\n        int n = s.size();\n        vector<int> mem(n+1,-1);\n        mem[n]=1;\n        return s.empty()? 0 : num(0,s,mem);   \n    }\n    int num(int i, string &s, vector<int> &mem) {\n        if(mem[i]>-1) return mem[i];\n        if(s[i]=='0') return mem[i] = 0;\n        int res = num(i+1,s,mem);\n        if(i<s.size()-1 && (s[i]=='1'||s[i]=='2'&&s[i+1]<'7')) res+=num(i+2,s,mem);\n        return mem[i] = res;\n    }",
                "url": "https://leetcode.com/problems/decode-ways/solutions/30451/evolve-from-recursion-to-dp/",
                "vote_count": "1532"
            },
            {
                "language": "java",
                "code": " public int numDecodings(String s) {\n        int n=s.length();\n        Integer[] mem=new Integer[n];\n        return s.length()==0?0:numDecodings(0,s,mem);      \n    }\n    private int numDecodings(int p, String s, Integer[] mem) {\n        int n=s.length();\n        if(p==n) return 1;\n        if(s.charAt(p)=='0') return 0;\n        if(mem[p]!=null) return mem[p];\n        int res=numDecodings(p+1,s,mem);\n        if(p<n-1&&(s.charAt(p)=='1'||s.charAt(p)=='2'&&s.charAt(p+1)<'7')) \n   res+=numDecodings(p+2,s,mem);\n        return mem[p]=res;\n    }",
                "url": "https://leetcode.com/problems/decode-ways/solutions/30451/evolve-from-recursion-to-dp/",
                "vote_count": "1532"
            },
            {
                "language": "cpp",
                "code": "    int numDecodings(string s) {\n        int n = s.size();\n        vector<int> dp(n+1);\n        dp[n] = 1;\n        for(int i=n-1;i>=0;i--) {\n            if(s[i]=='0') dp[i]=0;\n            else {\n                dp[i] = dp[i+1];\n                if(i<n-1 && (s[i]=='1'||s[i]=='2'&&s[i+1]<'7')) dp[i]+=dp[i+2];\n            }\n        }\n        return s.empty()? 0 : dp[0];   \n    }",
                "url": "https://leetcode.com/problems/decode-ways/solutions/30451/evolve-from-recursion-to-dp/",
                "vote_count": "1532"
            },
            {
                "language": "cpp",
                "code": " public int numDecodings(String s) {\n        int n=s.length();\n        int[] dp=new int[n+1];\n        dp[n]=1;\n        for(int i=n-1;i>=0;i--)\n            if(s.charAt(i)!='0') {\n                dp[i]=dp[i+1];\n                if(i<n-1&&(s.charAt(i)=='1'||s.charAt(i)=='2'&&s.charAt(i+1)<'7')) \n     dp[i]+=dp[i+2];\n            }\n        return dp[0];   \n    }",
                "url": "https://leetcode.com/problems/decode-ways/solutions/30451/evolve-from-recursion-to-dp/",
                "vote_count": "1532"
            },
            {
                "language": "csharp",
                "code": "    int numDecodings(string s) {\n        int p = 1, pp, n = s.size();\n        for(int i=n-1;i>=0;i--) {\n            int cur = s[i]=='0' ? 0 : p;\n            if(i<n-1 && (s[i]=='1'||s[i]=='2'&&s[i+1]<'7')) cur+=pp;\n            pp = p;\n            p = cur;\n        }\n        return s.empty()? 0 : p;   \n    }",
                "url": "https://leetcode.com/problems/decode-ways/solutions/30451/evolve-from-recursion-to-dp/",
                "vote_count": "1532"
            },
            {
                "language": "cpp",
                "code": " public int numDecodings(String s) {\n        int dp1=1, dp2=0, n=s.length();\n        for(int i=n-1;i>=0;i--) {\n            int dp=s.charAt(i)=='0'?0:dp1;\n            if(i<n-1&&(s.charAt(i)=='1'||s.charAt(i)=='2'&&s.charAt(i+1)<'7'))\n                dp+=dp2;\n            dp2=dp1;\n            dp1=dp;\n        }\n        return dp1;\n    }",
                "url": "https://leetcode.com/problems/decode-ways/solutions/30451/evolve-from-recursion-to-dp/",
                "vote_count": "1532"
            },
            {
                "language": "python",
                "code": "public int numDecodings(String s) {\n        if(s == null || s.length() == 0) return 0;\n        HashMap<Integer, Integer> map = new HashMap<>();\n        return dfs(s, map, 0);\n    }\n str.charAt(index + 1) < '7'))){",
                "url": "https://leetcode.com/problems/decode-ways/solutions/30451/evolve-from-recursion-to-dp/",
                "vote_count": "1532"
            },
            {
                "language": "csharp",
                "code": "",
                "url": "https://leetcode.com/problems/decode-ways/solutions/30451/evolve-from-recursion-to-dp/",
                "vote_count": "1532"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/decode-ways/solutions/30451/evolve-from-recursion-to-dp/",
                "vote_count": "1532"
            },
            {
                "language": "csharp",
                "code": "int numDecodings(string s) {\n        if(s[0] == '0')return 0;\n        if(s.size() == 1)return 1;\n        int last = 1, secondlast = 1;\n        for(int i = 1; i<s.size(); i++){\n            if(s[i] == '0')last = 0;\n            if(s[i-1] == '1' || s[i-1] == '2' && s[i] <= '6'){\n                last = last + secondlast;",
                "url": "https://leetcode.com/problems/decode-ways/solutions/30451/evolve-from-recursion-to-dp/",
                "vote_count": "1532"
            },
            {
                "language": "python",
                "code": "map.put(index, res);",
                "url": "https://leetcode.com/problems/decode-ways/solutions/30451/evolve-from-recursion-to-dp/",
                "vote_count": "1532"
            },
            {
                "language": "csharp",
                "code": "public int numDecodings(String s) {\n        if(s == null || s.length() == 0 || s.charAt(0) =='0') return 0;\n        int[] mem = new int[s.length()+1];\n(index+1)<'7')))",
                "url": "https://leetcode.com/problems/decode-ways/solutions/30451/evolve-from-recursion-to-dp/",
                "vote_count": "1532"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public int numDecodings(String s) {\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        int n = s.length();\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = s.charAt(0) != '0' ? 1 : 0;\n        for (int i = 2; i <= n; i++) {\n            int first = Integer.valueOf(s.substring(i - 1, i));\n            int second = Integer.valueOf(s.substring(i - 2, i));\n            if (first >= 1 && first <= 9) {\n               dp[i] += dp[i-1];  \n            }\n            if (second >= 10 && second <= 26) {\n                dp[i] += dp[i-2];\n            }\n        }\n        return dp[n];\n    }\n}",
                "url": "https://leetcode.com/problems/decode-ways/solutions/30358/java-clean-dp-solution-with-explanation/",
                "vote_count": "904"
            },
            {
                "language": "csharp",
                "code": "public int numDecodings(String s) {\n    if(s == null || s.length() == 0) {\n      return 0;\n    }\n    int n = s.length();\n    int[] dp = new int[n];\n    dp[0] = s.charAt(0) != '0' ? 1 : 0;\n    for(int i = 1; i < n; i++) {",
                "url": "https://leetcode.com/problems/decode-ways/solutions/30358/java-clean-dp-solution-with-explanation/",
                "vote_count": "904"
            },
            {
                "language": "csharp",
                "code": "public int numDecodings(String s) {\n    if (s == null || s.length() == 0) {\n        return 0;\n    }\n    char[] chars = s.toCharArray();\n    int[] dp = new int[chars.length];\n    dp[0] = chars[0] == '0' ? 0 : 1;\n    for (int i = 1; i < chars.length; i++) {",
                "url": "https://leetcode.com/problems/decode-ways/solutions/30358/java-clean-dp-solution-with-explanation/",
                "vote_count": "904"
            },
            {
                "language": "csharp",
                "code": " int numDecodings(string s) {\n    int n = s.size();\n    if (n == 0 || s[0] == '0') return 0;\n    if (n == 1) return 1;\n    int pre2 = 1, pre1 = 1;\n    int cur;\n    for (int i = 1; i < n; ++i) {\n        cur = 0;",
                "url": "https://leetcode.com/problems/decode-ways/solutions/30358/java-clean-dp-solution-with-explanation/",
                "vote_count": "904"
            },
            {
                "language": "python",
                "code": "def numDecodings(s): \n if not s:\n  return 0\n\n dp = [0 for x in range(len(s) + 1)] \n \n # base case initialization\n dp[0] = 1 \n dp[1] = 0 if s[0] == \"0\" else 1   #(1)\n\n for i in range(2, len(s) + 1): \n  # One step jump\n  if 0 < int(s[i-1:i]) <= 9:    #(2)\n   dp[i] += dp[i - 1]\n  # Two step jump\n  if 10 <= int(s[i-2:i]) <= 26: #(3)\n   dp[i] += dp[i - 2]\n return dp[len(s)]",
                "url": "https://leetcode.com/problems/decode-ways/solutions/253018/python-easy-to-understand-explanation-bottom-up-dynamic-programming/",
                "vote_count": "504"
            },
            {
                "language": "ruby",
                "code": "    def numDecodings(self, s: str) -> int:\n        if not s or s[0]=='0':\n            return 0\n\n        dp = [0 for x in range(len(s) + 1)] \n\n        # base case initialization\n        dp[0:2] = [1,1]",
                "url": "https://leetcode.com/problems/decode-ways/solutions/253018/python-easy-to-understand-explanation-bottom-up-dynamic-programming/",
                "vote_count": "504"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        # Edge case check\n        if s is None or s[0] == '0':\n            return 0\n        dp = [1] * len(s)\n        for i in range(1, len(s)): \n            # One digit check",
                "url": "https://leetcode.com/problems/decode-ways/solutions/253018/python-easy-to-understand-explanation-bottom-up-dynamic-programming/",
                "vote_count": "504"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        @cache\n        def dp(i):\n            if i == len(s): return 1\n            if s[i] == '0': return 0\n            \n            return dp(i+1) + (dp(i+2) if 10 <= int(s[i:i+2]) <= 26 else 0)",
                "url": "https://leetcode.com/problems/decode-ways/solutions/1410794/c-python-from-top-down-dp-to-bottom-up-dp-o-1-space-clean-concise/",
                "vote_count": "291"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    int ans(string s, int len){\n        if(s.length() == 0){\n            return 1;\n        }\n        if(s[0] == '0'){",
                "url": "https://leetcode.com/problems/decode-ways/solutions/1410794/c-python-from-top-down-dp-to-bottom-up-dp-o-1-space-clean-concise/",
                "vote_count": "291"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        a = [0, 1]\n        for i in range(len(s)):\n            if not i or not 9 < int(s[i - 1:i + 1]) < 27:\n                a[i % 2] = 0\n            if s[i] != \"0\":\n                a[i % 2] += a[i % 2 - 1]",
                "url": "https://leetcode.com/problems/decode-ways/solutions/1410794/c-python-from-top-down-dp-to-bottom-up-dp-o-1-space-clean-concise/",
                "vote_count": "291"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int numDecodings(String s) {\n        return DFS(s, 0);\n    }\n    public int DFS(String s, int index)\n    {\n        if(index == s.length()) return 1;\n        if(s.charAt(index) == '0') return 0;\n        int count = DFS(s, index + 1);\n        if(index < s.length()-1 && (s.charAt(index) == '1' || s.charAt(index) == '2' && s.charAt(index + 1) < '7'))\n        {\n            count += DFS(s, index + 2);\n        }\n        return count;\n    }\n    \n}",
                "url": "https://leetcode.com/problems/decode-ways/solutions/3162837/java-3-solutions-with-clear-explanation-brute-force-dp/",
                "vote_count": "13"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int numDecodings(String s) {\n        int [] dp = new int[s.length() + 1];\n        Arrays.fill(dp, -1);\n        return DFS(s, 0,dp);\n    }\n    public int DFS(String s, int index, int [] dp)\n    {\n        if(index == s.length()) return 1;\n        if(s.charAt(index) == '0') return 0;\n        if(dp[index] != -1) return dp[index];\n        int count = DFS(s, index + 1,dp);\n        if(index < s.length()-1 && (s.charAt(index) == '1' || s.charAt(index) == '2' && s.charAt(index + 1) < '7'))\n        {\n            count += DFS(s, index + 2,dp);\n        }\n        dp[index] = count;\n        return dp[index];\n    }\n    \n}",
                "url": "https://leetcode.com/problems/decode-ways/solutions/3162837/java-3-solutions-with-clear-explanation-brute-force-dp/",
                "vote_count": "13"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int numDecodings(String s) {\n        int len = s.length();\n        int [] dp = new int[len + 1];\n        dp[len] = 1;\n        for(int k = len -1; k >= 0; k--)\n        {\n            if(s.charAt(k) == '0') \n            {\n                continue;\n            }\n            int res = dp[k + 1];\n            if(k < len - 1 && (s.charAt(k) == '1' || s.charAt(k) == '2' && s.charAt(k+1) < '7')) \n            {\n                res += dp[k + 2];\n            }\n            dp[k] = res;\n\n        }\n        return dp[0];\n    }\n}",
                "url": "https://leetcode.com/problems/decode-ways/solutions/3162837/java-3-solutions-with-clear-explanation-brute-force-dp/",
                "vote_count": "13"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int numDecodings(String s) {\n        int len = s.length();\n        int [] dp = new int[len+1];\n        dp[0] = 1;\n        for(int k = 1; k <= len; k++)\n        {\n            if(s.charAt(k-1) == '0') \n            {\n                continue;\n            }\n\n            int res = dp[k  - 1];\n            if(k > 1 && (s.charAt(k-2) == '1' || s.charAt(k-2) == '2' && s.charAt(k-1) < '7')) \n            {\n                res += dp[k - 2];\n            }\n            dp[k] = res;\n\n        }\n        return dp[len];\n\n    }\n}",
                "url": "https://leetcode.com/problems/decode-ways/solutions/3162837/java-3-solutions-with-clear-explanation-brute-force-dp/",
                "vote_count": "13"
            }
        ]
    },
    "91": {
        "question_id": 92,
        "title": "Reverse Linked List II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/reverse-linked-list-ii",
        "description": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list. ",
        "examples": [
            {
                "input": "head = [1,2,3,4,5], left = 2, right = 4",
                "output": "[1,4,3,2,5]",
                "explanation": null
            },
            {
                "input": "head = [5], left = 1, right = 1",
                "output": "[5]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is n.",
            "1 <= n <= 500",
            "-500 <= Node.val <= 500",
            "1 <= left <= right <= n"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "class Solution(object):\n    def reverseBetween(self, head, m, n):\n        \"\"\"\n        :type head: ListNode\n        :type m: int\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or m == n: return head\n        p = dummy = ListNode(None)\n        dummy.next = head\n        for i in range(m-1): p = p.next\n        tail = p.next\n\n        for i in range(n-m):\n            tmp = p.next                  # a)\n            p.next = tail.next            # b)\n            tail.next = tail.next.next    # c)\n            p.next.next = tmp             # d)\n        return dummy.next",
                "url": "https://leetcode.com/problems/reverse-linked-list-ii/solutions/30709/talk-is-cheap-show-me-the-code-and-drawing/",
                "vote_count": "747"
            },
            {
                "language": "python",
                "code": "    ListNode reverse(ListNode head) {\n        if (head.next == null) return head;\n        ListNode last = reverse(head.next);\n        head.next.next = head;\n        head.next = null;\n        return last;\n    }",
                "url": "https://leetcode.com/problems/reverse-linked-list-ii/solutions/30709/talk-is-cheap-show-me-the-code-and-drawing/",
                "vote_count": "747"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/reverse-linked-list-ii/solutions/30709/talk-is-cheap-show-me-the-code-and-drawing/",
                "vote_count": "747"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/reverse-linked-list-ii/solutions/30709/talk-is-cheap-show-me-the-code-and-drawing/",
                "vote_count": "747"
            },
            {
                "language": "java",
                "code": "    public ListNode reverseBetween(ListNode head, int m, int n) {\n        if(head == null || m ==n) {\n            return head;\n        }\n        ListNode dummy = new ListNode(-1);\n        ListNode p = dummy;\n        dummy.next = head;\n        for(int i = 0; i < m-1;i++) {",
                "url": "https://leetcode.com/problems/reverse-linked-list-ii/solutions/30709/talk-is-cheap-show-me-the-code-and-drawing/",
                "vote_count": "747"
            },
            {
                "language": "",
                "code": "Input: head = [1,2,10,20,30,40,5], left = 3, right = 6\nOutput: [1,2,40,30,20,10,5]",
                "url": "https://leetcode.com/problems/reverse-linked-list-ii/solutions/2311084/java-c-tried-to-explain-every-step/",
                "vote_count": "271"
            },
            {
                "language": "ruby",
                "code": "So, the pre pointer will be assigned on just before left position\nCurr pointer & forw pointer will help in reversing the linkedlist\n\nSo, we gonna perform these steps,\ncurr.next = forw.next\nforw.next = curr.next ? prev.next [\"We are not sure at this point which one forw should have to point, so we gonna find out later\"]\nprev.next = forw\nforw = curr.next",
                "url": "https://leetcode.com/problems/reverse-linked-list-ii/solutions/2311084/java-c-tried-to-explain-every-step/",
                "vote_count": "271"
            },
            {
                "language": "rust",
                "code": "Because, let's say we have given \"left = 1\" then where our prev pointer will be assigned then, \nto handle that case we gonna use one dummy node. So, if left = 1 then our prev will be at dummy node",
                "url": "https://leetcode.com/problems/reverse-linked-list-ii/solutions/2311084/java-c-tried-to-explain-every-step/",
                "vote_count": "271"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        ListNode dummy = new ListNode(0); // created dummy node\n        dummy.next = head;\n        ListNode prev = dummy; // intialising prev pointer on dummy node\n        \n        for(int i = 0; i < left - 1; i++)\n            prev = prev.next; // adjusting the prev pointer on it's actual index\n        \n        ListNode curr = prev.next; // curr pointer will be just after prev\n        // reversing\n        for(int i = 0; i < right - left; i++){\n            ListNode forw = curr.next; // forw pointer will be after curr\n            curr.next = forw.next;\n            forw.next = prev.next;\n            prev.next = forw;\n        }\n        return dummy.next;\n    }\n}",
                "url": "https://leetcode.com/problems/reverse-linked-list-ii/solutions/2311084/java-c-tried-to-explain-every-step/",
                "vote_count": "271"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        ListNode *dummy = new ListNode(0); // created dummy node\n        dummy->next = head;\n        ListNode *prev = dummy; // intialising prev pointer on dummy node\n        \n        for(int i = 0; i < left - 1; i++)\n            prev = prev->next; // adjusting the prev pointer on it's actual index\n        \n        ListNode *curr = prev->next; // curr pointer will be just after prev\n        // reversing\n        for(int i = 0; i < right - left; i++){\n            ListNode *forw = curr->next; // forw pointer will be after curr\n            curr->next = forw->next;\n            forw->next = prev->next;\n            prev->next = forw;\n        }\n        return dummy->next;\n    }\n};",
                "url": "https://leetcode.com/problems/reverse-linked-list-ii/solutions/2311084/java-c-tried-to-explain-every-step/",
                "vote_count": "271"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/reverse-linked-list-ii/solutions/2311084/java-c-tried-to-explain-every-step/",
                "vote_count": "271"
            }
        ]
    },
    "92": {
        "question_id": 93,
        "title": "Restore IP Addresses",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.For example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order. ",
        "examples": [
            {
                "input": "s = \"25525511135\"",
                "output": "[\"255.255.11.135\",\"255.255.111.35\"]",
                "explanation": null
            },
            {
                "input": "s = \"0000\"",
                "output": "[\"0.0.0.0\"]",
                "explanation": null
            },
            {
                "input": "s = \"101023\"",
                "output": "[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= s.length <= 20",
            "s consists of digits only."
        ],
        "solutions": [
            {
                "language": "kotlin",
                "code": "    bool check(string s){\n        if(s.length() == 1)\n            return true;\n        if(s[0] == '0')\n            return false;\n        if(s.length() == 2)\n            return true;\n        if(s[0] > '2')",
                "url": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079368/c-easy-solution-iterative-approach-heavily-commented/",
                "vote_count": "181"
            },
            {
                "language": "typescript",
                "code": "   private List<String> ipes;\n   private int l;\n   public List<String> restoreIpAddresses(String s) {\n       ipes = new ArrayList<>();\n       l = s.length();\n       f(s, 0, \"\", 0);\n       return ipes;\n   }\n   ",
                "url": "https://leetcode.com/problems/restore-ip-addresses/solutions/3079368/c-easy-solution-iterative-approach-heavily-commented/",
                "vote_count": "181"
            }
        ]
    },
    "93": {
        "question_id": 94,
        "title": "Binary Tree Inorder Traversal",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/binary-tree-inorder-traversal",
        "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values. ",
        "examples": [
            {
                "input": "root = [1,null,2,3]",
                "output": "[1,3,2]",
                "explanation": null
            },
            {
                "input": "root = []",
                "output": "[]",
                "explanation": null
            },
            {
                "input": "root = [1]",
                "output": "[1]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [0, 100].",
            "-100 <= Node.val <= 100"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "def preorder(root):\n  return [root.val] + preorder(root.left) + preorder(root.right) if root else []",
                "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/solutions/283746/all-dfs-traversals-preorder-inorder-postorder-in-python-in-1-line/",
                "vote_count": "859"
            },
            {
                "language": "python",
                "code": "def inorder(root):\n  return  inorder(root.left) + [root.val] + inorder(root.right) if root else []",
                "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/solutions/283746/all-dfs-traversals-preorder-inorder-postorder-in-python-in-1-line/",
                "vote_count": "859"
            },
            {
                "language": "python",
                "code": "def postorder(root):\n  return  postorder(root.left) + postorder(root.right) + [root.val] if root else []",
                "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/solutions/283746/all-dfs-traversals-preorder-inorder-postorder-in-python-in-1-line/",
                "vote_count": "859"
            },
            {
                "language": "ruby",
                "code": " def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        def traverse(current_node):\n            if current_node.left:\n                traverse(current_node.left)\n            result.append(current_node.val)\n            if current_node.right:",
                "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/solutions/283746/all-dfs-traversals-preorder-inorder-postorder-in-python-in-1-line/",
                "vote_count": "859"
            }
        ]
    },
    "94": {
        "question_id": 95,
        "title": "Unique Binary Search Trees II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/unique-binary-search-trees-ii",
        "description": "Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order. ",
        "examples": [
            {
                "input": "n = 3",
                "output": "[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]",
                "explanation": null
            },
            {
                "input": "n = 1",
                "output": "[[1]]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= n <= 8"
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "public List<TreeNode> generateTrees(int n) {\n return generateSubtrees(1, n);\n}\n\nprivate List<TreeNode> generateSubtrees(int s, int e) {\n List<TreeNode> res = new LinkedList<TreeNode>();\n if (s > e) {\n  res.add(null); // empty tree\n  return res;\n }\n\n for (int i = s; i <= e; ++i) {\n  List<TreeNode> leftSubtrees = generateSubtrees(s, i - 1);\n  List<TreeNode> rightSubtrees = generateSubtrees(i + 1, e);\n\n  for (TreeNode left : leftSubtrees) {\n   for (TreeNode right : rightSubtrees) {\n    TreeNode root = new TreeNode(i);\n    root.left = left;\n    root.right = right;\n    res.add(root);\n   }\n  }\n }\n return res;\n}",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/31508/divide-and-conquer-f-i-g-i-1-g-n-i/",
                "vote_count": "308"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/31508/divide-and-conquer-f-i-g-i-1-g-n-i/",
                "vote_count": "308"
            },
            {
                "language": "csharp",
                "code": "Map<List<Integer>,List<TreeNode>> hm = new HashMap<>();\n\n\npublic List<TreeNode> generateTrees(int n) {\n    List<TreeNode> res = new LinkedList<TreeNode>();\n    if(n == 0) return res;",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/31508/divide-and-conquer-f-i-g-i-1-g-n-i/",
                "vote_count": "308"
            },
            {
                "language": "ruby",
                "code": "def generateTrees(self, n: int) -> List[TreeNode]:\n    if n==0:\n        return []\n    return self.generate(1,n)\ndef generate(self,start,end):\n    if start>end:\n        return [None]\n    res = []",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/31508/divide-and-conquer-f-i-g-i-1-g-n-i/",
                "vote_count": "308"
            },
            {
                "language": "java",
                "code": "public static List<TreeNode> generateTrees(int n) {\n    List<TreeNode>[] result = new List[n + 1];\n    result[0] = new ArrayList<TreeNode>();\n    if (n == 0) {\n        return result[0];\n    }\n\n    result[0].add(null);\n    for (int len = 1; len <= n; len++) {\n        result[len] = new ArrayList<TreeNode>();\n        for (int j = 0; j < len; j++) {\n            for (TreeNode nodeL : result[j]) {\n                for (TreeNode nodeR : result[len - j - 1]) {\n                    TreeNode node = new TreeNode(j + 1);\n                    node.left = nodeL;\n                    node.right = clone(nodeR, j + 1);\n                    result[len].add(node);\n                }\n            }\n        }\n    }\n    return result[n];\n}\n\nprivate static TreeNode clone(TreeNode n, int offset) {\n    if (n == null) {\n        return null;\n    }\n    TreeNode node = new TreeNode(n.val + offset);\n    node.left = clone(n.left, offset);\n    node.right = clone(n.right, offset);\n    return node;\n}",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/31493/java-solution-with-dp/",
                "vote_count": "274"
            },
            {
                "language": "csharp",
                "code": "public List<TreeNode> generateTrees(int n) {\n \n List<TreeNode>[] res = new List[n+1];\n res[0] = new ArrayList();\n if(n == 0) return res[0];",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/31493/java-solution-with-dp/",
                "vote_count": "274"
            },
            {
                "language": "csharp",
                "code": " public class Solution {\n TreeNode deepCopy(TreeNode root){\n  if(root == null) return null;\n  TreeNode tmp = new TreeNode(1);\n  tmp.left = deepCopy(root.left);\n  tmp.right = deepCopy(root.right);",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/31493/java-solution-with-dp/",
                "vote_count": "274"
            },
            {
                "language": "python",
                "code": "def generateTrees(self, n):\n    def node(val, left, right):\n        node = TreeNode(val)\n        node.left = left\n        node.right = right\n        return node\n    def trees(first, last):\n        return [node(root, left, right)\n                for root in range(first, last+1)\n                for left in trees(first, root-1)\n                for right in trees(root+1, last)] or [None]\n    return trees(1, n)",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/31495/should-be-6-liner/",
                "vote_count": "182"
            },
            {
                "language": "python",
                "code": "def node(val, left, right):\n    node = TreeNode(val)\n    node.left = left\n    node.right = right\n    return node\n\nclass Solution:\n    def generateTrees(self, last, first=1):\n        return [node(root, left, right)\n                for root in range(first, last+1)\n                for left in self.generateTrees(root-1, first)\n                for right in self.generateTrees(last, root+1)] or [None]",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/31495/should-be-6-liner/",
                "vote_count": "182"
            },
            {
                "language": "python",
                "code": "def generateTrees(self, n):\n    def generate(first, last):\n        trees = []\n        for root in range(first, last+1):\n            for left in generate(first, root-1):\n                for right in generate(root+1, last):\n                    node = TreeNode(root)\n                    node.left = left\n                    node.right = right\n                    trees += node,\n        return trees or [None]\n    return generate(1, n)",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/31495/should-be-6-liner/",
                "vote_count": "182"
            },
            {
                "language": "kotlin",
                "code": "class Solution(object):\n    def generateTrees(self, n):\n        if n < 1: return []\n        cache = {}\n        def generate(first, last):\n            if first > last: return [None]\n            if (first, last) in cache: return cache[first, last]\n            trees = []",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/31495/should-be-6-liner/",
                "vote_count": "182"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def generateTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[TreeNode]\n        \"\"\"\n        def generate(arr):\n            if not arr:",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/31495/should-be-6-liner/",
                "vote_count": "182"
            },
            {
                "language": "python",
                "code": "class TreeNode:\n    def __init__(self, x, left=None, right=None):\n        self.val = x\n        self.left = left\n        self.right = right",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/31495/should-be-6-liner/",
                "vote_count": "182"
            },
            {
                "language": "python",
                "code": "def generateTrees(self, n):\n        def trees(a, b):\n            return [TreeNode(i, l, r) for i in range(a, b) \n                                      for l in trees(a,i) \n                                      for r in trees(i+1,b)] or [None]\n        return trees(1,n+1) if n else []",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/31495/should-be-6-liner/",
                "vote_count": "182"
            },
            {
                "language": "kotlin",
                "code": "    def generateTrees(self, n):\n        if not n: return []\n        memo = {}\n        def node(val, left, right):\n            root, root.left, root.right = TreeNode(val), left, right\n            return root\n        def gen(i, j):",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/31495/should-be-6-liner/",
                "vote_count": "182"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\n        @lru_cache(None)\n        def dfs(left, right):\n            if left > right: return [None]\n            if left == right: return [TreeNode(left)]\n            ans = []\n            for root in range(left, right+1):\n                leftNodes = dfs(left, root - 1)\n                rightNodes = dfs(root+1, right)\n                for leftNode in leftNodes:\n                    for rightNode in rightNodes:\n                        rootNode = TreeNode(root, leftNode, rightNode)\n                        ans.append(rootNode)\n            return ans\n        \n        return dfs(1, n)",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/1440128/python-dfs-with-memoization-clean-concise/",
                "vote_count": "138"
            },
            {
                "language": "java",
                "code": "from functools import cache\n\nclass Solution:\n    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:\n        @cache\n        def dfs(left, right):\n            if left<right:\n                return [TreeNode(root, leftNode, rightNode) ",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/1440128/python-dfs-with-memoization-clean-concise/",
                "vote_count": "138"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def generateTrees(self,n: int, k=1) -> List[Optional[TreeNode]]:",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/1440128/python-dfs-with-memoization-clean-concise/",
                "vote_count": "138"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/1440128/python-dfs-with-memoization-clean-concise/",
                "vote_count": "138"
            },
            {
                "language": "cpp",
                "code": "vector<TreeNode*> buildTree(int start, int end) {\n vector<TreeNode*> ans;\n        \n    // If start > end, then subtree will be empty so add NULL in the ans and return it.\n    if(start > end) {\n  ans.push_back(NULL);\n        return ans;\n    }\n\n    // Iterate through all values from start to end to construct left and right subtree recursively\n for(int i = start; i <= end; ++i) {\n  vector<TreeNode*> leftSubTree = buildTree(start, i - 1);    // Construct left subtree\n        vector<TreeNode*> rightSubTree = buildTree(i + 1, end);     // Construct right subtree\n            \n  // loop through all left and right subtrees and connect them to ith root  \n  for(int j = 0; j < leftSubTree.size(); j++) {\n   for(int k = 0; k < rightSubTree.size(); k++) {\n    TreeNode* root = new TreeNode(i);   // Create root with value i\n    root->left = leftSubTree[j];   // Connect left subtree rooted at leftSubTree[j]\n                root->right = rightSubTree[k];   // Connect right subtree rooted at rightSubTree[k]\n    ans.push_back(root);    // Add this tree(rooted at i) to ans data-structure\n   }\n  }\n    }\n        \n return ans;\n}\n    \nvector<TreeNode*> generateTrees(int n) {\n return buildTree(1, n);\n}",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/1849266/c-detailed-explanation-recursive-tree-with-comments/",
                "vote_count": "78"
            },
            {
                "language": "",
                "code": "What a masterpiece!!!",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/1849266/c-detailed-explanation-recursive-tree-with-comments/",
                "vote_count": "78"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<TreeNode*> helper(int start,int end) {\n        vector<TreeNode*> v;\n        if(start > end) {\n            v.push_back(NULL);\n            return v;\n        }\n        for(int i = start; i <= end; i++){\n            auto left = helper(start,i-1);\n            auto right = helper(i+1,end);\n            for(auto l : left) {\n                for(auto r : right){\n                    TreeNode* newNode = new TreeNode(i, l, r);\n                    v.push_back(newNode);\n                }\n            }\n        }\n        return v;\n    }\n    \n    vector<TreeNode*> generateTrees(int n) {\n        if(n == 0) \n            return vector<TreeNode*>();\n        auto ans = helper(1,n);\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/703236/c-simple-and-short/",
                "vote_count": "56"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n, int s = 1) {\n        vector<TreeNode*> ans;\n        if(n < s)\n            return {nullptr};\n   \n  // Consider every number in range [s,n] as root \n        for(int i=s; i<=n; i++) {\n  \n   // generate all possible trees in range [s,i)\n            for(auto left: generateTrees(i-1, s)) {\n   \n    // generate all possible trees in range (i,e]\n                for(auto right: generateTrees(n, i+1))\n    \n     // make new trees with i as the root\n                    ans.push_back(new TreeNode(i, left, right));\n            }\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/1440883/small-c-solution/",
                "vote_count": "55"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    vector<TreeNode*> generate(vector<vector<vector<TreeNode*>>> &memo, int s, int e) {\n        if(s > e) {\n            return {nullptr};\n        }\n\n        if(memo[s][e].empty()) {\n            for(int i=s; i<=e; ++i) {",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/1440883/small-c-solution/",
                "vote_count": "55"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<TreeNode*> rec(int start, int end) {\n        vector<TreeNode*> res;\n        if (start > end) return {NULL};\n        \n        if (start == end) return {new TreeNode(start)};\n        \n        for (int i = start; i <= end; i++) {\n            vector<TreeNode*> left = rec(start, i-1), right = rec(i+1, end);\n            \n            for (auto l : left)\n                for (auto r : right)\n                    res.push_back(new TreeNode(i, l, r));\n        }\n        return res;\n    }\n    \n    vector<TreeNode*> generateTrees(int n) {\n        vector<TreeNode*> res = rec(1, n);\n        return res;\n    }\n};",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/1440190/c-python-simple-and-short-recursive-solutions-with-explanation/",
                "vote_count": "38"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def generateTrees(self, n: int) -> List[TreeNode]:\n        def rec(start, end):\n  \n            if start > end:\n                return [None]\n    \n            if start == end:\n                return [TreeNode(start)]\n            ret_list = []\n   \n            for i in range(start, end+1):\n                left = rec(start, i-1)\n                right = rec(i+1, end)\n                for pair in product(left, right):\n                    ret_list.append(TreeNode(i, pair[0], pair[1]))\n        \n            return ret_list\n        \n        res = rec(1,n)\n        return res",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/1440190/c-python-simple-and-short-recursive-solutions-with-explanation/",
                "vote_count": "38"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n, int s = 1) {\n        vector<TreeNode*> ans;\n        if(n < s) return {nullptr};                              \n         for(int i=s; i<=n; i++) {                                  // Consider every number in range [s,n] as root  \n            for(auto left: generateTrees(i-1, s)) {                  // generate all possible trees in range [s,i)\n                for(auto right: generateTrees(n, i+1))               // generate all possible trees in range (i,e]\n                    ans.push_back(new TreeNode(i, left, right));     // make new trees with i as the root\n            }\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/2503720/6-liner-c-recursive/",
                "vote_count": "13"
            },
            {
                "language": "swift",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\n\nclass Solution {\n    func generateTrees(_ n: Int) -> [TreeNode?] {\n        var nums: [Int] = []\n        \n        func copyNodes(_ node: TreeNode?, _ left: TreeNode?, _ right: TreeNode?) -> TreeNode? {\n            if node == nil { return nil } \n            else {\n                let newNode = TreeNode(node!.val)\n                newNode.left = copyNodes(left, left?.left, left?.right)\n                newNode.right = copyNodes(right, right?.left, right?.right)\n                return newNode\n            }\n        }\n\n        func generateNodes(_ node: TreeNode?, _ left: [TreeNode?], _ right: [TreeNode?]) -> [TreeNode?] {\n            let leftCount = left.count > 0 ? left.count : 1\n            let rightCount = right.count > 0 ? right.count : 1\n            var res: [TreeNode?] = []\n            \n            for i in 0..<leftCount {\n                let leftNode = left.count > 0 ? left[i] : nil\n                for j in 0..<rightCount {\n                    let rightNode = right.count > 0 ? right[j] : nil\n                    res.append(copyNodes(node, leftNode, rightNode))\n                }\n            }\n            return res\n        }\n\n        func nodes(_ nums: [Int]) -> [TreeNode?] {\n            if nums.count == 0 { return [] }\n            var res: [TreeNode?] = []\n\n            for (i, num) in nums.enumerated() {\n                let node = TreeNode(num)\n                let leftNodes = i > 0 ? nodes(Array(nums[0..<i])) : nodes([])\n                let rightNodes = i < nums.count - 1 ? nodes(Array(nums[i + 1...nums.count - 1])) : nodes([])\n                res += generateNodes(node, leftNodes, rightNodes)\n            }\n            return res\n        }\n        \n        for num in 1...n { nums.append(num) }\n        return nodes(nums)\n    }\n\n}",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/1926204/100-fastest-swift-solution/",
                "vote_count": "12"
            },
            {
                "language": "swift",
                "code": "func generateTrees(_ n: Int) -> [TreeNode?] {\n    var limit = n + 1\n    var memoSize = limit + 1\n    // This syntax is probably wrong - I am trying to create double array which can be",
                "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/1926204/100-fastest-swift-solution/",
                "vote_count": "12"
            }
        ]
    },
    "95": {
        "question_id": 96,
        "title": "Unique Binary Search Trees",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/unique-binary-search-trees",
        "description": "Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n. ",
        "examples": [
            {
                "input": "n = 3",
                "output": "5",
                "explanation": null
            },
            {
                "input": "n = 1",
                "output": "1",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= n <= 19"
        ],
        "solutions": [
            {
                "language": "",
                "code": "G(n) = F(1, n) + F(2, n) + ... + F(n, n). ",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/31666/dp-solution-in-6-lines-with-explanation-f-i-n-g-i-1-g-n-i/",
                "vote_count": "3563"
            },
            {
                "language": "",
                "code": "G(0)=1, G(1)=1. ",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/31666/dp-solution-in-6-lines-with-explanation-f-i-n-g-i-1-g-n-i/",
                "vote_count": "3563"
            },
            {
                "language": "lisp",
                "code": "F(i, n) = G(i-1) * G(n-i) 1 <= i <= n ",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/31666/dp-solution-in-6-lines-with-explanation-f-i-n-g-i-1-g-n-i/",
                "vote_count": "3563"
            },
            {
                "language": "",
                "code": "G(n) = G(0) * G(n-1) + G(1) * G(n-2) + \u2026 + G(n-1) * G(0) ",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/31666/dp-solution-in-6-lines-with-explanation-f-i-n-g-i-1-g-n-i/",
                "vote_count": "3563"
            },
            {
                "language": "cpp",
                "code": "public int numTrees(int n) {\n  int [] G = new int[n+1];\n  G[0] = G[1] = 1;\n    \n  for(int i=2; i<=n; ++i) {\n    for(int j=1; j<=i; ++j) {\n      G[i] += G[j-1] * G[i-j];\n    }\n  }\n  return G[n];\n}",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/31666/dp-solution-in-6-lines-with-explanation-f-i-n-g-i-1-g-n-i/",
                "vote_count": "3563"
            },
            {
                "language": "javascript",
                "code": "/*    \nHope it will help you to understand :\n    \n    n = 0;     null   \n    \n    count[0] = 1\n    \n    \n    n = 1;      1       ",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/31666/dp-solution-in-6-lines-with-explanation-f-i-n-g-i-1-g-n-i/",
                "vote_count": "3563"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\n    public int numTrees(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= i; j++) {\n                dp[i] += dp[j - 1]*dp[i - j];\n            }",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/31666/dp-solution-in-6-lines-with-explanation-f-i-n-g-i-1-g-n-i/",
                "vote_count": "3563"
            },
            {
                "language": "cpp",
                "code": " public int numTrees(int n) {\n        return trees(1, n);\n    }\n\n    int trees(int lo, int hi) {\n        if (lo >= hi) return 1;",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/31666/dp-solution-in-6-lines-with-explanation-f-i-n-g-i-1-g-n-i/",
                "vote_count": "3563"
            },
            {
                "language": "cpp",
                "code": "int numTrees(int n) {\n    vector<int> dp(n + 1);\n    dp[0] = 1;\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j < i / 2; j++) {\n            dp[i] += 2 * dp[j] * dp[i - j - 1];\n        }",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/31666/dp-solution-in-6-lines-with-explanation-f-i-n-g-i-1-g-n-i/",
                "vote_count": "3563"
            },
            {
                "language": "cpp",
                "code": "int numTrees(int n) {\n         int nums[2000]={1,1,};\n         int i,x;\n         for(x=2;x<=n;x++){\n           for(i=1;i<=x/2;i++)\n             nums[x]=nums[x]+nums[i-1]*nums[x-i];\n           if(x%2==0)nums[x]=2*nums[x];\n           else nums[x]=2*nums[x]+nums[x/2]*nums[x/2];  }",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/31666/dp-solution-in-6-lines-with-explanation-f-i-n-g-i-1-g-n-i/",
                "vote_count": "3563"
            },
            {
                "language": "",
                "code": " \n              1            1                   2                    3               3\n            \\            \\                 / \\                  /               /\n             3             2              1   3                2               1\n               /               \\                                 /                 \\\n              2                 3                              1                    2\n                     i = 1                   i = 2                       i = 3           \n(i = root node)",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565543/c-python-5-easy-solutions-w-explanation-optimization-from-brute-force-to-dp-to-catalan-o-n/",
                "vote_count": "509"
            },
            {
                "language": "ruby",
                "code": "           3                          2                         1               \n          / \\                        / \\                      /   \\      \nnumTrees(2) numTrees(0)    numTrees(1) numTrees(1)   numTrees(0) numTrees(2)              \n         i = 3                      i = 2                     i = 1           \n   \n                      i\n =>              /   \\ \n         numTrees(i-1) numTrees(n-i)",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565543/c-python-5-easy-solutions-w-explanation-optimization-from-brute-force-to-dp-to-catalan-o-n/",
                "vote_count": "509"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int numTrees(int n) {\n        if(n <= 1) return 1;\n        int ans = 0;\n        for(int i = 1; i <= n; i++) \n            ans += numTrees(i-1) * numTrees(n-i);\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565543/c-python-5-easy-solutions-w-explanation-optimization-from-brute-force-to-dp-to-catalan-o-n/",
                "vote_count": "509"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def numTrees(self, n: int) -> int:\n        if n <= 1: return 1\n        return sum(self.numTrees(i-1) * self.numTrees(n-i) for i in range(1, n+1))",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565543/c-python-5-easy-solutions-w-explanation-optimization-from-brute-force-to-dp-to-catalan-o-n/",
                "vote_count": "509"
            },
            {
                "language": "erlang",
                "code": "f(i) = numTrees(i)\n                                                                 f(5)\n        __________________________________|____________________________________________         \n                     \u2199                            \u2193                \u2193                \u2193                 \u2198\n          (f(0)*           f(4))                 f(1)*f(3)        f(2)*f(2)        f(3)*f(1)          f(4)*f(0)\n         _____________|_____________             \u2b06\ufe0f          \u2b06\ufe0f  \u2b06\ufe0f         \u2b06\ufe0f                 \u2b06\ufe0f\n              \u2199        \u2193        \u2193         \u2198      \n         f(0)f(3)     f(1)f(2)   f(2)f(1)   f(3)f(0)      \n     ______|_____       \u2b06\ufe0f  \u2b06\ufe0f        \u2b06\ufe0f\n          \u2199      \u2193     \u2198\n      f(0)f(2) f(1)f(1) f(2)f(1)\n          __|__          \u2b06\ufe0f \n      \u2199       \u2198\n     f(0)f(1)  f(1)f(0)",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565543/c-python-5-easy-solutions-w-explanation-optimization-from-brute-force-to-dp-to-catalan-o-n/",
                "vote_count": "509"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int dp[20]{};\n    int numTrees(int n) {\n        if(n <= 1) return 1;\n        if(dp[n]) return dp[n];\n        for(int i = 1; i <= n; i++) \n            dp[n] += numTrees(i-1) * numTrees(n-i);\n        return dp[n];\n    }\n};",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565543/c-python-5-easy-solutions-w-explanation-optimization-from-brute-force-to-dp-to-catalan-o-n/",
                "vote_count": "509"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    @cache\n    def numTrees(self, n: int) -> int:\n        if n <= 1: return 1\n        return sum(self.numTrees(i-1) * self.numTrees(n-i) for i in range(1, n+1))",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565543/c-python-5-easy-solutions-w-explanation-optimization-from-brute-force-to-dp-to-catalan-o-n/",
                "vote_count": "509"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n+1);\n        dp[0] = dp[1] = 1;\n        for(int i = 2; i <= n; i++) \n            for(int j = 1; j <= i; j++)\n                dp[i] += dp[j-1] * dp[i-j];\n        return dp[n];\n    }\n};",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565543/c-python-5-easy-solutions-w-explanation-optimization-from-brute-force-to-dp-to-catalan-o-n/",
                "vote_count": "509"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [0]*(n+1)\n        dp[0], dp[1] = 1, 1\n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        return dp[n]",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565543/c-python-5-easy-solutions-w-explanation-optimization-from-brute-force-to-dp-to-catalan-o-n/",
                "vote_count": "509"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    long ncr(int n, int r) {\n        long ans = 1;\n        for(int i = 0; i < r; i++) {\n            ans *= n-i;\n            ans /= i+1;\n        }\n        return ans;   \n    }\n    int numTrees(int n) {\n        return ncr(2*n, n) / (n + 1);\n    }\n};",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565543/c-python-5-easy-solutions-w-explanation-optimization-from-brute-force-to-dp-to-catalan-o-n/",
                "vote_count": "509"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565543/c-python-5-easy-solutions-w-explanation-optimization-from-brute-force-to-dp-to-catalan-o-n/",
                "vote_count": "509"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def numTrees(self, n: int) -> int:\n        return factorial(2*n) // (factorial(n)*factorial(n+1))",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565543/c-python-5-easy-solutions-w-explanation-optimization-from-brute-force-to-dp-to-catalan-o-n/",
                "vote_count": "509"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int numTrees(int n) {\n        long ans = 1;\n        for(int i = 0; i < n; i++) \n            ans *= (4*i+2) / (i+2.);\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565543/c-python-5-easy-solutions-w-explanation-optimization-from-brute-force-to-dp-to-catalan-o-n/",
                "vote_count": "509"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def numTrees(self, n: int) -> int:\n        return int(prod((4*i+2) / (i+2) for i in range(n)))",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565543/c-python-5-easy-solutions-w-explanation-optimization-from-brute-force-to-dp-to-catalan-o-n/",
                "vote_count": "509"
            },
            {
                "language": "cpp",
                "code": " public int numTrees(int n) {\n    int [] dp = new int[n+1];\n    dp[0]= 1;\n    dp[1] = 1;\n    for(int level = 2; level <=n; level++)\n        for(int root = 1; root<=level; root++)\n            dp[level] += dp[level-root]*dp[root-1];\n    return dp[n];\n}",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/31707/fantastic-clean-java-dp-solution-with-detail-explaination/",
                "vote_count": "454"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int numTrees(int n) {\n        if (n == 0) return 0;\n        // For convenience: when you say you have N numbers, I denote them 0-based as 0..N-1\n        // The table:   first dimension is SIZE of a tree: 0..N\n        //              second dimension is index, or 0-based value of the number: 0..N-1. +1 because want to use diagonal to store sumf or [..][I]\n        //              entry itself is: number of unique trees of size I, and rooted with number (or index) J = 0..I-1",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/31707/fantastic-clean-java-dp-solution-with-detail-explaination/",
                "vote_count": "454"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def numTrees(self, n):\n        return factorial(2*n)//factorial(n)//factorial(n)//(n+1)",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/703049/python-math-oneliner-o-n-using-catalan-number-explained/",
                "vote_count": "227"
            },
            {
                "language": "kotlin",
                "code": "    return [1,\n        2,\n        5,\n        14,\n        42,\n        132,\n        429,\n        1430,",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/703049/python-math-oneliner-o-n-using-catalan-number-explained/",
                "vote_count": "227"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int numTrees(int n, int[] dp){\n        if(n == 0 || n == 1) return 1;\n        if(dp[n]!=0) return dp[n];\n        int count = 0;\n        for(int i=1;i<=n;i++){\n            count += numTrees(i-1, dp) * numTrees(n - i, dp);",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/703049/python-math-oneliner-o-n-using-catalan-number-explained/",
                "vote_count": "227"
            },
            {
                "language": "php",
                "code": "def numTrees(self, n: int) -> int:\n\n    return factorial(2*n)//(factorial(n)*factorial(n+1))",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/703049/python-math-oneliner-o-n-using-catalan-number-explained/",
                "vote_count": "227"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int numTrees(int n) {\n        int result=0;\n        if(n==1 || n==0)\n            return 1;\n        for(int i=0;i<n;i++)\n            result+=numTrees(i)*numTrees(n-i-1);\n        return result;\n    }\n};",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1109205/detailed-analysis-3-different-approaches-explained/",
                "vote_count": "127"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int>result(n+1,0); //Initializing vector with 0\n        result[1]=result[0]=1;\n        for(int i=2;i<=n;i++)\n        {\n            for(int j=0;j<i;j++)\n            {\n                result[i]+=result[j]*result[i-j-1]; //Calculating C(i) to use for C(i+1) and storing it in result\n            }\n        }\n        return result[n]; //return answer\n    }\n};",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1109205/detailed-analysis-3-different-approaches-explained/",
                "vote_count": "127"
            },
            {
                "language": "javascript",
                "code": "     `C(n)=Ci(2n,n)/n+1`",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1109205/detailed-analysis-3-different-approaches-explained/",
                "vote_count": "127"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    long CalculateCoeff(int n,int k) //Function to calculate Ci(n.k)\n    {\n        long res=1;\n        if(k>n-k)\n            k=n-k;                    //Since Ci(n,k)=Ci(n,n-k), property of binomial coefficients\n        for(int i=0;i<k;i++)\n        {\n            res*=(n-i);\n            res/=(i+1);\n        }\n        return res;\n    }\n    int numTrees(int n) {\n        return CalculateCoeff(2*n,n)/(n+1);\n    }\n};",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1109205/detailed-analysis-3-different-approaches-explained/",
                "vote_count": "127"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1109205/detailed-analysis-3-different-approaches-explained/",
                "vote_count": "127"
            },
            {
                "language": "kotlin",
                "code": "}",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1109205/detailed-analysis-3-different-approaches-explained/",
                "vote_count": "127"
            },
            {
                "language": "",
                "code": "   1                                2\n  \\                            /\n    2                        1",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565533/java-simple-clean-dp-solution-w-detailed-example-beats-100-tc-o-n-2-sc-o-n/",
                "vote_count": "69"
            },
            {
                "language": "",
                "code": "   1                1                2                  3                 3\n \\                \\              / \\                /                 /\n  2                3            1   3              2                 1\n      \\              /                               /                   \\\n    3            2                               1                     2",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565533/java-simple-clean-dp-solution-w-detailed-example-beats-100-tc-o-n-2-sc-o-n/",
                "vote_count": "69"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int numTrees(int n) {\n        // Checking for Invalid Input\n        if (n < 0) {\n            throw new IllegalArgumentException(\"Invalid Input\");\n        }\n        // For n == 0, empty tree is a valid BST.\n        // For n == 1, valid BST can have only one node.\n        if (n <= 1) {\n            return 1;\n        }\n\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n\n        for (int i = 2; i <= n; i++) {\n            // We only need to do half as dp[i] is symmetrical.\n            // For example, when i = 5:\n            // dp[i] = dp[0]*dp[4] + dp[1]*dp[3] + dp[2]*dp[2] + dp[3]*dp[1] + dp[4]*dp[0]\n            // Here except dp[2]*dp[2] all others are appearing twice.\n            for (int j = 0; j < i / 2; j++) {\n                dp[i] += dp[j] * dp[i - 1 - j];\n            }\n            dp[i] *= 2;\n\n            // Only add i/2 * i/2 for odd numbers.\n            if ((i & 1) == 1) {\n                dp[i] += dp[i / 2] * dp[i / 2];\n            }\n        }\n\n        return dp[n];\n    }\n}",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565533/java-simple-clean-dp-solution-w-detailed-example-beats-100-tc-o-n-2-sc-o-n/",
                "vote_count": "69"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    \n    int dp[20];\n    ",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565533/java-simple-clean-dp-solution-w-detailed-example-beats-100-tc-o-n-2-sc-o-n/",
                "vote_count": "69"
            },
            {
                "language": "cpp",
                "code": "public int numTrees(int n) {\n        int[] dp = new int[n+1];\n        dp[0]=1;\n        dp[1]=1;\n        for(int i = 2; i<=n; i++) {\n            for(int j = 0; j <i; j++) {\n                dp[i] = dp[i] + dp[j] * dp[i-j-1];\n            }\n        }",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565533/java-simple-clean-dp-solution-w-detailed-example-beats-100-tc-o-n-2-sc-o-n/",
                "vote_count": "69"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int>cat(n+1, 0);\n        \n        cat[0] = 1;\n        cat[1] = 1;\n        \n        for(int i{2}; i<=n; ++i){\n            \n            for(int j{}; j<i; ++j){\n                \n                cat[i] += cat[j]*cat[i-j-1];\n            }\n        }\n        \n        return cat[n];\n    }\n};",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565599/c-easy-intuitive-sol-2-approaches-recursive-dp-catalan-numbers/",
                "vote_count": "40"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    int solve(int n, vector<int>&dp){\n        if(n <= 1) return 1;\n        if(dp[n] != -1) return dp[n];\n        \n        int res{};\n        \n        for(int i{1}; i<=n; ++i)\n            res += solve(i-1, dp)*solve(n-i, dp);\n        \n        return dp[n] = res;\n    }\n    \n    int numTrees(int n) {\n        vector<int>dp(n+1, -1);\n        return solve(n, dp);\n    }\n};",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565599/c-easy-intuitive-sol-2-approaches-recursive-dp-catalan-numbers/",
                "vote_count": "40"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    \n    int dp[20][20] ; // dp array",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565599/c-easy-intuitive-sol-2-approaches-recursive-dp-catalan-numbers/",
                "vote_count": "40"
            },
            {
                "language": "kotlin",
                "code": "}",
                "url": "https://leetcode.com/problems/unique-binary-search-trees/solutions/1565599/c-easy-intuitive-sol-2-approaches-recursive-dp-catalan-numbers/",
                "vote_count": "40"
            }
        ]
    },
    "96": {
        "question_id": 97,
        "title": "Interleaving String",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/interleaving-string",
        "description": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.An interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:s = s1 + s2 + ... + snt = t1 + t2 + ... + tm|n - m| <= 1The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...Note: a + b is the concatenation of strings a and b. ",
        "examples": [
            {
                "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"",
                "output": "true",
                "explanation": "One way to obtain s3 is:\nSplit s1 into s1 = \"aa\" + \"bc\" + \"c\", and s2 into s2 = \"dbbc\" + \"a\".\nInterleaving the two splits, we get \"aa\" + \"dbbc\" + \"bc\" + \"a\" + \"c\" = \"aadbbcbcac\".\nSince s3 can be obtained by interleaving s1 and s2, we return true."
            },
            {
                "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"",
                "output": "false",
                "explanation": "Notice how it is impossible to interleave s2 with any other string to obtain s3."
            },
            {
                "input": "s1 = \"\", s2 = \"\", s3 = \"\"",
                "output": "true",
                "explanation": null
            }
        ],
        "constraints": [
            "0 <= s1.length, s2.length <= 100",
            "0 <= s3.length <= 200",
            "s1, s2, and s3 consist of lowercase English letters."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": " bool isInterleave(string s1, string s2, string s3) {\n    \n    if(s3.length() != s1.length() + s2.length())\n        return false;\n    \n    bool table[s1.length()+1][s2.length()+1];\n    \n    for(int i=0; i<s1.length()+1; i++)\n        for(int j=0; j< s2.length()+1; j++){\n            if(i==0 && j==0)\n                table[i][j] = true;\n            else if(i == 0)\n                table[i][j] = ( table[i][j-1] && s2[j-1] == s3[i+j-1]);\n            else if(j == 0)\n                table[i][j] = ( table[i-1][j] && s1[i-1] == s3[i+j-1]);\n            else\n                table[i][j] = (table[i-1][j] && s1[i-1] == s3[i+j-1] ) || (table[i][j-1] && s2[j-1] == s3[i+j-1] );\n        }\n        \n    return table[s1.length()][s2.length()];\n}",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/31879/my-dp-solution-in-c/",
                "vote_count": "522"
            },
            {
                "language": "csharp",
                "code": "",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/31879/my-dp-solution-in-c/",
                "vote_count": "522"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    // s1: abc\n    // s2: bcd\n    // good s3: abbccd, abcbcd, abcdbc, etc.. order of characters from s1 and s2 should remain unchanged\n    bool isInterleave(string s1, string s2, string s3) {\n        \n        if((s1.size() + s2.size()) != s3.size())\n- 1] == s3[i + j - 1]);",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/31879/my-dp-solution-in-c/",
                "vote_count": "522"
            },
            {
                "language": "csharp",
                "code": "bool isInterleave(string s1, string s2, string s3) {\n    int m = s1.length();\n    int n = s2.length();\n    int p = s3.length();\n    \n    if (m + n != p) return false;\n    ",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/31879/my-dp-solution-in-c/",
                "vote_count": "522"
            },
            {
                "language": "go",
                "code": "bool isInterleave(string s1, string s2, string s3) {\n    if (s3.size() != s1.size() + s2.size()) return false;\n\n    int m = (int) s1.size();\n    int n = (int) s2.size();\n    // dp[i][j] = the first i chars in s1, the first j chars in s2\n    // can or not can construct to the first (i+j) chars in s3\n    vector<vector<bool>> dp(m+1, vector<bool>(n+1, false));",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/31879/my-dp-solution-in-c/",
                "vote_count": "522"
            },
            {
                "language": "typescript",
                "code": "public class Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if (s1.length() + s2.length() != s3.length()) return false;\n        int n1 = s1.length(), n2 = s2.length();\n        boolean[][] dp = new boolean[n1 + 1][n2 + 1];\n        for (int i = 0; i <= n1; i++) {\n            for (int j = 0; j <= n2; j++) {\n                if (i == 0 && j == 0) { // s1 empty, s2 empty\n)) || (j > 0 && dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/31879/my-dp-solution-in-c/",
                "vote_count": "522"
            },
            {
                "language": "csharp",
                "code": "    bool isInterleave(string s1, string s2, string s3) {\n        memset(dp,0,sizeof(dp));\n        if(s1.length()+s2.length()!=s3.length())return false;\n        for(int i=s1.length()+1;i--;){\n            for(int j=s2.length()+1;j--;){\n                if(s1.length()==i && s2.length()==j){\n                    dp[i][j]=1;\n                }\n                else{",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/31879/my-dp-solution-in-c/",
                "vote_count": "522"
            },
            {
                "language": "csharp",
                "code": "# code block\nclass Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        bool f[s1.size()+1][s2.size()+1];\n        memset(f,false,sizeof(f));\n        f[0][0]=true;",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/31879/my-dp-solution-in-c/",
                "vote_count": "522"
            },
            {
                "language": "",
                "code": "o--a--o--b--o--c--o\n|     |     |     |\na     a     a     a\n|     |     |     |\no--a--o--b--o--c--o\n|     |     |     |\na     a     a     a\n|     |     |     |\no--a--o--b--o--c--o\n|     |     |     |\nb     b     b     b\n|     |     |     |\no--a--o--b--o--c--o",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/31948/8ms-c-solution-using-bfs-with-explanation/",
                "vote_count": "292"
            },
            {
                "language": "",
                "code": "x--a--x--b--o--c--o\n|     |     |     |\na     a     a     a\n|     |     |     |\no--a--x--b--o--c--o\n|     |     |     |\na     a     a     a\n|     |     |     |\no--a--x--b--x--c--x\n|     |     |     |\nb     b     b     b\n|     |     |     |\no--a--o--b--o--c--x",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/31948/8ms-c-solution-using-bfs-with-explanation/",
                "vote_count": "292"
            },
            {
                "language": "cpp",
                "code": "struct MyPoint {\n    int y, x; \n    bool operator==(const MyPoint &p) const {\n        return p.y == y && p.x == x;\n    }\n};\nnamespace std {\n    template <>\n    struct hash<MyPoint> {\n        size_t operator () (const MyPoint &f) const {\n            return (std::hash<int>()(f.x) << 1) ^ std::hash<int>()(f.y);\n        }\n    };\n}\n\nclass Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        if (s1.size() + s2.size() != s3.size()) return false;\n\n        queue<MyPoint> q;\n        unordered_set<MyPoint> visited;\n        bool isSuccessful = false;\n        int i = 0;\n\n        q.push(MyPoint { 0, 0 });\n        q.push(MyPoint { -1, -1 });\n        while (!(1 == q.size() && -1 == q.front().x)) {\n            auto p = q.front();\n            q.pop();\n            if (p.y == s1.size() && p.x == s2.size()) {\n                return true;\n            }\n            if (-1 == p.y) {\n                q.push(p);\n                i++;\n                continue;\n            }\n            if (visited.find(p) != visited.end()) { continue; }\n            visited.insert(p);\n\n            if (p.y < s1.size()) { // down\n                if (s1[p.y] == s3[i]) { q.push(MyPoint { p.y + 1, p.x }); }\n            }\n            if (p.x < s2.size()) { // right \n                if (s2[p.x] == s3[i]) { q.push(MyPoint { p.y, p.x + 1 }); }\n            }\n        }\n        return false;\n    }\n};",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/31948/8ms-c-solution-using-bfs-with-explanation/",
                "vote_count": "292"
            },
            {
                "language": "cpp",
                "code": "    public boolean isInterleave(String s1, String s2, String s3) {\n        if (s1.length() + s2.length() != s3.length()) return false;\n        boolean[][] visited = new boolean[s1.length() + 1][s2.length() + 1];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{0, 0});",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/31948/8ms-c-solution-using-bfs-with-explanation/",
                "vote_count": "292"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        // BFS version\n        int l1 = s1.size(), l2 = s2.size(), l3 = s3.size();\n        if (l1 + l2 != l3) return false;\n        \n        vector<vector<bool>> visited(l1 + 1, vector<bool>(l2 + 1, false));",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/31948/8ms-c-solution-using-bfs-with-explanation/",
                "vote_count": "292"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        typedef pair<int, int> index;\n        unordered_set<int> visited;\n        queue<index> q;\n        q.push(index(-1, -1));",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/31948/8ms-c-solution-using-bfs-with-explanation/",
                "vote_count": "292"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        // image we have a (m+1) X (n+1) matrix, with each vertical edge to be chars from s1; horizontal edge with chars from s3\n        // the problem equals: whether a path exist from topleft to bottomright\n        \n        int m = s1.length();\n        int n = s2.length();\n        if(s3.length() != m + n) return false;\n\n.x + 1) * (n + 1) + curt.y]) {\n.x * (n + 1) + curt.y + 1)]) {",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/31948/8ms-c-solution-using-bfs-with-explanation/",
                "vote_count": "292"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        def dfs(i, j):\n            if i == len(s1) and j == len(s2):\n                return True\n            choose_s1, choose_s2 = False, False\n            if i < len(s1) and s1[i] == s3[i + j]:\n                choose_s1 = dfs(i + 1, j)\n            if j < len(s2) and s2[j] == s3[i + j]:\n                choose_s2 = dfs(i, j + 1)\n\n            return choose_s1 or choose_s2\n\n        return dfs(0, 0)",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/2249509/python-simple-solution-w-explanation-recursion-dp/",
                "vote_count": "128"
            },
            {
                "language": "erlang",
                "code": "                                        \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n                  \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2528 0, 0 \u2520\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n                  \u2502                     \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u251b                      \u2502\n              \u250f\u2501\u2501\u2501\u2537\u2501\u2501\u2513                                             \u250f\u2501\u2501\u2537\u2501\u2501\u2501\u2513     \n      \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2528 1, 0 \u2520\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e                         \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2528 0, 1 \u2520\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e                 \n      \u2502       \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u251b         \u2502                         \u2502         \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u251b         \u2502 \n  \u250f\u2501\u2501\u2501\u2537\u2501\u2501\u2513                  \u250f\u2501\u2501\u2537\u2501\u2501\u2501\u2513                 \u250f\u2501\u2501\u2501\u2537\u2501\u2501\u2513                    \u250f\u2501\u2501\u2537\u2501\u2501\u2501\u2513  \n  \u2503 2, 0 \u2503                  \u2503 1, 1 \u2503                 \u2503 1, 1 \u2503                    \u2503 0, 2 \u2503 \n  \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u251b                  \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u251b                 \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u251b                    \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u251b   \n     .                         .                        .                           .\n     .                         .                        .                           .\n     .                         .                        .                           .",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/2249509/python-simple-solution-w-explanation-recursion-dp/",
                "vote_count": "128"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n        @cache\n        def dfs(i, j):\n            if i == len(s1) and j == len(s2):\n                return True\n            choose_s1, choose_s2 = False, False\n            if i < len(s1) and s1[i] == s3[i + j]:\n                choose_s1 = dfs(i + 1, j)\n            if j < len(s2) and s2[j] == s3[i + j]:\n                choose_s2 = dfs(i, j + 1)\n\n            return choose_s1 or choose_s2\n\n        return dfs(0, 0)",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/2249509/python-simple-solution-w-explanation-recursion-dp/",
                "vote_count": "128"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        m, n = len(s1), len(s2)\n        if m + n != len(s3):\n            return False\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        for i in range(1, m + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        for j in range(1, n + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                choose_s1, choose_s2 = False, False\n                if s1[i - 1] == s3[i + j - 1]:\n                    choose_s1 = dp[i - 1][j]\n                if s2[j - 1] == s3[i + j - 1]:\n                    choose_s2 = dp[i][j - 1]\n                dp[i][j] = choose_s1 or choose_s2\n\n        return dp[m][n]",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/2249509/python-simple-solution-w-explanation-recursion-dp/",
                "vote_count": "128"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        m, n = len(s1), len(s2)\n        if m + n != len(s3):\n            return False\n        if n > m:\n            m, n = n, m\n            s1, s2 = s2, s1\n        dp = [False] * (n + 1)\n        dp[0] = True\n        for j in range(1, n + 1):\n            dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\n        for i in range(1, m + 1):\n            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\n            for j in range(1, n + 1):\n                choose_s1, choose_s2 = False, False\n                if s1[i - 1] == s3[i + j - 1]:\n                    choose_s1 = dp[j]\n                if s2[j - 1] == s3[i + j - 1]:\n                    choose_s2 = dp[j - 1]\n                dp[j] = choose_s1 or choose_s2\n\n        return dp[-1]",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/2249509/python-simple-solution-w-explanation-recursion-dp/",
                "vote_count": "128"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        \n        d={}\n        m=len(s1)\n        n=len(s2)\n        if m==0:\n            return s2==s3",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/2249509/python-simple-solution-w-explanation-recursion-dp/",
                "vote_count": "128"
            },
            {
                "language": "rust",
                "code": "def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m = len(s1)\n    n = len(s2)\n    if m+n != len(s3): return False   \n    dp = [[False for j in range(n+1)] for i in range(m+1)]\n    dp[0][0] = True           \nin one loop\n == s3[i+j-1]):",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/2249509/python-simple-solution-w-explanation-recursion-dp/",
                "vote_count": "128"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    bool helper(string& s1, string& s2, string &s3, int l1, int l2, int l3) {\n        if(l1<0 && l2<0 && l3<0) {\n            return true;\n        }\n        if(l1>=0 && s1[l1]==s3[l3] && l2>=0 && s2[l2]==s3[l3] ) {\n            return (helper(s1, s2, s3, l1-1, l2, l3-1) || helper(s1, s2, s3, l1, l2-1, l3-1));\n        }\n        else if(l1>=0 && s1[l1]==s3[l3])\n            return helper(s1, s2, s3, l1-1, l2, l3-1);\n        \n        else if(l2>=0 &&s2[l2]==s3[l3])\n            return helper(s1, s2, s3, l1, l2-1, l3-1);\n        \n        else return false;\n    }\n    \n    bool isInterleave(string s1, string s2, string s3) {\n        if(s3.size() != s1.size() + s2.size())\n   return false;\n        return helper(s1, s2, s3,s1.size()-1, s2.size()-1, s3.size()-1);\n    }\n};",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/2248553/c-recursive-memoization-code-with-explanation/",
                "vote_count": "89"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    // int dp[102][102];\n    bool helper(string& s1, string& s2, string &s3, int l1, int l2, int l3, vector<vector<int>>&dp) {\n        if(l1<0 && l2<0 && l3<0) {\n            return true;\n        }\n        if(l1>=0 && l2>=0 && dp[l1][l2]!=-1) {\n            return dp[l1][l2];\n        }\n        if(l1>=0 && s1[l1]==s3[l3] && l2>=0 && s2[l2]==s3[l3] ) {\n            return dp[l1][l2] = (helper(s1, s2, s3, l1-1, l2, l3-1, dp) || helper(s1, s2, s3, l1, l2-1, l3-1, dp));\n        }\n        else if(l1>=0 && s1[l1]==s3[l3])\n            return helper(s1, s2, s3, l1-1, l2, l3-1, dp);\n        \n        else if(l2>=0 &&s2[l2]==s3[l3])\n            return helper(s1, s2, s3, l1, l2-1, l3-1, dp);\n        \n        else return false;\n    }\n    \n    bool isInterleave(string s1, string s2, string s3) {\n        if(s3.size() != s1.size() + s2.size())\n   return false;\n        vector<vector<int>>dp(s1.size()+1, (vector<int>(s2.size()+1, -1)));\n        // memset(dp, -1, sizeof(dp));\n        return helper(s1, s2, s3,s1.size()-1, s2.size()-1, s3.size()-1, dp);\n    }\n};",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/2248553/c-recursive-memoization-code-with-explanation/",
                "vote_count": "89"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3): return False\n        m, n = len(s1), len(s2)\n        \n        @lru_cache(None)\n        def dp(i, j):\n            if i == m and j == n: return True  # Found a valid match\n            ans = False\n            if i < m and s1[i] == s3[i+j]:  # Case match s1[i] with s3[i+j]\n                ans |= dp(i + 1, j)\n            if j < n and s2[j] == s3[i+j]:  # Case match s2[j] with s3[i+j]\n                ans |= dp(i, j + 1)\n            return ans\n\n        return dp(0, 0)",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/1247494/python-3-from-top-down-to-bottom-up-2d-to-1d-space/",
                "vote_count": "81"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3): return False\n\n        m, n = len(s1), len(s2)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[m][n] = True\n        for i in range(m, -1, -1):\n            for j in range(n, -1, -1):\n                if i < m and s1[i] == s3[i + j]:\n                    dp[i][j] |= dp[i + 1][j]\n                if j < n and s2[j] == s3[i + j]:\n                    dp[i][j] |= dp[i][j + 1]\n        return dp[0][0]",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/1247494/python-3-from-top-down-to-bottom-up-2d-to-1d-space/",
                "vote_count": "81"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3): return False\n\n        m, n = len(s1), len(s2)\n        dp, dpPrev = [False] * (n + 1), [False] * (n + 1)\n        for i in range(m, -1, -1):\n            for j in range(n, -1, -1):\n                dp[j] = False\n                if i == m and j == n:\n                    dp[n] = True\n                if i < m and s1[i] == s3[i + j]:\n                    dp[j] |= dpPrev[j]\n                if j < n and s2[j] == s3[i + j]:\n                    dp[j] |= dp[j + 1]\n            dp, dpPrev = dpPrev, dp\n        return dpPrev[0]",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/1247494/python-3-from-top-down-to-bottom-up-2d-to-1d-space/",
                "vote_count": "81"
            },
            {
                "language": "rust",
                "code": "def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m,n=len(s1),len(s2)\n    if m+n!=len(s3):\n        return False\n    table=[[0 for i in range(n+1)] for j in range(m+1)]\n    def dp(i,j):\n        if table[i][j]!=0:\n            return True if table[i][j]==1 else False\n        if i==m and j==n:",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/1247494/python-3-from-top-down-to-bottom-up-2d-to-1d-space/",
                "vote_count": "81"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool dfs(int index, int l, int r, int turn, string &s1, string &s2, string &s3, vector<vector<vector<int>>> &dp){\n        if(index == s3.size()){\n            if(l == s1.size() && r == s2.size()) return true;\n            return false;\n        }\n        //cout << index << \",\" << l << \",\" << r << \" \" << turn << \"\\n\";",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/1247494/python-3-from-top-down-to-bottom-up-2d-to-1d-space/",
                "vote_count": "81"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def isInterleave(self, s1, s2, s3):\n        @lru_cache(None)\n        def dp(i, j):\n            if i == -1 and j == -1: return True\n            return (j >= 0 and s2[j] == s3[i+j+1] and dp(i, j-1)) or (i >= 0 and s1[i] == s3[i+j+1] and dp(i-1,j))\n        \n        return len(s1) + len(s2) == len(s3) and dp(len(s1) - 1, len(s2) - 1)",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/1246649/python-3-lines-dp-explained/",
                "vote_count": "53"
            },
            {
                "language": "java",
                "code": "def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    @cache\n    def match(i1, i2):\n        if i1 == n1 and i2 == n2: return True\n        return i1 < n1 and s1[i1] == s3[i1 + i2] and match(i1 + 1, i2) or i2 < n2 and s2[i2] == s3[i1 + i2] and match(i1, i2 + 1)\n\n    n1, n2 = len(s1), len(s2)\n    return n1 + n2 == len(s3) and match(0, 0)",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/1246649/python-3-lines-dp-explained/",
                "vote_count": "53"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        # dp(i, j): if s1[:i] and s2[:j] can form the s3[:i+j]\n       \n        @cache\n        def dfs(i, j):\n            if not i and not j:\n                return True",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/1246649/python-3-lines-dp-explained/",
                "vote_count": "53"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n  if (s1.length() + s2.length() != s3.length()) return false;\n  if (s1.length() < s2.length()) swap(s1, s2);\n  int m = s1.length(), n = s2.length();\n   \n        vector<bool> dp(n + 1, false);\n        dp[0] = true;\n        for (int j = 1; j <= n; j++) {\n            dp[j] = s3[j - 1] == s2[j - 1] && dp[j - 1];\n        }\n\n        for (int i = 1; i <= m; i++) {\n            dp[0] = s3[i - 1] == s1[i - 1] && dp[0];\n            for (int j = 1; j <= n; j++) {\n                dp[j] = (s3[i + j - 1] == s1[i - 1] && dp[j]);\n                dp[j] = dp[j] || (s3[i + j - 1] == s2[j - 1] && dp[j - 1]);\n            }\n        }\n        return dp.back();\n    }\n};",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/2248648/o-mn-dp-using-one-array-of-size-s2-length-python-c/",
                "vote_count": "16"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n        if len(s1) < len(s2):\n            s1, s2 = s2, s1\n        m, n = len(s1), len(s2)\n        \n        dp = [True] + [False] * n\n        for j in range(1, n + 1):\n            dp[j] = s2[j - 1] == s3[j - 1] and dp[j - 1]\n\n        for i in range(1, m + 1):\n            dp[0] = s1[i - 1] == s3[i - 1] and dp[0]\n            for j in range(1, n + 1):\n                dp[j] = (s1[i - 1] == s3[i + j - 1] and dp[j])\n                dp[j] = dp[j] or (s2[j - 1] == s3[i + j - 1] and dp[j - 1])\n        return dp[-1]",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/2248648/o-mn-dp-using-one-array-of-size-s2-length-python-c/",
                "vote_count": "16"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n  public:\n    int dp[102][102];\n  bool solve(string s1, string s2, string s3, int x, int y, int z) {\n    if (x < 0 and y < 0 and z < 0) return true;\n    if (x >= 0 and y >= 0 and dp[x][y] != -1) return dp[x][y];\n    if (x >= 0 and s1[x] == s3[z] and y >= 0 and s2[y] == s3[z])\n      return dp[x][y] = solve(s1, s2, s3, x - 1, y, z - 1) or solve(s1, s2, s3, x, y - 1, z - 1);\n    else if (x >= 0 and s1[x] == s3[z])\n      return solve(s1, s2, s3, x - 1, y, z - 1);\n    else if (y >= 0 and s2[y] == s3[z])\n      return solve(s1, s2, s3, x, y - 1, z - 1);\n    else\n      return false;\n  }\n  bool isInterleave(string s1, string s2, string s3) {\n    memset(dp, -1, sizeof(dp));\n    int x = s1.size(), y = s2.size(), z = s3.size();\n    if (x + y != z) return false;\n    return solve(s1, s2, s3, x - 1, y - 1, z - 1);\n  }\n};",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/2249641/c-based-on-aditya-verma-concept-recursion-memoization/",
                "vote_count": "13"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3): return False\n        @lru_cache(maxsize = None)\n        def dfs(p1,p2,p3):\n            if p1 == len(s1) and p2 == len(s2) and p3 == len(s3): return True\n            if p1 < len(s1) and s1[p1] == s3[p3] and dfs(p1+1,p2,p3+1): return True\n            if p2 < len(s2) and s2[p2] == s3[p3] and dfs(p1,p2+1,p3+1): return True\n            return False\n        return dfs(0,0,0)",
                "url": "https://leetcode.com/problems/interleaving-string/solutions/2250282/simple-top-down-memoization-with-explanation/",
                "vote_count": "11"
            }
        ]
    },
    "97": {
        "question_id": 98,
        "title": "Validate Binary Search Tree",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/validate-binary-search-tree",
        "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).A valid BST is defined as follows:The left subtree of a node contains only nodes with keys less than the node's key.The right subtree of a node contains only nodes with keys greater than the node's key.Both the left and right subtrees must also be binary search trees. ",
        "examples": [
            {
                "input": "root = [2,1,3]",
                "output": "true",
                "explanation": null
            },
            {
                "input": "root = [5,1,4,null,null,3,6]",
                "output": "false",
                "explanation": "The root node's value is 5 but its right child's value is 4."
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [1, 10^4].",
            "-2^31 <= Node.val <= 2^31 - 1"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "public List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> list = new ArrayList<>();\n    if(root == null) return list;\n    Stack<TreeNode> stack = new Stack<>();\n    while(root != null || !stack.empty()){\n        while(root != null){\n            stack.push(root);\n            root = root.left;\n        }\n        root = stack.pop();\n        list.add(root.val);\n        root = root.right;\n        \n    }\n    return list;\n}",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/32112/learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-java-solution/",
                "vote_count": "3436"
            },
            {
                "language": "cpp",
                "code": " public int kthSmallest(TreeNode root, int k) {\n     Stack<TreeNode> stack = new Stack<>();\n     while(root != null || !stack.isEmpty()) {\n         while(root != null) {\n             stack.push(root);    \n             root = root.left;   \n         } \n         root = stack.pop();\n         if(--k == 0) break;\n         root = root.right;\n     }\n     return root.val;\n }",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/32112/learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-java-solution/",
                "vote_count": "3436"
            },
            {
                "language": "kotlin",
                "code": "public boolean isValidBST(TreeNode root) {\n   if (root == null) return true;\n   Stack<TreeNode> stack = new Stack<>();\n   TreeNode pre = null;\n   while (root != null || !stack.isEmpty()) {\n      while (root != null) {\n         stack.push(root);\n         root = root.left;\n      }\n      root = stack.pop();\n      if(pre != null && root.val <= pre.val) return false;\n      pre = root;\n      root = root.right;\n   }\n   return true;\n}",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/32112/learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-java-solution/",
                "vote_count": "3436"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n   public boolean isValidBST(TreeNode root) {\n        if(root == null) return true;\n        Deque<TreeNode> stack = new LinkedList<>();\n        TreeNode prev = null;\n        boolean onRightSideOfPrev = false;\n        while(root != null || !stack.isEmpty()) {\n&& prev.val >= root.val))) {",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/32112/learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-java-solution/",
                "vote_count": "3436"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    TreeNode prev;\n        \n    public boolean isValidBST(TreeNode root) {\n        if (root == null)\n            return true;\n        \n        if(!isValidBST(root.left))",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/32112/learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-java-solution/",
                "vote_count": "3436"
            },
            {
                "language": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/32112/learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-java-solution/",
                "vote_count": "3436"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    private boolean isValid = true;\n    private TreeNode pre = null;\n    public boolean isValidBST(TreeNode root) {\n        helper(root);\n        return isValid;\n    }\n    ",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/32112/learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-java-solution/",
                "vote_count": "3436"
            },
            {
                "language": "kotlin",
                "code": " bool isValidBST(TreeNode* root, TreeNode* min=NULL, TreeNode* max=NULL) {\n        if (!root) return true;\n        if (min != NULL && root->val <= min->val) return false;\n        if (max != NULL && root->val >= max->val) return false;\n        return isValidBST(root->left, min, root) && isValidBST(root->right, root, max);\n    }",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/32112/learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-java-solution/",
                "vote_count": "3436"
            },
            {
                "language": "kotlin",
                "code": "    Stack<TreeNode> sTree = new Stack<>();\n    \n    TreeNode curr = null;\n        TreeNode pre = null;\n    curr=root;",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/32112/learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-java-solution/",
                "vote_count": "3436"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public boolean isValidBST(TreeNode root) {\n        if(root == null) {\n            return true;\n        }\n        Stack<TreeNode> stack = new Stack<>();\n        stack.push(root);\n        while(!stack.isEmpty()) {",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/32112/learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-java-solution/",
                "vote_count": "3436"
            },
            {
                "language": "kotlin",
                "code": "public class Solution {\n    public boolean isValidBST(TreeNode root) {\n        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n    \n    public boolean isValidBST(TreeNode root, long minVal, long maxVal) {\n        if (root == null) return true;\n        if (root.val >= maxVal || root.val <= minVal) return false;\n        return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);\n    }\n}",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/32109/my-simple-java-solution-in-3-lines/",
                "vote_count": "954"
            },
            {
                "language": "kotlin",
                "code": "private boolean help(TreeNode p, Integer low, Integer high) {\n    if (p == null) return true;\n    return (low == null || p.val > low) && (high == null || p.val < high) && help(p.left, low, p.val) && help(p.right, p.val, high);\n}\n\npublic boolean isValidBST(TreeNode root) {\n    return help(root, null, null);",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/32109/my-simple-java-solution-in-3-lines/",
                "vote_count": "954"
            },
            {
                "language": "kotlin",
                "code": "    public boolean isValidBST(TreeNode root) {        \n        return helper(root, null, null);   \n    }\n    \n    private boolean helper(TreeNode root, TreeNode min, TreeNode max) {",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/32109/my-simple-java-solution-in-3-lines/",
                "vote_count": "954"
            },
            {
                "language": "kotlin",
                "code": "public boolean isValidBST(TreeNode root) {\n        return backtrack(root, null, null);\n    }\n    private boolean backtrack(TreeNode root, Integer low, Integer high){\n        if(root == null) return true;\n        if(low != null && root.val <= low || high != null && root.val >= high) return false;\n        return backtrack(root.left,low,root.val) && backtrack(root.right,root.val,high);",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/32109/my-simple-java-solution-in-3-lines/",
                "vote_count": "954"
            },
            {
                "language": "kotlin",
                "code": "public class Solution {\n    public boolean isValidBST(TreeNode root) {\n        return isValidBST(root, null, null);\n    }\n    \n    private boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {\n        if (root == null) return true;\n        return (min == null || root.val > min.val) && (max == null || root.val < max.val)",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/32109/my-simple-java-solution-in-3-lines/",
                "vote_count": "954"
            },
            {
                "language": "kotlin",
                "code": "import java.util.Optional;\n\npublic class Solution {\n    public boolean isValidBST(TreeNode root) {\n        return isValidBST(root, Optional.empty(), Optional.empty());\n    }\n    \n    private boolean isValidBST(TreeNode node, Optional<Integer> min, Optional<Integer> max) {\n())) {",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/32109/my-simple-java-solution-in-3-lines/",
                "vote_count": "954"
            },
            {
                "language": "kotlin",
                "code": "    public boolean isValidBST(TreeNode node) {\n        return isValid(node, null, null);\n    }\n    \n    private boolean isValid(TreeNode n, Integer min, Integer max) {\n        return  (n == null) ||\n                (min == null || n.val > min) && (max == null || n.val < max) &&\n                isValid(n.left , min , n.val) && isValid(n.right, n.val, max);",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/32109/my-simple-java-solution-in-3-lines/",
                "vote_count": "954"
            },
            {
                "language": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        output =[]\n        self.inorder(root, output)\n        \n        for i in range(1, len(output)):\n   if output[i-1]>= output[i]:\n    return False\n        \n        return True\n    \n    # Time complexity of inorder traversal is O(n)\n    # Fun fact: Inorder traversal leads to a sorted array if it is \n    # a Valid Binary Search. Tree.\n    def inorder(self, root, output):\n        if root is None:\n            return\n        \n        self.inorder(root.left, output)\n        output.append(root.val)\n        self.inorder(root.right, output)\n        ",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/786520/general-tree-traversal-problems-interview-prep/",
                "vote_count": "369"
            },
            {
                "language": "python",
                "code": "# Recursive: runtime-16ms\n\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        output = []\n        self.inorder(root, output)\n        return output\n        \n    def inorder(self, root, output):\n        if root is None:\n            return\n        \n        self.inorder(root.left, output)\n        output.append(root.val)\n        self.inorder(root.right, output)\n\n\n# Iterative Runtime: 20 ms, faster than 70.13%\n\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        output = []\n        stack=[]\n        \n        while stack or root:\n            \n            if root:\n                stack.append(root)\n                root =root.left\n                \n            else:\n                temp =stack.pop()\n                output.append(temp.val)\n                root= temp.right\n           \n        return output",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/786520/general-tree-traversal-problems-interview-prep/",
                "vote_count": "369"
            },
            {
                "language": "python",
                "code": "## Recursive Solution: Runtime: 36 ms, faster than 97.16%\n\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\nclass Solution(object):\n    def preorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        \n        output =[]\n        \n        # perform dfs on the root and get the output stack\n        self.dfs(root, output)\n        \n        # return the output of all the nodes.\n        return output\n    \n    def dfs(self, root, output):\n        \n        # If root is none return \n        if root is None:\n            return\n        \n        # for preorder we first add the root val\n        output.append(root.val)\n        \n        # Then add all the children to the output\n        for child in root.children:\n            self.dfs(child, output)\n       \n    \n    \n# Iterative Solution- Runtime: 40 ms, faster than 91.86% \n\n\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution(object):\n    def preorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if root is None:\n            return []\n        \n        stack = [root]\n        output = []\n        \n        # Till there is element in stack the loop runs.\n        while stack:\n            \n            #pop the last element from the stack and store it into temp.\n            temp = stack.pop()\n            \n            # append. the value of temp to output\n            output.append(temp.val)\n            \n            #add the children of the temp into the stack in reverse order.\n            # children of 1 = [3,2,4], if not reveresed then 4 will be popped out first from the stack.\n            # if reversed then stack = [4,2,3]. Here 3 will pop out first.\n            # This continues till the stack is empty.\n            stack.extend(temp.children[::-1])\n        \n        #return the output\n        return output\n        ",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/786520/general-tree-traversal-problems-interview-prep/",
                "vote_count": "369"
            },
            {
                "language": "python",
                "code": "# Recursive solution\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        output =[]\n        self.dfs(root, output)\n        return output\n    \n    def dfs(self, root, output):\n        if root is None:\n            return\n        \n        output.append(root.val)\n        self.dfs(root.left, output)\n        self.dfs(root.right, output)\n       \n    \n# Iterative Solution- Runtime: 12 ms, faster than 97.82%\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        output =[]\n        stack = [root]\n        \n        while stack:\n            temp=stack.pop()\n            if temp:\n                output.append(temp.val)\n                stack.append(temp.right)\n                stack.append(temp.left)\n        \n        return output",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/786520/general-tree-traversal-problems-interview-prep/",
                "vote_count": "369"
            },
            {
                "language": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        if root is None:\n            return []\n        \n        result = []\n        self.dfs(root, \"\", result)\n        return result\n\n    def dfs(self, root, path, result):\n        if not root.left and not root.right:\n            result.append(path + str(root.val))\n        \n        if root.left:\n            self.dfs(root.left, path + str(root.val) + \"->\" , result)\n        if root.right:\n            self.dfs(root.right, path + str(root.val) + \"->\", result)\n        ",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/786520/general-tree-traversal-problems-interview-prep/",
                "vote_count": "369"
            },
            {
                "language": "python",
                "code": "# Recursive : Runtime: 40 ms, faster than 89.79% \n\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution(object):\n    def postorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        output =[]\n        self.dfs(root, output)\n        return output\n    \n    def dfs(self, root, output):\n        if root is None:\n            return\n        for child in root.children:\n            self.dfs(child, output)\n        \n        output.append(root.val)\n \n \n # Iterative Solution: Runtime: 48 ms, faster than 62.81%\n \n `\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution(object):\n    def postorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        output =[]\n        stack = [root]\n        \n        while stack:\n            root = stack.pop()\n            if root:\n                output.append(root.val)\n                stack += root.children\n                \n        return output[::-1]`\n        ",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/786520/general-tree-traversal-problems-interview-prep/",
                "vote_count": "369"
            },
            {
                "language": "python",
                "code": "# Recursive solution\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        output = []\n        self.dfs(root, output)\n        return output\n    \n    def dfs(self, root, output):\n        if root is None:\n            return\n        self.dfs(root.left, output)\n        self.dfs(root.right, output) \n        output.append(root.val)\n  \n  \n# Iterative solution: Runtime: 12 ms, faster than 98.10%\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        output = []\n        stack =[root]\n        \n        if not root:\n            return None\n        \n        # iterate only when there is elements inside the stack.\n        while stack:\n            \n            # pop the element from stack and stored it into temp\n            temp=stack.pop()\n            \n            #append the value of temp to output\n            output.append(temp.val)\n            \n            #Now traverse through left node and add the node to stack\n            if temp.left:\n                stack.append(temp.left)\n                \n            #else traverse through right node and add to stack\n            if temp.right:\n                stack.append(temp.right)\n         \n        # After iterating through the stack,  print the result in reverse order.  \n        return output[::-1]\n    \n    \n# Example: Iteration 1 : #stack=[1] - first iteration, temp =1, \n                #output[1]\n                #temp.left is Null\n                #temp.right is [2]\n                # stack =[2]",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/786520/general-tree-traversal-problems-interview-prep/",
                "vote_count": "369"
            },
            {
                "language": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        output =[]\n        self.dfs(root, 0, output)\n        return output\n    \n    def dfs(self, root, level, output):\n        \n        if not root:\n            return\n        \n        if len(output) < level+1:\n            output.append([])\n            \n        output[level].append(root.val)    \n        self.dfs(root.left, level+1, output)\n        self.dfs(root.right, level+1, output)\n        ",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/786520/general-tree-traversal-problems-interview-prep/",
                "vote_count": "369"
            },
            {
                "language": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        output = []\n        self.dfs(root, 0, output)\n        return output[::-1]\n    \n    def dfs(self, root, level, output):\n        if root is None:\n             return\n            \n        if len(output) < level+1:\n            output.append([])\n            \n        output[level].append(root.val)\n        self.dfs(root.left, level+1, output)\n        self.dfs(root.right, level+1, output)",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/786520/general-tree-traversal-problems-interview-prep/",
                "vote_count": "369"
            },
            {
                "language": "python",
                "code": "\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[List[int]]\n        \"\"\"\n        output=[]\n        self.dfs(root, 0, output)\n        return output\n    \n    def dfs(self, root, level ,output):\n        if root is None:\n            return\n        if len(output)< level+1:\n            output.append([])\n        \n        output[level].append(root.val)\n        for child in root.children:\n            self.dfs(child, level+1, output)\n      ",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/786520/general-tree-traversal-problems-interview-prep/",
                "vote_count": "369"
            },
            {
                "language": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        output=[]\n        self.dfs(root, 0, output)\n        \n        for i in range(len(output)):\n            if i % 2 !=0:\n                output[i].reverse()\n            else:\n                continue\n        return output\n    \n    def dfs(self, root, level, output):\n        if root is None:\n            return\n        \n        if len(output) < level+1:\n            output.append([])\n        \n        output[level].append(root.val)\n        self.dfs(root.left, level+1, output)\n        self.dfs(root.right, level+1, output)\n        ",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/786520/general-tree-traversal-problems-interview-prep/",
                "vote_count": "369"
            },
            {
                "language": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not preorder:\n            return None\n        \n        #pattern is preorder=[root, left, right]\n        #inorder = [left, root, right],  so find index and value using root.\n        \n        root = TreeNode(preorder[0])\n        \n        root_index= 0\n        \n        #iterate through inorder list and find the list index of the root.\n        for i in range(len(inorder)):\n            if inorder[i]== root.val:\n                root_index = i\n            else:\n                continue\n                \n        #slice the inorder list into left and right.     \n        left_inorder = inorder[:root_index]\n        right_inorder = inorder[root_index+1:]\n        \n        #slice the preorder list into left and right.\n        left_preorder = preorder[1:len(left_inorder)+1]\n        right_preorder = preorder[len(left_preorder)+1:]\n        \n        #append by updating preorder and inorder lists\n        root.left = self.buildTree(left_preorder, left_inorder)\n        root.right = self.buildTree(right_preorder, right_inorder)\n        \n        return root",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/786520/general-tree-traversal-problems-interview-prep/",
                "vote_count": "369"
            },
            {
                "language": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        # PATTERN\n        # inorder: l, root, right\n        # postorder: l,r,root\n        # the last element of postorder is root\n        \n        if not inorder or not postorder:\n            return None\n        \n        root_index=0\n        \n        # Build the data structure based on root value\n        root = TreeNode(postorder.pop())\n        \n        for i in range(len(inorder)):\n            if inorder[i]==root.val:\n                root_index=i\n            else:\n                continue\n        \n        left_in=inorder[:root_index]\n        right_in = inorder[root_index+1:]\n        \n        root.right = self.buildTree(right_in, postorder)\n        root.left = self.buildTree(left_in,  postorder)\n\n        return root\n   ",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/786520/general-tree-traversal-problems-interview-prep/",
                "vote_count": "369"
            },
            {
                "language": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def constructFromPrePost(self, pre, post):\n        \"\"\"\n        :type pre: List[int]\n        :type post: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        if not pre:\n            return None\n        \n        root = TreeNode(post.pop())\n        \n        if len(pre) == 1:\n            return root\n        \n        # Find the index of the root value from pre\n        for i in range(len(pre)):\n            if pre[i]==post[-1]:\n                root_index= i\n            else:\n                continue\n        \n        root.right = self.constructFromPrePost(pre[root_index:], post) \n        root.left = self.constructFromPrePost(pre[1:root_index],post) \n        \n        return root \n   \n# Explanation:   root=1, root_index = 0, root.right=(pre(1,2,3,4,5,6,7))  [1, 2,3,4,5,6,7]                           vii\n         # root = 3, root_index= 4, root.right=(pre(3,6,7))  [3,4,5,6,7]                               v\n           # root=7, root_index=2, root.right= pre(7), now len(pre) == 1, return 7 ---[7]        i\n           # root =6, root_index=1, root.left= pre(6), now len(pre)==1, return 6 -----[6,7]      ii \n\n         # root =2, root_index= 1, root.right= pre(2,4,5)   [2,3,4,5,6,7]                               vi \n           # root = 5, root_index=2, root.right= pre(5)  now len(pre)==1, return 5 ----[5,6,7]   iii\n           # root = 4, root_index=1, root.right= pre(4)  now len(pre)==1, return 4-----[4,5,6,7]  iv",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/786520/general-tree-traversal-problems-interview-prep/",
                "vote_count": "369"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isValidBST(self, node: Optional[TreeNode],low=-inf, high=inf) -> bool:\n            return (not node) or ((low < node.val < high) and self.isValidBST(node.left, low, node.val)  and self.isValidBST(node.right, node.val, high))",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/2409071/python-one-liner-96-6-with-detailed-explantion-recursion-simple/",
                "vote_count": "70"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        \n        def helper(node, low, high):\n            if not node:\n                return True\n            if not (low < node.val < high):\n                return False\n            return helper(node.left, low, node.val) and helper(node.right, node.val, high)\n        \n        return helper(root, -inf, inf)",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/2409071/python-one-liner-96-6-with-detailed-explantion-recursion-simple/",
                "vote_count": "70"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\nvector<int> numbers;//declare it globally, it contains the inorder traversal of BST\n\nvoid inorderpush(TreeNode* root){\n    if(root==nullptr){\n        return;\n    }\n    inorderpush(root->left);\n    numbers.push_back(root->val);//inserts the element in array\n    inorderpush(root->right);\n}\n\nbool isValidBST(TreeNode* root) {\n    inorderpush(root);\n\n    for(int i=0;i<numbers.size()-1;i++){\n        if(numbers[i+1]<=numbers[i]){\n            return false;//if array is not strictly increasing\n        }\n    }\n    return true; //if array is strictly increasing   \n    }\n};",
                "url": "https://leetcode.com/problems/validate-binary-search-tree/solutions/3053617/c-inorder-ascending-order/",
                "vote_count": "23"
            }
        ]
    },
    "98": {
        "question_id": 99,
        "title": "Recover Binary Search Tree",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/recover-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure. ",
        "examples": [
            {
                "input": "root = [1,3,null,null,2]",
                "output": "[3,1,null,null,2]",
                "explanation": "3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid."
            },
            {
                "input": "root = [3,1,4,null,null,2]",
                "output": "[2,1,4,null,null,3]",
                "explanation": "2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid."
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [2, 1000].",
            "-2^31 <= Node.val <= 2^31 - 1"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "private void traverse (TreeNode root) {\n   if (root == null)\n      return;\n   traverse(root.left);\n   // Do some business\n   traverse(root.right);\n}",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/32535/no-fancy-algorithm-just-simple-and-powerful-in-order-traversal/",
                "vote_count": "1849"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    \n    TreeNode firstElement = null;\n    TreeNode secondElement = null;\n    // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized\n    TreeNode prevElement = new TreeNode(Integer.MIN_VALUE);\n    \n    public void recoverTree(TreeNode root) {\n        \n        // In order traversal to find the two elements\n        traverse(root);\n        \n        // Swap the values of the two nodes\n        int temp = firstElement.val;\n        firstElement.val = secondElement.val;\n        secondElement.val = temp;\n    }\n    \n    private void traverse(TreeNode root) {\n        \n        if (root == null)\n            return;\n            \n        traverse(root.left);\n        \n        // Start of \"do some business\", \n        // If first element has not been found, assign it to prevElement (refer to 6 in the example above)\n        if (firstElement == null && prevElement.val >= root.val) {\n            firstElement = prevElement;\n        }\n    \n        // If first element is found, assign the second element to the root (refer to 2 in the example above)\n        if (firstElement != null && prevElement.val >= root.val) {\n            secondElement = root;\n        }        \n        prevElement = root;\n\n        // End of \"do some business\"\n\n        traverse(root.right);\n}",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/32535/no-fancy-algorithm-just-simple-and-powerful-in-order-traversal/",
                "vote_count": "1849"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    private TreeNode first;\n    private TreeNode second;\n    private TreeNode pre;\n    public void recoverTree(TreeNode root) {\n        if(root==null) return;\n        first = null;",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/32535/no-fancy-algorithm-just-simple-and-powerful-in-order-traversal/",
                "vote_count": "1849"
            },
            {
                "language": "kotlin",
                "code": "",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/32535/no-fancy-algorithm-just-simple-and-powerful-in-order-traversal/",
                "vote_count": "1849"
            },
            {
                "language": "csharp",
                "code": "public void morrisTraversal(TreeNode root){\n  TreeNode temp = null;\n  while(root!=null){\n   if(root.left!=null){\n    // connect threading for root\n    temp = root.left;\n    while(temp.right!=null && temp.right != root)\n     temp = temp.right;\n    // the threading already exists\n    if(temp.right!=null){\n     temp.right = null;\n     System.out.println(root.val);\n     root = root.right;\n    }else{\n     // construct the threading\n     temp.right = root;\n     root = root.left;\n    }\n   }else{\n    System.out.println(root.val);\n    root = root.right;\n   }\n  }\n }",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/32559/detail-explain-about-how-morris-traversal-finds-two-incorrect-pointer/",
                "vote_count": "353"
            },
            {
                "language": "scala",
                "code": "    if(pre!=null && pre.val > root.val){\n     if(first==null){first = pre;second = root;}\n     else{second = root;}\n  }\npre = root;",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/32559/detail-explain-about-how-morris-traversal-finds-two-incorrect-pointer/",
                "vote_count": "353"
            },
            {
                "language": "kotlin",
                "code": "public void recoverTree(TreeNode root) {\n        TreeNode pre = null;\n        TreeNode first = null, second = null;\n        // Morris Traversal\n        TreeNode temp = null;\n  while(root!=null){\n   if(root.left!=null){\n    // connect threading for root\n    temp = root.left;\n    while(temp.right!=null && temp.right != root)\n     temp = temp.right;\n    // the threading already exists\n    if(temp.right!=null){\n        if(pre!=null && pre.val > root.val){\n            if(first==null){first = pre;second = root;}\n            else{second = root;}\n        }\n        pre = root;\n        \n     temp.right = null;\n     root = root.right;\n    }else{\n     // construct the threading\n     temp.right = root;\n     root = root.left;\n    }\n   }else{\n    if(pre!=null && pre.val > root.val){\n        if(first==null){first = pre;second = root;}\n        else{second = root;}\n    }\n    pre = root;\n    root = root.right;\n   }\n  }\n  // swap two node values;\n  if(first!= null && second != null){\n      int t = first.val;\n      first.val = second.val;\n      second.val = t;\n  }\n    }",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/32559/detail-explain-about-how-morris-traversal-finds-two-incorrect-pointer/",
                "vote_count": "353"
            },
            {
                "language": "javascript",
                "code": "if(first == null) {first = pre; second = root;}\nelse {second = root;} ",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/32559/detail-explain-about-how-morris-traversal-finds-two-incorrect-pointer/",
                "vote_count": "353"
            },
            {
                "language": "javascript",
                "code": "if(first==null) first = pre;",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/32559/detail-explain-about-how-morris-traversal-finds-two-incorrect-pointer/",
                "vote_count": "353"
            },
            {
                "language": "python",
                "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/32559/detail-explain-about-how-morris-traversal-finds-two-incorrect-pointer/",
                "vote_count": "353"
            },
            {
                "language": "rust",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/32559/detail-explain-about-how-morris-traversal-finds-two-incorrect-pointer/",
                "vote_count": "353"
            },
            {
                "language": "java",
                "code": "public class Solution {\n\n TreeNode start = null;\n TreeNode end = null;\n TreeNode prev = null;\n\n public void recoverTree(TreeNode root) {\n  prev = new TreeNode(Integer.MIN_VALUE);",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/32559/detail-explain-about-how-morris-traversal-finds-two-incorrect-pointer/",
                "vote_count": "353"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    TreeNode prev=null,first=null,second=null;\n    void inorder(TreeNode root){\n        if(root==null)\n            return ;\n        inorder(root.left);\n        if(prev!=null&&root.val<prev.val){\n            if(first==null)\n                first=prev;\n            second=root;\n        }\n        prev=root;\n        inorder(root.right);\n    }\n    public void recoverTree(TreeNode root) {\n        if(root==null)\n            return ; \n        inorder(root);\n        int temp=first.val;\n        first.val=second.val;\n        second.val=temp;\n    }\n}",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/1962981/idea-inorder-traversal-easy-to-understand/",
                "vote_count": "216"
            },
            {
                "language": "cpp",
                "code": "TreeNode* prev=NULL, *first=NULL,*second=NULL;\nvoid utility (TreeNode* root)\n{\n   if(root==NULL) return;\n\n   utility(root->left);\n   if(prev!=NULL && root->val<prev->val)",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/1962981/idea-inorder-traversal-easy-to-understand/",
                "vote_count": "216"
            },
            {
                "language": "",
                "code": "   5\n  /   \\\n6     8\n  /\n  4",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/1962281/c-easy-to-understand/",
                "vote_count": "85"
            },
            {
                "language": "",
                "code": "   5\n  /   \\\n4     8\n  /\n  6",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/1962281/c-easy-to-understand/",
                "vote_count": "85"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n TreeNode* firstMistake, *secondMistake, *pre;\n void recoverTree(TreeNode* root) {\n  pre = new TreeNode(INT_MIN);\n  inorder(root);\n  swap(firstMistake->val, secondMistake->val);\n }\n\n void inorder(TreeNode* root) {\n  if(root == nullptr) \n   return;\n\n  inorder(root->left);\n\n  if(firstMistake == nullptr && root->val < pre->val)\n   firstMistake = pre;\n  if(firstMistake != nullptr && root->val < pre->val)\n   secondMistake = root;\n  pre = root;\n\n  inorder(root->right);\n }\n};",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/1962281/c-easy-to-understand/",
                "vote_count": "85"
            },
            {
                "language": "",
                "code": "   5\n  /   \\\n6     8\n     /\n     4",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/1962281/c-easy-to-understand/",
                "vote_count": "85"
            },
            {
                "language": "",
                "code": "",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/1962281/c-easy-to-understand/",
                "vote_count": "85"
            },
            {
                "language": "cpp",
                "code": "    TreeNode * first_mistake = nullptr, * second_mistake = nullptr; \n    TreeNode * prev = nullptr;\n    //prev holds \"the previous node\" in the follow sense:\n    //traverse() goes through the the nodes In-order, say the order is: node1, node2, node3, ....\n    //  so node1 will be the left-most node in the tree.\n    //If you're currently at node1 then prev == nullptr. \n    //If you're currently at node2 then prev == node1. ",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/1962281/c-easy-to-understand/",
                "vote_count": "85"
            },
            {
                "language": "typescript",
                "code": "",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/1962281/c-easy-to-understand/",
                "vote_count": "85"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def recoverTree(self, root):\n \n        # the idea is the in order BST is always increasing, if not, then there is something wrong\n        def inorderBST(root):\n            if not root:    return\n            \n            # track left side to start with min\n            inorderBST(root.left)\n\n            # so that the first prev is the smallest node\n            # and update each time\n            if self.prev:\n                \n                # when order is wrong\n    # check the examples in the illustration\n                if self.prev.val > root.val:\n                    if not self.first:\n                        self.first = self.prev\n                    self.second = root\n            \n            # update the prev node\n            self.prev = root\n            \n            # check right side\n            inorderBST(root.right)\n        \n        \n        self.first = self.second = self.prev = None\n        inorderBST(root)\n        \n        # swap the two wrong ones\n        self.first.val, self.second.val = self.second.val, self.first.val\n        \n        return",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/1962833/beginner-level-illustration-11-line-solution/",
                "vote_count": "49"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def recoverTree(self, root):\n\n        def inorderBST(root):\n            if not root:    return\n            \n            inorderBST(root.left)\n\n            if self.prev and self.prev.val > root.val:\n                if not self.first:  self.first = self.prev\n                self.second = root\n            self.prev = root\n\n            inorderBST(root.right)\n        \n        \n        self.first = self.second = self.prev = None\n        inorderBST(root)\n        self.first.val, self.second.val = self.second.val, self.first.val",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/1962833/beginner-level-illustration-11-line-solution/",
                "vote_count": "49"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> v;\n    int i=0;\n    void inorder(TreeNode* root){\n        if(!root) return;\n        inorder(root->left);\n        v.push_back(root->val);\n        inorder(root->right);\n    }\n    void check(TreeNode* root){\n        if(!root) return;\n        check(root->left);\n        if(v[i]!=root->val) swap(v[i],root->val);\n        i++;\n        check(root->right);\n    }\n    void recoverTree(TreeNode* root) {\n        inorder(root);\n        sort(v.begin(),v.end());\n        check(root);\n    }\n};",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/1962583/c-2-approach-brute-force-optimal/",
                "vote_count": "38"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    TreeNode* first, *last, *prev;\npublic:\n    void inorder(TreeNode* root){\n        if(root==NULL) return;\n        inorder(root->left);\n        if(prev!=NULL && (root->val<prev->val)){\n            if(first==NULL){\n                first=prev;\n                last=root; \n            }\n            else\n                last=root;\n        }\n        prev=root;\n        inorder(root->right);\n    }\n    void recoverTree(TreeNode* root) {\n        first=last=prev=NULL;\n        inorder(root);\n        swap(first->val,last->val);\n    }\n};",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/1962583/c-2-approach-brute-force-optimal/",
                "vote_count": "38"
            },
            {
                "language": "java",
                "code": "class Solution {\n     // Creating three global pointers\n    TreeNode previous = null;\n    TreeNode first = null;\n    TreeNode second = null;\n    \n    public void recoverTree(TreeNode root) {\n        // Finding the two swapped nodes\n        solve(root);\n        \n        //Swaping the value of nodes\n        int temp = first.val;\n        first.val = second.val;\n        second.val = temp;\n    }\n     //New Function to find the two nodes\n    public void solve(TreeNode root){\n        \n        if(root == null){\n            return;\n        }\n        \n        //Doing inorder traversal i.e, sarting from left then right\n        solve(root.left);\n        \n        // If current node is smaller than previous, then previous node is invalid\n        if(previous != null && root.val < previous.val){\n            \n            //Storing previous node\n            if(first == null){\n                first = previous;\n            }\n            \n            //If both nodes are adjacent, save the current node in that case\n            second = root;\n            \n        }\n        \n        //Making current node as previous node\n        previous = root;\n        \n        //Moving to right sub-tree\n        solve(root.right);\n        \n    }\n}",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/1962276/clear-n-easy-to-understand-code/",
                "vote_count": "22"
            },
            {
                "language": "kotlin",
                "code": "",
                "url": "https://leetcode.com/problems/recover-binary-search-tree/solutions/1962276/clear-n-easy-to-understand-code/",
                "vote_count": "22"
            }
        ]
    },
    "99": {
        "question_id": 100,
        "title": "Same Tree",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/same-tree",
        "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.Two binary trees are considered the same if they are structurally identical, and the nodes have the same value. ",
        "examples": [
            {
                "input": "p = [1,2,3], q = [1,2,3]",
                "output": "true",
                "explanation": null
            },
            {
                "input": "p = [1,2], q = [1,null,2]",
                "output": "false",
                "explanation": null
            },
            {
                "input": "p = [1,2,1], q = [1,1,2]",
                "output": "false",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in both trees is in the range [0, 100].",
            "-10^4 <= Node.val <= 10^4"
        ],
        "solutions": [
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q)    return true;\n        if(!p || !q)    return false;\n            return (p->val == q->val && isSameTree(p->right, q->right) && isSameTree(p->left, q->left));\n    }\n};",
                "url": "https://leetcode.com/problems/same-tree/solutions/3027456/c-recursion-one-line-and-iterative-solution-with-explaination/",
                "vote_count": "86"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q)\n    {\n        stack<pair<TreeNode*, TreeNode*>> st;\n        st.push({p, q});\n        while (!st.empty()) {\n            auto [node1, node2] = st.top();\n            st.pop();\n            if (!node1 && !node2) continue;\n            if (!node1 || !node2 || node1->val != node2->val) return false;\n            st.push({node1->left, node2->left});\n            st.push({node1->right, node2->right});\n        }\n        return true;\n    }\n};",
                "url": "https://leetcode.com/problems/same-tree/solutions/3027456/c-recursion-one-line-and-iterative-solution-with-explaination/",
                "vote_count": "86"
            }
        ]
    },
    "100": {
        "question_id": 101,
        "title": "Symmetric Tree",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/symmetric-tree",
        "description": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). ",
        "examples": [
            {
                "input": "root = [1,2,2,3,4,4,3]",
                "output": "true",
                "explanation": null
            },
            {
                "input": "root = [1,2,2,null,3,null,3]",
                "output": "false",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [1, 1000].",
            "-100 <= Node.val <= 100"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isSymmetricHelper(TreeNode* leftNode, TreeNode* rightNode){\n        if(leftNode==NULL && rightNode==NULL) return true;\n        if(leftNode==NULL || rightNode==NULL || leftNode->val != rightNode->val) return false;\n        \n        return isSymmetricHelper(leftNode->left, rightNode->right) && isSymmetricHelper(leftNode->right, rightNode->left);\n    }\n\n    bool isSymmetric(TreeNode* root) {\n        if(root == NULL) return true;\n        return isSymmetricHelper(root->left, root->right);\n    }\n};",
                "url": "https://leetcode.com/problems/symmetric-tree/solutions/3290198/image-explanation-recursive-non-recursive-complete-intuition/",
                "vote_count": "66"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        if(root == NULL) return true;\n\n        queue<TreeNode*> q;\n        q.push(root->left);\n        q.push(root->right);\n        while(!q.empty()){\n            TreeNode* leftNode = q.front();\n            q.pop();\n            TreeNode* rightNode = q.front();\n            q.pop();\n\n            if(leftNode==NULL && rightNode==NULL) continue;\n            if(leftNode==NULL || rightNode==NULL || leftNode->val != rightNode->val) return false;\n            q.push(leftNode->left);\n            q.push(rightNode->right);\n            q.push(leftNode->right);\n            q.push(rightNode->left);\n        }\n        return true;\n    }\n};",
                "url": "https://leetcode.com/problems/symmetric-tree/solutions/3290198/image-explanation-recursive-non-recursive-complete-intuition/",
                "vote_count": "66"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return isMirror(root, root);\n    }\n    private boolean isMirror(TreeNode n1, TreeNode n2){\n        if(n1==null && n2==null)\n            return true;\n        if(n1!=null && n2!=null && n1.val==n2.val)",
                "url": "https://leetcode.com/problems/symmetric-tree/solutions/3290198/image-explanation-recursive-non-recursive-complete-intuition/",
                "vote_count": "66"
            },
            {
                "language": "kotlin",
                "code": "public boolean isSymmetric(TreeNode root) {\n        return dfs(root.left,root.right);        \n    }\n    private boolean dfs(TreeNode root1,TreeNode root2){\n        if(root1==null && root2==null) return true;\n        if((root1==null || root2==null)) return false;\n        return (root1.val==root2.val)&&dfs(root1.left,root2.right) && dfs(root1.right,root2.left);\n    }",
                "url": "https://leetcode.com/problems/symmetric-tree/solutions/3290198/image-explanation-recursive-non-recursive-complete-intuition/",
                "vote_count": "66"
            },
            {
                "language": "rust",
                "code": "Thanks for visiting my solution.\ud83d\ude0a Keep Learning\nPlease give my solution an upvote! \ud83d\udc4d\nIt's a simple way to show your appreciation and\nkeep me motivated. Thank you! \ud83d\ude0a",
                "url": "https://leetcode.com/problems/symmetric-tree/solutions/3290112/easy-solutions-in-java-python-and-c-look-at-once/",
                "vote_count": "63"
            }
        ]
    },
    "101": {
        "question_id": 102,
        "title": "Binary Tree Level Order Traversal",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/binary-tree-level-order-traversal",
        "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level). ",
        "examples": [
            {
                "input": "root = [3,9,20,null,null,15,7]",
                "output": "[[3],[9,20],[15,7]]",
                "explanation": null
            },
            {
                "input": "root = [1]",
                "output": "[[1]]",
                "explanation": null
            },
            {
                "input": "root = []",
                "output": "[]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [0, 2000].",
            "-1000 <= Node.val <= 1000"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n    vector<vector<int>>ans;\n        if(!root)return ans;\n        queue<TreeNode*>q;\n        q.push(root);\n        while(!q.empty()){\n           int sz=q.size();\n           vector<int>v;\n           while(sz--){\n               TreeNode * f=q.front();\n               v.push_back(q.front()->val);\n               q.pop();\n               if(f->left)q.push(f->left);\n               if(f->right)q.push(f->right);\n\n           }\n           ans.push_back(v);\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/binary-tree-level-order-traversal/solutions/3196962/c-bfs-dfs-o-n-explained/",
                "vote_count": "37"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void dfs(TreeNode * root ,vector<vector<int>>&ans,int d=0){\n      if(!root)return;\n      if(d>=ans.size())ans.push_back({});\n      ans[d].push_back(root->val);\n      dfs(root->left,ans,d+1);\n      dfs(root->right,ans,d+1);\n  }\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>>ans;\n        if(!root)return ans;\n         if(!root)return ans;\n         dfs(root,ans);\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/binary-tree-level-order-traversal/solutions/3196962/c-bfs-dfs-o-n-explained/",
                "vote_count": "37"
            },
            {
                "language": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        Queue<TreeNode> q = new LinkedList<>();\n        List<List<Integer>> finalAns = new ArrayList<List<Integer>>();\n        if(root==null){\n            return finalAns;\n        }\n        q.add(root);\n        while(!q.isEmpty()){\n            int levels = q.size();\n            List<Integer> subLevels = new ArrayList<>();\n            for(int i=0;i<levels;i++){\n                if(q.peek().left!=null){\n                    q.add(q.peek().left);\n                }\n                if(q.peek().right!=null){\n                    q.add(q.peek().right);\n                }\n                subLevels.add(q.remove().val);\n            }\n            finalAns.add(subLevels);\n        }\n        return finalAns;\n    }\n}",
                "url": "https://leetcode.com/problems/binary-tree-level-order-traversal/solutions/3267417/well-explained-code-in-java-use-of-arraylist-and-queues/",
                "vote_count": "32"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        list1=[]\n        q=deque()\n        q.append(root)\n        while q:\n            level=[]\n            for i in range(len(q)):\n                poping=q.popleft()\n                if poping:\n                    level.append(poping.val)\n                    q.append(poping.left)\n                    q.append(poping.right)\n            if level:\n                list1.append(level)\n        return list1\n    #please upvote me it would encourage me alot",
                "url": "https://leetcode.com/problems/binary-tree-level-order-traversal/solutions/3293559/unprecedented-logic-python3/",
                "vote_count": "13"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        \n        vector<vector<int>> ans ; \n        vector<int> output ;  \n\n        // edge case \n        if (root == NULL)\n        {\n            return ans ; \n        }\n\n        // insert the first element and separator in the vector \n        queue<TreeNode*> q; \n        q.push(root) ;  //insert the first node the root node \n        q.push(NULL) ;  // the first separator comes after root node \n\n        while (!q.empty())\n        {\n            TreeNode *temp = q.front() ; \n            q.pop() ; \n            // if element at the front is a separator means one level has been traversed so we push the 1-D vector storing elements of that level into the 2-D vector that we have to return \n            if (temp == NULL)\n            {\n                ans.push_back(output) ; \n                output.clear() ; \n\n                // also if the queue is not empty meaning there are still child nodes present in it we would enter another separator in the queue \n                if (!q.empty())\n                {\n                    q.push(NULL) ; \n                }\n            }\n            // else if temp is not NULL\n            else\n            {\n                // insert elements into the 1-D vector \n                output.push_back(temp -> val) ;\n                // also check if the left and right nodes of temp are not NULL then insert them into queue as well\n                if (temp -> left != NULL)\n                {\n                    q.push(temp -> left) ;\n                }\n\n                if (temp -> right != NULL)\n                {\n                    q.push(temp -> right) ; \n                }\n            }\n        }\n        return ans ; \n    }\n};",
                "url": "https://leetcode.com/problems/binary-tree-level-order-traversal/solutions/3181454/c-solution-using-queues-and-separator-explained/",
                "vote_count": "12"
            }
        ]
    },
    "102": {
        "question_id": 103,
        "title": "Binary Tree Zigzag Level Order Traversal",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal",
        "description": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between). ",
        "examples": [
            {
                "input": "root = [3,9,20,null,null,15,7]",
                "output": "[[3],[20,9],[15,7]]",
                "explanation": null
            },
            {
                "input": "root = [1]",
                "output": "[[1]]",
                "explanation": null
            },
            {
                "input": "root = []",
                "output": "[]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [0, 2000].",
            "-100 <= Node.val <= 100"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        vector<vector<int>>ans;\n        if(!root)return ans;\n        queue<TreeNode*>q;\n        q.push(root);\n        int i=0;\n        while(!q.empty()){\n           int sz=q.size();\n           vector<int>v;\n           while(sz--){\n               TreeNode * f=q.front();\n               v.push_back(q.front()->val);\n               q.pop();\n               if(f->left)q.push(f->left);\n               if(f->right)q.push(f->right);\n\n           }\n           if(i++%2)\n           reverse(v.begin(),v.end());\n           ans.push_back(v);\n\n        }\n        return ans;\n    \n    }\n};",
                "url": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3198360/c-level-order-traversal-beats-100-bfs/",
                "vote_count": "42"
            },
            {
                "language": "cpp",
                "code": "vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        vector<vector<int>>ans;\n        if(!root)return ans;\n        queue<TreeNode*>q;\n        q.push(root);\n        int i=0;\n        while(!q.empty()){\n           int sz=q.size();\n           vector<int>v(sz);\n           int j=0,n=sz;\n           while(sz--){\n               TreeNode * f=q.front();\n               q.pop();\n               if(i%2==0)\n               v[j]=f->val;\n               else v[n-j-1]=f->val;\n               j++;\n               if(f->left)q.push(f->left);\n               if(f->right)q.push(f->right);\n           }\n           i++;\n           ans.push_back(v);\n\n        }\n        return ans;\n    \n    }",
                "url": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3198360/c-level-order-traversal-beats-100-bfs/",
                "vote_count": "42"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        if (root == null)\n            return res;\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\n        q.add(root);\n        boolean leftToRight = true;",
                "url": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3198360/c-level-order-traversal-beats-100-bfs/",
                "vote_count": "42"
            },
            {
                "language": "",
                "code": "                    Please Upvote If You Find It Helpful",
                "url": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3203450/simplest-solution-full-explanation-c-python3/",
                "vote_count": "32"
            }
        ]
    },
    "103": {
        "question_id": 104,
        "title": "Maximum Depth of Binary Tree",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree",
        "description": "Given the root of a binary tree, return its maximum depth.A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. ",
        "examples": [
            {
                "input": "root = [3,9,20,null,null,15,7]",
                "output": "3",
                "explanation": null
            },
            {
                "input": "root = [1,null,2]",
                "output": "2",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [0, 10^4].",
            "-100 <= Node.val <= 100"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "int maxDepthLeft = maxDepth(root->left);\nint maxDepthRight = maxDepth(root->right);\nreturn max(maxDepthLeft, maxDepthRight) + 1;",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1770060/c-recursive-dfs-example-dry-run-well-explained/",
                "vote_count": "1363"
            },
            {
                "language": "cpp",
                "code": "int maxDepth(TreeNode* root) {\n        if(!root) return 0;\n        int maxLeft = maxDepth(root->left);\n        int maxRight = maxDepth(root->right);\n        return max(maxLeft, maxRight)+1;\n    }",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1770060/c-recursive-dfs-example-dry-run-well-explained/",
                "vote_count": "1363"
            },
            {
                "language": "java",
                "code": "  static  int count=0;\n    public int maxDepth(TreeNode root) {\n       \n        if(root==null)\n            return count;\n        else\n        {\n            return 1+ Math.max(maxDepth(root.left),maxDepth(root.right));\n        }",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1770060/c-recursive-dfs-example-dry-run-well-explained/",
                "vote_count": "1363"
            },
            {
                "language": "rust",
                "code": " int maxDepth(TreeNode* root) { return root ? std::max(maxDepth(root->left), maxDepth(root->right)) + 1 : 0; }",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1770060/c-recursive-dfs-example-dry-run-well-explained/",
                "vote_count": "1363"
            },
            {
                "language": "java",
                "code": "private static int solve(TreeNode root, int depth){\n if(root == null) return depth;\n int left  = solve(root.left,  depth + 1);\n int right = solve(root.right, depth + 1);\n return Math.max(left, right);\n}\npublic int maxDepth(TreeNode root) {\n return solve(root, 0);",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1770060/c-recursive-dfs-example-dry-run-well-explained/",
                "vote_count": "1363"
            },
            {
                "language": "java",
                "code": "class Solution {\n    int maxCount = 0;\n    public int maxDepth(TreeNode root) {\n       maxDep(root, 0); \n       return maxCount; \n    }\n     public void maxDep(TreeNode root , int count){\n         if(root == null){\n             return;",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1770060/c-recursive-dfs-example-dry-run-well-explained/",
                "vote_count": "1363"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        def dfs(root, depth):\n            if not root: return depth\n            return max(dfs(root.left, depth + 1), dfs(root.right, depth + 1))\n                       \n        return dfs(root, 0)",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1769367/python3-recursive-dfs-explained/",
                "vote_count": "213"
            },
            {
                "language": "ruby",
                "code": "    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1769367/python3-recursive-dfs-explained/",
                "vote_count": "213"
            },
            {
                "language": "ruby",
                "code": "def maxDepth(self, root: TreeNode) -> int:\n    \n    if not root: return 0\n    \n    queue = [(root, 1)]\n    self.res = 0\n    \n    while queue:",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1769367/python3-recursive-dfs-explained/",
                "vote_count": "213"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(!root) return 0;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1769367/python3-recursive-dfs-explained/",
                "vote_count": "213"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1769367/python3-recursive-dfs-explained/",
                "vote_count": "213"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:          \n            return 0 if not root else 1 + max(self.maxDepth(root.left), self.maxDepth(root.right)) ",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1769367/python3-recursive-dfs-explained/",
                "vote_count": "213"
            },
            {
                "language": "java",
                "code": "public int maxDepth(TreeNode root) {\n    if(root==null)return 0;\n\n    int left=maxDepth(root.left);\n    int right=maxDepth(root.right);\n\n    return Math.max(left,right)+1;",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1769367/python3-recursive-dfs-explained/",
                "vote_count": "213"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1769367/python3-recursive-dfs-explained/",
                "vote_count": "213"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int maxDepth(TreeNode root) {\n        // Base Condition\n        if(root == null) return 0;\n        // Hypothesis\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        // Induction\n        return Math.max(left, right) + 1;\n    }\n}",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1769344/java-c-easy-to-go-explanation-solution/",
                "vote_count": "168"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == NULL) return 0;\n        int left = maxDepth(root->left);\n        int right = maxDepth(root->right);\n        return max(left, right) + 1;\n    }\n};",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1769344/java-c-easy-to-go-explanation-solution/",
                "vote_count": "168"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(!root) return 0;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1769344/java-c-easy-to-go-explanation-solution/",
                "vote_count": "168"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1769344/java-c-easy-to-go-explanation-solution/",
                "vote_count": "168"
            },
            {
                "language": "java",
                "code": "class Solution {\nint left = 0;\nint right = 0;\n    public int maxDepth(TreeNode root) {\n \n        if(root == null) return 0;",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/1769344/java-c-easy-to-go-explanation-solution/",
                "vote_count": "168"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n\n    int maxDepth(TreeNode* root) {\n        \n        if(root==NULL) return 0;\n\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};",
                "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/3191646/c-faster-than-80-recursive-solution-clean-concise-code/",
                "vote_count": "12"
            }
        ]
    },
    "104": {
        "question_id": 105,
        "title": "Construct Binary Tree from Preorder and Inorder Traversal",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal",
        "description": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree. ",
        "examples": [
            {
                "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]",
                "output": "[3,9,20,null,null,15,7]",
                "explanation": null
            },
            {
                "input": "preorder = [-1], inorder = [-1]",
                "output": "[-1]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= preorder.length <= 3000",
            "inorder.length == preorder.length",
            "-3000 <= preorder[i], inorder[i] <= 3000",
            "preorder and inorder consist of unique values.",
            "Each value of inorder also appears in preorder.",
            "preorder is guaranteed to be the preorder traversal of the tree.",
            "inorder is guaranteed to be the inorder traversal of the tree."
        ],
        "solutions": [
            {
                "language": "java",
                "code": "public TreeNode buildTree(int[] preorder, int[] inorder) {\n    return helper(0, 0, inorder.length - 1, preorder, inorder);\n}\n\npublic TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) {\n    if (preStart > preorder.length - 1 || inStart > inEnd) {\n        return null;\n    }\n    TreeNode root = new TreeNode(preorder[preStart]);\n    int inIndex = 0; // Index of current root in inorder\n    for (int i = inStart; i <= inEnd; i++) {\n        if (inorder[i] == root.val) {\n            inIndex = i;\n        }\n    }\n    root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder);\n    root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder);\n    return root;\n}",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/34538/my-accepted-java-solution/",
                "vote_count": "926"
            },
            {
                "language": "java",
                "code": "public TreeNode buildTree(int[] preorder, int[] inorder) {\n    Map<Integer, Integer> inMap = new HashMap<Integer, Integer>();\n\n    for(int i = 0; i < inorder.length; i++) {\n        inMap.put(inorder[i], i);\n);\nint inEnd, Map<Integer, Integer> inMap) {\n- 1, inMap);\n, inMap);",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/34538/my-accepted-java-solution/",
                "vote_count": "926"
            },
            {
                "language": "java",
                "code": " public TreeNode buildTree(int[] preorder, int[] inorder) {\n    if(preorder.length!=inorder.length) return null;\n    return build(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1);\n}\n\npublic TreeNode build(int [] preorder, int preLow, int preHigh, int[] inorder, int inLow, int inHigh){\n    if(preLow>preHigh || inLow>inHigh) return null;\n    TreeNode root = new TreeNode(preorder[preLow]);\n;       ",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/34538/my-accepted-java-solution/",
                "vote_count": "926"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        unordered_map<int, int> mp;\n        for (int i = 0; i < inorder.size(); i++) {\n            mp[inorder[i]] = i;\n        }\n, int ps, int is, int ie) {",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/34538/my-accepted-java-solution/",
                "vote_count": "926"
            },
            {
                "language": "java",
                "code": "class Solution {\n    int pStart = 0;\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if(preorder == null ||inorder == null || preorder.length ==0 || inorder.length==0)\n            return null;\n        Map<Integer, Integer> indexes = new HashMap();\n        for(int i =0; i<inorder.length; i++){\n> indexes ){",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/34538/my-accepted-java-solution/",
                "vote_count": "926"
            },
            {
                "language": "java",
                "code": "public TreeNode buildTree(int[] inorder, int[] postorder) {\n return buildTreeInPost(postorder.length-1, 0, inorder.length-1, postorder, inorder); \n}\nprivate TreeNode buildTreeInPost(int postStart, int inStart, int inEnd, int[] postorder, int[] inorder) {\n if(inStart>inEnd ||postStart<0) return null;\n TreeNode root = new TreeNode(postorder[postStart]);\n);",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/34538/my-accepted-java-solution/",
                "vote_count": "926"
            },
            {
                "language": "ruby",
                "code": "def buildTree(self, preorder, inorder):\n    if inorder:\n        ind = inorder.index(preorder.pop(0))\n        root = TreeNode(inorder[ind])\n        root.left = self.buildTree(preorder, inorder[0:ind])\n        root.right = self.buildTree(preorder, inorder[ind+1:])\n        return root",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/34579/python-short-recursive-solution/",
                "vote_count": "895"
            },
            {
                "language": "python",
                "code": "    def buildTree(self, preorder, inorder):\n  ",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/34579/python-short-recursive-solution/",
                "vote_count": "895"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        ",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/34579/python-short-recursive-solution/",
                "vote_count": "895"
            },
            {
                "language": "ruby",
                "code": "class Solution(object):\n    def buildTree(self, preorder, inorder):\n        inorder_map = {val: i for i, val in enumerate(inorder)}\n        return self.dfs_helper(inorder_map, preorder, 0, len(inorder) - 1)\n    \n    \n    def dfs_helper(self, inorder_map, preorder, left, right):",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/34579/python-short-recursive-solution/",
                "vote_count": "895"
            },
            {
                "language": "python",
                "code": "from collections import deque\nclass Solution:\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/34579/python-short-recursive-solution/",
                "vote_count": "895"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/34579/python-short-recursive-solution/",
                "vote_count": "895"
            },
            {
                "language": "ruby",
                "code": "if inorder:\n        node = TreeNode(preorder[0])\n        node_index = inorder.index(preorder[0])\n        l_len = len(inorder[:node_index])\n        node.left = self.buildTree(preorder[1:l_len+1], inorder[0:l_len])",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/34579/python-short-recursive-solution/",
                "vote_count": "895"
            },
            {
                "language": "ruby",
                "code": "",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/34579/python-short-recursive-solution/",
                "vote_count": "895"
            },
            {
                "language": "ruby",
                "code": "   def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\n        \n        if not preorder or not inorder:\n            return None\n\n        if len(preorder) == 1:\n            return TreeNode(preorder[0])\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n       \n        root.left = self.buildTree(preorder[1:root_index + 1],inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index + 1:],inorder[root_index + 1:])\n        \n        return root",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/981152/recursion-explanation-visuals-python/",
                "vote_count": "193"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def buildTree(self, preorder, inorder):\n        if inorder:\n            INDEX = inorder.index(preorder.pop(0))\n            root = TreeNode(inorder[INDEX])\n            root.left = self.buildTree(preorder, inorder[:INDEX])\n            root.right = self.buildTree(preorder, inorder[INDEX+1:])\n   \n            return root",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/2279180/python-explained/",
                "vote_count": "162"
            },
            {
                "language": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        preorder.reverse()",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/2279180/python-explained/",
                "vote_count": "162"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n  int n = inorder.size();\n        int Idx = 0;\n        return helper(preorder, inorder, Idx, 0, n-1);\n    }\n    \n    TreeNode* helper(vector<int>& preorder, vector<int>& inorder, int& Idx, int left, int right) {\n        if (left > right) return NULL;\n        int pivot = left;  // find the root from inorder\n        while(inorder[pivot] != preorder[Idx]) pivot++;\n        \n        Idx++;\n        TreeNode* newNode = new TreeNode(inorder[pivot]);\n        newNode->left = helper(preorder, inorder, Idx, left, pivot-1);\n        newNode->right = helper(preorder, inorder, Idx, pivot+1, right);\n        return newNode;\n    }\n};",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/2279613/c-recursive-using-map-approaches/",
                "vote_count": "58"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        map<int,int> mp;\n        for(int i=0;i<preorder.size();i++){\n            mp[inorder[i]]=i;\n        }\n        TreeNode* root = construct(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,mp);\n        return root;\n    }\n    TreeNode* construct(vector<int>&preorder, int preStart, int preEnd, vector<int> &inorder,int inStart, int inEnd, map<int,int> &mp){\n        if(preStart>preEnd || inStart>inEnd) return NULL;\n        TreeNode* root = new TreeNode(preorder[preStart]);\n        int inRoot = mp[root->val];\n        int numsLeft = inRoot-inStart;\n        \n        root->left = construct(preorder,preStart+1,preStart+numsLeft,inorder,inStart,inRoot-1,mp);\n        root->right = construct(preorder,preStart+numsLeft+1,preEnd,inorder,inRoot+1,inEnd,mp);\n        return root;\n    }\n};",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/2279613/c-recursive-using-map-approaches/",
                "vote_count": "58"
            }
        ]
    },
    "105": {
        "question_id": 106,
        "title": "Construct Binary Tree from Inorder and Postorder Traversal",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal",
        "description": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree. ",
        "examples": [
            {
                "input": "inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]",
                "output": "[3,9,20,null,null,15,7]",
                "explanation": null
            },
            {
                "input": "inorder = [-1], postorder = [-1]",
                "output": "[-1]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= inorder.length <= 3000",
            "postorder.length == inorder.length",
            "-3000 <= inorder[i], postorder[i] <= 3000",
            "inorder and postorder consist of unique values.",
            "Each value of postorder also appears in inorder.",
            "inorder is guaranteed to be the inorder traversal of the tree.",
            "postorder is guaranteed to be the postorder traversal of the tree."
        ],
        "solutions": [
            {
                "language": "rust",
                "code": "Thanks for visiting my solution.\ud83d\ude0a Keep Learning\nPlease give my solution an upvote! \ud83d\udc4d\nIt's a simple way to show your appreciation and\nkeep me motivated. Thank you! \ud83d\ude0a",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solutions/3302159/easy-solutions-in-java-python-and-c-look-at-once/",
                "vote_count": "179"
            },
            {
                "language": "",
                "code": "inorder = [9,3,15,20,7]\npostorder = [9,15,7,20,3]",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solutions/3302302/clean-codes-full-explanation-using-stack-c-java-python3/",
                "vote_count": "27"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int postorderIndex;\n    unordered_map<int, int> inorderIndexUmp;\n\n    TreeNode* buildTreeHelper(vector<int>& postorder, int left, int right) {\n        if (left > right)\n            return nullptr;\n        int rootValue = postorder[postorderIndex--];\n        TreeNode* root = new TreeNode(rootValue);\n        int inorderPivotIndex = inorderIndexUmp[rootValue];\n        //think about it...why I took root -> right first then root -> left ?\n        root -> right = buildTreeHelper(postorder, inorderPivotIndex + 1, right);\n        root -> left = buildTreeHelper(postorder, left, inorderPivotIndex - 1);\n        return root;\n    }\n\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        postorderIndex = postorder.size() - 1;\n        for (int i = 0; i < inorder.size(); i++) {\n            inorderIndexUmp[inorder[i]] = i;\n        }\n        return buildTreeHelper(postorder, 0, postorder.size() - 1);\n    }\n};",
                "url": "https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solutions/3302713/day-75-divide-and-conquer-hash-table-easiest-beginner-friendly-sol/",
                "vote_count": "11"
            }
        ]
    },
    "106": {
        "question_id": 107,
        "title": "Binary Tree Level Order Traversal II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root). ",
        "examples": [
            {
                "input": "root = [3,9,20,null,null,15,7]",
                "output": "[[15,7],[9,20],[3]]",
                "explanation": null
            },
            {
                "input": "root = [1]",
                "output": "[[1]]",
                "explanation": null
            },
            {
                "input": "root = []",
                "output": "[]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [0, 2000].",
            "-1000 <= Node.val <= 1000"
        ],
        "solutions": []
    },
    "107": {
        "question_id": 108,
        "title": "Convert Sorted Array to Binary Search Tree",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree",
        "description": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree. ",
        "examples": [
            {
                "input": "nums = [-10,-3,0,5,9]",
                "output": "[0,-3,9,-10,null,5]",
                "explanation": "[0,-10,5,null,-3,null,9] is also accepted:\n"
            },
            {
                "input": "nums = [1,3]",
                "output": "[3,1]",
                "explanation": "[1,null,3] and [3,1] are both height-balanced BSTs."
            }
        ],
        "constraints": [
            "1 <= nums.length <= 10^4",
            "-10^4 <= nums[i] <= 10^4",
            "nums is sorted in a strictly increasing order."
        ],
        "solutions": [
            {
                "language": "kotlin",
                "code": "class Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:\n        total_nums = len(nums)\n        if not total_nums:\n            return None\n\n        mid_node = total_nums // 2\n        return TreeNode(\n            nums[mid_node], \n            self.sortedArrayToBST(nums[:mid_node]), self.sortedArrayToBST(nums[mid_node + 1 :])\n        )",
                "url": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/solutions/2406277/python-easily-understood-faster-than-86-less-than-83-recursion/",
                "vote_count": "159"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:\n        return self.makeBST(nums, 0, len(nums))\n    \n    def makeBST(self, nums, start, end):\n        if start >= end: return None\n        return TreeNode(\n            val=nums[ (start + end)//2 ],",
                "url": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/solutions/2406277/python-easily-understood-faster-than-86-less-than-83-recursion/",
                "vote_count": "159"
            },
            {
                "language": "java",
                "code": "public TreeNode sortedArrayToBST(int[] nums) {\n        return CreateBST(nums, 0, nums.length - 1);\n    }\n\n    private TreeNode CreateBST(int nums[], int l, int r) {\n        if (l > r) { // Base Condition or Recursion Stoping Condition\n            return null;\n        }\n  // so basically in this question we have to convert sorted array to height balanced tree\n  // so if we directly create tree in given sorted order it will become linked list\n  // so we have to take middle element as head value such it will  become height balanced tree \n        int mid = (l + r) / 2; \n        TreeNode root = new TreeNode(nums[mid]); // mid value or median \n        root.left = CreateBST(nums, l, mid - 1); // assign the value for left of subtree that is l to mid -1 for given array\n        root.right = CreateBST(nums, mid + 1, r); // assign the value for right go subtree that is mid+1 to r for given array\n        return root;\n    }",
                "url": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/solutions/2404676/java-solution-recursion-0ms-100-faster-beginner-friendly/",
                "vote_count": "139"
            }
        ]
    },
    "108": {
        "question_id": 109,
        "title": "Convert Sorted List to Binary Search Tree",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree",
        "description": "Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balanced binary search tree. ",
        "examples": [
            {
                "input": "head = [-10,-3,0,5,9]",
                "output": "[0,-3,9,-10,null,5]",
                "explanation": "One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST."
            },
            {
                "input": "head = []",
                "output": "[]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in head is in the range [0, 2 * 10^4].",
            "-10^5 <= Node.val <= 10^5"
        ],
        "solutions": [
            {
                "language": "kotlin",
                "code": "class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head==null)\n            return null;\n        if(head.next==null)\n            return new TreeNode(head.val);\n        ListNode slow=head;\n        ListNode fast=head.next.next;\n        while(fast!=null && fast.next!=null){\n            slow=slow.next;\n            fast=fast.next.next;\n        }\n        TreeNode res=new TreeNode(slow.next.val);\n        ListNode righthalf=slow.next.next;\n        slow.next=null;\n        res.left=sortedListToBST(head);\n        res.right=sortedListToBST(righthalf);\n        return res;\n    }\n}",
                "url": "https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282028/java-easy-using-slow-fast-pointer-recursively/",
                "vote_count": "157"
            },
            {
                "language": "solution_a",
                "code": "",
                "url": "https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282028/java-easy-using-slow-fast-pointer-recursively/",
                "vote_count": "157"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        List<Integer> l = new ArrayList<>();\n        while(head != null) {\n            l.add(head.val);\n            head = head.next;\n        }",
                "url": "https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282028/java-easy-using-slow-fast-pointer-recursively/",
                "vote_count": "157"
            },
            {
                "language": "kotlin",
                "code": " Solution {\n  public:\n   TreeNode* fun(vector<int>&nums,int l,int r){\n       if(l>r){\n           return NULL;\n        } \n    int mid=l+(r-l)/2;\n    TreeNode* root=new TreeNode(nums[mid]);\n    root->left=fun(nums,l,mid-1);",
                "url": "https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282028/java-easy-using-slow-fast-pointer-recursively/",
                "vote_count": "157"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* convertToBST(ListNode* start, ListNode* end){\n        if(start == end) return nullptr;\n        ListNode* slow = start;\n        ListNode* fast = start;\n\n        while(fast!=end && fast->next!=end){\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        TreeNode* head = new TreeNode(slow->val);\n        head->left = convertToBST(start, slow);\n        head->right = convertToBST(slow->next, end);\n        return head;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head == nullptr) return nullptr;\n        return convertToBST(head, nullptr);\n    }\n};",
                "url": "https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282118/image-explanation-slow-fast-pointer-recursion-complete-intuition/",
                "vote_count": "75"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        if(head.next == null) return new TreeNode(head.val);\n        ListNode middle = getMiddle(head);\n        TreeNode root = new TreeNode(middle.val);\n        root.right = sortedListToBST(middle.next);\n        middle.next =null;\n        root.left = sortedListToBST(head);\n        return root;\n    }\n    \n    public ListNode getMiddle(ListNode head){\n        //if(head == null || head.next==null) return null;\n        ListNode fast = head;\n        ListNode slow = head;\n        ListNode prev = null;\n        while(fast!=null && fast.next!=null){\n            fast = fast.next.next;\n            prev = slow;\n            slow = slow.next;\n            \n        }\n        if(prev!=null)prev.next =null;\n        return slow;\n    }\n}",
                "url": "https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3281968/beats-100-video-java-c-python/",
                "vote_count": "49"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head == NULL) return NULL;\n        if(head->next == NULL) return new TreeNode(head->val);\n        ListNode* middle = getMiddle(head);\n        TreeNode* root = new TreeNode(middle->val);\n        root->right = sortedListToBST(middle->next);\n        middle->next = NULL;\n        root->left = sortedListToBST(head);\n        return root;\n    }\n    \n    ListNode* getMiddle(ListNode* head){\n        //if(head == NULL || head->next==NULL) return NULL;\n        ListNode* fast = head;\n        ListNode* slow = head;\n        ListNode* prev = NULL;\n        while(fast!=NULL && fast->next!=NULL){\n            fast = fast->next->next;\n            prev = slow;\n            slow = slow->next;\n        }\n        if(prev!=NULL) prev->next = NULL;\n        return slow;\n    }\n};",
                "url": "https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3281968/beats-100-video-java-c-python/",
                "vote_count": "49"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        middle = self.getMiddle(head)\n        root = TreeNode(middle.val)\n        root.right = self.sortedListToBST(middle.next)\n        middle.next = None\n        root.left = self.sortedListToBST(head)\n        return root\n    \n    def getMiddle(self, head: ListNode) -> ListNode:\n        fast = head\n        slow = head\n        prev = None\n        while fast and fast.next:\n            fast = fast.next.next\n            prev = slow\n            slow = slow.next\n        if prev:\n            prev.next = None\n        return slow",
                "url": "https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3281968/beats-100-video-java-c-python/",
                "vote_count": "49"
            },
            {
                "language": "rust",
                "code": "Thanks for visiting my solution.\ud83d\ude0a Keep Learning\nPlease give my solution an upvote! \ud83d\udc4d\nIt's a simple way to show your appreciation and\nkeep me motivated. Thank you! \ud83d\ude0a",
                "url": "https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3281995/easy-solutions-in-java-python-and-c-look-at-once/",
                "vote_count": "21"
            }
        ]
    },
    "109": {
        "question_id": 110,
        "title": "Balanced Binary Tree",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/balanced-binary-tree",
        "description": "Given a binary tree, determine if it is height-balanced. ",
        "examples": [
            {
                "input": "root = [3,9,20,null,null,15,7]",
                "output": "true",
                "explanation": null
            },
            {
                "input": "root = [1,2,2,3,3,null,null,4,4]",
                "output": "false",
                "explanation": null
            },
            {
                "input": "root = []",
                "output": "true",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [0, 5000].",
            "-10^4 <= Node.val <= 10^4"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class solution {\npublic:\n    int depth (TreeNode *root) {\n        if (root == NULL) return 0;\n        return max (depth(root -> left), depth (root -> right)) + 1;\n    }\n\n    bool isBalanced (TreeNode *root) {\n        if (root == NULL) return true;\n        \n        int left=depth(root->left);\n        int right=depth(root->right);\n        \n        return abs(left - right) <= 1 && isBalanced(root->left) && isBalanced(root->right);\n    }\n};",
                "url": "https://leetcode.com/problems/balanced-binary-tree/solutions/35691/the-bottom-up-o-n-solution-would-be-better/",
                "vote_count": "1120"
            },
            {
                "language": "cpp",
                "code": "class solution {\npublic:\nint dfsHeight (TreeNode *root) {\n        if (root == NULL) return 0;\n        \n        int leftHeight = dfsHeight (root -> left);\n        if (leftHeight == -1) return -1;\n        int rightHeight = dfsHeight (root -> right);\n        if (rightHeight == -1) return -1;\n        \n        if (abs(leftHeight - rightHeight) > 1)  return -1;\n        return max (leftHeight, rightHeight) + 1;\n    }\n    bool isBalanced(TreeNode *root) {\n        return dfsHeight (root) != -1;\n    }\n};",
                "url": "https://leetcode.com/problems/balanced-binary-tree/solutions/35691/the-bottom-up-o-n-solution-would-be-better/",
                "vote_count": "1120"
            },
            {
                "language": "typescript",
                "code": "public boolean isBalanced(TreeNode root) {\n        if(root == null){\n            return true;\n        }\n        return helper(root) != -1;\n    }\n    private int helper(TreeNode root){\n        if(root == null){",
                "url": "https://leetcode.com/problems/balanced-binary-tree/solutions/35691/the-bottom-up-o-n-solution-would-be-better/",
                "vote_count": "1120"
            },
            {
                "language": "typescript",
                "code": "boolean isBalanced = true;\n    public boolean isBalanced(TreeNode root) {\n        if(root == null) return isBalanced;\n        backtrack(root);\n        return isBalanced;\n    }\n    private int backtrack(TreeNode root){\n        if(root == null) return 0;",
                "url": "https://leetcode.com/problems/balanced-binary-tree/solutions/35691/the-bottom-up-o-n-solution-would-be-better/",
                "vote_count": "1120"
            },
            {
                "language": "typescript",
                "code": "    public boolean isBalanced(TreeNode root) {\n        return dfsHeight(root) != -1;\n    }\n    \n    private int dfsHeight(TreeNode root) {\n        if (root == null)",
                "url": "https://leetcode.com/problems/balanced-binary-tree/solutions/35691/the-bottom-up-o-n-solution-would-be-better/",
                "vote_count": "1120"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public boolean isBalanced(TreeNode root) {\n        // If the tree is empty, we can say it\u2019s balanced...\n        if (root == null)  return true;\n        // Height Function will return -1, when it\u2019s an unbalanced tree...\n  if (Height(root) == -1)  return false;\n  return true;\n }\n    // Create a function to return the \u201cheight\u201d of a current subtree using recursion...\n public int Height(TreeNode root) {\n        // Base case...\n  if (root == null)  return 0;\n        // Height of left subtree...\n  int leftHeight = Height(root.left);\n        // Height of height subtree...\n  int rightHight = Height(root.right);\n        // In case of left subtree or right subtree unbalanced, return -1...\n  if (leftHeight == -1 || rightHight == -1)  return -1;\n        // If their heights differ by more than \u20181\u2019, return -1...\n        if (Math.abs(leftHeight - rightHight) > 1)  return -1;\n        // Otherwise, return the height of this subtree as max(leftHeight, rightHight) + 1...\n  return Math.max(leftHeight, rightHight) + 1;\n    }\n}",
                "url": "https://leetcode.com/problems/balanced-binary-tree/solutions/2428871/very-easy-100-fully-explained-c-java-python-javascript-python3/",
                "vote_count": "180"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        // If the tree is empty, we can say it\u2019s balanced...\n        if (root == NULL)  return true;\n        // Height Function will return -1, when it\u2019s an unbalanced tree...\n  if (Height(root) == -1)  return false;\n  return true;\n }\n    // Create a function to return the \u201cheight\u201d of a current subtree using recursion...\n int Height(TreeNode* root) {\n        // Base case...\n  if (root == NULL)  return 0;\n        // Height of left subtree...\n  int leftHeight = Height(root->left);\n        // Height of height subtree...\n  int rightHight = Height(root->right);\n        // In case of left subtree or right subtree unbalanced or their heights differ by more than \u20181\u2019, return -1...\n  if (leftHeight == -1 || rightHight == -1 || abs(leftHeight - rightHight) > 1)  return -1;\n        // Otherwise, return the height of this subtree as max(leftHeight, rightHight) + 1...\n  return max(leftHeight, rightHight) + 1;\n    }\n};",
                "url": "https://leetcode.com/problems/balanced-binary-tree/solutions/2428871/very-easy-100-fully-explained-c-java-python-javascript-python3/",
                "vote_count": "180"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def isBalanced(self, root):\n        return (self.Height(root) >= 0)\n    def Height(self, root):\n        if root is None:  return 0\n        leftheight, rightheight = self.Height(root.left), self.Height(root.right)\n        if leftheight < 0 or rightheight < 0 or abs(leftheight - rightheight) > 1:  return -1\n        return max(leftheight, rightheight) + 1",
                "url": "https://leetcode.com/problems/balanced-binary-tree/solutions/2428871/very-easy-100-fully-explained-c-java-python-javascript-python3/",
                "vote_count": "180"
            },
            {
                "language": "javascript",
                "code": "var isBalanced = function(root) {\n    // If the tree is empty, we can say it\u2019s balanced...\n    if (root == null)  return true;\n    // Height Function will return -1, when it\u2019s an unbalanced tree...\n if (Height(root) == -1)  return false;\n return true;\n}\n// Create a function to return the \u201cheight\u201d of a current subtree using recursion...\nvar Height = function(root) {\n    // Base case...\n if (root == null)  return 0;\n    // Height of left subtree...\n let leftHeight = Height(root.left);\n    // Height of height subtree...\n let rightHight = Height(root.right);\n    // In case of left subtree or right subtree unbalanced, return -1...\n if (leftHeight == -1 || rightHight == -1)  return -1;\n    // If their heights differ by more than \u20181\u2019, return -1...\n    if (Math.abs(leftHeight - rightHight) > 1)  return -1;\n    // Otherwise, return the height of this subtree as max(leftHeight, rightHight) + 1...\n return Math.max(leftHeight, rightHight) + 1;\n};",
                "url": "https://leetcode.com/problems/balanced-binary-tree/solutions/2428871/very-easy-100-fully-explained-c-java-python-javascript-python3/",
                "vote_count": "180"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        return (self.Height(root) >= 0)\n    def Height(self, root: Optional[TreeNode]) -> bool:\n        if root is None:  return 0\n        leftheight, rightheight = self.Height(root.left), self.Height(root.right)\n        if leftheight < 0 or rightheight < 0 or abs(leftheight - rightheight) > 1:  return -1\n        return max(leftheight, rightheight) + 1",
                "url": "https://leetcode.com/problems/balanced-binary-tree/solutions/2428871/very-easy-100-fully-explained-c-java-python-javascript-python3/",
                "vote_count": "180"
            },
            {
                "language": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        def dfs(root):\n            if root==None:\n                return [True,0]\n            left,right=dfs(root.left),def(root.right)\n            balanced=left[0] and right[0] and abs(left[1]-right[1])<=1\n            return [balanced,1+max(left[1],right[1])]\n        return dfs(root)[0]\n    #please upvote me it would encourage me alot\n\n        ",
                "url": "https://leetcode.com/problems/balanced-binary-tree/solutions/3282033/6-lines-code-python3/",
                "vote_count": "11"
            }
        ]
    },
    "110": {
        "question_id": 111,
        "title": "Minimum Depth of Binary Tree",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree",
        "description": "Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.Note: A leaf is a node with no children. ",
        "examples": [
            {
                "input": "root = [3,9,20,null,null,15,7]",
                "output": "2",
                "explanation": null
            },
            {
                "input": "root = [2,null,3,null,4,null,5,null,6]",
                "output": "5",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [0, 10^5].",
            "-1000 <= Node.val <= 1000"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "public class Solution {\n    public int minDepth(TreeNode root) {\n        if(root == null) return 0;\n        int left = minDepth(root.left);\n        int right = minDepth(root.right);\n        return (left == 0 || right == 0) ? left + right + 1: Math.min(left,right) + 1;\n       \n    }\n}",
                "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/36045/my-4-line-java-solution/",
                "vote_count": "490"
            },
            {
                "language": "cpp",
                "code": "/** Solution 1: DFS \n * Key point: \n * if a node only has one child -> MUST return the depth of the side with child, i.e. MAX(left, right) + 1\n * if a node has two children on both side -> return min depth of two sides, i.e. MIN(left, right) + 1\n * */\npublic int minDepth(TreeNode root) {\n    if (root == null) {\n        return 0;",
                "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/36045/my-4-line-java-solution/",
                "vote_count": "490"
            },
            {
                "language": "kotlin",
                "code": "   public static int minDepth(TreeNode root) {\n if (root == null) return 0;\n if (root.left == null) return minDepth(root.right) + 1;\n if (root.right == null) return minDepth(root.left) + 1;\n return Math.min(minDepth(root.left),minDepth(root.right)) + 1;\n}",
                "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/36045/my-4-line-java-solution/",
                "vote_count": "490"
            },
            {
                "language": "csharp",
                "code": " public int minDepth(TreeNode root) {\n        if(root == null)\n            return 0;\n        Queue<TreeNode> que = new LinkedList();\n        int level =1;\n        que.add(root);\n        while(!que.isEmpty()){\n            int size = que.size();",
                "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/36045/my-4-line-java-solution/",
                "vote_count": "490"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public int minDepth(TreeNode root) {",
                "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/36045/my-4-line-java-solution/",
                "vote_count": "490"
            },
            {
                "language": "csharp",
                "code": "public int minDepth(TreeNode root) {\n        if(root == null) return 0;\n        List<TreeNode> list = new LinkedList<>();\n        list.add(root);\n        int level = 1;\n        while(!list.isEmpty()){",
                "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/36045/my-4-line-java-solution/",
                "vote_count": "490"
            },
            {
                "language": "typescript",
                "code": "public int minDepth(TreeNode root) {\n    if(root == null) return 0;\n    if(root.left == null || root.right == null) {\n        return 1 + Math.max(minDepth(root.left), minDepth(root.right));\n    }\n    return 1 + Math.min(minDepth(root.left), minDepth(root.right));\n}",
                "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/36045/my-4-line-java-solution/",
                "vote_count": "490"
            },
            {
                "language": "kotlin",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n(root.right) + 1);",
                "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/36045/my-4-line-java-solution/",
                "vote_count": "490"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        // Base case...\n        // If the subtree is empty i.e. root is NULL, return depth as 0...\n        if(root == NULL)  return 0;\n        // Initialize the depth of two subtrees...\n        int leftDepth = minDepth(root->left);\n        int rightDepth = minDepth(root->right);\n        // If the both subtrees are empty...\n        if(root->left == NULL && root->right == NULL)\n            return 1;\n        // If the left subtree is empty, return the depth of right subtree after adding 1 to it...\n        if(root->left == NULL)\n            return 1 + rightDepth;\n        // If the right subtree is empty, return the depth of left subtree after adding 1 to it...\n        if(root->right == NULL)\n            return 1 + leftDepth;\n        // When the two child function return its depth...\n        // Pick the minimum out of these two subtrees and return this value after adding 1 to it...\n        return min(leftDepth, rightDepth) + 1;    // Adding 1 is the current node which is the parent of the two subtrees...\n    }\n};",
                "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/2429057/very-easy-100-fully-explained-c-java-python-js-c-python3/",
                "vote_count": "70"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public int minDepth(TreeNode root) {\n        // Base case...\n        // If the subtree is empty i.e. root is NULL, return depth as 0...\n        if(root == null)  return 0;\n        // Initialize the depth of two subtrees...\n        int leftDepth = minDepth(root.left);\n        int rightDepth = minDepth(root.right);\n        // If the both subtrees are empty...\n        if(root.left == null && root.right == null)\n            return 1;\n        // If the left subtree is empty, return the depth of right subtree after adding 1 to it...\n        if(root.left == null)\n            return 1 + rightDepth;\n        // If the right subtree is empty, return the depth of left subtree after adding 1 to it...\n        if(root.right == null)\n            return 1 + leftDepth;\n        // When the two child function return its depth...\n        // Pick the minimum out of these two subtrees and return this value after adding 1 to it...\n        return Math.min(leftDepth, rightDepth) + 1;    // Adding 1 is the current node which is the parent of the two subtrees...\n    }\n}",
                "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/2429057/very-easy-100-fully-explained-c-java-python-js-c-python3/",
                "vote_count": "70"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def minDepth(self, root):\n        # Base case...\n        # If the subtree is empty i.e. root is NULL, return depth as 0...\n        if root is None:  return 0\n        # Initialize the depth of two subtrees...\n        leftDepth = self.minDepth(root.left)\n        rightDepth = self.minDepth(root.right)\n        # If the both subtrees are empty...\n        if root.left is None and root.right is None:\n            return 1\n        # If the left subtree is empty, return the depth of right subtree after adding 1 to it...\n        if root.left is None:\n            return 1 + rightDepth\n        # If the right subtree is empty, return the depth of left subtree after adding 1 to it...\n        if root.right is None:\n            return 1 + leftDepth\n        # When the two child function return its depth...\n        # Pick the minimum out of these two subtrees and return this value after adding 1 to it...\n        return min(leftDepth, rightDepth) + 1;    # Adding 1 is the current node which is the parent of the two subtrees...",
                "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/2429057/very-easy-100-fully-explained-c-java-python-js-c-python3/",
                "vote_count": "70"
            },
            {
                "language": "kotlin",
                "code": "var minDepth = function(root) {\n    // Base case...\n    // If the subtree is empty i.e. root is NULL, return depth as 0...\n    if(root == null)  return 0;\n    // If the both subtrees are empty...\n    if(root.left == null && root.right == null)\n        return 1;\n    // If the left subtree is empty, return the depth of right subtree after adding 1 to it...\n    if(root.left == null)\n        return 1 + minDepth(root.right);\n    // If the right subtree is empty, return the depth of left subtree after adding 1 to it...\n    if(root.right == null)\n        return 1 + minDepth(root.left);\n    // When the two child function return its depth...\n    // Pick the minimum out of these two subtrees and return this value after adding 1 to it...\n    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;    // Adding 1 is the current node which is the parent of the two subtrees...\n};",
                "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/2429057/very-easy-100-fully-explained-c-java-python-js-c-python3/",
                "vote_count": "70"
            },
            {
                "language": "cpp",
                "code": "int minDepth(struct TreeNode* root){\n    if(root == NULL)\n        return 0;\n    else {\n        int leftDepth = minDepth(root->left);\n        int rightDepth = minDepth(root->right);\n        if(leftDepth > rightDepth)\n            return rightDepth + 1;\n        else\n            return leftDepth + 1;\n    }\n}",
                "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/2429057/very-easy-100-fully-explained-c-java-python-js-c-python3/",
                "vote_count": "70"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def minDepth(self, root: Optional[TreeNode]) -> int:\n        # Base case...\n        # If the subtree is empty i.e. root is NULL, return depth as 0...\n        if root is None:  return 0\n        # Initialize the depth of two subtrees...\n        leftDepth = self.minDepth(root.left)\n        rightDepth = self.minDepth(root.right)\n        # If the both subtrees are empty...\n        if root.left is None and root.right is None:\n            return 1\n        # If the left subtree is empty, return the depth of right subtree after adding 1 to it...\n        if root.left is None:\n            return 1 + rightDepth\n        # If the right subtree is empty, return the depth of left subtree after adding 1 to it...\n        if root.right is None:\n            return 1 + leftDepth\n        # When the two child function return its depth...\n        # Pick the minimum out of these two subtrees and return this value after adding 1 to it...\n        return min(leftDepth, rightDepth) + 1;    # Adding 1 is the current node which is the parent of the two subtrees...",
                "url": "https://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/2429057/very-easy-100-fully-explained-c-java-python-js-c-python3/",
                "vote_count": "70"
            }
        ]
    },
    "111": {
        "question_id": 112,
        "title": "Path Sum",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/path-sum",
        "description": "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.A leaf is a node with no children. ",
        "examples": [
            {
                "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22",
                "output": "true",
                "explanation": "The root-to-leaf path with the target sum is shown."
            },
            {
                "input": "root = [1,2,3], targetSum = 5",
                "output": "false",
                "explanation": "There two root-to-leaf paths in the tree:\n(1 --> 2): The sum is 3.\n(1 --> 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5."
            },
            {
                "input": "root = [], targetSum = 0",
                "output": "false",
                "explanation": "Since the tree is empty, there are no root-to-leaf paths."
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [0, 5000].",
            "-1000 <= Node.val <= 1000",
            "-1000 <= targetSum <= 1000"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool rootToLeafPathSum(TreeNode* root, int targetSum, int sum){\n        if(root == nullptr)\n            return false;\n        if(root -> left == nullptr && root -> right == nullptr){\n            sum = sum + root -> val;\n            if(sum == targetSum)\n                return true;   \n        }\n        return rootToLeafPathSum(root -> left, targetSum, sum + root -> val) || rootToLeafPathSum(root -> right, targetSum, sum + root -> val);\n    }\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        int sum = 0;\n        return rootToLeafPathSum(root, targetSum, sum);\n    }\n};",
                "url": "https://leetcode.com/problems/path-sum/solutions/3096296/easiest-beginner-friendly-sol-recursion-o-n-time-and-o-h-space/",
                "vote_count": "58"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum)\n    {\n        if(root == NULL)\n        {\n            return false;\n        }\n        if(root->left == NULL && root->right == NULL && root->val - targetSum == 0)\n        {\n            return true;\n        }\n        \n        bool left = hasPathSum(root->left,targetSum - root->val);\n        bool right = hasPathSum(root->right,targetSum - root->val);\n        \n        return left || right;\n    }\n};",
                "url": "https://leetcode.com/problems/path-sum/solutions/2658162/c-beats-95-easy-explained-optimized/",
                "vote_count": "50"
            },
            {
                "language": "kotlin",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        if(!root)\n            return false;\n        if(!root->left && !root->right && root->val==targetSum)\n            return true;\n        else\n            return hasPathSum(root->left, targetSum-root->val) ||\n            hasPathSum(root->right, targetSum-root->val);\n    }\n};",
                "url": "https://leetcode.com/problems/path-sum/solutions/3054429/accepted-easy-solution-short-simple-best-method/",
                "vote_count": "28"
            }
        ]
    },
    "112": {
        "question_id": 113,
        "title": "Path Sum II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/path-sum-ii",
        "description": "Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children. ",
        "examples": [
            {
                "input": "root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22",
                "output": "[[5,4,11,2],[5,8,4,5]]",
                "explanation": "There are two paths whose sum equals targetSum:\n5 + 4 + 11 + 2 = 22\n5 + 8 + 4 + 5 = 22"
            },
            {
                "input": "root = [1,2,3], targetSum = 5",
                "output": "[]",
                "explanation": null
            },
            {
                "input": "root = [1,2], targetSum = 0",
                "output": "[]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [0, 5000].",
            "-1000 <= Node.val <= 1000",
            "-1000 <= targetSum <= 1000"
        ],
        "solutions": [
            {
                "language": "kotlin",
                "code": "class Solution:\n    def pathSum(self, root: TreeNode, target_sum: int) -> List[List[int]]:\n        output, stack = [], []\n        if root:\n            stack.append((root, root.val, [root.val]))\n        while stack:\n            cur_node, cur_sum, path = stack.pop()\n            \n.val]))\nval]))",
                "url": "https://leetcode.com/problems/path-sum-ii/solutions/1382332/c-python-dfs-clean-concise-time-complexity-explained/",
                "vote_count": "235"
            },
            {
                "language": "python",
                "code": "def dfs(root, sum, path):\n  if not root:\n     if currSum == targetSum:\n       results.append(currPath)\n     return",
                "url": "https://leetcode.com/problems/path-sum-ii/solutions/1382332/c-python-dfs-clean-concise-time-complexity-explained/",
                "vote_count": "235"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> ans;\n    \n    // the idea is to use dfs to traverse the tree from all root to leaf paths\n    // `path` is used to store the current route \n    // `remainingSum` is used to store thre remaining sum that we need with the initial value `targetSum`.\n    //  we substract it from the node value when we traverse down the tree\n    // if we arrive the leaf and the the remaining sum is eqaul to leaf node value\n    // then we can add `path` to ans\n    // e.g. path = [5,4,11,2] and remainingSum = targetSum = 22\n    // traverse node 5, remainingSum = 22 - 5 = 17\n    // traverse node 4, remainingSum = 17 - 4 = 13\n    // traverse node 11, remainingSum = 13 - 11 = 2\n    // traverse node 2, remainingSum = 2 - 2 = 0\n    // remainingSum is 0 which means the sum of current path is eqaul to targetSum\n    // so how to find another path?\n    // we can backtrack here\n    // we can pop back a node and try another\n    // e.g. path = [5, 4, 11, 7]\n    // pop 7 out = [5, 4, 11]\n    // push 2 = [5, 4, 11, 2]\n    // ... etc\n    void dfs(TreeNode* node, vector<int>& path, int remainingSum) {\n        // if it is nullptr, then return\n        if (!node) return;\n        // add the current node val to path\n        path.push_back(node-> val);\n        // !node->left && !node->right : check if it is a leaf node\n        // remainingSum == node->val: check if the remaining sum - node->val == 0\n        // if both condition is true, then we find one of the paths\n        if (!node->left && !node->right && remainingSum == node->val) ans.push_back(path);\n        // traverse left sub tree with updated remaining sum\n        // we don't need to check if left sub tree is nullptr or not\n        // as we handle it in the first line of this function\n        dfs(node-> left, path, remainingSum - node-> val);\n        // traverse right sub tree with updated remaining sum\n        // we don't need to check if right sub tree is nullptr or not\n        // as we handle it in the first line of this function\n        dfs(node-> right, path, remainingSum - node-> val);\n        // backtrack \n        path.pop_back();\n    }\n    \n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\n        // used to store current route\n        vector<int> path;\n        // dfs from the root\n        dfs(root, path, targetSum);\n        return ans;  \n    }\n};",
                "url": "https://leetcode.com/problems/path-sum-ii/solutions/2615948/leetcode-the-hard-way-explained-line-by-line/",
                "vote_count": "57"
            },
            {
                "language": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # the idea is to use dfs to traverse the tree from all root to leaf paths\n    # `path` is used to store the current route \n    # `remainingSum` is used to store thre remaining sum that we need with the initial value `targetSum`.\n    #  we substract it from the node value when we traverse down the tree\n    # if we arrive the leaf and the the remaining sum is eqaul to leaf node value\n    # then we can add `path` to ans\n    # e.g. path = [5,4,11,2] and remainingSum = targetSum = 22\n    # traverse node 5, remainingSum = 22 - 5 = 17\n    # traverse node 4, remainingSum = 17 - 4 = 13\n    # traverse node 11, remainingSum = 13 - 11 = 2\n    # traverse node 2, remainingSum = 2 - 2 = 0\n    # remainingSum is 0 which means the sum of current path is eqaul to targetSum\n    # so how to find another path?\n    # we can backtrack here\n    # we can pop back a node and try another\n    # e.g. path = [5, 4, 11, 7]\n    # pop 7 out = [5, 4, 11]\n    # push 2 = [5, 4, 11, 2]\n    # ... etc\n    def dfs(self, root, path, ans, remainingSum):\n        # if it is None, then return\n        if not root:\n            return\n        # add the current node val to path\n        path.append(root.val)\n        # !node.left && !node.right : check if it is a leaf node\n        # remainingSum == node.val: check if the remaining sum - node.val == 0\n        # if both condition is true, then we find one of the paths\n        if not root.left and not root.right and remainingSum == root.val:\n            ans.append(list(path))\n        # traverse left sub tree with updated remaining sum\n        # we don't need to check if left sub tree is nullptr or not\n        # as we handle it in the first line of this function\n        self.dfs(root.left, path, ans, remainingSum - root.val)\n        # traverse right sub tree with updated remaining sum\n        # we don't need to check if right sub tree is nullptr or not\n        # as we handle it in the first line of this function\n        self.dfs(root.right, path, ans, remainingSum - root.val)\n        # backtrack \n        path.pop()\n    \n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\n        ans = []\n        self.dfs(root, [], ans, targetSum)\n        return ans\n            ",
                "url": "https://leetcode.com/problems/path-sum-ii/solutions/2615948/leetcode-the-hard-way-explained-line-by-line/",
                "vote_count": "57"
            },
            {
                "language": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    List<List<Integer>> ans = new ArrayList<List<Integer>>();\n    // the idea is to use dfs to traverse the tree from all root to leaf paths\n    // `path` is used to store the current route \n    // `remainingSum` is used to store thre remaining sum that we need with the initial value `targetSum`.\n    //  we substract it from the node value when we traverse down the tree\n    // if we arrive the leaf and the the remaining sum is eqaul to leaf node value\n    // then we can add `path` to ans\n    // e.g. path = [5,4,11,2] and remainingSum = targetSum = 22\n    // traverse node 5, remainingSum = 22 - 5 = 17\n    // traverse node 4, remainingSum = 17 - 4 = 13\n    // traverse node 11, remainingSum = 13 - 11 = 2\n    // traverse node 2, remainingSum = 2 - 2 = 0\n    // remainingSum is 0 which means the sum of current path is eqaul to targetSum\n    // so how to find another path?\n    // we can backtrack here\n    // we can pop back a node and try another\n    // e.g. path = [5, 4, 11, 7]\n    // pop 7 out = [5, 4, 11]\n    // push 2 = [5, 4, 11, 2]\n    // ... etc\n    private void dfs(TreeNode node, List<Integer> path, int remainingSum) {\n        // if it is null, then return\n        if (node == null) return;\n        // add the current node val to path\n        path.add(node.val);\n        // !node.left && !node.right : check if it is a leaf node\n        // remainingSum == node.val: check if the remaining sum - node.val == 0\n        // if both condition is true, then we find one of the paths\n        if (node.left == null && node.right == null && remainingSum == node.val) ans.add(new ArrayList<>(path));\n        // traverse left sub tree with updated remaining sum\n        // we don't need to check if left sub tree is nullptr or not\n        // as we handle it in the first line of this function\n        this.dfs(node.left, path, remainingSum - node.val);\n        // traverse right sub tree with updated remaining sum\n        // we don't need to check if right sub tree is nullptr or not\n        // as we handle it in the first line of this function\n        this.dfs(node.right, path, remainingSum - node.val);\n        // backtrack \n        path.remove(path.size() - 1);\n    }\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n        List<Integer> path = new ArrayList<Integer>();\n        dfs(root, path, targetSum);\n        return ans;\n    }\n}",
                "url": "https://leetcode.com/problems/path-sum-ii/solutions/2615948/leetcode-the-hard-way-explained-line-by-line/",
                "vote_count": "57"
            },
            {
                "language": "go",
                "code": "ans.append(list(path))",
                "url": "https://leetcode.com/problems/path-sum-ii/solutions/2615948/leetcode-the-hard-way-explained-line-by-line/",
                "vote_count": "57"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n\npublic:\n    vector<vector<int>> answer;\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\n        vector<int> path;\n        dfs(root, targetSum, path);// using dfs to traverse on each node\n        return answer;\n    }\n    void dfs(TreeNode* root, int newtarget, vector<int>& path) {\n        if (!root) return; // if current root is null return\n        path.push_back(root->val);\n        newtarget -= root->val; // new target will be the privious target- the value of that node\n        if (!root->left && !root->right) { // check whether it is a leaf node or not\n            if (newtarget == 0) // if we get valid path, pushback in our answer\n                answer.push_back(path);\n        } else {\n            dfs(root->left, newtarget, path);\n            dfs(root->right, newtarget, path);\n        }\n        path.pop_back(); // for the backtracking\n    }\n};",
                "url": "https://leetcode.com/problems/path-sum-ii/solutions/2616083/short-c-explained-solution-beginner-friendly-by-mr-coder/",
                "vote_count": "48"
            },
            {
                "language": "erlang",
                "code": " PLEASE UPVOTE IF YOU LIKE.",
                "url": "https://leetcode.com/problems/path-sum-ii/solutions/2616699/java-detailed-explanation-100-faster-code-easy-solution/",
                "vote_count": "36"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n        List<Integer> currentPath = new ArrayList();\n        List<List<Integer>> allPaths = new ArrayList();\n        findPathsRecursive(root,targetSum,currentPath,allPaths);\n        return allPaths;\n    }\n    private static void findPathsRecursive(TreeNode currentNode, int sum, List<Integer> currentPath,List<List<Integer>> allPaths){\n         if(currentNode==null)return;\n         // add the current node to the path\n         currentPath.add(currentNode.val);\n         // if the current node is a leaf and its value is equal to sum, save the current path\n         if(currentNode.val==sum && currentNode.left==null && currentNode.right==null)\n             allPaths.add(new ArrayList<Integer>(currentPath));\n         else{\n             // traverse the left sub-tree\n             findPathsRecursive(currentNode.left,sum-currentNode.val,currentPath,allPaths);\n             // traverse the right sub-tree\n             findPathsRecursive(currentNode.right,sum-currentNode.val,currentPath,allPaths);\n         }\n         // remove the current node from the path to backtrack, \n         // we need to remove the current node while we are going up the recursive call stack.\n         currentPath.remove(currentPath.size()-1);\n      }\n\n}",
                "url": "https://leetcode.com/problems/path-sum-ii/solutions/2616699/java-detailed-explanation-100-faster-code-easy-solution/",
                "vote_count": "36"
            },
            {
                "language": "csharp",
                "code": "    List<List<Integer>> ans = new ArrayList<>();\n    pathSumHelper(root, targetSum, 0, ans, new ArrayList<>());\n    return ans;\n}\n\npublic void pathSumHelper(TreeNode root, int targetSum, int sum, List<List<Integer>> ans, List<Integer> path) {\n    if(root==null){",
                "url": "https://leetcode.com/problems/path-sum-ii/solutions/2616699/java-detailed-explanation-100-faster-code-easy-solution/",
                "vote_count": "36"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    vector<vector<int>> ans;\n    vector<int> path;\n    \n    void dfs(TreeNode* root, int current, int target) {\n        if(!root) {\n            return;\n        }\n        \n        current += root->val;\n        path.push_back(root->val);\n        \n  // When we reach at leaf node, we have to check if current sum is equal to target\n        if(current == target && !root->left && !root->right) {\n            ans.push_back(path);\n        }    \n        \n        dfs(root->left, current, target);\n        dfs(root->right, current, target);\n        \n        path.pop_back();\n    }\n    \n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\n        dfs(root, 0, targetSum);\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/path-sum-ii/solutions/2616034/c-dfs-related-problems/",
                "vote_count": "23"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/path-sum-ii/solutions/2616034/c-dfs-related-problems/",
                "vote_count": "23"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/path-sum-ii/solutions/2616034/c-dfs-related-problems/",
                "vote_count": "23"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/path-sum-ii/solutions/2616034/c-dfs-related-problems/",
                "vote_count": "23"
            }
        ]
    },
    "113": {
        "question_id": 114,
        "title": "Flatten Binary Tree to Linked List",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list",
        "description": "Given the root of a binary tree, flatten the tree into a \"linked list\":The \"linked list\" should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.The \"linked list\" should be in the same order as a pre-order traversal of the binary tree. ",
        "examples": [
            {
                "input": "root = [1,2,5,3,4,null,6]",
                "output": "[1,null,2,null,3,null,4,null,5,null,6]",
                "explanation": null
            },
            {
                "input": "root = []",
                "output": "[]",
                "explanation": null
            },
            {
                "input": "root = [0]",
                "output": "[0]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [0, 2000].",
            "-100 <= Node.val <= 100"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "private TreeNode prev = null;\n\npublic void flatten(TreeNode root) {\n    if (root == null)\n        return;\n    flatten(root.right);\n    flatten(root.left);\n    root.right = prev;\n    root.left = null;\n    prev = root;\n}",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/36977/my-short-post-order-traversal-java-solution-for-share/",
                "vote_count": "1817"
            },
            {
                "language": "",
                "code": "1\n \\\n  2\n   \\\n    3\n     \\\n      4",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/36977/my-short-post-order-traversal-java-solution-for-share/",
                "vote_count": "1817"
            },
            {
                "language": "",
                "code": "",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/36977/my-short-post-order-traversal-java-solution-for-share/",
                "vote_count": "1817"
            },
            {
                "language": "typescript",
                "code": "",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/36977/my-short-post-order-traversal-java-solution-for-share/",
                "vote_count": "1817"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/36977/my-short-post-order-traversal-java-solution-for-share/",
                "vote_count": "1817"
            },
            {
                "language": "",
                "code": "    1\n   / \\\n  2   5\n / \\   \\\n3   4   6\n-----------        \npre = 5\ncur = 4",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/36977/my-short-post-order-traversal-java-solution-for-share/",
                "vote_count": "1817"
            },
            {
                "language": "typescript",
                "code": "public void flatten(TreeNode root) {\n    flatten(root,null);\n}\nprivate TreeNode flatten(TreeNode root, TreeNode pre) {\n    if(root==null) return pre;\n    pre=flatten(root.right,pre);    \n    pre=flatten(root.left,pre);",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/36977/my-short-post-order-traversal-java-solution-for-share/",
                "vote_count": "1817"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/36977/my-short-post-order-traversal-java-solution-for-share/",
                "vote_count": "1817"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/36977/my-short-post-order-traversal-java-solution-for-share/",
                "vote_count": "1817"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/36977/my-short-post-order-traversal-java-solution-for-share/",
                "vote_count": "1817"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    //version that uses the global variable\n    // private TreeNode prev = null;\n    // public void flatten(TreeNode root) {\n    //     if (root == null)\n    //         return;\n    //     flatten(root.right);\n    //     flatten(root.left);",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/36977/my-short-post-order-traversal-java-solution-for-share/",
                "vote_count": "1817"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    void flatten(TreeNode *root) {\n  TreeNode*now = root;\n  while (now)\n  {\n   if(now->left)\n   {\n                //Find current node's prenode that links to current node's right subtree\n    TreeNode* pre = now->left;\n    while(pre->right)\n    {\n     pre = pre->right;\n    }\n    pre->right = now->right;\n                //Use current node's left subtree to replace its right subtree(original right \n                //subtree is already linked by current node's prenode\n    now->right = now->left;\n    now->left = NULL;\n   }\n   now = now->right;\n  }\n    }\n};",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/37010/share-my-simple-non-recursive-solution-o-1-space-complexity/",
                "vote_count": "708"
            },
            {
                "language": "java",
                "code": "public void flatten(TreeNode root) {\n TreeNode cur = root;\n while (cur != null) {\n  if (cur.left != null) {\n   TreeNode last = cur.left;\n   while (last.right != null) last = last.right;\n   last.right = cur.right;",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/37010/share-my-simple-non-recursive-solution-o-1-space-complexity/",
                "vote_count": "708"
            },
            {
                "language": "kotlin",
                "code": "public class Solution {\n    public void flatten(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        if (root.left == null && root.right == null) {\n            return;\n        }",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/37010/share-my-simple-non-recursive-solution-o-1-space-complexity/",
                "vote_count": "708"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n# @param root, a tree node\n# @return nothing, do it in place\ndef flatten(self, root):\n    if not root:\n        return\n    \n    # using Morris Traversal of BT",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/37010/share-my-simple-non-recursive-solution-o-1-space-complexity/",
                "vote_count": "708"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public void flatten(TreeNode root) {\n      while(root != null){\n          if(root.left != null){\n              TreeNode prev = root.left;\n              while(prev.right != null){\n                  prev = prev.right;\n              }",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/37010/share-my-simple-non-recursive-solution-o-1-space-complexity/",
                "vote_count": "708"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def flatten(self, root: TreeNode) -> None:\n        curr = root\n        \n        while curr:\n            if curr.left != None:\n                p = curr.left\n                while p.right != None:\n                    p = p.right\n                    \n                p.right = curr.right\n                \n                curr.right = curr.left\n                curr.left = None\n            \n            curr = curr.right",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/1208004/extremely-intuitive-o-1-space-solution-with-simple-explanation-python/",
                "vote_count": "261"
            },
            {
                "language": "java",
                "code": "    public void flatten(TreeNode root) {\n        TreeNode cur = root;\n        TreeNode prev = null;\n        while (cur != null) {            \n            if (cur.left != null) {\n                prev = cur.left;\n                while (prev.right != null) {",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/1208004/extremely-intuitive-o-1-space-solution-with-simple-explanation-python/",
                "vote_count": "261"
            },
            {
                "language": "javascript",
                "code": "var flatten = function(root) {\n    let curr = root\n    while (curr) {\n        if (curr.left) {\n            let runner = curr.left\n            while (runner.right) runner = runner.right\n            runner.right = curr.right, curr.right = curr.left, curr.left = null\n        }\n        curr = curr.right\n    }\n};",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/1207642/js-python-java-c-simple-o-1-space-recursive-solutions-w-explanation/",
                "vote_count": "220"
            },
            {
                "language": "csharp",
                "code": "var flatten = function(root) {\n    let head = null, curr = root\n    while (head != root) {\n        if (curr.right === head) curr.right = null\n        if (curr.left === head) curr.left = null\n        if (curr.right) curr = curr.right\n        else if (curr.left) curr = curr.left\n        else curr.right = head, head = curr, curr = root\n    }\n};",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/1207642/js-python-java-c-simple-o-1-space-recursive-solutions-w-explanation/",
                "vote_count": "220"
            },
            {
                "language": "javascript",
                "code": "var flatten = function(root) {\n    let head = null\n    const revPreOrder = node => {\n        if (node.right) revPreOrder(node.right)\n        if (node.left) revPreOrder(node.left)\n        node.left = null, node.right = head, head = node\n    }\n    if (root) revPreOrder(root)\n};",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/1207642/js-python-java-c-simple-o-1-space-recursive-solutions-w-explanation/",
                "vote_count": "220"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def flatten(self, root: TreeNode) -> None:\n        curr = root\n        while curr:\n            if curr.left:\n                runner = curr.left\n                while runner.right: runner = runner.right\n                runner.right, curr.right, curr.left = curr.right, curr.left, None\n            curr = curr.right",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/1207642/js-python-java-c-simple-o-1-space-recursive-solutions-w-explanation/",
                "vote_count": "220"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def flatten(self, root: TreeNode) -> None:\n        head, curr = None, root\n        while head != root:\n            if curr.right == head: curr.right = None\n            if curr.left == head: curr.left = None\n            if curr.right: curr = curr.right\n            elif curr.left: curr = curr.left\n            else: curr.right, head, curr = head, curr, root",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/1207642/js-python-java-c-simple-o-1-space-recursive-solutions-w-explanation/",
                "vote_count": "220"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    head = None\n    def flatten(self, root: TreeNode) -> None:\n        def revPreOrder(node: TreeNode) -> None:\n            if node.right: revPreOrder(node.right)\n            if node.left: revPreOrder(node.left)\n            node.left, node.right, self.head = None, self.head, node\n        if root: revPreOrder(root)",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/1207642/js-python-java-c-simple-o-1-space-recursive-solutions-w-explanation/",
                "vote_count": "220"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public void flatten(TreeNode root) {\n        TreeNode curr = root;\n        while (curr != null) {\n            if (curr.left != null) {\n                TreeNode runner = curr.left;\n                while (runner.right != null) runner = runner.right;\n                runner.right = curr.right;\n                curr.right = curr.left;\n                curr.left = null;\n            }\n            curr = curr.right;\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/1207642/js-python-java-c-simple-o-1-space-recursive-solutions-w-explanation/",
                "vote_count": "220"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public void flatten(TreeNode root) {\n        TreeNode head = null, curr = root;\n        while (head != root) {\n            if (curr.right == head) curr.right = null;\n            if (curr.left == head) curr.left = null;\n            if (curr.right != null) curr = curr.right;\n            else if (curr.left != null) curr = curr.left;\n            else {\n                curr.right = head;\n                head = curr;\n                curr = root;\n            }\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/1207642/js-python-java-c-simple-o-1-space-recursive-solutions-w-explanation/",
                "vote_count": "220"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    TreeNode head = null;\n    public void flatten(TreeNode root) {\n        if (root != null) revPreOrder(root);\n    }\n    private void revPreOrder(TreeNode node) {\n        if (node.right != null) revPreOrder(node.right);\n        if (node.left != null) revPreOrder(node.left);\n        node.left = null;\n        node.right = head;\n        head = node;\n    }\n}",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/1207642/js-python-java-c-simple-o-1-space-recursive-solutions-w-explanation/",
                "vote_count": "220"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode* curr = root;\n        while (curr) {\n            if (curr->left) {\n                TreeNode* runner = curr->left;\n                while (runner->right != nullptr) runner = runner->right;\n                runner->right = curr->right, curr->right = curr->left, curr->left = nullptr;\n            }\n            curr = curr->right;\n        }\n    }\n};",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/1207642/js-python-java-c-simple-o-1-space-recursive-solutions-w-explanation/",
                "vote_count": "220"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode *head = nullptr, *curr = root;\n        while (head != root) {\n            if (curr->right == head) curr->right = nullptr;\n            if (curr->left == head) curr->left = nullptr;\n            if (curr->right) curr = curr->right;\n            else if (curr->left) curr = curr->left;\n            else curr->right = head, head = curr, curr = root;\n        }\n    }\n};",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/1207642/js-python-java-c-simple-o-1-space-recursive-solutions-w-explanation/",
                "vote_count": "220"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void flatten(TreeNode* root) {\n        if (root) revPreOrder(root);\n    }\nprivate:\n    TreeNode* head = nullptr;\n    void revPreOrder(TreeNode* node) {\n        if (node->right) revPreOrder(node->right);\n        if (node->left) revPreOrder(node->left);\n        node->left = nullptr, node->right = head, head = node;\n    }\n};",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/1207642/js-python-java-c-simple-o-1-space-recursive-solutions-w-explanation/",
                "vote_count": "220"
            },
            {
                "language": "cpp",
                "code": "vector[i] -> right = vector[i+1];\nvector[i] -> left = NULL;",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/2338791/c-explained/",
                "vote_count": "144"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    \n    TreeNode* rightmost(TreeNode* root){\n        if (root->right==NULL) return root;\n        return rightmost(root->right);\n    }\n    \n    void flatten(TreeNode* root) {\n        if (root==NULL) return;\n        TreeNode* nextright;\n        TreeNode* rightMOST;\n        \n        while (root){\n            \n            if (root->left){\n                rightMOST = rightmost(root->left);\n                nextright = root->right;\n                root->right = root->left;\n                root->left=NULL;\n                rightMOST->right=nextright;\n            }\n            root=root->right;\n        }\n    }\n};",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/2338791/c-explained/",
                "vote_count": "144"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    TreeNode prev=null;\n    public void flatten(TreeNode root) {\n         if(root==null)\n            return;\n        flatten(root.right);//traverse till right most.\n        flatten(root.left);//got to left of right most\n       root.left=null;//set left as null\n        root.right=prev;//set right to previously traversed node\n        prev=root;  //set prev to current node.\n    }\n    \n    \n}",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/2338861/java-easy-solution-with-explanation/",
                "vote_count": "38"
            },
            {
                "language": "javascript",
                "code": "Input: root = [1,2,5,3,4,null,6]\nOutput: [1,null,2,null,3,null,4,null,5,null,6]",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/2338948/explanation-so-far/",
                "vote_count": "28"
            },
            {
                "language": "python",
                "code": "The first method We gonna use is # RECURSION",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/2338948/explanation-so-far/",
                "vote_count": "28"
            },
            {
                "language": "rust",
                "code": "So, for that one what we gonna do is, instead of removing and attaching every single time, we gonna have 2 trees\n> Left temporary tree\n> Right temporary tree\nAnd we gonna flatten these 2 trees and attach to right. \nTo flatten them we gonna use the help of recursion.",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/2338948/explanation-so-far/",
                "vote_count": "28"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public void flatten(TreeNode root) {\n        if(root == null) return;\n        // step-1\n        TreeNode Left = root.left;\n        TreeNode Right = root.right;\n  \n        // step-2\n        root.left = null;\n  \n        // step-3\n        flatten(Left);\n        flatten(Right);\n        root.right = Left;\n        TreeNode curr = root;\n  \n        // step-4\n        while(curr.right != null) curr = curr.right;\n  \n        // step-5\n        curr.right = Right;\n    }\n}",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/2338948/explanation-so-far/",
                "vote_count": "28"
            },
            {
                "language": "python",
                "code": "# Morris Traversal",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/2338948/explanation-so-far/",
                "vote_count": "28"
            },
            {
                "language": "rust",
                "code": "> So, in this we start from root.\n> Then we check if it's left doesn't pointing to null, then go to it's right most node and attach it's right to become the root of my tree\n> Let's see what I'm talking about.",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/2338948/explanation-so-far/",
                "vote_count": "28"
            },
            {
                "language": "rust",
                "code": "> After doing that, I'll remove the root pointer and left of my root becomes null & right of my root will become this left tree.\n> Let's see how's it goes like,",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/2338948/explanation-so-far/",
                "vote_count": "28"
            },
            {
                "language": "rust",
                "code": "Now, again we going to repeat the same process,\n> Check left,\n> If not null, go to it's right most child\n> Connect it root to right\n> Connect the whole left to root->right\n> Make root->left = null\n> Update root to root->right",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/2338948/explanation-so-far/",
                "vote_count": "28"
            },
            {
                "language": "rust",
                "code": "And we'll complete the process till the end, although \"3\" doesn't have it's left but we still go to it's right and complete the process till the end. ",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/2338948/explanation-so-far/",
                "vote_count": "28"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public void flatten(TreeNode root) {\n        if(root == null) return;\n        while(root != null){\n            if(root.left != null) {\n                TreeNode Left = root.left;\n                TreeNode curr = Left;\n                while(curr.right != null) curr = curr.right;\n                curr.right = root.right;  // Morris Traversal main step\n                root.left =null;\n                root.right = Left;\n            }\n            root = root.right;  \n        }\n    }\n}",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/2338948/explanation-so-far/",
                "vote_count": "28"
            },
            {
                "language": "rust",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/2338948/explanation-so-far/",
                "vote_count": "28"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/2338948/explanation-so-far/",
                "vote_count": "28"
            }
        ]
    },
    "114": {
        "question_id": 115,
        "title": "Distinct Subsequences",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/distinct-subsequences",
        "description": "Given two strings s and t, return the number of distinct subsequences of s which equals t.The test cases are generated so that the answer fits on a 32-bit signed integer. ",
        "examples": [
            {
                "input": "s = \"rabbbit\", t = \"rabbit\"",
                "output": "3\nExplanation:\nAs shown below, there are 3 ways you can generate \"rabbit\" from s.\nrabbbit\nrabbbit\nrabbbit",
                "explanation": null
            },
            {
                "input": "s = \"babgbag\", t = \"bag\"",
                "output": "5\nExplanation:\nAs shown below, there are 5 ways you can generate \"bag\" from s.\nbabgbag\nbabgbag\nbabgbag\nbabgbag\nbabgba",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= s.length, t.length <= 1000",
            "s and t consist of English letters."
        ],
        "solutions": [
            {
                "language": "",
                "code": "  S 0123....j\nT +----------+\n  |1111111111|\n0 |0         |\n1 |0         |\n2 |0         |\n. |0         |\n. |0         |\ni |0         |",
                "url": "https://leetcode.com/problems/distinct-subsequences/solutions/37327/easy-to-understand-dp-in-java/",
                "vote_count": "648"
            },
            {
                "language": "",
                "code": "           *  *\n      S = [acdabefbc]\nmem[1] = [0111222222]",
                "url": "https://leetcode.com/problems/distinct-subsequences/solutions/37327/easy-to-understand-dp-in-java/",
                "vote_count": "648"
            },
            {
                "language": "",
                "code": "               *  * ]\n      S = [acdabefbc]\nmem[1] = [0111222222]\nmem[2] = [0000022244]",
                "url": "https://leetcode.com/problems/distinct-subsequences/solutions/37327/easy-to-understand-dp-in-java/",
                "vote_count": "648"
            },
            {
                "language": "",
                "code": "      S = [a   b    ]\n      S = [a      b ]\n      S = [   ab    ]\n      S = [   a   b ]",
                "url": "https://leetcode.com/problems/distinct-subsequences/solutions/37327/easy-to-understand-dp-in-java/",
                "vote_count": "648"
            },
            {
                "language": "cpp",
                "code": "public int numDistinct(String S, String T) {\n    // array creation\n    int[][] mem = new int[T.length()+1][S.length()+1];\n\n    // filling the first row: with 1s\n    for(int j=0; j<=S.length(); j++) {\n        mem[0][j] = 1;\n    }\n    \n    // the first column is 0 by default in every other rows but the first, which we need.\n    \n    for(int i=0; i<T.length(); i++) {\n        for(int j=0; j<S.length(); j++) {\n            if(T.charAt(i) == S.charAt(j)) {\n                mem[i+1][j+1] = mem[i][j] + mem[i+1][j];\n            } else {\n                mem[i+1][j+1] = mem[i+1][j];\n            }\n        }\n    }\n    \n    return mem[T.length()][S.length()];\n}",
                "url": "https://leetcode.com/problems/distinct-subsequences/solutions/37327/easy-to-understand-dp-in-java/",
                "vote_count": "648"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/distinct-subsequences/solutions/37327/easy-to-understand-dp-in-java/",
                "vote_count": "648"
            },
            {
                "language": "cpp",
                "code": "public int numDistinct(String s, String t) {\n        int m = s.length(), n = t.length();\n        int[][] dp = new int[m + 1][n + 1];\n        // initialize the dp value when t is an empty string, number of subsequence of an empty string should be 1\n        for(int i = 0; i < m; i ++){\n            dp[i][0] = 1;\n        }",
                "url": "https://leetcode.com/problems/distinct-subsequences/solutions/37327/easy-to-understand-dp-in-java/",
                "vote_count": "648"
            },
            {
                "language": "",
                "code": "              *  * \n      S = [acdabefbc]\nmem[1] = [0111222222]\nmem[2] = [00000222_ ]",
                "url": "https://leetcode.com/problems/distinct-subsequences/solutions/37327/easy-to-understand-dp-in-java/",
                "vote_count": "648"
            },
            {
                "language": "java",
                "code": "public int numDistinct(String s, String t) {\n        if(s == null || t == null) return 0;\n        int[][] mem = new int[s.length() + 1][t.length() + 1];\n        for(int i = 0;i<= s.length(); i++) Arrays.fill(mem[i], -1);\n        return backtrack(s,t,mem,0,0);\n    }\n    private int backtrack(String s, String t, int[][] mem, int sStart, int tStart){\n        if(mem[sStart][tStart] != -1) return mem[sStart][tStart];\n,sStart+ 1, tStart + 1);",
                "url": "https://leetcode.com/problems/distinct-subsequences/solutions/37327/easy-to-understand-dp-in-java/",
                "vote_count": "648"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/distinct-subsequences/solutions/37327/easy-to-understand-dp-in-java/",
                "vote_count": "648"
            },
            {
                "language": "javascript",
                "code": " For example:\n S = \"aba\"",
                "url": "https://leetcode.com/problems/distinct-subsequences/solutions/37327/easy-to-understand-dp-in-java/",
                "vote_count": "648"
            },
            {
                "language": "cpp",
                "code": "int numDistinct(string s, string t) {\n        int n = s.length(), m = t.length();\n        vector<double>dp(m+1, 0);\n        dp[0] = 1;\n        for(int i = 1; i <= n; i++) {\n            for(int j = m; j > 0; j--) {\n                if(s[i-1] == t[j-1]) dp[j] = dp[j-1] + dp[j];\n            }\n        }\n        return dp[m];    \n    }",
                "url": "https://leetcode.com/problems/distinct-subsequences/solutions/2561368/7-lines-c-solution-of-updated-testcases-better-than-97-of-submissions/",
                "vote_count": "17"
            }
        ]
    },
    "115": {
        "question_id": 116,
        "title": "Populating Next Right Pointers in Each Node",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node",
        "description": "You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:struct Node {  int val;  Node *left;  Node *right;  Node *next;}Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.Initially, all next pointers are set to NULL. ",
        "examples": [
            {
                "input": "root = [1,2,3,4,5,6,7]",
                "output": "[1,#,2,3,#,4,5,6,7,#]",
                "explanation": "Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level."
            },
            {
                "input": "root = []",
                "output": "[]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [0, 2^12 - 1].",
            "-1000 <= Node.val <= 1000",
            "You may only use constant extra space.",
            "The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem."
        ],
        "solutions": [
            {
                "language": "rust",
                "code": "void connect(TreeLinkNode *root) {\n    if (root == NULL) return;\n    TreeLinkNode *pre = root;\n    TreeLinkNode *cur = NULL;\n    while(pre->left) {\n        cur = pre;\n        while(cur) {\n            cur->left->next = cur->right;\n            if(cur->next) cur->right->next = cur->next->left;\n            cur = cur->next;\n        }\n        pre = pre->left;\n    }\n}",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37472/a-simple-accepted-solution/",
                "vote_count": "946"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public Node connect(Node root) {\n        dfs(root, null);        \n        return root;\n    }\n    \n    private void dfs(Node curr, Node next) {\n        if (curr == null) return;",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37472/a-simple-accepted-solution/",
                "vote_count": "946"
            },
            {
                "language": "typescript",
                "code": "public class Solution {\n    public void connect(TreeLinkNode root) {\n        if(root == null || root.left == null) return;\n        connectNodes(root.left, root.right);\n    }\n    \n    public void connectNodes(TreeLinkNode node1, TreeLinkNode node2) {\n        node1.next = node2;",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37472/a-simple-accepted-solution/",
                "vote_count": "946"
            },
            {
                "language": "java",
                "code": "public void connect(TreeLinkNode root) {\n    while(root != null && root.left != null) {\n        TreeLinkNode cur = root;\n        while(cur != null) {\n            cur.left.next = cur.right;\n            cur.right.next = cur.next == null ? null : cur.next.left;\n            cur = cur.next;",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37472/a-simple-accepted-solution/",
                "vote_count": "946"
            },
            {
                "language": "cpp",
                "code": "void connect(TreeLinkNode *root) {\n        if (!root) return; //Edge Case\n        \n        queue<TreeLinkNode*> q;\n        \n        //Trick: Push NULL to maintain depth information",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37472/a-simple-accepted-solution/",
                "vote_count": "946"
            },
            {
                "language": "rust",
                "code": "",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37472/a-simple-accepted-solution/",
                "vote_count": "946"
            },
            {
                "language": "rust",
                "code": "",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37472/a-simple-accepted-solution/",
                "vote_count": "946"
            },
            {
                "language": "java",
                "code": "public void connect(TreeLinkNode root) {\n        if (root == null) return;\n        \n        TreeLinkNode pre = root;\n        \n        TreeLinkNode cur = null;\n        \n        while(pre.left != null) {",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37472/a-simple-accepted-solution/",
                "vote_count": "946"
            },
            {
                "language": "kotlin",
                "code": "public class Solution {\n    public void connect(TreeLinkNode root) {\n        if(root == null) return;\n        if(root.left == null && root.right == null)  return;\n        if(root.left != null && root.right != null)\n            root.left.next = root.right;\n        if(root.next != null)\n            root.right.next = root.next.left;",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37472/a-simple-accepted-solution/",
                "vote_count": "946"
            },
            {
                "language": "java",
                "code": "public void connect(TreeLinkNode root) {\n        if(root == null) return;\n        while(root != null){\n            TreeLinkNode firstNode = root;\n            while(root != null){\n                if(root.left != null) root.left.next = root.right;\n                if(root.right != null && root.next != null) root.right.next = root.next.left;\n                root = root.next;\n            }",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37472/a-simple-accepted-solution/",
                "vote_count": "946"
            },
            {
                "language": "java",
                "code": "public Node connect(Node root) {\n        if(root == null) return root;\n        Node dummy = new Node(0);\n        dummy.next = root;\n        Node pre = root;",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37472/a-simple-accepted-solution/",
                "vote_count": "946"
            },
            {
                "language": "csharp",
                "code": "",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37472/a-simple-accepted-solution/",
                "vote_count": "946"
            },
            {
                "language": "csharp",
                "code": "public Node connect(Node root) {\n        if(root== null) {\n            return root;\n        }\n        Queue<Node> que = new LinkedList();\n        que.offer(root);\n        while(!que.isEmpty()) {\n            int size = que.size();",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37472/a-simple-accepted-solution/",
                "vote_count": "946"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    Node* connect(Node* root) {\n        if(!root) return nullptr;\n        queue<Node*> q;\n        q.push(root);        \n        while(size(q)) {\n            Node* rightNode = nullptr;                    // set rightNode to null initially\n            for(int i = size(q); i; i--) {                // traversing each level\n                auto cur = q.front(); q.pop();            // pop a node from current level and,\n                cur -> next = rightNode;                  // set its next pointer to rightNode\n                rightNode = cur;                          // update rightNode as cur for next iteration\n                if(cur -> right)                          // if a child exists\n                    q.push(cur -> right),                 // IMP: push right first to do right-to-left BFS\n                    q.push(cur -> left);                  // then push left\n            }\n        }\n        return root;\n    }\n};",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1654181/c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs/",
                "vote_count": "758"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def connect(self, root):\n        if not root: return None\n        q = deque([root])\n        while q:\n            rightNode = None\n            for _ in range(len(q)):\n                cur = q.popleft()\n                cur.next, rightNode = rightNode, cur\n                if cur.right:\n                    q.extend([cur.right, cur.left])\n        return root",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1654181/c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs/",
                "vote_count": "758"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public Node connect(Node root) {\n        if(root == null) return null;\n        Queue<Node> q = new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()) {\n            Node rightNode = null;\n            for(int i = q.size(); i > 0; i--) {\n                Node cur = q.poll();\n                cur.next = rightNode;\n                rightNode = cur;\n                if(cur.right != null) {\n                    q.offer(cur.right);\n                    q.offer(cur.left);\n                }\n            }\n        }\n        return root;        \n    }\n}",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1654181/c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs/",
                "vote_count": "758"
            },
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    Node* connect(Node* root) {\n        if(!root) return nullptr;\n        auto L = root -> left, R = root -> right, N = root -> next;\n        if(L) {\n            L -> next = R;                                // next of root's left is assigned as root's right\n            if(N) R -> next = N -> left;                  // next of root's right is assigned as root's next's left (if root's next exist)\n            connect(L);                                   // recurse left  - simple DFS \n            connect(R);                                   // recurse right\n        }\n        return root;\n    }\n};",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1654181/c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs/",
                "vote_count": "758"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def connect(self, root):\n        if not root: return None\n        L, R, N = root.left, root.right, root.next\n        if L:\n            L.next = R\n            if N: R.next = N.left\n            self.connect(L)\n            self.connect(R)\n        return root",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1654181/c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs/",
                "vote_count": "758"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public Node connect(Node root) {\n        if(root == null) return null;\n        Node L = root.left, R = root.right, N = root.next;\n        if(L != null) {\n            L.next = R;\n            if(N != null) R.next = N.left;\n            connect(L);\n            connect(R);\n        }\n        return root;\n    }\n}",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1654181/c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs/",
                "vote_count": "758"
            },
            {
                "language": "",
                "code": "cur = root",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1654181/c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs/",
                "vote_count": "758"
            },
            {
                "language": "rust",
                "code": "if(cur -> left) {\n cur -> left -> next = cur -> right;\n if(cur -> next) cur -> right -> next = cur -> next -> left;\n}",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1654181/c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs/",
                "vote_count": "758"
            },
            {
                "language": "rust",
                "code": "root = root -> left\n// next iteration\ncur = root",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1654181/c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs/",
                "vote_count": "758"
            },
            {
                "language": "rust",
                "code": "if(cur -> left) {\n cur -> left -> next = cur -> right;\n if(cur -> next) cur -> right -> next = cur -> next -> left;\n}",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1654181/c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs/",
                "vote_count": "758"
            },
            {
                "language": "rust",
                "code": "for(; cur; cur = cur -> next)\n    // ...",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1654181/c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs/",
                "vote_count": "758"
            },
            {
                "language": "kotlin",
                "code": "if(cur -> left)\n    // ...\nelse break",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1654181/c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs/",
                "vote_count": "758"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    Node* connect(Node* root) {\n        auto head = root;\n        for(; root; root = root -> left) \n            for(auto cur = root; cur; cur = cur -> next)   // traverse each level - it's just BFS taking advantage of next pointers          \n                if(cur -> left) {                          // update next pointers of children if they exist               \n                    cur -> left -> next = cur -> right;\n                    if(cur -> next) cur -> right -> next = cur -> next -> left;\n                }\n                else break;                                // if no children exist, stop iteration                                                  \n        \n        return head;\n    }\n};",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1654181/c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs/",
                "vote_count": "758"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def connect(self, root):\n        head = root\n        while root:\n            cur, root = root, root.left\n            while cur:\n                if cur.left:\n                    cur.left.next = cur.right\n                    if cur.next: cur.right.next = cur.next.left\n                else: break\n                cur = cur.next\n                \n        return head",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1654181/c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs/",
                "vote_count": "758"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public Node connect(Node root) {\n        Node head = root;\n        for(; root != null; root = root.left) \n            for(Node cur = root; cur != null; cur = cur.next) \n                if(cur.left != null) {\n                    cur.left.next = cur.right;\n                    if(cur.next != null) cur.right.next = cur.next.left;\n                } else break;\n        \n        return head;\n    }\n}",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1654181/c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs/",
                "vote_count": "758"
            },
            {
                "language": "cpp",
                "code": "        int size = queue.size();\n        for(int i =0; i<size; i++)",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1654181/c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs/",
                "vote_count": "758"
            },
            {
                "language": "typescript",
                "code": "public class Solution {\n    public void connect(TreeLinkNode root) {\n        TreeLinkNode level_start=root;\n        while(level_start!=null){\n            TreeLinkNode cur=level_start;\n            while(cur!=null){\n                if(cur.left!=null) cur.left.next=cur.right;\n                if(cur.right!=null && cur.next!=null) cur.right.next=cur.next.left;\n                \n                cur=cur.next;\n            }\n            level_start=level_start.left;\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37461/java-solution-with-o-1-memory-o-n-time/",
                "vote_count": "557"
            },
            {
                "language": "typescript",
                "code": "    public void connect(TreeLinkNode root) {\n      if(root == null) return;    \n      helper(root.left, root.right);    \n    }\n    \n    void helper(TreeLinkNode node1, TreeLinkNode node2){\n      if(node1 == null) return;    \n      node1.next = node2;\n      helper(node1.left, node1.right);",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37461/java-solution-with-o-1-memory-o-n-time/",
                "vote_count": "557"
            },
            {
                "language": "cpp",
                "code": "void connect(TreeLinkNode *root) {\n        if (!root) return; //Edge Case\n        \n        queue<TreeLinkNode*> q;\n        \n        //Trick: Push NULL to maintain depth information",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37461/java-solution-with-o-1-memory-o-n-time/",
                "vote_count": "557"
            },
            {
                "language": "rust",
                "code": "",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37461/java-solution-with-o-1-memory-o-n-time/",
                "vote_count": "557"
            },
            {
                "language": "rust",
                "code": "",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37461/java-solution-with-o-1-memory-o-n-time/",
                "vote_count": "557"
            },
            {
                "language": "java",
                "code": "public Node connect(Node root) {\n    Node level_start = root;\n    while (level_start!=null){\n        Node cur = level_start;\n        while (cur != null) {\n            if (cur.left != null) {\n                cur.left.next = cur.right;\n                if (cur.next != null) cur.right.next = cur.next.left; // we don't need to check for the right child",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37461/java-solution-with-o-1-memory-o-n-time/",
                "vote_count": "557"
            },
            {
                "language": "java",
                "code": "public Node connect(Node root) {   \n    \n    if(root == null) return null;  \n    Node pre = root;\n    \n    while(pre.left != null){       \n        Node curr = pre;",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37461/java-solution-with-o-1-memory-o-n-time/",
                "vote_count": "557"
            },
            {
                "language": "java",
                "code": "    public Node connect(Node root) {\n        Node levelStart = root;\n        while (levelStart != null) {\n            Node cur = levelStart;\n            while (cur != null) {\n                if (cur.left != null) cur.left.next = cur.right;\n                if (cur.right != null && cur.next != null) cur.right.next = cur.next.left;",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/37461/java-solution-with-o-1-memory-o-n-time/",
                "vote_count": "557"
            },
            {
                "language": "rust",
                "code": "//Upvote and Comment \n\nclass Solution {\npublic:\nNode* connect(Node* root) {\n    //base case\n    if(root == NULL) return NULL;\n    //connects the left subtree of same level with right subtree of that same level \n    if(root->left != NULL) root->left->next = root->right;\n    //connect the rightmost node of a level to the leftmost node of the next level.\n    if(root->right != NULL && root->next != NULL) root->right->next = root->next->left;\n    //recursive calls for left and right subtrees.\n    connect(root->left);\n    connect(root->right);\n    return root;\n   }\n};",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1653846/c-easy-to-solve-beginner-friendly-with-detailed-explanations-and-dry-run/",
                "vote_count": "136"
            },
            {
                "language": "rust",
                "code": "//Upvote and Comment\n\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        //Initialize pointers\n        Node *prev = root, *curr;\n        while (prev) {\n            curr = prev;\n            while (curr && curr->left) { \n                //connects the left subtree of same level with right subtree of that same level \n                curr->left->next = curr->right;\n                //connect the rightmost node of a level to the leftmost node of the next level.\n                if (curr -> next) curr->right->next = curr->next->left;\n                curr = curr->next;\n            }\n            prev = prev -> left;\n        }\n        return root;\n    }\n};",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1653846/c-easy-to-solve-beginner-friendly-with-detailed-explanations-and-dry-run/",
                "vote_count": "136"
            },
            {
                "language": "rust",
                "code": "    if(root->left != NULL) root->left->next = root->right; // We check here that root->left is not null here - so no need to check again for root->right given that the input is a perfect binary tree\n    if(root->right != NULL && root->next != NULL) root->right->next = root->next->left;",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/1653846/c-easy-to-solve-beginner-friendly-with-detailed-explanations-and-dry-run/",
                "vote_count": "136"
            }
        ]
    },
    "116": {
        "question_id": 117,
        "title": "Populating Next Right Pointers in Each Node II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii",
        "description": "Given a binary treestruct Node {  int val;  Node *left;  Node *right;  Node *next;}Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.Initially, all next pointers are set to NULL. ",
        "examples": [
            {
                "input": "root = [1,2,3,4,5,null,7]",
                "output": "[1,#,2,3,#,4,5,7,#]",
                "explanation": "Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level."
            },
            {
                "input": "root = []",
                "output": "[]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [0, 6000].",
            "-100 <= Node.val <= 100",
            "You may only use constant extra space.",
            "The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem."
        ],
        "solutions": [
            {
                "language": "java",
                "code": "public class Solution {\n    \n    //based on level order traversal\n    public void connect(TreeLinkNode root) {\n\n        TreeLinkNode head = null; //head of the next level\n        TreeLinkNode prev = null; //the leading node on the next level\n        TreeLinkNode cur = root;  //current node of current level\n\n        while (cur != null) {\n            \n            while (cur != null) { //iterate on the current level\n                //left child\n                if (cur.left != null) {\n                    if (prev != null) {\n                        prev.next = cur.left;\n                    } else {\n                        head = cur.left;\n                    }\n                    prev = cur.left;\n                }\n                //right child\n                if (cur.right != null) {\n                    if (prev != null) {\n                        prev.next = cur.right;\n                    } else {\n                        head = cur.right;\n                    }\n                    prev = cur.right;\n                }\n                //move to next node\n                cur = cur.next;\n            }\n            \n            //move to next level\n            cur = head;\n            head = null;\n            prev = null;\n        }\n        \n    }\n}",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/37828/o-1-space-o-n-complexity-iterative-solution/",
                "vote_count": "803"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public void connect(TreeLinkNode root) {\n        if (root == null) return;\n        TreeLinkNode curP = root;\n        TreeLinkNode nextDummyHead = new TreeLinkNode(0);\n        TreeLinkNode p = nextDummyHead;\n        while (curP != null) {\n            if (curP.left != null) {",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/37828/o-1-space-o-n-complexity-iterative-solution/",
                "vote_count": "803"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public void connect(TreeLinkNode root) {\n        // Logic: \n        //        node moves to all nodes in tree in level order fashion\n        //        needle keeps sewing together next level's children\n\n        // levelHead is sentinel, keeps track of start node of next level\n        TreeLinkNode node = root, levelHead = new TreeLinkNode(0);",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/37828/o-1-space-o-n-complexity-iterative-solution/",
                "vote_count": "803"
            },
            {
                "language": "typescript",
                "code": "public class Solution {\n\n    public void connect(TreeLinkNode root) {\n        TreeLinkNode head=root;//The left most node in the lower level\n        TreeLinkNode prev=null;//The previous node in the lower level\n        TreeLinkNode curr=null;//The current node in the upper level\n        while (head!=null){\n            curr=head;",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/37828/o-1-space-o-n-complexity-iterative-solution/",
                "vote_count": "803"
            },
            {
                "language": "java",
                "code": "   public class Solution {\n       public static void connect(TreeLinkNode root) {\n      TreeLinkNode nextHead = new TreeLinkNode(0);\n      nextHead.next = root;",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/37828/o-1-space-o-n-complexity-iterative-solution/",
                "vote_count": "803"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def connect(self, root):\n        \"\"\"\n        :type root: TreeLinkNode\n        :rtype: nothing",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/37828/o-1-space-o-n-complexity-iterative-solution/",
                "vote_count": "803"
            },
            {
                "language": "java",
                "code": "public void connect(TreeLinkNode root) {\n    if (root == null)\n        return;\n    TreeLinkNode dummy = new TreeLinkNode(0);\n    dummy.next = root;\n    while (dummy.next != null) {\n        TreeLinkNode cur = dummy.next, pre = dummy;\n        dummy.next = null;\n        while (cur != null) {",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/37828/o-1-space-o-n-complexity-iterative-solution/",
                "vote_count": "803"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public void connect(TreeLinkNode root) {\n        if(root == null) return;\n        \n        TreeLinkNode head = root;\n        while(head != null){\n            head = linkNextLevel(head);\n        }",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/37828/o-1-space-o-n-complexity-iterative-solution/",
                "vote_count": "803"
            },
            {
                "language": "rust",
                "code": "void connect(TreeLinkNode *root) {\n    if (root == NULL) return;\n    TreeLinkNode * start = root;//start of cur level\n    TreeLinkNode * end = root;//end of all levels\n    TreeLinkNode * levelEnd = root;//cur level's end\n    while (start != NULL)\n    {\n        if (start->left != NULL)",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/37828/o-1-space-o-n-complexity-iterative-solution/",
                "vote_count": "803"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public void connect(TreeLinkNode root) {\n        \n        while(root != null){\n            TreeLinkNode tempChild = new TreeLinkNode(0);\n            TreeLinkNode currentChild = tempChild;\n            while(root!=null){\n                if(root.left != null) { currentChild.next = root.left; currentChild = currentChild.next;}\n                if(root.right != null) { currentChild.next = root.right; currentChild = currentChild.next;}\n                root = root.next;\n            }\n            root = tempChild.next;\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/37811/simple-solution-using-constant-space/",
                "vote_count": "525"
            },
            {
                "language": "java",
                "code": "public void connect(TreeLinkNode root) {\n    TreeLinkNode tempChild = new TreeLinkNode(0);\n    while (root != null) {\n        TreeLinkNode currentChild = tempChild;\n        while (root != null) {\n            if (root.left != null) {\n                currentChild.next = root.left;",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/37811/simple-solution-using-constant-space/",
                "vote_count": "525"
            },
            {
                "language": "java",
                "code": "public void connect(TreeLinkNode root) {\n    TreeLinkNode dummyhead = new TreeLinkNode(0);\n    TreeLinkNode current = null;\n    while (root != null) {\n        current = dummyhead;\n while (root != null) {",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/37811/simple-solution-using-constant-space/",
                "vote_count": "525"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public Node connect(Node root) {\n        Node first = root;\n        Node dummy = new Node(0);\n        Node pre = dummy;\n        while(first!=null){\n            while(first!=null){",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/37811/simple-solution-using-constant-space/",
                "vote_count": "525"
            },
            {
                "language": "rust",
                "code": "void connect(TreeLinkNode *root) \n    {\n        if(root == NULL)\n            return;",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/37811/simple-solution-using-constant-space/",
                "vote_count": "525"
            },
            {
                "language": "typescript",
                "code": "public void connect(TreeLinkNode root) {\n    TreeLinkNode head=root,tmpNode=new TreeLinkNode(0);\n    //loop the head in the level\n    while(head!=null){\n     //loop the node in each level\n     TreeLinkNode node=head,child=tmpNode;\n     while(node!=null){\n      if(node.left!=null){",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/37811/simple-solution-using-constant-space/",
                "vote_count": "525"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public void connect(TreeLinkNode root) {\n        if(root == null) return;\n        TreeLinkNode dummy = new TreeLinkNode(0);\n        while(root != null){\n            dummy.next = null;\n            TreeLinkNode temp = dummy;\n            while(root != null){",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/37811/simple-solution-using-constant-space/",
                "vote_count": "525"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def connect(self, root):\n        node = root\n        while node:\n            curr = dummy = Node(0)\n            while node:\n                if node.left:\n                    curr.next = node.left\n                    curr = curr.next\n                if node.right:\n                    curr.next = node.right\n                    curr = curr.next\n                node = node.next\n            node = dummy.next\n               \n        return root",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/961868/python-o-n-solution-explained/",
                "vote_count": "171"
            },
            {
                "language": "python",
                "code": "#new (parent) level\nwhile node:\n    #creating a dummy leftmost node for the next (child) level\n    curr = dummy = Node(0)\n    #while nodes exist at the same (ie parent) level\n    while node:\n        ...",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/961868/python-o-n-solution-explained/",
                "vote_count": "171"
            },
            {
                "language": "go",
                "code": "func connect(root *Node) *Node {\n    var curr, head, tail *Node\n    head = root\n    append := func(node *Node) {\n        if node == nil {\n            return\n        }\n        node.Next = nil",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/961868/python-o-n-solution-explained/",
                "vote_count": "171"
            },
            {
                "language": "ruby",
                "code": "def connect(self, root: 'Node') -> 'Node':\n        pa=root\n        dumych = Node()\n        ch = dumych\n        while pa:\n            if pa.left:\n                ch.next = pa.left",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/961868/python-o-n-solution-explained/",
                "vote_count": "171"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        if not root:\n            return None\n        q = deque()\n        q.append(root)\n        dummy=Node(-999) # to initialize with a not null prev\n        while q:\n            length=len(q) # find level length\n            \n            prev=dummy\n            for _ in range(length): # iterate through all nodes in the same level\n                popped=q.popleft()\n                if popped.left:\n                    q.append(popped.left)\n                    prev.next=popped.left\n                    prev=prev.next\n                if popped.right:\n                    q.append(popped.right)\n                    prev.next=popped.right\n                    prev=prev.next                \n                 \n        return root",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/2033286/python-easy-bfs-and-o-1-space-with-explanation/",
                "vote_count": "43"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        if not root:\n            return None\n        \n        curr=root\n        dummy=Node(-999)        \n        head=root        \n\n  while head:\n            curr=head # initialize current level's head\n            prev=dummy # init prev for next level linked list traversal\n   # iterate through the linked-list of the current level and connect all the siblings in the next level\n            while curr:  \n                if curr.left:\n                    prev.next=curr.left\n                    prev=prev.next\n                if curr.right:\n                    prev.next=curr.right\n                    prev=prev.next                                                \n                curr=curr.next\n            head=dummy.next # update head to the linked list of next level\n            dummy.next=None # reset dummy node\n        return root\n            ",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/2033286/python-easy-bfs-and-o-1-space-with-explanation/",
                "vote_count": "43"
            },
            {
                "language": "javascript",
                "code": "var connect = function(root) {\n    if (!root) return root;\n    \n    let queue = [root];\n    let tempQueue = [];\n        \n    while(queue.length){\n        let curr = queue.splice(0, 1)[0];\n        let {left, right} = curr;\n                \n        if (left) tempQueue.push(left);\n        if (right) tempQueue.push(right);\n        \n        if (queue.length === 0){\n            curr.next = null;\n            queue = tempQueue;\n            tempQueue = [];\n        }else{\n            curr.next = queue[0];\n        }\n    }\n    \n    return root;\n};",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/2167737/javascript-test-case-typeerror/",
                "vote_count": "29"
            },
            {
                "language": "ruby",
                "code": "Line 109 in solution.js\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type Node\");\n             ^\nTypeError: {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null,\"next\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}}},\"right\":{\"val\":5,\"left\":null,\"right\":null,\"next\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null}},\"next\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null}},\"right\":{\"val\":3,\"left\":null,\"right\":{\"val\":7,\"left\":null,\"right\":null,\"next\":null},\"next\":null},\"next\":null} is not valid value for the expected return type Node\n    Line 109: Char 20 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 41: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/2167737/javascript-test-case-typeerror/",
                "vote_count": "29"
            },
            {
                "language": "javascript",
                "code": "var connect = function (root) {\n  if (root === null) return null;\n  let queue = [];\n  let tempValue = null;",
                "url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solutions/2167737/javascript-test-case-typeerror/",
                "vote_count": "29"
            }
        ]
    },
    "117": {
        "question_id": 118,
        "title": "Pascal's Triangle",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/pascals-triangle",
        "description": "Given an integer numRows, return the first numRows of Pascal's triangle.In Pascal's triangle, each number is the sum of the two numbers directly above it as shown: ",
        "examples": [
            {
                "input": "numRows = 5",
                "output": "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]",
                "explanation": null
            }
        ],
        "constraints": [],
        "solutions": [
            {
                "language": "cpp",
                "code": "// Please, UpVote, if you like it :-) Thank you\nvector<vector<int>> generate(int numRows) {\n vector<vector<int>> ret;\n for (int i = 0; i < numRows; i++) {\n  vector<int> row(i + 1, 1);\n  for (int j = 1; j < i; j++) {\n   row[j] = ret[i - 1][j] + ret[i - 1][j - 1];\n  }\n  ret.push_back(row);\n }\n return ret;\n}",
                "url": "https://leetcode.com/problems/pascals-triangle/solutions/727318/c-simple-solution-0-ms-beats-100-00/",
                "vote_count": "417"
            },
            {
                "language": "cpp",
                "code": "    for(int i=0; i<numRows;i++){\n        vector<int> inner_sets;\n        for(int j=0; j <= i;j++){",
                "url": "https://leetcode.com/problems/pascals-triangle/solutions/727318/c-simple-solution-0-ms-beats-100-00/",
                "vote_count": "417"
            },
            {
                "language": "cpp",
                "code": "vector<vector<int>> generate(int numRows) {\n        vector <vector <int>> res;\n        vector <int> temp;\n        temp.reserve(numRows);\n        for(int i = 0; i<numRows; i++){\n            temp.push_back(1);\n            for(int j = 1; j<i; j++){",
                "url": "https://leetcode.com/problems/pascals-triangle/solutions/727318/c-simple-solution-0-ms-beats-100-00/",
                "vote_count": "417"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        ",
                "url": "https://leetcode.com/problems/pascals-triangle/solutions/727318/c-simple-solution-0-ms-beats-100-00/",
                "vote_count": "417"
            },
            {
                "language": "cpp",
                "code": "vector<vector<int>> generate(int n) {\n       vector<vector<int>>arr(n);\n       for(int i=0;i<n;i++){\n           arr[i] = vector<int>(i+1);\n           for(int j=0;j<=i;j++){\n             if(j==0 || j==i){\n                   arr[i][j]=1;                }\n               else{\n                  int ele=arr[i-1][j-1]+arr[i-1][j];",
                "url": "https://leetcode.com/problems/pascals-triangle/solutions/727318/c-simple-solution-0-ms-beats-100-00/",
                "vote_count": "417"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>>triangle;\n        vector<int>prevRow;\n        for(int i = 0;i<numRows;i++){\n            vector<int>row;\n            for(int j =0;j<i+1;j++){\n                //edge digits",
                "url": "https://leetcode.com/problems/pascals-triangle/solutions/727318/c-simple-solution-0-ms-beats-100-00/",
                "vote_count": "417"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        return [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1], [1, 9, 36, 84, 126, 126, 84, 36, 9, 1], [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1], [1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1], [1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1], [1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1], [1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1], [1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1], [1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1], [1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1], [1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1], [1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1], [1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1], [1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1], [1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1], [1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1], [1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1], [1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1], [1, 26, 325, 2600, 14950, 65780, 230230, 657800, 1562275, 3124550, 5311735, 7726160, 9657700, 10400600, 9657700, 7726160, 5311735, 3124550, 1562275, 657800, 230230, 65780, 14950, 2600, 325, 26, 1], [1, 27, 351, 2925, 17550, 80730, 296010, 888030, 2220075, 4686825, 8436285, 13037895, 17383860, 20058300, 20058300, 17383860, 13037895, 8436285, 4686825, 2220075, 888030, 296010, 80730, 17550, 2925, 351, 27, 1], [1, 28, 378, 3276, 20475, 98280, 376740, 1184040, 3108105, 6906900, 13123110, 21474180, 30421755, 37442160, 40116600, 37442160, 30421755, 21474180, 13123110, 6906900, 3108105, 1184040, 376740, 98280, 20475, 3276, 378, 28, 1], [1, 29, 406, 3654, 23751, 118755, 475020, 1560780, 4292145, 10015005, 20030010, 34597290, 51895935, 67863915, 77558760, 77558760, 67863915, 51895935, 34597290, 20030010, 10015005, 4292145, 1560780, 475020, 118755, 23751, 3654, 406, 29, 1]][:numRows]",
                "url": "https://leetcode.com/problems/pascals-triangle/solutions/2301657/simple-o-1-solution-in-python/",
                "vote_count": "179"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> generate(int numRows) {\n        // Create an array list to store the output result...\n        List<List<Integer>> output = new ArrayList<List<Integer>>();\n        // Base cases...\n     if (numRows <= 0)  return output;\n        // Create an array list to store the prev triangle value for further addition...\n     ArrayList<Integer> prev = new ArrayList<Integer>();\n        // Inserting for the first row & store the prev array to the output array...\n     prev.add(1);\n     output.add(prev);\n        // For rest of the rows, Traverse all elements through a for loop...\n     for (int i = 2; i <= numRows; i++) {\n            // Create another array to store the current triangle value...\n      ArrayList<Integer> curr = new ArrayList<Integer>();\n      curr.add(1);    //first\n            // Calculate for each of the next values...\n      for (int j = 0; j < prev.size() - 1; j++) {\n                // Inserting the addition of the prev arry two values...\n       curr.add(prev.get(j) + prev.get(j + 1));    //middle\n      }\n            // Store the number 1...\n      curr.add(1);    //last\n            // Store the value in the Output array...\n      output.add(curr);\n            // Set prev is equal to curr...\n      prev = curr;\n     }\n     return output;      // Return the output list of pascal values...\n    }\n}",
                "url": "https://leetcode.com/problems/pascals-triangle/solutions/2490404/easy-0-ms-100-fully-explained-java-c-python-javascript-python3-dp/",
                "vote_count": "128"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> output;\n        // Base cases...\n        if(numRows == 0)  return output;\n        // Traverse all the elements through a loop\n        for(int i=0; i<numRows; i++)\n            output.push_back(vector<int>(i + 1, 1));    // Initialize the first row of the pascal triangle as {1}.\n        // For generating each row of the triangle...\n        for (int i = 2; i < numRows; ++i)\n            // Run an inner loop from j = 1 to j = {previous row size} for calculating element of each row of the triangle.\n            for (int j = 1; j < output[i].size() - 1; ++j)\n                // Calculate the elements of a row, add each pair of adjacent elements of the previous row in each step of the inner loop.\n                output[i][j] = output[i - 1][j - 1] + output[i - 1][j];\n        return output;      // After the inner loop gets over, simply output the row generated.\n    }\n};",
                "url": "https://leetcode.com/problems/pascals-triangle/solutions/2490404/easy-0-ms-100-fully-explained-java-c-python-javascript-python3-dp/",
                "vote_count": "128"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def generate(self, numRows):\n        # Create an array list to store the output result...\n        output = []\n        for i in range(numRows):\n            if(i == 0):\n                # Create a list to store the prev triangle value for further addition...\n                # Inserting for the first row & store the prev array to the output array...\n                prev = [1]\n                output.append(prev)\n            else:\n                curr = [1]\n                j = 1\n                # Calculate for each of the next values...\n                while(j < i):\n                    # Inserting the addition of the prev arry two values...\n                    curr.append(prev[j-1] + prev[j])\n                    j+=1\n                # Store the number 1...\n                curr.append(1)\n                # Store the value in the Output array...\n                output.append(curr)\n                # Set prev is equal to curr...\n                prev = curr\n        return output       # Return the output list of pascal values...",
                "url": "https://leetcode.com/problems/pascals-triangle/solutions/2490404/easy-0-ms-100-fully-explained-java-c-python-javascript-python3-dp/",
                "vote_count": "128"
            },
            {
                "language": "javascript",
                "code": "var generate = function(numRows) {\n    var i = 0;\n    var j = 0;\n    // Create an array list to store the output result...\n    var res = [];\n    // For generating each row of the triangle...\n    for (i = 0; i < numRows; i++) {\n        res.push(Array(i + 1));       // Initialize the first row of the pascal triangle as {1}...\n        for (j = 0; j <= i; j++) {\n            // Primary...\n            if (j === 0 || j === i) {\n                res[i][j] = 1;\n            }\n            else {\n                // Calculate the elements of a row, add each pair of adjacent elements of the previous row in each step of the inner loop.\n                res[i][j] = res[i - 1][j - 1] + res[i - 1][j];\n            }\n        }\n    }\n    return res;      // Return the output list of pascal values...\n};",
                "url": "https://leetcode.com/problems/pascals-triangle/solutions/2490404/easy-0-ms-100-fully-explained-java-c-python-javascript-python3-dp/",
                "vote_count": "128"
            },
            {
                "language": "cpp",
                "code": "class Solution(object):\n    def generate(self, numRows):\n        output = [[1]]\n        for i in range(1,numRows):\n            curr = [1]\n            j = 1\n            while(j < i):",
                "url": "https://leetcode.com/problems/pascals-triangle/solutions/2490404/easy-0-ms-100-fully-explained-java-c-python-javascript-python3-dp/",
                "vote_count": "128"
            },
            {
                "language": "dart",
                "code": "public List<List<Integer>> generate(int num) {\n        int jagged[][] = new int[num][];\n        for(int i=0;i<num;i++){\n            int row[] = new int[i+1];\n            row[0]=1;\n            for(int j=1;j<i;j++) row[j]=jagged[i-1][j-1]+jagged[i-1][j];\n            row[i]=1;\n            jagged[i]=row;\n        }return (List)Arrays.asList(jagged);",
                "url": "https://leetcode.com/problems/pascals-triangle/solutions/2490404/easy-0-ms-100-fully-explained-java-c-python-javascript-python3-dp/",
                "vote_count": "128"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N^2). Where N is the numRows. Here total number of iterations are : N*(N+1)/2 which creates the time complexity.\n\n    Space Complexity : O(1). Constant space. Because we are creating 2D vector output as per the demand of\n    program.\n\n    Solved using Dynamic Programming Approach(Tabulation: Bottom Up).\n\n*/\n\nclass Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> output(numRows);\n        for(int i=0; i<numRows; i++){\n            output[i].resize(i+1, 1);\n            for(int j=1; j<i; j++){\n                output[i][j] = output[i-1][j-1] + output[i-1][j];\n            }\n        }\n        return output;\n    }\n};",
                "url": "https://leetcode.com/problems/pascals-triangle/solutions/3176431/best-c-solution-ever-dp-tabulation-bottom-up-one-stop-solution/",
                "vote_count": "83"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public List<List<Integer>> generate(int numRows) {\n        int[][] pascal = new int[numRows][];\n        for (int i = 0; i < numRows; i++){\n            int[] row = new int[i + 1];\n            row[0] = 1;\n            row[i] = 1;\n            for (int j = 1; j < i; j++){\n                row[j] = pascal[i - 1][j - 1] + pascal[i - 1][j];\n            }\n            pascal[i] = row;\n        }\n        return (List)Arrays.asList(pascal);\n    }\n}",
                "url": "https://leetcode.com/problems/pascals-triangle/solutions/3151541/java-solution-0-ms-beats-100/",
                "vote_count": "14"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        ans = []\n        for i in range(1, numRows + 1):\n            row = [1] * i\n            for j in range(1,i-1):\n                row[j] = ans[i - 2][j] + ans[i - 2][j - 1]\n            ans.append(row)\n        return ans",
                "url": "https://leetcode.com/problems/pascals-triangle/solutions/3190724/python-clean-simple-fibonacci-like-solution/",
                "vote_count": "10"
            },
            {
                "language": "python",
                "code": "def generate(self, numRows):\n    res = [[1]]\n    for i in range(1, numRows):\n        res += [map(lambda x, y: x+y, res[-1] + [0], [0] + res[-1])]\n    return res[:numRows]",
                "url": "https://leetcode.com/problems/pascals-triangle/solutions/3190724/python-clean-simple-fibonacci-like-solution/",
                "vote_count": "10"
            },
            {
                "language": "",
                "code": "    1 3 3 1 0 \n +  0 1 3 3 1\n =  1 4 6 4 1",
                "url": "https://leetcode.com/problems/pascals-triangle/solutions/3190724/python-clean-simple-fibonacci-like-solution/",
                "vote_count": "10"
            }
        ]
    },
    "118": {
        "question_id": 119,
        "title": "Pascal's Triangle II",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/pascals-triangle-ii",
        "description": "Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.In Pascal's triangle, each number is the sum of the two numbers directly above it as shown: ",
        "examples": [
            {
                "input": "rowIndex = 3",
                "output": "[1,3,3,1]",
                "explanation": null
            },
            {
                "input": "rowIndex = 1",
                "output": "[1,1]",
                "explanation": null
            }
        ],
        "constraints": [
            "0 <= rowIndex <= 33"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector<int> A(rowIndex+1, 0);\n        A[0] = 1;\n        for(int i=1; i<rowIndex+1; i++)\n            for(int j=i; j>=1; j--)\n                A[j] += A[j-1];\n        return A;\n    }\n};",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/38420/here-is-my-brief-o-k-solution/",
                "vote_count": "472"
            },
            {
                "language": "csharp",
                "code": "public static List<Integer> getRow2(int rowIndex) {\n List<Integer> ret = new ArrayList<Integer>();\n ret.add(1);\n for (int i = 1; i <= rowIndex; i++) {\n  for (int j = i - 1; j >= 1; j--) {\n   int tmp = ret.get(j - 1) + ret.get(j);\n   ret.set(j, tmp);\n  }",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/38420/here-is-my-brief-o-k-solution/",
                "vote_count": "472"
            },
            {
                "language": "cpp",
                "code": "public List<Integer> getRow(int rowIndex) {\n      Integer[] result =  new Integer[rowIndex + 1];\n      Arrays.fill(result, 0);\n      result[0] = 1;\n      for(int i = 1; i < rowIndex + 1; i++)",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/38420/here-is-my-brief-o-k-solution/",
                "vote_count": "472"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<Integer> getRow(int rowIndex) {\n        long nCk = 1;\n        List<Integer> result = new ArrayList<Integer>();\n        for(int i=0;i<=rowIndex;i++){\n            result.add((int)nCk);\n            nCk = nCk *(rowIndex-i)/(i+1);\n        }",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/38420/here-is-my-brief-o-k-solution/",
                "vote_count": "472"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector<int> ints(rowIndex + 1, 1);\n        for(int row = 0; row < rowIndex; row++) {\n            for(int col = row; col > 0; col--) {\n                ints[col] += ints[col - 1];\n            }",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/38420/here-is-my-brief-o-k-solution/",
                "vote_count": "472"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/38420/here-is-my-brief-o-k-solution/",
                "vote_count": "472"
            },
            {
                "language": "ruby",
                "code": "class Solution(object):\n    def getRow(self, r):\n        ans = [1]*(r+1);\n        up = r\n        down = 1\n        for i in range(1, r):\n            ans[i] = ans[i-1]*up/down;\n            up = up - 1\n            down = down + 1\n        return ans;",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/1203260/very-easy-o-n-time-0-ms-beats-100-simple-maths-all-languages/",
                "vote_count": "105"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<Integer> getRow(int r) {\n        List<Integer> ans = new ArrayList<>();\n        ans.add(1);\n        long temp = 1;\n        for(int i=1,up=r,down=1;i<=r;i++,up--, down++){\n            temp=temp*up/down;\n            ans.add((int)temp);\n        }\n        return ans;\n    }\n}",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/1203260/very-easy-o-n-time-0-ms-beats-100-simple-maths-all-languages/",
                "vote_count": "105"
            },
            {
                "language": "javascript",
                "code": "var getRow = function(r) {\n    var ans = new Array(r+1)\n    ans[0]=ans[r]=1\n    for(i=1,up=r;i<r;i++,up--)\n        ans[i] = ans[i-1]*up/i\n    return ans\n};",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/1203260/very-easy-o-n-time-0-ms-beats-100-simple-maths-all-languages/",
                "vote_count": "105"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> getRow(int r) {\n        vector<int>v(r+1);\n        long temp=1;\n        v[0]=v[r]=1;\n        for(int i=1,up=r,down=1;i<r;i++,up--,down++){\n            temp = temp*up/down;\n            v[i]=temp;\n        }\n        return v;\n    }\n};",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/1203260/very-easy-o-n-time-0-ms-beats-100-simple-maths-all-languages/",
                "vote_count": "105"
            },
            {
                "language": "cpp",
                "code": "int* getRow(int r, int* rS){\n    int*ans = calloc(r + 1, sizeof(int));\n    long temp=1;\n    ans[0]=1;\n    for(int i=1,up=r;i<=r;i++,up--){\n        temp=temp*up/i;\n        ans[i]=temp;\n    }\n    *rS = r+1;\n    return ans;\n}",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/1203260/very-easy-o-n-time-0-ms-beats-100-simple-maths-all-languages/",
                "vote_count": "105"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public IList<int> GetRow(int r) {\n        var ans = new int[r+1];\n        ans[0]=ans[r]=1;\n        long temp=1;\n        for(int i=1,up=r;i<r;i++,up--){\n            temp = temp * up / i;\n            ans[i]=(int)temp;\n        }\n        return ans;\n    }\n}",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/1203260/very-easy-o-n-time-0-ms-beats-100-simple-maths-all-languages/",
                "vote_count": "105"
            },
            {
                "language": "ruby",
                "code": "def get_row(r)\n    return [1] if r==0\n    ans = [1]\n    temp = 1\n    for i in 1...r do\n        temp = temp * (r-i+1)/i\n        ans << temp\n    end\n    ans << 1\n    return ans\nend",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/1203260/very-easy-o-n-time-0-ms-beats-100-simple-maths-all-languages/",
                "vote_count": "105"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    func getRow(_ r: Int) -> [Int] {\n        if r==0 {\n            return [1]\n        }\n        var ans = [Int](repeating: 1, count: r+1)\n        for i in 1...r {\n            ans[i] = ans[i-1]*(r-i+1)/i\n        }\n        return ans\n    }\n}",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/1203260/very-easy-o-n-time-0-ms-beats-100-simple-maths-all-languages/",
                "vote_count": "105"
            },
            {
                "language": "go",
                "code": "func getRow(r int) []int {\n    var ans = make([]int,r+1)\n    ans[0] = 1\n    ans[r] = 1\n    for i:=1; i<=r; i++ {\n        ans[i] = ans[i-1]*(r-i+1)/i\n    }\n    return ans\n}",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/1203260/very-easy-o-n-time-0-ms-beats-100-simple-maths-all-languages/",
                "vote_count": "105"
            },
            {
                "language": "kotlin",
                "code": "object Solution {\n    implicit def arrayToList[A](a: Array[A]) = a.toList\n    def getRow(r: Int): List[Int] = {\n        var ans = new Array[Int](r+1)\n        ans(0) = 1\n        var temp: Long = 1\n        for( i <- 1 to r){\n            temp = temp*(r-i+1)/i\n            ans(i) = temp.asInstanceOf[Int]\n        }\n        return ans\n    }\n}",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/1203260/very-easy-o-n-time-0-ms-beats-100-simple-maths-all-languages/",
                "vote_count": "105"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    fun getRow(r: Int): List<Int> {\n        var ans = MutableList<Int>(r+1){1}\n        var temp: Long = 1\n        for (i in 1..r){\n            temp = temp*(r-i+1)/i\n            ans[i] = temp.toInt()\n        }\n        return ans\n    }\n}",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/1203260/very-easy-o-n-time-0-ms-beats-100-simple-maths-all-languages/",
                "vote_count": "105"
            },
            {
                "language": "rust",
                "code": "impl Solution {\n    pub fn get_row(r: i32) -> Vec<i32> {\n        let mut ans : Vec<i32> = Vec::new();  \n        ans.push(1);\n        let mut temp: i64 = 1;\n        let mut up = r as i64;\n        let mut down = 1 as i64;\n        for i in 1..=r {\n            temp = temp*up/down;\n            ans.push(temp as i32);\n            up-=1;\n            down+=1;\n        }\n        return ans;\n    }\n}",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/1203260/very-easy-o-n-time-0-ms-beats-100-simple-maths-all-languages/",
                "vote_count": "105"
            },
            {
                "language": "php",
                "code": "class Solution {\n    function getRow($r) {\n        $ans = array(1);\n        $temp = 1;\n        for($i=1;$i<=$r;$i++){\n            $temp = $temp*($r-$i+1)/$i;\n            array_push($ans, $temp);\n        }\n        return $ans;\n    }\n}",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/1203260/very-easy-o-n-time-0-ms-beats-100-simple-maths-all-languages/",
                "vote_count": "105"
            },
            {
                "language": "typescript",
                "code": "function getRow(r: number): number[] {\n    var ans:number[] = [1]\n    var temp:number = 1\n    for(var i:number=1;i<=r;i++){\n        temp = temp*(r-i+1)/i\n        ans.push(temp)\n    }\n    return ans\n};",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/1203260/very-easy-o-n-time-0-ms-beats-100-simple-maths-all-languages/",
                "vote_count": "105"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> getRow(int r) {\n        vector<int>v(r+1);\n        long temp=1;\n        v[0]=v[r]=1;\n        for(int i=1,up=r,down=1;i<=r/2;i++,up--,down++){",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/1203260/very-easy-o-n-time-0-ms-beats-100-simple-maths-all-languages/",
                "vote_count": "105"
            },
            {
                "language": "csharp",
                "code": "    public List<Integer> getRow(int rowIndex) {\n        \n        var pascal = new ArrayList<Integer>();\n        pascal.add(1);\n        \n        buildRow(pascal, rowIndex, 1L, rowIndex, 1);\n        \n        return pascal;",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/1203260/very-easy-o-n-time-0-ms-beats-100-simple-maths-all-languages/",
                "vote_count": "105"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N^2). Where N is the rowIndex+1. Here total number of iterations are : N*(N+1)/2 which\n    creates the time complexity.\n\n    Space Complexity : O(1). Constant space. Because we are creating 2D Array(output) as per the demand of\n    program.\n\n    Solved using Dynamic Programming Approach(Tabulation: Bottom Up) With 2D Array(output) Extra Space.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector<vector<int>> output(rowIndex+1);\n        for(int i=0; i<=rowIndex; i++){\n            output[i].resize(i+1, 1);\n            for(int j=1; j<i; j++){\n                output[i][j] = output[i-1][j-1] + output[i-1][j];\n            }\n        }\n        return output.back();\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^2). Where N is the rowIndex+1. Here total number of iterations are : N*(N+1)/2 which\n    creates the time complexity.\n\n    Space Complexity : O(1). Constant space. Because we are creating Array(output) as per the demand of\n    program.\n\n    Solved using Dynamic Programming Approach(Tabulation: Bottom Up) With 1D Array(output) Extra Space.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector<int> output(rowIndex+1, 0);\n        output[0] = 1;\n        for(int i=0; i<rowIndex; i++){\n            for(int j=i+1; j>=1; j--){\n                output[j] += output[j-1];\n            }\n        }\n        return output;\n    }\n};",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/3177710/best-c-2-solutions-ever-dp-tabulation-bottom-up-one-stop-solution/",
                "vote_count": "12"
            },
            {
                "language": "javascript",
                "code": "//           n!\n// nCr = -----------\n//        r!.(n-r)!\n\n//                  n!\n// nC(r-1) = -----------------\n//            (r-1)!.(n-r+1)!\n\n//                     n!        (r-1)!x(n-r+1)!\n// nCr / nC(r-1) = ----------- x ---------------\n//                  r!.(n-r)!          n!\n\n//                 (n-r+1)\n//               = -------\n//                    r\n\n// nC0 = 1\n// nCr = nC(r-1) x (n-r+1) / r",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/3190206/single-loop-solution-with-concise-explanation-c-maths-magic/",
                "vote_count": "10"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> getRow(int n) {\n        vector<int> vec(n+1, 1);\n        long long int temp = 1;\n        for(int i = 1; i < n; i++) {\n            temp = temp * (n-i+1) / i;\n            vec[i] = temp;\n        } return vec;\n    }\n};",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/3190206/single-loop-solution-with-concise-explanation-c-maths-magic/",
                "vote_count": "10"
            },
            {
                "language": "",
                "code": "1 ",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/3122469/c-accepted-easy-explanation-0ms-beats-100/",
                "vote_count": "10"
            },
            {
                "language": "",
                "code": "1,1 ",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/3122469/c-accepted-easy-explanation-0ms-beats-100/",
                "vote_count": "10"
            },
            {
                "language": "cpp",
                "code": "1,1,1\n1,2,1 <= final row",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/3122469/c-accepted-easy-explanation-0ms-beats-100/",
                "vote_count": "10"
            },
            {
                "language": "cpp",
                "code": "1,2,1,1\n1,3,3,1 <= final row ",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/3122469/c-accepted-easy-explanation-0ms-beats-100/",
                "vote_count": "10"
            },
            {
                "language": "dart",
                "code": "1,2,1,1=> {1,(1+2),(2+1),1} => {1,3,3,1} ",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/3122469/c-accepted-easy-explanation-0ms-beats-100/",
                "vote_count": "10"
            },
            {
                "language": "dart",
                "code": "1,1,1=> {1,(1+1),1} => {1,2,1}",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/3122469/c-accepted-easy-explanation-0ms-beats-100/",
                "vote_count": "10"
            },
            {
                "language": "dart",
                "code": "1,3,3,1,1=> {1,(1+3),(3+3),(3+1),1} => {1,4,6,4,1}",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/3122469/c-accepted-easy-explanation-0ms-beats-100/",
                "vote_count": "10"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n       vector<int> r;\n       for(int i=0;i<=rowIndex;i++){\n           r.push_back(1);\n           for(int j=i-1;j>=1;--j){\n               r[j]=r[j]+r[j-1];\n           }\n       }\n       return r;\n    }\n};",
                "url": "https://leetcode.com/problems/pascals-triangle-ii/solutions/3122469/c-accepted-easy-explanation-0ms-beats-100/",
                "vote_count": "10"
            }
        ]
    },
    "119": {
        "question_id": 120,
        "title": "Triangle",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/triangle",
        "description": "Given a triangle array, return the minimum path sum from top to bottom.For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row. ",
        "examples": [
            {
                "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
                "output": "11",
                "explanation": "The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above)."
            },
            {
                "input": "triangle = [[-10]]",
                "output": "-10",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= triangle.length <= 200",
            "triangle[0].length == 1",
            "triangle[i].length == triangle[i - 1].length + 1",
            "-10^4 <= triangle[i][j] <= 10^4"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "minpath[k][i] = min( minpath[k+1][i], minpath[k+1][i+1]) + triangle[k][i];",
                "url": "https://leetcode.com/problems/triangle/solutions/38730/dp-solution-for-triangle/",
                "vote_count": "1183"
            },
            {
                "language": "python",
                "code": "For the kth level:\nminpath[i] = min( minpath[i], minpath[i+1]) + triangle[k][i]; ",
                "url": "https://leetcode.com/problems/triangle/solutions/38730/dp-solution-for-triangle/",
                "vote_count": "1183"
            },
            {
                "language": "cpp",
                "code": "int minimumTotal(vector<vector<int> > &triangle) {\n    int n = triangle.size();\n    vector<int> minlen(triangle.back());\n    for (int layer = n-2; layer >= 0; layer--) // For each layer\n    {\n        for (int i = 0; i <= layer; i++) // Check its every 'node'\n        {\n            // Find the lesser of its two children, and sum the current value in the triangle with it.\n            minlen[i] = min(minlen[i], minlen[i+1]) + triangle[layer][i]; \n        }\n    }\n    return minlen[0];\n}",
                "url": "https://leetcode.com/problems/triangle/solutions/38730/dp-solution-for-triangle/",
                "vote_count": "1183"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n        // corner case\n        if(triangle == null || triangle.size() == 0) return 0;\n        \n        // M[i] represents the min total from bottom to current position\n        // copy the last row in triangle to M\n        int m = triangle.size();",
                "url": "https://leetcode.com/problems/triangle/solutions/38730/dp-solution-for-triangle/",
                "vote_count": "1183"
            },
            {
                "language": "csharp",
                "code": "",
                "url": "https://leetcode.com/problems/triangle/solutions/38730/dp-solution-for-triangle/",
                "vote_count": "1183"
            },
            {
                "language": "csharp",
                "code": "",
                "url": "https://leetcode.com/problems/triangle/solutions/38730/dp-solution-for-triangle/",
                "vote_count": "1183"
            },
            {
                "language": "csharp",
                "code": " public int minimumTotal(List<List<Integer>> triangle) {\n  if(triangle.size() == 0)\n   return 0;\n  \n  for (int i=triangle.size() - 2; i>=0; i--) {\n   for (int j=0; j<=i; j++) {\n    List<Integer> nextRow = triangle.get(i+1);\n    int sum = Math.min(nextRow.get(j), nextRow.get(j+1)) + triangle.get(i).get(j);",
                "url": "https://leetcode.com/problems/triangle/solutions/38730/dp-solution-for-triangle/",
                "vote_count": "1183"
            },
            {
                "language": "java",
                "code": "    public int MinimumTotal(IList<IList<int>> triangle)\n    {\n        if (triangle.Count == 0)\n        {\n[j]);",
                "url": "https://leetcode.com/problems/triangle/solutions/38730/dp-solution-for-triangle/",
                "vote_count": "1183"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n        for(int i=triangle.size()-2;i>=0;i--){\n            for(int j=0;j<=i;j++){\n                int self = triangle.get(i).get(j);         //\u83b7\u53d6\u7b2c\uff08i+1\uff09\u884c\uff08j+1\uff09\u4e2a\u6570\u5b57\n                int res = Math.min(triangle.get(i+1).get(j)+self,   triangle.get(i+1).get(j+1)+self);    //\u5f97\u5230\u8fd9\u4e00\u884c\u4e0e\u4e0b\u4e00\u884c\u76f8\u90bb\u6570\u7684\u548c\u7684\u6700\u5c0f\u503c\n                triangle.get(i).set(j,res);         //\u66f4\u65b0\u7b2c\uff08i+1\uff09\u884c\u7b2c\uff08j+1\uff09\u4e2a\u6570\u5b57",
                "url": "https://leetcode.com/problems/triangle/solutions/38730/dp-solution-for-triangle/",
                "vote_count": "1183"
            },
            {
                "language": "cpp",
                "code": "public class Triangle{\npublic int minimumTotal(List<List<Integer>> triangle) {\n    Deque<Integer> queue = new LinkedList<Integer>();\n    int count=triangle.size();\n    queue.add(triangle.get(0).get(0));\n    for (int i=1;i<count;i++){",
                "url": "https://leetcode.com/problems/triangle/solutions/38730/dp-solution-for-triangle/",
                "vote_count": "1183"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n        int m = triangle.size();\n        // use null to distinguish whether it is empty\n        Integer[][] memo = new Integer[m][m];\n        List<Integer> bottom = triangle.get(m-1);\n        for (int i=0;i<bottom.size();i++){",
                "url": "https://leetcode.com/problems/triangle/solutions/38730/dp-solution-for-triangle/",
                "vote_count": "1183"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int minimumTotal(vector<vector<int> > &triangle) {\n        int n= triangle.size();\n        for(int i=n-2 ; i>=0 ; i--){\n            for(vector<int>::size_type j=0 ; j<triangle[i].size() ; j++ ){\n                triangle[i][j] = min(triangle[i][j]+triangle[i+1][j],triangle[i][j]+triangle[i+1][j+1]);\n            }",
                "url": "https://leetcode.com/problems/triangle/solutions/38730/dp-solution-for-triangle/",
                "vote_count": "1183"
            },
            {
                "language": "csharp",
                "code": "public int minimumTotal(List<List<Integer>> triangle) {\n        if(triangle == null || triangle.size() == 0) return 0;\n        int[] dp = new int[triangle.size() + 1];//O(n) space\n        Arrays.fill(dp,Integer.MAX_VALUE);//initialize with Integer.MAX_VALUE to simplify the boundary.\n        ListIterator<List<Integer>> it = triangle.listIterator();//use iterator instead of list.get(i)\n        dp[1] = it.next().get(0);//add one item\n        while(it.hasNext()){",
                "url": "https://leetcode.com/problems/triangle/solutions/38730/dp-solution-for-triangle/",
                "vote_count": "1183"
            },
            {
                "language": "",
                "code": "   2\n  3 4\n 6 5 7\n4 1 8 3",
                "url": "https://leetcode.com/problems/triangle/solutions/2146264/c-python-simple-solution-w-explanation-recursion-dp/",
                "vote_count": "216"
            },
            {
                "language": "",
                "code": "   2\n  4 5\n 6 5 1\n4 1 8 2",
                "url": "https://leetcode.com/problems/triangle/solutions/2146264/c-python-simple-solution-w-explanation-recursion-dp/",
                "vote_count": "216"
            },
            {
                "language": "",
                "code": "                                                  \u250f\u2501\u2501\u2501\u2513\n                            \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2528 2 \u2520\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n                            \u2502                     \u2517\u2501\u2501\u2501\u251b                     \u2502\n                          \u250f\u2501\u2537\u2501\u2513                                           \u250f\u2501\u2537\u2501\u2513     \n                \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2528 3 \u2520\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e                       \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2528 4 \u2520\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e                 \n                \u2502         \u2517\u2501\u2501\u2501\u251b         \u2502                       \u2502         \u2517\u2501\u2501\u2501\u251b         \u2502 \n              \u250f\u2501\u2537\u2501\u2513                   \u250f\u2501\u2537\u2501\u2513                   \u250f\u2501\u2537\u2501\u2513                   \u250f\u2501\u2537\u2501\u2513  \n        \u256d\u2500\u2500\u2500\u2500\u2500\u2528 6 \u2520\u2500\u2500\u2500\u2500\u2500\u256e       \u256d\u2500\u2500\u2500\u2500\u2500\u2528 5 \u2520\u2500\u2500\u2500\u2500\u2500\u256e       \u256d\u2500\u2500\u2500\u2500\u2500\u2528 5 \u2520\u2500\u2500\u2500\u2500\u2500\u256e       \u256d\u2500\u2500\u2500\u2500\u2500\u2528 7 \u2520\u2500\u2500\u2500\u2500\u2500\u256e \n        \u2502     \u2517\u2501\u2501\u2501\u251b     \u2502       \u2502     \u2517\u2501\u2501\u2501\u251b     \u2502       \u2502     \u2517\u2501\u2501\u2501\u251b     \u2502       \u2502     \u2517\u2501\u2501\u2501\u251b     \u2502 \n      \u250f\u2501\u2537\u2501\u2513           \u250f\u2501\u2537\u2501\u2513   \u250f\u2501\u2537\u2501\u2513           \u250f\u2501\u2537\u2501\u2513   \u250f\u2501\u2537\u2501\u2513           \u250f\u2501\u2537\u2501\u2513   \u250f\u2501\u2537\u2501\u2513           \u250f\u2501\u2537\u2501\u2513 \n      \u2503 4 \u2503           \u2503 1 \u2503   \u2503 1 \u2503           \u2503 8 \u2503   \u2503 1 \u2503           \u2503 8 \u2503   \u2503 8 \u2503           \u2503 3 \u2503\n      \u2517\u2501\u2501\u2501\u251b           \u2517\u2501\u2501\u2501\u251b   \u2517\u2501\u2501\u2501\u251b           \u2517\u2501\u2501\u2501\u251b   \u2517\u2501\u2501\u2501\u251b           \u2517\u2501\u2501\u2501\u251b   \u2517\u2501\u2501\u2501\u251b           \u2517\u2501\u2501\u2501\u251b",
                "url": "https://leetcode.com/problems/triangle/solutions/2146264/c-python-simple-solution-w-explanation-recursion-dp/",
                "vote_count": "216"
            },
            {
                "language": "",
                "code": "                                                  \u250f\u2501\u2501\u2501\u2513\n                            \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2528 2 \u2520\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n                            \u2502                     \u2517\u2501\u2501\u2501\u251b                     \u2502\n                          \u250f\u2501\u2537\u2501\u2513                                           \u250f\u2501\u2537\u2501\u2513     \n                \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2528 3 \u2520\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e                       \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2528 4 \u2520\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e                 \n                \u2502         \u2517\u2501\u2501\u2501\u251b         \u2502                       \u2502         \u2517\u2501\u2501\u2501\u251b         \u2502 \n              \u250f\u2501\u2537\u2501\u2513          .........\u250f\u2501\u2537\u2501\u2513......... .........\u250f\u2501\u2537\u2501\u2513 ........          \u250f\u2501\u2537\u2501\u2513  \n        \u256d\u2500\u2500\u2500\u2500\u2500\u2528 6 \u2520\u2500\u2500\u2500\u2500\u2500\u256e    .  \u256d\u2500\u2500\u2500\u2500\u2500\u2528 5 \u2520\u2500\u2500\u2500\u2500\u2500\u256e  . .  \u256d\u2500\u2500\u2500\u2500\u2500\u2528 5 \u2520\u2500\u2500\u2500\u2500\u2500\u256e  .    \u256d\u2500\u2500\u2500\u2500\u2500\u2528 7 \u2520\u2500\u2500\u2500\u2500\u2500\u256e \n        \u2502     \u2517\u2501\u2501\u2501\u251b     \u2502    .  \u2502     \u2517\u2501\u2501\u2501\u251b     \u2502  . .  \u2502     \u2517\u2501\u2501\u2501\u251b     \u2502  .    \u2502     \u2517\u2501\u2501\u2501\u251b     \u2502 \n      \u250f\u2501\u2537\u2501\u2513           \u250f\u2501\u2537\u2501\u2513  .\u250f\u2501\u2537\u2501\u2513           \u250f\u2501\u2537\u2501\u2513. .\u250f\u2501\u2537\u2501\u2513           \u250f\u2501\u2537\u2501\u2513.  \u250f\u2501\u2537\u2501\u2513           \u250f\u2501\u2537\u2501\u2513 \n      \u2503 4 \u2503           \u2503 1 \u2503  .\u2503 1 \u2503           \u2503 8 \u2503. .\u2503 1 \u2503           \u2503 8 \u2503.  \u2503 8 \u2503           \u2503 3 \u2503\n      \u2517\u2501\u2501\u2501\u251b           \u2517\u2501\u2501\u2501\u251b  .\u2517\u2501\u2501\u2501\u251b           \u2517\u2501\u2501\u2501\u251b. .\u2517\u2501\u2501\u2501\u251b           \u2517\u2501\u2501\u2501\u251b.  \u2517\u2501\u2501\u2501\u251b           \u2517\u2501\u2501\u2501\u251b\n                             ....................... ....................... ",
                "url": "https://leetcode.com/problems/triangle/solutions/2146264/c-python-simple-solution-w-explanation-recursion-dp/",
                "vote_count": "216"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        @cache\n        def dfs(i, j):\n            if i == len(triangle):\n                return 0\n\n            lower_left = triangle[i][j] + dfs(i + 1, j)\n            lower_right = triangle[i][j] + dfs(i + 1, j + 1)\n\n            return min(lower_left, lower_right)\n\n        return dfs(0, 0)",
                "url": "https://leetcode.com/problems/triangle/solutions/2146264/c-python-simple-solution-w-explanation-recursion-dp/",
                "vote_count": "216"
            },
            {
                "language": "rust",
                "code": "1. Suppose that only the last level is given. \n\n4 1 8 3\n\nThen what should be your answer?\n\nIf you thought 1, then congratulations \ud83c\udf89 you are correct. This is our first subproblem. \n\n2. Now, the last two levels are given.\n\n 6 5 7\n4 1 8 3\n\nHere, what should be the answer and what information do you need to store?\n\nClearly, the answer is 6 (5 -> 1). But, this may not be the optimal path. So, we need to store all the optimal paths, i.e.,\n[(6 -> 1), (5 -> 1), 7 -> 3)] or [7, 6, 10]. This is our second subproblem.\n\n3. Last 3 levels are given.\n\n  3 4\n 6 5 7\n4 1 8 3\n\nAgain, what should be the answer and what information do you need to store (or use)?\n\nAnswer is 9 (3 -> 5 -> 1). Do we need to look again at all the paths? Can we use the information that we previously stored?\nNo and Yes.\nIf we replace the triangle as\n  3 4\n 7 6 10\nthen also, we'll get the same answer. And we can store this information as [(3 -> 6), (4 -> 6)] or [9, 10].\n\n4. All levels are given\n\n   2\n  3 4\n 6 5 7\n4 1 8 3\n\nWhich can be replaced as:\n   2\n  9 10\n\nAnd hence, our answer is 11 (2 -> 9)",
                "url": "https://leetcode.com/problems/triangle/solutions/2146264/c-python-simple-solution-w-explanation-recursion-dp/",
                "vote_count": "216"
            },
            {
                "language": "java",
                "code": "def minimumTotal(self, triangle: List[List[int]]) -> int:\n\n    dp = [0] * (len(triangle) + 1)\n    \n    for row in triangle[::-1]:\n        for i, n in enumerate(row):\n            dp[i] = n + min(dp[i], dp[i + 1])\n    ",
                "url": "https://leetcode.com/problems/triangle/solutions/2146264/c-python-simple-solution-w-explanation-recursion-dp/",
                "vote_count": "216"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        vector<vector<int>> dp = triangle;\n        for(int i=triangle.size()-2;i>=0;i--){\n            for(int j=0; j<triangle[i].size();j++){\n                dp[i][j]+=min(dp[i+1][j],dp[i+1][j+1]);",
                "url": "https://leetcode.com/problems/triangle/solutions/2146264/c-python-simple-solution-w-explanation-recursion-dp/",
                "vote_count": "216"
            },
            {
                "language": "cpp",
                "code": "int minimumTotal(vector<vector<int>>& triangle) {\n    \n        int n = triangle.size();\n    \n        for(int i=n-2;i>=0;--i){        \n            for(int j=0;j<=i;++j){\n                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]);\n            }",
                "url": "https://leetcode.com/problems/triangle/solutions/2146264/c-python-simple-solution-w-explanation-recursion-dp/",
                "vote_count": "216"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def minimumTotal(self, t: List[List[int]]) -> int:\n        for i in range(len(t)-2, -1, -1):\n            for j in range(i+1):\n                t[i][j] += min(t[i+1][j], t[i+1][j+1])\n            \n        return t[0][0]",
                "url": "https://leetcode.com/problems/triangle/solutions/2146264/c-python-simple-solution-w-explanation-recursion-dp/",
                "vote_count": "216"
            },
            {
                "language": "cpp",
                "code": " // Recursion *** Will Give TLE ***\n int solve(int i, int j, int n, vector<vector<int>>&triangle) {\n  if(i == n - 1)\n   return triangle[i][j];\n  int bottom = triangle[i][j] + solve(i+1, j, n, triangle);\n  int  bottom_right = triangle[i][j] + solve(i+1, j+1, n, triangle);\n  return min(bottom, bottom_right);\n }\n int minimumTotal(vector<vector<int>>& triangle) {\n  int n = triangle.size();\n  return solve(0, 0, n, triangle);\n }\n ",
                "url": "https://leetcode.com/problems/triangle/solutions/2145266/c-4-approaches-recursion-memoization-tabulation-space-optimal/",
                "vote_count": "94"
            },
            {
                "language": "cpp",
                "code": " // Memoization\n int solve(int i, int j, int n, vector<vector<int>>&triangle, vector<vector<int>>&dp) {\n  if(i == n - 1)\n   return triangle[i][j];\n  if(dp[i][j] != -1)\n   return dp[i][j];\n  int bottom = triangle[i][j] + solve(i+1, j, n, triangle, dp);\n  int  bottom_right = triangle[i][j] + solve(i+1, j+1, n, triangle, dp);\n  return dp[i][j] = min(bottom, bottom_right);\n }\n int minimumTotal(vector<vector<int>>& triangle) {\n  int n = triangle.size();\n  vector<vector<int>>dp(n, vector<int>(n, -1));\n  return solve(0, 0, n, triangle, dp);\n }\n ",
                "url": "https://leetcode.com/problems/triangle/solutions/2145266/c-4-approaches-recursion-memoization-tabulation-space-optimal/",
                "vote_count": "94"
            },
            {
                "language": "cpp",
                "code": " // Tabulation\n int minimumTotal(vector<vector<int>>& triangle) {\n  int n = triangle.size();\n  vector<vector<int>>dp(n, vector<int>(n, -1));\n  for(int i = 0; i < n; i++) \n   dp[n-1][i] = triangle[n-1][i];\n  for(int i = n-2; i >= 0; i--) {\n   for(int j = i; j >= 0; j--) {\n    int up = triangle[i][j] + dp[i+1][j];\n    int up_left = triangle[i][j] + dp[i+1][j+1];\n    dp[i][j] = min(up, up_left);\n   }\n  }\n  return dp[0][0];\n }\n ",
                "url": "https://leetcode.com/problems/triangle/solutions/2145266/c-4-approaches-recursion-memoization-tabulation-space-optimal/",
                "vote_count": "94"
            },
            {
                "language": "cpp",
                "code": "// Space Optimization\n int minimumTotal(vector<vector<int>>& triangle) {\n  int n = triangle.size();\n  vector<int>next(n);\n  for(int i = n-1; i >= 0; i--) {\n   vector<int>curr(n);\n   for(int j = i; j >= 0; j--) {\n    if(i == n-1)\n     curr[j] = triangle[i][j];\n    else {\n     int up = triangle[i][j] + next[j];\n     int up_left = triangle[i][j] + next[j+1];\n     curr[j] = min(up, up_left);\n    }\n   }\n   next = curr;\n  }\n  return next[0];\n }",
                "url": "https://leetcode.com/problems/triangle/solutions/2145266/c-4-approaches-recursion-memoization-tabulation-space-optimal/",
                "vote_count": "94"
            },
            {
                "language": "cpp",
                "code": "int minimumTotal(vector<vector<int>>& arr) {\n    int row = arr.size();\n    vector<int> front = arr[row-1];\n\n    for(int i = row-2 ; i>=0 ; i--)\n    {\n        for(int j = 0 ; j<=i ; j++)",
                "url": "https://leetcode.com/problems/triangle/solutions/2145266/c-4-approaches-recursion-memoization-tabulation-space-optimal/",
                "vote_count": "94"
            },
            {
                "language": "cpp",
                "code": "    int dfs(vector<vector<int>>& triangle, int i, int j, vector<vector<int>>&dp) {\n        if (i == triangle.size()) return 0;\n        if (dp[i][j] != -1) return dp[i][j];\n        dp[i][j] = (triangle[i][j] + min(dfs(triangle, i+1, j, dp), dfs(triangle, i+1, j+1, dp)));\n        return dp[i][j];\n    }\n    \n    int minimumTotal(vector<vector<int>>& triangle) {",
                "url": "https://leetcode.com/problems/triangle/solutions/2145266/c-4-approaches-recursion-memoization-tabulation-space-optimal/",
                "vote_count": "94"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    // Tabulation\n int minimumTotal(vector<vector<int>>& triangle) \n    {\n  int n = triangle.size();",
                "url": "https://leetcode.com/problems/triangle/solutions/2145266/c-4-approaches-recursion-memoization-tabulation-space-optimal/",
                "vote_count": "94"
            }
        ]
    },
    "120": {
        "question_id": 121,
        "title": "Best Time to Buy and Sell Stock",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock",
        "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day.You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. ",
        "examples": [
            {
                "input": "prices = [7,1,5,3,6,4]",
                "output": "5",
                "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell."
            },
            {
                "input": "prices = [7,6,4,3,1]",
                "output": "0",
                "explanation": "In this case, no transactions are done and the max profit = 0."
            }
        ],
        "constraints": [
            "1 <= prices.length <= 10^5",
            "0 <= prices[i] <= 10^4"
        ],
        "solutions": [
            {
                "language": "",
                "code": "prices = [7,6,4,3,1]",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/1735550/python-javascript-easy-solution-with-very-clear-explanation/",
                "vote_count": "1491"
            },
            {
                "language": "cpp",
                "code": "{\n        int lsf = Integer.MAX_VALUE; // least so far\n        int op = 0; // overall profit\n        int pist = 0; // profit if sold today\n        \n        for(int i = 0; i < prices.length; i++){\n            if(prices[i] < lsf){ // if we found new buy value which is more smaller then previous one\n                lsf = prices[i]; // update our least so far\n            }\n            pist = prices[i] - lsf; // calculating profit if sold today by, Buy - sell\n            if(op < pist){ // if pist is more then our previous overall profit\n                op = pist; // update overall profit\n            }\n        }\n        return op; // return op ",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/1735493/java-c-best-ever-explanation-could-possible/",
                "vote_count": "947"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int lsf = Integer.MAX_VALUE;\n        int op = 0;\n        int pist = 0;\n        \n        for(int i = 0; i < prices.length; i++){\n            if(prices[i] < lsf){\n                lsf = prices[i];\n            }\n            pist = prices[i] - lsf;\n            if(op < pist){\n                op = pist;\n            }\n        }\n        return op;\n    }\n}",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/1735493/java-c-best-ever-explanation-could-possible/",
                "vote_count": "947"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int lsf = INT_MAX;\n        int op = 0;\n        int pist = 0;\n        \n        for(int i = 0; i < prices.size(); i++){\n            if(prices[i] < lsf){\n                lsf = prices[i];\n            }\n            pist = prices[i] - lsf;\n            if(op < pist){\n                op = pist;\n            }\n        }\n        return op;\n    }\n};",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/1735493/java-c-best-ever-explanation-could-possible/",
                "vote_count": "947"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int buy=Integer.MAX_VALUE,sell=0;\n        for(int i=0;i<prices.length;i++){\n            buy=Math.min(buy,prices[i]);\n            sell=Math.max(sell,prices[i]-buy);\n        }\n       return sell;",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/1735493/java-c-best-ever-explanation-could-possible/",
                "vote_count": "947"
            },
            {
                "language": "python",
                "code": "    public int maxProfit(int[] prices) {\n        int profit = 0;\n        int len = prices.length;\n        int iBuy = 0; // index when buying\n        for(int i=0;i<len;i++){\n            if(prices[iBuy] > prices[i]) iBuy = i;",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/1735493/java-c-best-ever-explanation-could-possible/",
                "vote_count": "947"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        \n        int max = 0;",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/1735493/java-c-best-ever-explanation-could-possible/",
                "vote_count": "947"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/1735493/java-c-best-ever-explanation-could-possible/",
                "vote_count": "947"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        l = 10000 \n        ans = 0 \n        p = 0\n        for i in prices:\n            if i < l:\n                l = i",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/1735493/java-c-best-ever-explanation-could-possible/",
                "vote_count": "947"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N^2), Where N is the size of the Array(prices). As we check for possible pair, and the\n    total number of pairs are : N*(N\u20131)/2.\n\n    Space complexity : O(1), Constant space.\n\n    Using Array(Two Nested Loop). Brute Force Approach.\n\n    Note : This will give TLE.\n\n*/\n\n\n/***************************************** Approach 1 Code *****************************************/\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int n = prices.size(), maxProfit = 0;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n                if(prices[j] - prices[i] > maxProfit){\n                    maxProfit = prices[j] - prices[i];\n                }\n            }\n        }\n        return maxProfit;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N), As we iterate the array(prices) two times. Where N = size of the array.\n\n    Space complexity : O(N), Array(maxPrices) space.\n\n    Solved using Dynamic Programming Approach(tabulation).\n\n*/\n\n\n/***************************************** Approach 2 Code *****************************************/\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int n = prices.size();\n        vector<int> maxPrices(n, 0);\n        maxPrices[n-1] = prices[n-1];\n        for(int i=n-2; i>=0; i--){\n            maxPrices[i] = max(maxPrices[i+1], prices[i]); \n        }\n        int maxProfit = 0;\n        for(int i=0; i<n; i++){\n            maxProfit = max(maxProfit, maxPrices[i] - prices[i]); \n        }\n        return maxProfit;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N), As we iterate the array(prices) two times. Where N = size of the array.\n\n    Space Complexity : O(1), Constant space.\n\n    Solved using Dynamic Programming Approach(Space optimisation).\n\n*/\n\n\n/***************************************** Approach 3 Code *****************************************/\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int n = prices.size();\n        int buyAtPrice = INT_MAX;\n        int maxProfit = 0;\n        for(int i=0; i<n; i++){\n            buyAtPrice = min(buyAtPrice, prices[i]);\n            maxProfit = max(maxProfit, prices[i] - buyAtPrice); \n        }\n        return maxProfit;\n    }\n};",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3169837/best-c-3-solution-dp-space-optimization-brute-force-optimize/",
                "vote_count": "82"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int n = prices.size();\n        int maximumProfit = 0, minStockVal = INT_MAX;\n        int i = 0;\n        while (i < n) {\n            minStockVal = min(minStockVal, prices[i]);\n            // whenever the price of current stock is greater then then the stock value which we bought then only we will sell the stock \n            if (prices[i] >= minStockVal)\n                maximumProfit = max(maximumProfit, prices[i] - minStockVal);\n            i++;\n        }\n        return maximumProfit;\n    }\n};",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3226882/day-56-o-n-time-and-o-1-space-easiest-beginner-friendly-sol/",
                "vote_count": "39"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int lsf = Integer.MAX_VALUE;\n        int op = 0;\n        int pist = 0;\n        \n        for(int i = 0; i < prices.length; i++){\n            if(prices[i] < lsf){\n                lsf = prices[i];\n            }\n            pist = prices[i] - lsf;\n            if(op < pist){\n                op = pist;\n            }\n        }\n        return op;\n    }\n}",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227453/fast-java-solution/",
                "vote_count": "33"
            }
        ]
    },
    "121": {
        "question_id": 122,
        "title": "Best Time to Buy and Sell Stock II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii",
        "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.Find and return the maximum profit you can achieve. ",
        "examples": [
            {
                "input": "prices = [7,1,5,3,6,4]",
                "output": "7",
                "explanation": "Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7."
            },
            {
                "input": "prices = [1,2,3,4,5]",
                "output": "4",
                "explanation": "Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4."
            },
            {
                "input": "prices = [7,6,4,3,1]",
                "output": "0",
                "explanation": "There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0."
            }
        ],
        "constraints": [
            "1 <= prices.length <= 3 * 10^4",
            "0 <= prices[i] <= 10^4"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "public int maxProfit(int[] prices) {\n        int i = 0, buy, sell, profit = 0, N = prices.length - 1;\n        while (i < N) {\n            while (i < N && prices[i + 1] <= prices[i]) i++;\n            buy = prices[i];\n\n            while (i < N && prices[i + 1] > prices[i]) i++;\n            sell = prices[i];\n\n            profit += sell - buy;\n        }\n        return profit;\n}",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/208241/explanation-for-the-dummy-like-me/",
                "vote_count": "789"
            },
            {
                "language": "swift",
                "code": "public Pair<List<Pair<Integer, Integer>>, Integer> buysAndSells(int[] prices) {\n        int i = 0, iBuy, iSell, profit = 0, N = prices.length - 1;\n        List<Pair<Integer, Integer>> buysAndSells = new ArrayList<Pair<Integer, Integer>>();\n        while (i < N) {\n            while (i < N && prices[i + 1] <= prices[i]) i++;\n            iBuy = i;\n\n            while (i < N && prices[i + 1] > prices[i]) i++;\n            iSell = i;\n\n            profit += prices[iSell] - prices[iBuy];\n            Pair<Integer, Integer> bs = new Pair<Integer, Integer>(iBuy, iSell);\n            buysAndSells.add(bs);\n        }\n        return new Pair<List<Pair<Integer, Integer>>, Integer>(buysAndSells, profit);\n}\n \npublic class Pair<T1, T2> {\n    public T1 fst;\n    public T2 snd;\n    public Pair(T1 f, T2 s) {\n        fst = f;\n        snd = s;\n    }\n}",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/208241/explanation-for-the-dummy-like-me/",
                "vote_count": "789"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/208241/explanation-for-the-dummy-like-me/",
                "vote_count": "789"
            },
            {
                "language": "cpp",
                "code": "public int maxProfit(final int[] A) {\n   if (A.length <= 1)\n        return 0;\n    int maxprofit = 0;\n    for (int i = 1; i < A.length; i++) {\n        maxprofit += Math.max(0, A[i] - A[i - 1]);\n    }\n    return maxprofit;",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/208241/explanation-for-the-dummy-like-me/",
                "vote_count": "789"
            },
            {
                "language": "cpp",
                "code": "public int maxProfit(int[] prices) {\n    int profit=0;\n    // i for buy day index\n    // j for sell index\n    for (int i=0;i<prices.length-1;i++) {\n        if(prices[i] < prices[i+1]) {\n            int j=i+1;\n            while(j < prices.length-1 && prices[j] < prices[j+1]) {\n                j++;",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/208241/explanation-for-the-dummy-like-me/",
                "vote_count": "789"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n\n        price_gain = []\n        \n        for idx in range( len(prices)-1 ):\n            \n            if prices[idx] < prices[idx+1]:\n                \n                price_gain.append( prices[idx+1]- prices[idx])\n                \n        return sum( price_gain )",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/803206/python-js-java-go-c-o-n-by-dp-greedy-visualization/",
                "vote_count": "481"
            },
            {
                "language": "csharp",
                "code": "",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/803206/python-js-java-go-c-o-n-by-dp-greedy-visualization/",
                "vote_count": "481"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/803206/python-js-java-go-c-o-n-by-dp-greedy-visualization/",
                "vote_count": "481"
            },
            {
                "language": "go",
                "code": "",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/803206/python-js-java-go-c-o-n-by-dp-greedy-visualization/",
                "vote_count": "481"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/803206/python-js-java-go-c-o-n-by-dp-greedy-visualization/",
                "vote_count": "481"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n\n        return sum( ( prices[idx+1]-prices[idx] ) for idx in range(len(prices)-1) if prices[idx] < prices[idx+1] )",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/803206/python-js-java-go-c-o-n-by-dp-greedy-visualization/",
                "vote_count": "481"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        \n        profit_from_price_gain = 0\n        for idx in range( len(prices)-1 ):\n            \n            if prices[idx] < prices[idx+1]:\n                profit_from_price_gain += ( prices[idx+1] - prices[idx])\n                \n        return profit_from_price_gain",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/803206/python-js-java-go-c-o-n-by-dp-greedy-visualization/",
                "vote_count": "481"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int maxProfit(int[] prices) {      \n        int profitFromPriceGain = 0;\n        \n        for( int i = 0 ; i < prices.length-1 ; i++ ){\n            \n            if( prices[i] < prices[i+1] ){\n                profitFromPriceGain += ( prices[i+1] - prices[i] );\n            }\n        }\n        \n        return profitFromPriceGain;\n    }\n}",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/803206/python-js-java-go-c-o-n-by-dp-greedy-visualization/",
                "vote_count": "481"
            },
            {
                "language": "javascript",
                "code": "var maxProfit = function(prices) {\n    \n    let profitFromPriceGain = 0;\n    \n    for( let i = 0 ; i < prices.length-1 ; i++ ){\n        \n        if( prices[i] < prices[i+1] ){\n            profitFromPriceGain += (  prices[i+1] - prices[i] );\n        }\n    }\n    \n    return profitFromPriceGain;\n}",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/803206/python-js-java-go-c-o-n-by-dp-greedy-visualization/",
                "vote_count": "481"
            },
            {
                "language": "go",
                "code": "func maxProfit(prices []int) int {\n    \n    profitFromPriceGain := 0\n    \n    for i := 0 ; i < len(prices)-1 ; i++{\n        \n        if( prices[i] < prices[i+1] ){\n            profitFromPriceGain += ( prices[i+1] - prices[i] )\n        }\n    }\n\n    return profitFromPriceGain\n}",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/803206/python-js-java-go-c-o-n-by-dp-greedy-visualization/",
                "vote_count": "481"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        \n        int profitFromPriceGain = 0;\n        \n        for( size_t i = 0 ; i < prices.size()-1 ; i++ ){\n            \n            if( prices[i] < prices[i+1] ){\n                profitFromPriceGain += ( prices[i+1] - prices[i] );\n            }\n            \n        }\n        return profitFromPriceGain;\n    }\n};",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/803206/python-js-java-go-c-o-n-by-dp-greedy-visualization/",
                "vote_count": "481"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        prices.append(0)\n        profit = 0\n        buy_price = prices[0]\n        \n        for day, price in enumerate(prices):\n            if price < prices[day - 1]: # sell and buy again",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/803206/python-js-java-go-c-o-n-by-dp-greedy-visualization/",
                "vote_count": "481"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int maxProfit(int[] prices) {\n  // We need prices for 2 days at least to find the profit.\n        if (prices == null || prices.length <= 1) {\n            return 0;\n        }\n\n        int totalProfit = 0;\n        for (int i = 1; i < prices.length; i++) {\n            // Checking if we can profit with previous day's price.\n            // If yes, then we buy on previous day and sell on current day.\n            // Add all such profits to get the total profit.\n            if (prices[i - 1] < prices[i]) {\n                totalProfit += prices[i] - prices[i - 1];\n            }\n        }\n\n        return totalProfit;\n    }\n}",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/1569081/java-simple-clean-dp-solutions-for-all-6-buy-sell-stock-questions-on-leetcode/",
                "vote_count": "208"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        if (prices == null || prices.length <= 1) {\n            return 0;\n        }\n\n        int maxProfitHere = 0;\n        int maxProfitSoFar = 0;\n        for (int i = 1; i < prices.length; i++) {\n            maxProfitHere = Math.max(0, maxProfitHere + prices[i] - prices[i - 1]);\n            maxProfitSoFar = Math.max(maxProfitSoFar, maxProfitHere);\n        }\n\n        return maxProfitSoFar;\n    }\n}",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/1569081/java-simple-clean-dp-solutions-for-all-6-buy-sell-stock-questions-on-leetcode/",
                "vote_count": "208"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        if (prices == null || prices.length <= 1) {\n            return 0;\n        }\n\n        int buy1 = -prices[0];\n        int sell1 = buy1 + prices[0];\n        int buy2 = sell1 - prices[0];\n        int sell2 = buy2 + prices[0];\n\n        for (int i = 1; i < prices.length; i++) {\n            // The maximum money left after buying 1st stock.\n            buy1 = Math.max(buy1, -prices[i]);\n\n            // The maximum money left after selling 1st stock.\n            sell1 = Math.max(sell1, buy1 + prices[i]);\n\n            // The maximum money left after buying 2nd stock.\n            buy2 = Math.max(buy2, sell1 - prices[i]);\n\n            // The maximum money left after selling 2nd stock.\n            sell2 = Math.max(sell2, buy2 + prices[i]);\n        }\n\n        return Math.max(sell1, sell2);\n    }\n}",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/1569081/java-simple-clean-dp-solutions-for-all-6-buy-sell-stock-questions-on-leetcode/",
                "vote_count": "208"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int maxProfit(int k, int[] prices) {\n        if (prices == null || prices.length <= 1 || k <= 0) {\n            return 0;\n        }\n        if (k >= prices.length / 2) {\n            return quickSolve(prices);\n        }\n\n        int len = prices.length;\n        int[] dp1 = new int[len];\n        int[] dp2 = new int[len];\n        for (int i = 0; i < k; i++) {\n            int tempMax = -prices[0];\n            for (int j = 1; j < len; j++) {\n                dp2[j] = Math.max(dp2[j - 1], prices[j] + tempMax);\n                tempMax = Math.max(tempMax, dp1[j] - prices[j]);\n            }\n            dp1 = Arrays.copyOf(dp2, len);\n        }\n\n        return dp2[len - 1];\n    }\n\n    private int quickSolve(int[] prices) {\n        int totalProfit = 0;\n        for (int i = 1; i < prices.length; i++) {\n            if (prices[i - 1] < prices[i]) {\n                totalProfit += prices[i] - prices[i - 1];\n            }\n        }\n        return totalProfit;\n    }\n}",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/1569081/java-simple-clean-dp-solutions-for-all-6-buy-sell-stock-questions-on-leetcode/",
                "vote_count": "208"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        if (prices == null || prices.length <= 1) {\n            return 0;\n        }\n\n        int buy = -prices[0];\n        int sell = 0;\n        int prevSell = 0;\n\n        for (int i = 1; i < prices.length; i++) {\n            // buy[i] = Math.max(sell[i-2]-prices[i], buy[i-1])\n            // sell[i-2]-prices[i] -> Buy after a 1 day cooldown\n            // buy[i-1] -> cooldown\n            buy = Math.max(prevSell - prices[i], buy);\n\n            // sell[i-1];\n            prevSell = sell;\n\n            // sell[i] = Math.max(buy[i]+prices, sell[i-1])\n            // buy[i]+prices -> sell the stock.\n            // sell[i-1] -> cooldown\n            sell = Math.max(buy + prices[i], sell);\n        }\n\n        return sell;\n    }\n}",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/1569081/java-simple-clean-dp-solutions-for-all-6-buy-sell-stock-questions-on-leetcode/",
                "vote_count": "208"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int maxProfit(int[] prices, int fee) {\n        if (prices == null || prices.length < 2) {\n            return 0;\n        }\n\n        int buy = -prices[0];\n        int sell = 0;\n\n        for (int i = 1; i < prices.length; i++) {\n\n            // buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i])\n            buy = Math.max(sell - prices[i], buy);\n\n            // sell[i] = Math.max(sell[i - 1], buy[i] + prices[i])\n            sell = Math.max(buy + prices[i] - fee, sell);\n        }\n\n        return sell;\n    }\n}",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/1569081/java-simple-clean-dp-solutions-for-all-6-buy-sell-stock-questions-on-leetcode/",
                "vote_count": "208"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def maxProfit(self, a: List[int]) -> int:\n        ans=0\n        x=a[0]\n        for i in range(1,len(a)):\n            if(x>a[i]):\n                x=a[i]\n            else:\n                ans+=a[i]-x\n                x=a[i]\n        return ans\n\n        ",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/3343376/python3-greedy/",
                "vote_count": "18"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        \n        result = 0\n        if len(prices) < 2:\n            return result\n\n        lowest = prices[0]",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/3343376/python3-greedy/",
                "vote_count": "18"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        maxprofit=0\n        for i in range(len(prices)-1):\n            if prices[i+1]>prices[i]:\n                maxprofit+=prices[i+1]-prices[i]\n        return maxprofit\n    #please upvote me it would encourage me alot",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/3307280/fantastic-logic-python3/",
                "vote_count": "14"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit = 0;\n        for (int i = 1; i < prices.length; i++) {\n            if (prices[i] > prices[i - 1])\n                maxprofit += prices[i] - prices[i - 1];\n        } return maxprofit;\n    }\n}",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solutions/3258316/best-3-lines-of-code-easiest-solution-in-o-n/",
                "vote_count": "12"
            }
        ]
    },
    "122": {
        "question_id": 123,
        "title": "Best Time to Buy and Sell Stock III",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii",
        "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day.Find the maximum profit you can achieve. You may complete at most two transactions.Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). ",
        "examples": [
            {
                "input": "prices = [3,3,5,0,0,3,1,4]",
                "output": "6",
                "explanation": "Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3"
            },
            {
                "input": "prices = [1,2,3,4,5]",
                "output": "4",
                "explanation": "Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again."
            },
            {
                "input": "prices = [7,6,4,3,1]",
                "output": "0",
                "explanation": "In this case, no transaction is done, i.e. max profit = 0."
            }
        ],
        "constraints": [
            "1 <= prices.length <= 10^5",
            "0 <= prices[i] <= 10^5"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "dp[k, i] = max(dp[k, i-1], prices[i] - prices[j] + dp[k-1, j-1]), j=[0..i-1]",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/135704/detail-explanation-of-dp-solution/",
                "vote_count": "1323"
            },
            {
                "language": "python",
                "code": "        public int MaxProfitDp(int[] prices) {\n            if (prices.Length == 0) return 0;\n            var dp = new int[3, prices.Length];\n            for (int k = 1; k <= 2; k++)  {\n                for (int i = 1; i < prices.Length; i++) {\n                    int min = prices[0];\n                    for (int j = 1; j <= i; j++)\n                        min = Math.Min(min, prices[j] - dp[k-1, j-1]);\n                    dp[k, i] = Math.Max(dp[k, i-1], prices[i] - min);\n                }\n            }\n\n            return dp[2, prices.Length - 1];\n        }",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/135704/detail-explanation-of-dp-solution/",
                "vote_count": "1323"
            },
            {
                "language": "python",
                "code": "        public int MaxProfitDpCompact1(int[] prices) {\n            if (prices.Length == 0) return 0;\n            var dp = new int[3, prices.Length];\n            for (int k = 1; k <= 2; k++) {\n                int min = prices[0];\n                for (int i = 1; i < prices.Length; i++) {\n                    min = Math.Min(min, prices[i] - dp[k-1, i-1]);\n                    dp[k, i] = Math.Max(dp[k, i-1], prices[i] - min);\n                }\n            }\n\n            return dp[2, prices.Length - 1];\n        }",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/135704/detail-explanation-of-dp-solution/",
                "vote_count": "1323"
            },
            {
                "language": "csharp",
                "code": "        public int MaxProfitDpCompact1T(int[] prices) {\n            if (prices.Length == 0) return 0;\n            var dp = new int[3, prices.Length];\n            var min = new int[3];\n            Array.Fill(min, prices[0]);\n            for (int i = 1; i < prices.Length; i++) {\n                for (int k = 1; k <= 2; k++) {\n                    min[k] = Math.Min(min[k], prices[i] - dp[k-1, i-1]);\n                    dp[k, i] = Math.Max(dp[k, i-1], prices[i] - min[k]);\n                }\n            }\n\n            return dp[2, prices.Length - 1];\n        }",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/135704/detail-explanation-of-dp-solution/",
                "vote_count": "1323"
            },
            {
                "language": "csharp",
                "code": "        public int MaxProfitDpCompact2(int[] prices) {\n            if (prices.Length == 0) return 0;\n            var dp = new int[3];\n            var min = new int[3];\n            Array.Fill(min, prices[0]);\n            for (int i = 1; i < prices.Length; i++)  {\n                for (int k = 1; k <= 2; k++) {\n                    min[k] = Math.Min(min[k], prices[i] - dp[k-1]);\n                    dp[k] = Math.Max(dp[k], prices[i] - min[k]);\n                }\n            }\n\n            return dp[2];\n        }",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/135704/detail-explanation-of-dp-solution/",
                "vote_count": "1323"
            },
            {
                "language": "cpp",
                "code": "        public int MaxProfitDpCompactFinal(int[] prices)  {\n            int buy1 = int.MaxValue, buy2 = int.MaxValue;\n            int sell1 = 0, sell2 = 0;\n\n            for (int i = 0; i < prices.Length; i++) {\n                buy1 = Math.Min(buy1, prices[i]);\n                sell1 = Math.Max(sell1, prices[i] - buy1);\n                buy2 = Math.Min(buy2, prices[i] - sell1);\n                sell2 = Math.Max(sell2, prices[i] - buy2);\n            }\n\n            return sell2;\n        }",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/135704/detail-explanation-of-dp-solution/",
                "vote_count": "1323"
            },
            {
                "language": "typescript",
                "code": "//Version 1\n//Time complexity is O(kn^2), space complexity is O(kn).\nclass Solution {",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/135704/detail-explanation-of-dp-solution/",
                "vote_count": "1323"
            },
            {
                "language": "java",
                "code": "public int maxProfit(int[] prices) {\n        if(prices == null || prices.length == 0) return 0;\n        int totalK = 2;\n        int[][] dp = new int[totalK+1][prices.length];\n        for(int k = 1;k<=totalK;k++){//profit = 0 when k = 0\n            for(int i = 1;i< prices.length;i++){\n                int maxProfitSellOnDayI = Math.max(0,prices[i] - prices[0]);//buy on day 0, sell on day i\n- prices[j]);",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/135704/detail-explanation-of-dp-solution/",
                "vote_count": "1323"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/135704/detail-explanation-of-dp-solution/",
                "vote_count": "1323"
            },
            {
                "language": "python",
                "code": "dp[i] = max(dp[i-1], prices[i] - prices[j] + dp[j-2]), j=[0..i-1]",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/135704/detail-explanation-of-dp-solution/",
                "vote_count": "1323"
            },
            {
                "language": "csharp",
                "code": "    public int MaxProfit(int[] prices) {",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/135704/detail-explanation-of-dp-solution/",
                "vote_count": "1323"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/135704/detail-explanation-of-dp-solution/",
                "vote_count": "1323"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        if (prices.length == 0) return 0;\n        int[] dp = new int[prices.length];\n        for (int k = 1; k <= 2; k++) {\n            int min = prices[0], last = 0;\n            for (int i = 1; i < prices.length; i++) {",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/135704/detail-explanation-of-dp-solution/",
                "vote_count": "1323"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\n    public int maxProfit(int[] prices) {\n        int hold1 = Integer.MIN_VALUE, hold2 = Integer.MIN_VALUE;\n        int release1 = 0, release2 = 0;\n        for(int i:prices){                              // Assume we only have 0 money at first\n            release2 = Math.max(release2, hold2+i);     // The maximum if we've just sold 2nd stock so far.\n            hold2    = Math.max(hold2,    release1-i);  // The maximum if we've just buy  2nd stock so far.\n            release1 = Math.max(release1, hold1+i);     // The maximum if we've just sold 1nd stock so far.\n            hold1    = Math.max(hold1,    -i);          // The maximum if we've just buy  1st stock so far. \n        }\n        return release2; ///Since release1 is initiated as 0, so release2 will always higher than release1.\n    }\n}",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/39611/is-it-best-solution-with-o-n-o-1/",
                "vote_count": "832"
            },
            {
                "language": "javascript",
                "code": "var maxProfit = function(prices) {\n  let oneBuyOneSell = 0;\n  let twoBuyTwoSell = 0;\n  let oneBuy = Number.POSITIVE_INFINITY\n  let twoBuy = Number.POSITIVE_INFINITY;\n  \n  for(let i = 0; i < prices.length; i++) {",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/39611/is-it-best-solution-with-o-n-o-1/",
                "vote_count": "832"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/39611/is-it-best-solution-with-o-n-o-1/",
                "vote_count": "832"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int buyOne = Integer.MAX_VALUE;\n        int SellOne = 0;\n        int buyTwo = Integer.MAX_VALUE;\n        int SellTwo = 0;\n        for(int p : prices) {\n            buyOne = Math.min(buyOne, p);\n            SellOne = Math.max(SellOne, p - buyOne);",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/39611/is-it-best-solution-with-o-n-o-1/",
                "vote_count": "832"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/39611/is-it-best-solution-with-o-n-o-1/",
                "vote_count": "832"
            },
            {
                "language": "cpp",
                "code": "public int maxProfit(int[] prices) {\n    int oneBuy = Integer.MIN_VALUE;\n    int oneBuyOneSell = 0;\n    int twoBuy = Integer.MIN_VALUE;\n    int twoBuyTwoSell = 0;\n    for(int i = 0; i < prices.length; i++){\n        oneBuy = Math.max(oneBuy, -prices[i]);//we set prices to negative, so the calculation of profit will be convenient\n        oneBuyOneSell = Math.max(oneBuyOneSell, prices[i] + oneBuy);\n        twoBuy = Math.max(twoBuy, oneBuyOneSell - prices[i]);//we can buy the second only after first is sold",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/39611/is-it-best-solution-with-o-n-o-1/",
                "vote_count": "832"
            },
            {
                "language": "python",
                "code": "     public static int maxProfit(int [] prices){\n     int maxProfit1 = 0; \n     int maxProfit2 = 0; \n     int lowestBuyPrice1 = Integer.MAX_VALUE;",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/39611/is-it-best-solution-with-o-n-o-1/",
                "vote_count": "832"
            },
            {
                "language": "python",
                "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int b1 = INT_MIN, s1 = 0, b2 = INT_MIN, s2 = 0;\n        for (int p : prices) {\n            b1 = max(b1, -p);\n            s1 = max(s1, b1 + p);",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/39611/is-it-best-solution-with-o-n-o-1/",
                "vote_count": "832"
            },
            {
                "language": "javascript",
                "code": "\"lowestBuyPrice2\" = buyPrice2 - maxProfit1 \n                  = buyPrice2 - (highestSellPrice1 - lowestBuyPrice1). ",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/39611/is-it-best-solution-with-o-n-o-1/",
                "vote_count": "832"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/39611/is-it-best-solution-with-o-n-o-1/",
                "vote_count": "832"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/39611/is-it-best-solution-with-o-n-o-1/",
                "vote_count": "832"
            },
            {
                "language": "cpp",
                "code": "public int maxProfit(int k, int[] prices) {\n    int[] s = new int[k+1];\n    int[] b = new int[k+1];\n    for(int i=0; i<b.length; i++)\n        b[i] = Integer.MIN_VALUE;\n    for(int p : prices) {",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/39611/is-it-best-solution-with-o-n-o-1/",
                "vote_count": "832"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/39611/is-it-best-solution-with-o-n-o-1/",
                "vote_count": "832"
            },
            {
                "language": "swift",
                "code": "// Assume we are in state S\n// If we buy, we are spending money but we can also choose to do nothing\n// Doing nothing means going from S->S\n// Buying means going from some state X->S, losing some money in the process\nS = max(S, X-prices[i])\n\n// Similarly, for selling a stock\nS = max(S, X+prices[i])",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/149383/easy-dp-solution-using-state-machine-o-n-time-complexity-o-1-space-complexity/",
                "vote_count": "496"
            },
            {
                "language": "python",
                "code": "int maxProfit(vector<int>& prices) {\n if(prices.empty()) return 0;\n int s1=-prices[0],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN;\n        \n for(int i=1;i<prices.size();++i) {            \n  s1 = max(s1, -prices[i]);\n  s2 = max(s2, s1+prices[i]);\n  s3 = max(s3, s2-prices[i]);\n  s4 = max(s4, s3+prices[i]);\n }\n return max(0,s4);\n}",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/149383/easy-dp-solution-using-state-machine-o-n-time-complexity-o-1-space-complexity/",
                "vote_count": "496"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def maxProfit(self, p):\n        if len(p) == 0:\n            return 0\n\n        k = 2\n        states = [0] + [-float('inf') for i in range(2*k)]\n        states[1] = -p[0]",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/149383/easy-dp-solution-using-state-machine-o-n-time-complexity-o-1-space-complexity/",
                "vote_count": "496"
            },
            {
                "language": "php",
                "code": "private int maxProfit(int[] array, int t) {\n    int[] stock = new int[t * 2];\n    Arrays.fill(stock, Integer.MIN_VALUE);\n    stock[0] = -array[0];\n    for(int i = 1; i < array.length; ++i) {\n      stock[0] = Math.max(stock[0], -array[i]);\n      for (int j = 1; j < 2 * t; j += 2) {\n        stock[j] = Math.max(stock[j], stock[j - 1] + array[i]);",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/149383/easy-dp-solution-using-state-machine-o-n-time-complexity-o-1-space-complexity/",
                "vote_count": "496"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/149383/easy-dp-solution-using-state-machine-o-n-time-complexity-o-1-space-complexity/",
                "vote_count": "496"
            },
            {
                "language": "python",
                "code": "int maxProfit(vector<int>& prices) {\n if(prices.empty()) return 0;\n int s1=-prices[0],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN;\n\n        int s0 = 0;\n        \n for(int i=1;i<prices.size();++i) {\n                s0 = s0;            ",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/149383/easy-dp-solution-using-state-machine-o-n-time-complexity-o-1-space-complexity/",
                "vote_count": "496"
            },
            {
                "language": "cpp",
                "code": "    unordered_map<string, int> memo;\n    int profit(vector<int> prices, int i, int isBuy, int k){\n        if(i == prices.size() || k == 2)     // return if two transactions are completed\n            return 0;\n        string key = to_string(i) + \"-\" + to_string(isBuy) + \"-\" + to_string(k);\n        if(memo.find(key)!=memo.end())\n            return memo[key];\n        int a,b;\n        if(isBuy){                           // if isBuy is 1, we have a choice to purchase the stock\n            a = profit(prices, i + 1, 1, k);                       // do not buy\n            b = profit(prices, i + 1, 0, k) - prices[i];           // buy and add the cost \n        }  \n        else{                                // if isBuy is 0, we can only sell as we have already bought\n            a = profit(prices, i + 1, 0, k);                       // do not sell\n            b = profit(prices, i + 1, 1, k + 1) + prices[i];       // sell and add the profit\n        }   \n        return memo[key] = max(a, b);        // best choice among trading and skipping\n    }\n    \n    int maxProfit(vector<int>& prices) {\n        return profit(prices, 0, 1, 0);\n    }",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/796990/c-worst-to-best-solution-explained-for-dummies-like-me/",
                "vote_count": "298"
            },
            {
                "language": "cpp",
                "code": "int maxProfit(vector<int>& prices) {\n        if(!prices.size())\n            return 0;\n        int n = prices.size();\n        int left[n], right[n];\n        int leftmin = prices[0], rightmax = prices[n-1], maxprofit = 0;\n        left[0] = 0; right[n - 1] = 0;                                     // because we can't make any profit with just 1 element\n        int i,j;\n        for(i = 1, j = n-2; i < n, j >= 0; i++, j--){\n            leftmin  = min(leftmin, prices[i]);                            // find the minimum price till now\n            left[i]  = max(left[i - 1], prices[i] - leftmin);              // max of selling today or skipping (previous max profit)\n            rightmax = max(rightmax, prices[j]);                           // find the maximum price to the right\n            right[j] = max(right[j + 1], rightmax - prices[j]);            // max of buying today or skipping\n        }\n        for(int i = 0; i < n; i++){\n            maxprofit = max(maxprofit, left[i] + right[i]);\n        }\n        return maxprofit;\n    }\n    \n    // EG: PRICES = [3,3,5,0,0,3,1,4]\n    //     LEFT   = [0,0,2,2,2,2,2,3]\n    //     RIGHT  = [2,2,4,4,4,1,0,0]\n    //     SUM    = [2,2,6,6,6,3,2,3] \n //     MAX PROFIT = 6",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/796990/c-worst-to-best-solution-explained-for-dummies-like-me/",
                "vote_count": "298"
            },
            {
                "language": "python",
                "code": "int maxProfit(vector<int>& prices) {\n        if(!prices.size())\n            return 0;\n        int buy1    = INT_MAX;\n        int profit1 = INT_MIN;\n        int buy2    = INT_MAX;\n        int profit2 = INT_MIN;\n        for(int i = 0; i < prices.size(); i++){\n            buy1    = min(buy1, prices[i]);\n            profit1 = max(profit1, prices[i] - buy1);\n            buy2    = min(buy2, prices[i] - profit1);\n            profit2 = max(profit2, prices[i] - buy2);\n        }\n        return profit2;\n    }",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/796990/c-worst-to-best-solution-explained-for-dummies-like-me/",
                "vote_count": "298"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int n;\n    int dp[100002][2][2];\n    int solve(vector<int>& prices,int i,int hold,int k){\n        if(i>=n || k==0)return 0;",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/796990/c-worst-to-best-solution-explained-for-dummies-like-me/",
                "vote_count": "298"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int n = prices.length;\n        if(n < 2){\n            return 0;\n        }",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/796990/c-worst-to-best-solution-explained-for-dummies-like-me/",
                "vote_count": "298"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/796990/c-worst-to-best-solution-explained-for-dummies-like-me/",
                "vote_count": "298"
            },
            {
                "language": "lisp",
                "code": " ans1 = solve(day + 1, transactionsLeft); ",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/1523723/c-four-solutions-recursion-memoization-dp-with-o-n-space-dp-with-o-1-space/",
                "vote_count": "174"
            },
            {
                "language": "cpp",
                "code": "   bool buy = (transactionsLeft % 2 == 0);\n if(buy == true) {\n  ans2 = -prices[day] + solve(day + 1, transactionsLeft - 1);\n }else{\n  ans2 = prices[day] + solve(day + 1, transactionsLeft - 1);\n }",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/1523723/c-four-solutions-recursion-memoization-dp-with-o-n-space-dp-with-o-1-space/",
                "vote_count": "174"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    int solve(vector<int>&prices, int day, int transactionsLeft){\n        \n        if(day == prices.size()){\n            return 0;\n        }\n        \n        if(transactionsLeft == 0){\n            return 0;\n        }\n        \n        // choice 1\n        // no transaction today\n        int ans1 = solve(prices, day + 1, transactionsLeft);\n        \n        \n        // choice 2\n        // doing the possible transaction today     \n        int ans2 = 0;\n        bool buy = (transactionsLeft % 2 == 0);\n        \n        if(buy == true){ // buy\n            ans2 = -prices[day] + solve(prices, day + 1, transactionsLeft - 1);\n        }else{ // sell\n            ans2 = prices[day] + solve(prices, day + 1, transactionsLeft - 1);\n        }\n        \n        return max(ans1, ans2);\n        \n        \n    }\n    \n    \n    int maxProfit(vector<int>& prices) {\n        \n        int ans = solve(prices, 0, 4); // starting with day 0 and max 4 transactions can be done\n        return ans;\n        \n    }\n};",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/1523723/c-four-solutions-recursion-memoization-dp-with-o-n-space-dp-with-o-1-space/",
                "vote_count": "174"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    int solve(vector<int>&prices, int day, int transactionsLeft, vector<vector<int>> &Memo){\n        \n        if(day == prices.size()){\n            return 0;\n        }\n        \n        if(transactionsLeft == 0){\n            return 0;\n        }\n        \n        int &ans = Memo[day][transactionsLeft]; \n        \n        if(ans != -1){ // if problem has already been solved \n            return ans;\n        }\n        \n        // choice 1\n        // no transaction today\n        int ans1 = solve(prices, day + 1, transactionsLeft, Memo);\n        \n        \n        // choice 2\n        // doing the possible transaction today     \n        int ans2 = 0;\n        bool buy = (transactionsLeft % 2 == 0);\n        \n        if(buy == true){ // buy\n            ans2 = -prices[day] + solve(prices, day + 1, transactionsLeft - 1, Memo);\n        }else{ // sell\n            ans2 = prices[day] + solve(prices, day + 1, transactionsLeft - 1, Memo);\n        }\n        \n        return ans = max(ans1, ans2); // store ans in memo before returning\n        \n        \n    }\n    \n    \n    int maxProfit(vector<int>& prices) {\n        \n        vector<vector<int>> Memo(prices.size(), vector<int>(5, -1));\n        int ans = solve(prices, 0, 4, Memo);\n        return ans;\n        \n    }\n};",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/1523723/c-four-solutions-recursion-memoization-dp-with-o-n-space-dp-with-o-1-space/",
                "vote_count": "174"
            },
            {
                "language": "java",
                "code": "class Solution {\npublic:\n    \n    int maxProfit(vector<int>& prices) {\n        \n        int dp[prices.size() + 1][5];\n        \n        \n        for(int day = (int) prices.size();day >= 0;day--){\n            \n            for(int transactionsLeft = 0;transactionsLeft <= 4;transactionsLeft++){\n                \n                int &ans = dp[day][transactionsLeft];\n                \n                if(day == prices.size()){\n                    ans = 0;\n                }else if(transactionsLeft == 0){\n                    ans = 0;\n                }else{\n                    \n                    // choice 1\n                    // no transaction today\n                    int ans1 = dp[day + 1][transactionsLeft];\n                    \n                    // choice 2\n                    // doing the possible transaction today     \n                    int ans2 = 0;\n                    bool buy = (transactionsLeft % 2 == 0);\n\n                    if(buy == true){ // buy\n                        ans2 = -prices[day] + dp[day + 1][transactionsLeft - 1];\n                    }else{ // sell\n                        ans2 = prices[day] + dp[day + 1][transactionsLeft - 1];\n                    }\n\n                    ans = max(ans1, ans2);\n\n                }\n                \n            }\n        }\n        return dp[0][4];\n        \n    }\n};",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/1523723/c-four-solutions-recursion-memoization-dp-with-o-n-space-dp-with-o-1-space/",
                "vote_count": "174"
            },
            {
                "language": "java",
                "code": "class Solution {\npublic:\n    \n    int maxProfit(vector<int>& prices) {\n        \n        int dp[2][5];\n        \n        \n        for(int day = (int) prices.size();day >= 0;day--){\n            \n            for(int transactionsLeft = 0;transactionsLeft <= 4;transactionsLeft++){\n                \n                \n                int &ans = dp[day % 2][transactionsLeft];\n                \n                if(day == prices.size()){\n                    ans = 0;\n                }else if(transactionsLeft == 0){\n                    ans = 0;\n                }else{\n                    \n                    // choice 1\n                    // no transaction today\n                    int ans1 = dp[(day + 1) % 2][transactionsLeft];\n                    \n                    // choice 2\n                    // doing the possible transaction today     \n                    int ans2 = 0;\n                    bool buy = (transactionsLeft % 2 == 0);\n\n                    if(buy == true){ // buy\n                        ans2 = -prices[day] + dp[(day + 1) % 2][transactionsLeft - 1];\n                    }else{ // sell\n                        ans2 = prices[day] + dp[(day + 1) % 2][transactionsLeft - 1];\n                    }\n\n                    ans = max(ans1, ans2);\n\n                }\n                \n            }\n        }\n        return dp[0][4];\n        \n    }\n};",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/1523723/c-four-solutions-recursion-memoization-dp-with-o-n-space-dp-with-o-1-space/",
                "vote_count": "174"
            },
            {
                "language": "python",
                "code": "  bool buy = (transactionsLeft % 2 == 0);",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/1523723/c-four-solutions-recursion-memoization-dp-with-o-n-space-dp-with-o-1-space/",
                "vote_count": "174"
            },
            {
                "language": "python",
                "code": "int recursion(int[] prices, int n, int index, int count, int buy) {\n    if(index == n) return 0;",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/1523723/c-four-solutions-recursion-memoization-dp-with-o-n-space-dp-with-o-1-space/",
                "vote_count": "174"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n  def maxProfit(self, prices: List[int]) -> int:\n    if not prices:\n        return 0\n\n    # initialize variables for first buy, first sell, second buy, and second sell\n    buy1, buy2 = float('inf'), float('inf')\n    sell1, sell2 = 0, 0\n\n    # iterate over prices to update buy and sell values\n    for price in prices:\n        # update first buy and sell values\n        buy1 = min(buy1, price)\n        sell1 = max(sell1, price - buy1)\n        # update second buy and sell values\n        buy2 = min(buy2, price - sell1)\n        sell2 = max(sell2, price - buy2)\n\n    return sell2",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solutions/3195880/with-step-by-step-explanation/",
                "vote_count": "14"
            }
        ]
    },
    "123": {
        "question_id": 124,
        "title": "Binary Tree Maximum Path Sum",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/binary-tree-maximum-path-sum",
        "description": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.The path sum of a path is the sum of the node's values in the path.Given the root of a binary tree, return the maximum path sum of any non-empty path. ",
        "examples": [
            {
                "input": "root = [1,2,3]",
                "output": "6",
                "explanation": "The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6."
            },
            {
                "input": "root = [-10,9,20,null,null,15,7]",
                "output": "42",
                "explanation": "The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42."
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [1, 3 * 10^4].",
            "-1000 <= Node.val <= 1000"
        ],
        "solutions": [
            {
                "language": "ruby",
                "code": "1. class Solution:\n2.     def maxPathSum(self, root: TreeNode) -> int:\n3.   max_path = float(\"-inf\") # placeholder to be updated\n4.   def get_max_gain(node):\n5.    nonlocal max_path # This tells that max_path is not a local variable\n6.    if node is None:\n7.     return 0\n8.     \n9.    gain_on_left = max(get_max_gain(node.left), 0) # Read the part important observations\n10.   gain_on_right = max(get_max_gain(node.right), 0)  # Read the part important observations\n11.    \n12.   current_max_path = node.val + gain_on_left + gain_on_right # Read first three images of going down the recursion stack\n13.   max_path = max(max_path, current_max_path) # Read first three images of going down the recursion stack\n14.    \n15.   return node.val + max(gain_on_left, gain_on_right) # Read the last image of going down the recursion stack\n16.    \n17.    \n18.  get_max_gain(root) # Starts the recursion chain\n19.  return max_path  ",
                "url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/603423/python-recursion-stack-thinking-process-diagram/",
                "vote_count": "2339"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        self.max_path = float(\"-inf\")\n        self.helper(root)\n        ",
                "url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/603423/python-recursion-stack-thinking-process-diagram/",
                "vote_count": "2339"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        \n        childrenSum = dict()\n        centerNode = None\n        maxSum = float('-inf')",
                "url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/603423/python-recursion-stack-thinking-process-diagram/",
                "vote_count": "2339"
            },
            {
                "language": "python",
                "code": "private int maximumSum(TreeNode root)",
                "url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/603423/python-recursion-stack-thinking-process-diagram/",
                "vote_count": "2339"
            }
        ]
    },
    "124": {
        "question_id": 125,
        "title": "Valid Palindrome",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/valid-palindrome",
        "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.Given a string s, return true if it is a palindrome, or false otherwise. ",
        "examples": [
            {
                "input": "s = \"A man, a plan, a canal: Panama\"",
                "output": "true",
                "explanation": "\"amanaplanacanalpanama\" is a palindrome."
            },
            {
                "input": "s = \"race a car\"",
                "output": "false",
                "explanation": "\"raceacar\" is not a palindrome."
            },
            {
                "input": "s = \" \"",
                "output": "true",
                "explanation": "s is an empty string \"\" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome."
            }
        ],
        "constraints": [
            "1 <= s.length <= 2 * 10^5",
            "s consists only of printable ASCII characters."
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        if (s.isEmpty()) {\n         return true;\n        }\n        int start = 0;\n        int last = s.length() - 1;\n        while(start <= last) {\n         char currFirst = s.charAt(start);\n         char currLast = s.charAt(last);\n         if (!Character.isLetterOrDigit(currFirst )) {\n          start++;\n         } else if(!Character.isLetterOrDigit(currLast)) {\n          last--;\n         } else {\n          if (Character.toLowerCase(currFirst) != Character.toLowerCase(currLast)) {\n           return false;\n          }\n          start++;\n          last--;\n         }\n        }\n        return true;\n    }\n}",
                "url": "https://leetcode.com/problems/valid-palindrome/solutions/3165353/beats-96-9-well-explained-code-in-java/",
                "vote_count": "172"
            },
            {
                "language": "typescript",
                "code": "import java.util.StringTokenizer;\nclass Solution {\n    public boolean isPalindrome(String s) {\n        String s2=\"\";\n        StringTokenizer st=new StringTokenizer(s, \" ?./*_`-+['$]=&():$#@!^}{;,\\\"|\\\\\");\n        while(st.hasMoreTokens())\n        {\n            s2+=\"\"+st.nextToken();\n        }\n        s2=s2.trim();\n        s2=s2.toLowerCase();\n        StringBuffer sb=new StringBuffer(s2);\n        if(s2.equals(\"\"+sb.reverse()))\n        return true;\n        return false;\n        \n    }\n}//IF YOU LIKED PLEASE UPVOTE \n//THANK YOU FOR SEEING IT.",
                "url": "https://leetcode.com/problems/valid-palindrome/solutions/3263712/easiest-java-solution-ever-exsisted-is-here/",
                "vote_count": "11"
            }
        ]
    },
    "125": {
        "question_id": 126,
        "title": "Word Ladder II",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/word-ladder-ii",
        "description": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:Every adjacent pair of words differs by a single letter.Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.sk == endWordGiven two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk]. ",
        "examples": [
            {
                "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
                "output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\nExplanation:\u00a0There are 2 shortest transformation sequences:\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\n\"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\"",
                "explanation": null
            },
            {
                "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
                "output": "[]",
                "explanation": "The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence."
            }
        ],
        "constraints": [
            "1 <= beginWord.length <= 5",
            "endWord.length == beginWord.length",
            "1 <= wordList.length <= 500",
            "wordList[i].length == beginWord.length",
            "beginWord, endWord, and wordList[i] consist of lowercase English letters.",
            "beginWord != endWord",
            "All the words in wordList are unique.",
            "The sum of all shortest transformation sequences does not exceed 10^5."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "    vector<vector<string>> findLadders(string beginWord, string endWord, unordered_set<string> &wordList) {\n        //very interesting problem\n        //It can be solved with standard BFS. The tricky idea is doing BFS of paths instead of words!\n        //Then the queue becomes a queue of paths.\n        vector<vector<string>> ans;\n        queue<vector<string>> paths;\n        wordList.insert(endWord);\n        paths.push({beginWord});\n        int level = 1;\n        int minLevel = INT_MAX;\n        \n        //\"visited\" records all the visited nodes on this level\n        //these words will never be visited again after this level \n        //and should be removed from wordList. This is guaranteed\n        // by the shortest path.\n        unordered_set<string> visited; \n        \n        while (!paths.empty()) {\n            vector<string> path = paths.front();\n            paths.pop();\n            if (path.size() > level) {\n                //reach a new level\n                for (string w : visited) wordList.erase(w);\n                visited.clear();\n                if (path.size() > minLevel)\n                    break;\n                else\n                    level = path.size();\n            }\n            string last = path.back();\n            //find next words in wordList by changing\n            //each element from 'a' to 'z'\n            for (int i = 0; i < last.size(); ++i) {\n                string news = last;\n                for (char c = 'a'; c <= 'z'; ++c) {\n                    news[i] = c;\n                    if (wordList.find(news) != wordList.end()) {\n                    //next word is in wordList\n                    //append this word to path\n                    //path will be reused in the loop\n                    //so copy a new path\n                        vector<string> newpath = path;\n                        newpath.push_back(news);\n                        visited.insert(news);\n                        if (news == endWord) {\n                            minLevel = level;\n                            ans.push_back(newpath);\n                        }\n                        else\n                            paths.push(newpath);\n                    }\n                }\n            }\n        }\n        return ans;\n    }",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/40434/c-solution-using-standard-bfs-method-no-dfs-or-backtracking/",
                "vote_count": "605"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        List<List<String>> ans = new ArrayList<>();\n        Set<String> wordSet = new HashSet<>(wordList);\n        if (!wordSet.contains(endWord)) return ans;\n        \n        Queue<List<String>> queue = new LinkedList<>();   // each element in queue is a path\n        queue.offer(Arrays.asList(beginWord));",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/40434/c-solution-using-standard-bfs-method-no-dfs-or-backtracking/",
                "vote_count": "605"
            },
            {
                "language": "cpp",
                "code": "vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        unordered_set<string> st (wordList.begin(),wordList.end());\n        unordered_set<string> visited;\n        vector<vector<string>> ans;\n        queue<vector<string>> q;\n        q.push({beginWord});\n        while(!q.empty()){\n            int size = q.size();",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/40434/c-solution-using-standard-bfs-method-no-dfs-or-backtracking/",
                "vote_count": "605"
            },
            {
                "language": "cpp",
                "code": "class Solution {\nprivate:\n    unordered_set<string> wordList;\n    vector<vector<string>> ans;\n    unordered_set<string> visited;\n            \n    int level = 1;\n    int minLevel = INT_MAX;\n{\n&endWord)",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/40434/c-solution-using-standard-bfs-method-no-dfs-or-backtracking/",
                "vote_count": "605"
            },
            {
                "language": "erlang",
                "code": "wordList.insert(endWord);",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/40434/c-solution-using-standard-bfs-method-no-dfs-or-backtracking/",
                "vote_count": "605"
            },
            {
                "language": "ruby",
                "code": "if (wordList.find(endWord) == wordList.end())\n    return {};",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/40434/c-solution-using-standard-bfs-method-no-dfs-or-backtracking/",
                "vote_count": "605"
            },
            {
                "language": "python",
                "code": "nextLevel[nei].append(path + [nei])  # form new paths with `nei` word at the end",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/1359027/c-python-bfs-level-by-level-with-picture-clean-concise/",
                "vote_count": "162"
            },
            {
                "language": "cpp",
                "code": "// BFS gives TLE if we store path while traversing because whenever we find a better visit time for a word, we have to clear/make a new path vector everytime. \n// The idea is to first use BFS to search from beginWord to endWord and generate the word-to-children mapping at the same time. \n// Then, use DFS (backtracking) to generate the transformation sequences according to the mapping. \n// The reverse DFS allows us to only make the shortest paths, never having to clear a whole sequence when we encounter better result in BFS\n// No string operations are done, by dealing with indices instead.\n\n\n\nclass Solution {\npublic:\nbool able(string s,string t){\n    int c=0;\n    for(int i=0;i<s.length();i++)\n        c+=(s[i]!=t[i]);\n    return c==1;\n}\nvoid bfs(vector<vector<int>> &g,vector<int> parent[],int n,int start,int end){\n    vector <int> dist(n,1005);\n    queue <int> q;\n    q.push(start);\n    parent[start]={-1};\n    dist[start]=0;\n    while(!q.empty()){\n        int x=q.front();\n        q.pop();\n        for(int u:g[x]){\n            if(dist[u]>dist[x]+1){\n                dist[u]=dist[x]+1;\n                q.push(u);\n                parent[u].clear();\n                parent[u].push_back(x);\n            }\n            else if(dist[u]==dist[x]+1)\n                parent[u].push_back(x);\n        }\n    }\n}\nvoid shortestPaths(vector<vector<int>> &Paths, vector<int> &path, vector<int> parent[],int node){\n    if(node==-1){\n        // as parent of start was -1, we've completed the backtrack\n        Paths.push_back(path);\n        return ;\n    }\n    for(auto u:parent[node]){\n        path.push_back(u);\n        shortestPaths(Paths,path,parent,u);\n        path.pop_back();\n    }\n}\nvector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n    // start and end are indices of beginWord and endWord\n    int n=wordList.size(),start=-1,end=-1;\n    vector<vector<string>> ANS;\n    for(int i=0;i<n;i++){\n        if(wordList[i]==beginWord)\n            start=i;\n        if(wordList[i]==endWord)\n            end=i;\n    }\n    \n    // if endWord doesn't exist, return empty list\n    if(end==-1)\n        return ANS;\n    \n    // if beginWord doesn't exist, add it in start of WordList\n    if(start==-1){\n        wordList.emplace(wordList.begin(),beginWord);\n        start=0;\n        end++;\n        n++;\n    }\n    // for each word, we're making adjency list of neighbour words (words that can be made with one letter change)\n    // Paths will store all the shortest paths (formed later by backtracking)\n    vector<vector<int>> g(n,vector<int>()),Paths;\n    \n    // storing possible parents for each word (to backtrack later), path is the current sequence (while backtracking)\n    vector<int> parent[n],path;\n    \n    // creating adjency list for each pair of words in the wordList (including beginword)\n    for(int i=0;i<n-1;i++)\n        for(int j=i+1;j<n;j++)\n            if(able(wordList[i],wordList[j])){\n                g[i].push_back(j);\n                g[j].push_back(i);\n            }\n    \n    bfs(g,parent,n,start,end); \n    \n    // backtracking to make shortestpaths\n    shortestPaths(Paths,path,parent,end);\n    for(auto u:Paths){\n        vector <string> now;\n        for(int i=0;i<u.size()-1;i++)\n            now.push_back(wordList[u[i]]);\n        reverse(now.begin(),now.end());\n        now.push_back(wordList[end]);\n        ANS.push_back(now);\n    }\n    return ANS;\n}\n}; ",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/2421786/c-using-bfs-and-backtracking-no-tle/",
                "vote_count": "127"
            },
            {
                "language": "cpp",
                "code": "// BFS gives TLE if we store path while traversing because whenever we find a better visit time for a word, we have to clear/make a new path vector everytime. \n// The idea is to first use BFS to search from beginWord to endWord and generate the word-to-children mapping at the same time. \n// Then, use DFS (backtracking) to generate the transformation sequences according to the mapping. \n// The reverse DFS allows us to only make the shortest paths, never having to clear a whole sequence when we encounter better result in BFS\n// No string operations are done, by dealing with indices instead.\n\n\n){\n) {",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/2421786/c-using-bfs-and-backtracking-no-tle/",
                "vote_count": "127"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        vector<vector<string>> ans;\n        int n = size(wordList), src = -1, dst = -1;\n        for (int i = 0; i < n; i++) {\n            if (wordList[i] == beginWord) src = i;\n            else if (wordList[i] == endWord) dst = i;\n<int>& path, int v) {\n });",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/2421786/c-using-bfs-and-backtracking-no-tle/",
                "vote_count": "127"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n\n    WILDCARD = \".\"\n    \n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        \"\"\"\n        Given a wordlist, we perform BFS traversal to generate a word tree where\n        every node points to its parent node.\n        \n        Then we perform a DFS traversal on this tree starting at the endWord.\n        \"\"\"\n        if endWord not in wordList:\n            # end word is unreachable\n            return []\n        \n        # first generate a word tree from the wordlist\n        word_tree = self.getWordTree(beginWord, endWord, wordList)\n        \n        # then generate a word ladder from the word tree\n        return self.getLadders(beginWord, endWord, word_tree)\n    \n    \n    def getWordTree(self,\n                    beginWord: str,\n                    endWord: str,\n                    wordList: List[str]) -> Dict[str, List[str]]:\n        \"\"\"\n        BFS traversal from begin word until end word is encountered.\n        \n        This functions constructs a tree in reverse, starting at the endWord.\n        \"\"\"\n        # Build an adjacency list using patterns as keys\n        # For example: \".it\" -> (\"hit\"), \"h.t\" -> (\"hit\"), \"hi.\" -> (\"hit\")\n        adjacency_list = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + Solution.WILDCARD + word[i+1:]\n                adjacency_list[pattern].append(word)\n        \n        # Holds the tree of words in reverse order\n        # The key is an encountered word.\n        # The value is a list of preceding words.\n        # For example, we got to beginWord from no other nodes.\n        # {a: [b,c]} means we got to \"a\" from \"b\" and \"c\"\n        visited_tree = {beginWord: []}\n        \n        # start off the traversal without finding the word\n        found = False\n        \n        q = deque([beginWord])\n        while q and not found:\n            n = len(q)\n            \n            # keep track of words visited at this level of BFS\n            visited_this_level = {}\n\n            for i in range(n):\n                word = q.popleft()\n                \n                for i in range(len(word)):\n                    # for each pattern of the current word\n                    pattern = word[:i] + Solution.WILDCARD + word[i+1:]\n\n                    for next_word in adjacency_list[pattern]:\n                        if next_word == endWord:\n                            # we don't return immediately because other\n                            # sequences might reach the endWord in the same\n                            # BFS level\n                            found = True\n                        if next_word not in visited_tree:\n                            if next_word not in visited_this_level:\n                                visited_this_level[next_word] = [word]\n                                # queue up next word iff we haven't visited it yet\n                                # or already are planning to visit it\n                                q.append(next_word)\n                            else:\n                                visited_this_level[next_word].append(word)\n            \n            # add all seen words at this level to the global visited tree\n            visited_tree.update(visited_this_level)\n            \n        return visited_tree\n    \n    \n    def getLadders(self,\n                   beginWord: str,\n                   endWord: str,\n                   wordTree: Dict[str, List[str]]) -> List[List[str]]:\n        \"\"\"\n        DFS traversal from endWord to beginWord in a given tree.\n        \"\"\"\n        def dfs(node: str) -> List[List[str]]:\n            if node == beginWord:\n                return [[beginWord]]\n            if node not in wordTree:\n                return []\n\n            res = []\n            parents = wordTree[node]\n            for parent in parents:\n                res += dfs(parent)\n            for r in res:\n                r.append(node)\n            return res\n\n        return dfs(endWord)",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/2367587/python-bfs-dfs-with-explanation-why-optimization-is-needed-to-not-tle/",
                "vote_count": "71"
            },
            {
                "language": "cpp",
                "code": "class Solution\n{\npublic:\n    vector<vector<string>> res;\n    vector<string> te;\n    unordered_map<string, int> mp;\n    string b;\n    void dfs(string s)  // Step 2\n    {\n        te.push_back(s);\n        if (s == b)\n        {\n            vector<string> x = te;\n            reverse(x.begin(), x.end());\n            res.push_back(x);\n            te.pop_back();\n            return;\n        }\n        int cur = mp[s];\n        for (int i = 0; i < s.size(); i++)\n        {\n            char c = s[i];\n            for (char cc = 'a'; cc <= 'z'; cc++)\n            {\n                s[i] = cc;\n                if (mp.count(s) && mp[s] == cur - 1)\n                    dfs(s);\n            }\n            s[i] = c;\n        }\n        te.pop_back();\n        return;\n    }\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string> &wordList)\n    {\n        unordered_set<string> dict(wordList.begin(), wordList.end());\n        b = beginWord;\n        queue<string> q;\n        int k = beginWord.size();\n        q.push({beginWord});\n        mp[beginWord] = 0;\n        while (!q.empty())  // Step 1\n        {\n            int n = q.size();\n            while (n--)\n            {\n                string t = q.front();\n                q.pop();\n                int x = mp[t] + 1;\n                for (int i = 0; i < k; i++)\n                {\n                    string temp = t;\n                    for (char ch = 'a'; ch <= 'z'; ch++)\n                    {\n                        temp[i] = ch;\n                        if (!mp.count(temp) && dict.count(temp))\n                            mp[temp] = x, q.push(temp);\n                    }\n                }\n            }\n        }\n        if (mp.count(endWord))\n            dfs(endWord);\n        return res;\n    }\n};",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/2423080/c-no-tle-august-2022-simple-bfs-explained/",
                "vote_count": "50"
            },
            {
                "language": "cpp",
                "code": "class Solution\n{\n    private:\n        vector<vector<string>> res;\n        vector<string> backPath;\n        unordered_map<string, int> wordDist;\n        string begin;\n        \n)",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/2423080/c-no-tle-august-2022-simple-bfs-explained/",
                "vote_count": "50"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    List<List<String>> res = new ArrayList();\n    List<String> tmp = new ArrayList();\n    Map<String, Integer> map = new HashMap<>();\n    String start;\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n        Set<String> dict = new HashSet<>(wordList);",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/2423080/c-no-tle-august-2022-simple-bfs-explained/",
                "vote_count": "50"
            },
            {
                "language": "go",
                "code": " class Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n   d = defaultdict(list)\n   for word in wordList:\n    for i in range(len(word)):\n     d[word[:i]+\"*\"+word[i+1:]].append(word)\n\n   if endWord not in wordList:\n    return []\n\n   visited1 = defaultdict(list)\n   q1 = deque([beginWord])\n   visited1[beginWord] = []\n\n   visited2 = defaultdict(list)\n   q2 = deque([endWord])\n   visited2[endWord] = []\n\n   ans = []\n   def dfs(v, visited, path, paths):\n    path.append(v)\n    if not visited[v]:\n     if visited is visited1:\n      paths.append(path[::-1])\n     else:\n      paths.append(path[:])\n    for u in visited[v]:\n     dfs(u, visited, path, paths)\n    path.pop()\n\n   def bfs(q, visited1, visited2, frombegin):\n    level_visited = defaultdict(list)\n    for _ in range(len(q)):\n     u = q.popleft()\n\n     for i in range(len(u)):\n      for v in d[u[:i]+\"*\"+u[i+1:]]:\n       if v in visited2:\n        paths1 = []\n        paths2 = []\n        dfs(u, visited1, [], paths1)\n        dfs(v, visited2, [], paths2)\n        if not frombegin:\n         paths1, paths2 = paths2, paths1\n        for a in paths1:\n         for b in paths2:\n          ans.append(a+b)\n       elif v not in visited1:\n        if v not in level_visited:\n         q.append(v)\n        level_visited[v].append(u)\n    visited1.update(level_visited)\n\n   while q1 and q2 and not ans:\n    if len(q1) <= len(q2):\n     bfs(q1, visited1, visited2, True)\n    else:\n     bfs(q2, visited2, visited1, False)\n\n   return ans\n   \n   ",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/2422401/46ms-python-97-faster-working-multiple-solutions-95-memory-efficient-solution/",
                "vote_count": "37"
            },
            {
                "language": "rust",
                "code": " class Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n   res = []\n   edge = collections.defaultdict(set)\n   wordList = set(wordList)\n   for word in wordList:\n    for i in range(len(word)):\n     edge[word[:i] +'*'+word[i+1:]].add(word)\n   bfsedge = {}\n\n   def bfs():\n    minl = 0\n    queue = set()\n    queue.add(beginWord)\n    while queue:\n     next_queue = set()\n     for word in queue:\n      if word in wordList:\n       wordList.remove(word)\n     bfsedge[minl] = collections.defaultdict(set)\n     for word in queue:\n      if word == endWord:\n       return minl\n      for i in range(len(word)):\n       for w in edge[word[:i]+'*'+word[i+1:]]:\n        if w in wordList:\n         next_queue.add(w)\n         bfsedge[minl][w].add(word)\n     queue = next_queue\n     minl += 1\n    return minl\n\n   def dfs(seq, endWord):\n    if seq[-1] == endWord:\n     res.append(seq.copy())\n     return\n    for nextWord in bfsedge[minl-len(seq)][seq[-1]]:\n     if nextWord not in seq:\n      dfs(seq+[nextWord], endWord)\n\n   minl = bfs()\n   dfs([endWord], beginWord)\n   # reverse the sequence\n   for sq in res:\n    sq.reverse()\n   return res\n   \n   ",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/2422401/46ms-python-97-faster-working-multiple-solutions-95-memory-efficient-solution/",
                "vote_count": "37"
            },
            {
                "language": "ruby",
                "code": " from collections import deque\n class Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n   if endWord not in wordList:return []\n   wordList.append(beginWord)\n   wordList.append(endWord)\n   distance = {}\n\n\n   self.bfs(endWord, distance, wordList)\n\n   results = []\n   self.dfs(beginWord, endWord, distance, wordList, [beginWord], results)\n\n   return results\n\n  def bfs(self, start, distance, w):\n   distance[start] = 0\n   queue = deque([start])\n   while queue:\n    word = queue.popleft()\n    for next_word in self.get_next_words(word, w):\n     if next_word not in distance:\n      distance[next_word] = distance[word] + 1\n      queue.append(next_word)\n\n  def get_next_words(self, word, w):\n   words = []\n   for i in range(len(word)):\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n     next_word = word[:i] + c + word[i + 1:]\n     if next_word != word and next_word in w:\n      words.append(next_word)\n   return words\n\n  def dfs(self, curt, target, distance, w, path, results):\n   if curt == target:\n    results.append(list(path))\n    return\n\n   for word in self.get_next_words(curt, w):\n    if distance[word] != distance[curt] - 1:\n     continue\n    path.append(word)\n    self.dfs(word, target, distance, w, path, results)\n    path.pop()",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/2422401/46ms-python-97-faster-working-multiple-solutions-95-memory-efficient-solution/",
                "vote_count": "37"
            },
            {
                "language": "erlang",
                "code": "beginWord = \"hit\"\nendWord = \"cog\"\n[\"hot\",\"dot\",\"tog\",\"cog\"]",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/2422401/46ms-python-97-faster-working-multiple-solutions-95-memory-efficient-solution/",
                "vote_count": "37"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        List<List<String>> ans = new ArrayList<>(); \n        Map<String, Set<String>> reverse = new HashMap<>(); // reverse graph start from endWord\n        Set<String> wordSet = new HashSet<>(wordList); // remove the duplicate words\n        wordSet.remove(beginWord); // remove the first word to avoid cycle path\n        Queue<String> queue = new LinkedList<>(); // store current layer nodes\n        queue.add(beginWord); // first layer has only beginWord\n        Set<String> nextLevel = new HashSet<>(); // store nextLayer nodes\n        boolean findEnd = false; // find endWord flag\n        while (!queue.isEmpty()) { // traverse current layer nodes\n            String word = queue.remove();\n            for (String next : wordSet) {\n                if (isLadder(word, next)) { // is ladder words\n     // construct the reverse graph from endWord\n                    Set<String> reverseLadders = reverse.computeIfAbsent(next, k -> new HashSet<>());\n                    reverseLadders.add(word); \n                    if (endWord.equals(next)) {\n                        findEnd = true;\n                    }\n                    nextLevel.add(next); // store next layer nodes\n                }\n            }\n            if (queue.isEmpty()) { // when current layer is all visited\n                if (findEnd) break; // if find the endWord, then break the while loop\n                queue.addAll(nextLevel); // add next layer nodes to queue\n                wordSet.removeAll(nextLevel); // remove all next layer nodes in wordSet\n                nextLevel.clear();\n            }\n        }\n        if (!findEnd) return ans; // if can't reach endWord from startWord, then return ans.\n        Set<String> path = new LinkedHashSet<>();\n        path.add(endWord);\n  // traverse reverse graph from endWord to beginWord\n        findPath(endWord, beginWord, reverse, ans, path); \n        return ans;\n    }\n\n\n    private void findPath(String endWord, String beginWord, Map<String, Set<String>> graph,\n                                 List<List<String>> ans, Set<String> path) {\n        Set<String> next = graph.get(endWord);\n        if (next == null) return;\n        for (String word : next) {\n            path.add(word);\n            if (beginWord.equals(word)) {\n                List<String> shortestPath = new ArrayList<>(path);\n                Collections.reverse(shortestPath); // reverse words in shortest path\n                ans.add(shortestPath); // add the shortest path to ans.\n            } else {\n                findPath(word, beginWord, graph, ans, path);\n            }\n            path.remove(word);\n        }\n    }\n\n    private boolean isLadder(String s, String t) {\n        if (s.length() != t.length()) return false;\n        int diffCount = 0;\n        int n = s.length();\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) != t.charAt(i)) diffCount++;\n            if (diffCount > 1) return false;\n        }\n        return diffCount == 1;\n    }\n}",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/2421907/java-easy-explanation-commented/",
                "vote_count": "36"
            },
            {
                "language": "typescript",
                "code": "    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        // visited map\n        Map<String, Boolean> wordMap = new HashMap<>();\n        for (String word : wordList) {\n            wordMap.put(word, false);\n        }\n\n<List<String>> levelList) {",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/2421907/java-easy-explanation-commented/",
                "vote_count": "36"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<String>> ans;\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        ans=new ArrayList<>();\n        \n        Map<String, List<String>> graph = new HashMap<>();\n        for(String s: wordList) {\n            graph.put(s, new ArrayList<>());\n        }\n        //if beginword is not in graph then add it\n        if(!graph.containsKey(beginWord)) {\n            wordList.add(beginWord);\n            graph.put(beginWord, new ArrayList<>());\n        }\n        \n        for(String s: wordList) {\n            for(int i=0;i<s.length();i++) {\n                for(char ch='a';ch<='z';ch++) {\n                    String checkWord=s.substring(0, i)+ch+s.substring(i+1);\n                    if(graph.containsKey(checkWord) && !s.equals(checkWord)) {\n                        List<String> l=graph.get(s);\n                        l.add(checkWord);\n                        graph.put(s, l);\n                    }\n                }\n            }\n        }\n        \n        Set<String> visited=new HashSet<>(wordList.size());\n        Map<String, Integer> distFromStarting = new HashMap<>(); //distance from begin node\n        //will use it to calculate dfs in reverse order from endWord to beginWord\n        \n        //debug\n        // System.out.println(\"Graph->\"+graph);\n        \n        int shortestLength = bfs(beginWord, endWord, graph, visited, distFromStarting); //for shortest path using bfs\n        if(shortestLength==0) return ans;\n        \n        //debug\n        // System.out.println(distFromStarting);\n        \n        //optimised DFS\n        reverseDFS(endWord, beginWord, new ArrayList<>(), graph, distFromStarting);\n        return ans;\n    }\n    \n    //from source to destination bfs\n    public int bfs(String src, String des, Map<String, List<String>> graph, Set<String> visited, Map<String, Integer> distFromStarting) {\n        List<List<String>> ans=new ArrayList<>();\n        \n        Queue<String> queue=new LinkedList<>();\n        queue.add(src);\n        visited.add(src);\n        int level=0;\n        distFromStarting.put(src, 0);\n        \n        while(!queue.isEmpty()) {\n            int size=queue.size();\n                \n            for(int i=0;i<size;i++) {\n                String cur=queue.remove();\n                //debug\n                // System.out.println(ret);\n                if(cur.equals(des)) {\n                    return level;\n                }\n                for(String n: graph.get(cur)) {\n                    if(!visited.contains(n)) {\n                        visited.add(n);\n                        queue.add(n);\n                        distFromStarting.put(n, distFromStarting.get(cur)+1);\n                    }\n                }\n            }\n            \n            level++;\n        }\n        //debug\n        // System.out.println(ret);\n        return 0;\n    }\n    \n    public void reverseDFS(String src, String des, List<String> path, Map<String, List<String>> graph, Map<String , Integer> distFromStarting) {\n        if(src.equals(des)) {\n            path.add(des);\n            List<String> list=new ArrayList<>(path);\n            Collections.reverse(list);\n            \n            //debug\n            // System.out.println(list);\n            \n            ans.add(list);\n            path.remove(path.size()-1);\n            return;\n        }\n        \n        path.add(src);\n        \n        //debug\n        // System.out.println(path);\n            \n        for(String next: graph.get(src)) {\n            // System.out.println(path+\" \"+next);\n            if(distFromStarting.containsKey(next) && distFromStarting.get(next)+1==distFromStarting.get(src)) {\n                reverseDFS(next, des, path, graph, distFromStarting);\n            }\n        }\n        \n        path.remove(path.size()-1);\n    }\n}",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/2425494/java-solution-88-ms/",
                "vote_count": "12"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    Set<String> set = new HashSet();\n    String beginWord, endWord;\n    Map<String, Integer> dist = new HashMap();\n    List<List<String>> res;\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        this.beginWord = beginWord;\n        this.endWord = endWord;\n        this.res = new ArrayList();\n        for (String word : wordList) {\n            set.add(word);\n        }\n        short_path();\n        if (dist.get(endWord) == null) return res;\n        List<String> path = new ArrayList();\n        path.add(endWord);\n        dfs(endWord, path);\n        return res;\n    }\n    \n    private void short_path() {\n        Queue<String> q = new LinkedList();\n        q.offer(beginWord);\n        dist.put(beginWord, 0);\n        while(q.size() > 0) {\n            String cur = q.poll();\n            if (cur.equals(endWord) ) break;\n            char[] charCur = cur.toCharArray();\n            for (int i = 0; i < cur.length(); i++) {\n                char c = charCur[i];\n                for (char j = 'a'; j <= 'z'; j++) {\n                    charCur[i] = j;\n                    String s = new String(charCur);\n                    if (set.contains(s) && dist.get(s) == null) {\n                        dist.put(s, dist.get(cur) + 1);\n                        q.offer(s);\n                    }\n                    \n                }\n                charCur[i] = c;\n            }\n        }\n    }\n    \n    private void dfs(String word, List<String> path) {\n        if (word.equals(beginWord)) {\n            List list = new ArrayList(path);\n            Collections.reverse(list);\n            res.add(list);\n            return;\n        }\n        char[] charCur = word.toCharArray();\n        for (int i = 0; i < word.length(); i++) {\n            char c = charCur[i];\n            for (char j = 'a'; j <= 'z'; j++) {\n                charCur[i] = j;\n                String s = new String(charCur);\n                if (dist.get(s) != null && dist.get(s) + 1 == dist.get(word)) {\n                    path.add(s);\n                    dfs(s, path);\n                    path.remove(path.size() - 1);\n                }\n                    \n            }\n            charCur[i] = c;\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/word-ladder-ii/solutions/2424809/java-efficient-solution-updated/",
                "vote_count": "11"
            }
        ]
    },
    "126": {
        "question_id": 127,
        "title": "Word Ladder",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/word-ladder",
        "description": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:Every adjacent pair of words differs by a single letter.Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.sk == endWordGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists. ",
        "examples": [
            {
                "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
                "output": "5",
                "explanation": "One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long."
            },
            {
                "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
                "output": "0",
                "explanation": "The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence."
            }
        ],
        "constraints": [
            "1 <= beginWord.length <= 10",
            "endWord.length == beginWord.length",
            "1 <= wordList.length <= 5000",
            "wordList[i].length == beginWord.length",
            "beginWord, endWord, and wordList[i] consist of lowercase English letters.",
            "beginWord != endWord",
            "All the words in wordList are unique."
        ],
        "solutions": [
            {
                "language": "java",
                "code": "start = be\nend = ko\nwords = [\"ce\", \"mo\", \"ko\", \"me\", \"co\"]",
                "url": "https://leetcode.com/problems/word-ladder/solutions/1764371/a-very-highly-detailed-explanation/",
                "vote_count": "746"
            },
            {
                "language": "cpp",
                "code": "queue = [\"be\"  ]\nchanges = 1\nset = [\"be\"  ]",
                "url": "https://leetcode.com/problems/word-ladder/solutions/1764371/a-very-highly-detailed-explanation/",
                "vote_count": "746"
            },
            {
                "language": "csharp",
                "code": "Another, thing i forgot to mention is our changes variable is being updated on every iteration.\nSo, we have gone from be -> ce -> co which is a total of 3 changes.",
                "url": "https://leetcode.com/problems/word-ladder/solutions/1764371/a-very-highly-detailed-explanation/",
                "vote_count": "746"
            },
            {
                "language": "cpp",
                "code": "queue = [  ]\nchanges = 4\nset = [\"be\", \"ce\", \"me\", \"co\", \"mo\", \"ko\"  ]",
                "url": "https://leetcode.com/problems/word-ladder/solutions/1764371/a-very-highly-detailed-explanation/",
                "vote_count": "746"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if(!set.contains(endWord)) return 0;\n        \n        Queue<String> queue = new LinkedList<>();\n        queue.add(beginWord);\n        \n        Set<String> visited = new HashSet<>();\n        queue.add(beginWord);\n        \n        int changes = 1;\n        \n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i = 0; i < size; i++){\n                String word = queue.poll();\n                if(word.equals(endWord)) return changes;\n                \n                for(int j = 0; j < word.length(); j++){\n                    for(int k = 'a'; k <= 'z'; k++){\n                        char arr[] = word.toCharArray();\n                        arr[j] = (char) k;\n                        \n                        String str = new String(arr);\n                        if(set.contains(str) && !visited.contains(str)){\n                            queue.add(str);\n                            visited.add(str);\n                        }\n                    }\n                }\n            }\n            ++changes;\n        }\n        return 0;\n    }\n}",
                "url": "https://leetcode.com/problems/word-ladder/solutions/1764371/a-very-highly-detailed-explanation/",
                "vote_count": "746"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        queue<string> q;\n        set<string> st,words;\n        for(string s:wordList)\n            words.insert(s);\n        st.insert(beginWord);",
                "url": "https://leetcode.com/problems/word-ladder/solutions/1764371/a-very-highly-detailed-explanation/",
                "vote_count": "746"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        queue = deque([beginWord])\n        visited = set([beginWord])\n        wordList = set(wordList)\n        \n        changes = 1\n        ",
                "url": "https://leetcode.com/problems/word-ladder/solutions/1764371/a-very-highly-detailed-explanation/",
                "vote_count": "746"
            },
            {
                "language": "erlang",
                "code": "beginWord = \"hit\",\nendWord = \"cog\",\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
                "url": "https://leetcode.com/problems/word-ladder/solutions/40707/c-bfs/",
                "vote_count": "732"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        unordered_set<string> dict(wordList.begin(), wordList.end());\n        queue<string> todo;\n        todo.push(beginWord);\n        int ladder = 1;\n        while (!todo.empty()) {\n            int n = todo.size();\n            for (int i = 0; i < n; i++) {\n                string word = todo.front();\n                todo.pop();\n                if (word == endWord) {\n                    return ladder;\n                }\n                dict.erase(word);\n                for (int j = 0; j < word.size(); j++) {\n                    char c = word[j];\n                    for (int k = 0; k < 26; k++) {\n                        word[j] = 'a' + k;\n                        if (dict.find(word) != dict.end()) {\n                            todo.push(word);\n                        }\n                     }\n                    word[j] = c;\n                }\n            }\n            ladder++;\n        }\n        return 0;\n    }\n};",
                "url": "https://leetcode.com/problems/word-ladder/solutions/40707/c-bfs/",
                "vote_count": "732"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        unordered_set<string> dict(wordList.begin(), wordList.end()), head, tail, *phead, *ptail;\n        if (dict.find(endWord) == dict.end()) {\n            return 0;\n        }\n        head.insert(beginWord);\n        tail.insert(endWord);\n        int ladder = 2;\n        while (!head.empty() && !tail.empty()) {\n            if (head.size() < tail.size()) {\n                phead = &head;\n                ptail = &tail;\n            } else {\n                phead = &tail;\n                ptail = &head;\n            }\n            unordered_set<string> temp;\n            for (auto it = phead -> begin(); it != phead -> end(); it++) {    \n                string word = *it;\n                for (int i = 0; i < word.size(); i++) {\n                    char t = word[i];\n                    for (int j = 0; j < 26; j++) {\n                        word[i] = 'a' + j;\n                        if (ptail -> find(word) != ptail -> end()) {\n                            return ladder;\n                        }\n                        if (dict.find(word) != dict.end()) {\n                            temp.insert(word);\n                            dict.erase(word);\n                        }\n                    }\n                    word[i] = t;\n                }\n            }\n            ladder++;\n            phead -> swap(temp);\n        }\n        return 0;\n    }\n};",
                "url": "https://leetcode.com/problems/word-ladder/solutions/40707/c-bfs/",
                "vote_count": "732"
            },
            {
                "language": "dart",
                "code": "    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> dict = new HashSet<>(wordList), vis = new HashSet<>();\n        Queue<String> q = new LinkedList<>();",
                "url": "https://leetcode.com/problems/word-ladder/solutions/40707/c-bfs/",
                "vote_count": "732"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        unordered_set<string> wordDict(wordList.begin(), wordList.end());\n        //wordDict.insert(endWord);\n        queue<string> toVisit;\n        addNextWords(beginWord, wordDict, toVisit);",
                "url": "https://leetcode.com/problems/word-ladder/solutions/40707/c-bfs/",
                "vote_count": "732"
            },
            {
                "language": "cpp",
                "code": "    class Solution {\n    \n    public:\n        ",
                "url": "https://leetcode.com/problems/word-ladder/solutions/40707/c-bfs/",
                "vote_count": "732"
            },
            {
                "language": "java",
                "code": " public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n\n        Deque<String> toVisit = new ArrayDeque<>();\n        Set<String> wordSet = new HashSet<>(wordList.size());\n\n        // change to hashset.\n        wordSet.addAll(wordList);\n        if(!wordSet.contains(endWord))return 0;  // no solution if endword not in wordSet.",
                "url": "https://leetcode.com/problems/word-ladder/solutions/40707/c-bfs/",
                "vote_count": "732"
            },
            {
                "language": "ruby",
                "code": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        wordList.add(endWord)\n        queue = collections.deque([[beginWord, 1]])\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in wordList:\n                        wordList.remove(next_word)\n                        queue.append([next_word, length + 1])\n        return 0",
                "url": "https://leetcode.com/problems/word-ladder/solutions/40729/compact-python-solution/",
                "vote_count": "484"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        wordList = set(wordList)\n        queue = collections.deque([[beginWord, 1]])\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in wordList:\n                        wordList.remove(next_word)\n                        queue.append([next_word, length + 1])\n        return 0",
                "url": "https://leetcode.com/problems/word-ladder/solutions/40729/compact-python-solution/",
                "vote_count": "484"
            },
            {
                "language": "ruby",
                "code": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        charSet = {w for word in wordList for w in word}\n        .......\n            for i in range(len(word)):\n                for c in charSet:",
                "url": "https://leetcode.com/problems/word-ladder/solutions/40729/compact-python-solution/",
                "vote_count": "484"
            },
            {
                "language": "dart",
                "code": "public class Solution {\n\npublic int ladderLength(String beginWord, String endWord, Set<String> wordList) {\n Set<String> beginSet = new HashSet<String>(), endSet = new HashSet<String>();\n\n int len = 1;\n int strLen = beginWord.length();\n HashSet<String> visited = new HashSet<String>();\n \n beginSet.add(beginWord);\n endSet.add(endWord);\n while (!beginSet.isEmpty() && !endSet.isEmpty()) {\n  if (beginSet.size() > endSet.size()) {\n   Set<String> set = beginSet;\n   beginSet = endSet;\n   endSet = set;\n  }\n\n  Set<String> temp = new HashSet<String>();\n  for (String word : beginSet) {\n   char[] chs = word.toCharArray();\n\n   for (int i = 0; i < chs.length; i++) {\n    for (char c = 'a'; c <= 'z'; c++) {\n     char old = chs[i];\n     chs[i] = c;\n     String target = String.valueOf(chs);\n\n     if (endSet.contains(target)) {\n      return len + 1;\n     }\n\n     if (!visited.contains(target) && wordList.contains(target)) {\n      temp.add(target);\n      visited.add(target);\n     }\n     chs[i] = old;\n    }\n   }\n  }\n\n  beginSet = temp;\n  len++;\n }\n \n return 0;\n}\n}",
                "url": "https://leetcode.com/problems/word-ladder/solutions/40711/two-end-bfs-in-java-31ms/",
                "vote_count": "364"
            },
            {
                "language": "kotlin",
                "code": "if(!wordList.contains(endWord)) return 0;",
                "url": "https://leetcode.com/problems/word-ladder/solutions/40711/two-end-bfs-in-java-31ms/",
                "vote_count": "364"
            },
            {
                "language": "typescript",
                "code": "",
                "url": "https://leetcode.com/problems/word-ladder/solutions/40711/two-end-bfs-in-java-31ms/",
                "vote_count": "364"
            },
            {
                "language": "dart",
                "code": "    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) {\n            return 0;\n        }\n        Set<String> dict = new HashSet<>(wordList);\n        Set<String> beginSet = new HashSet<>();",
                "url": "https://leetcode.com/problems/word-ladder/solutions/40711/two-end-bfs-in-java-31ms/",
                "vote_count": "364"
            },
            {
                "language": "csharp",
                "code": "public int ladderLength(String beginWord, String endWord, List<String> wordAsList) {\n        if(!wordAsList.contains(endWord)) return 0;\n        \n        Set<String> wordList = new HashSet<String>(wordAsList);\n        Set<String> start = new HashSet<String>();\n        Set<String> end = new HashSet<String>();\n        int length = 1;\n        start.add(beginWord); end.add(endWord);",
                "url": "https://leetcode.com/problems/word-ladder/solutions/40711/two-end-bfs-in-java-31ms/",
                "vote_count": "364"
            },
            {
                "language": "dart",
                "code": "public int ladderLength(String beginWord, String endWord, List<String> wordList) {  \n        Set<String> wordSet = new HashSet<>(wordList);\n        if (!wordSet.contains(endWord))\n            return 0;\n        Set<String> beginSet = new HashSet<>(), endSet = new HashSet<>();\n\n        int len = 1;\n        Set<String> visited = new HashSet<>();",
                "url": "https://leetcode.com/problems/word-ladder/solutions/40711/two-end-bfs-in-java-31ms/",
                "vote_count": "364"
            }
        ]
    },
    "127": {
        "question_id": 128,
        "title": "Longest Consecutive Sequence",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/longest-consecutive-sequence",
        "description": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.You must write an algorithm that runs in O(n) time. ",
        "examples": [
            {
                "input": "nums = [100,4,200,1,3,2]",
                "output": "4",
                "explanation": "The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4."
            },
            {
                "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
                "output": "9",
                "explanation": null
            }
        ],
        "constraints": [
            "0 <= nums.length <= 10^5",
            "-10^9 <= nums[i] <= 10^9"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "def longestConsecutive(self, nums):\n    nums = set(nums)\n    best = 0\n    for x in nums:\n        if x - 1 not in nums:\n            y = x + 1\n            while y in nums:\n                y += 1\n            best = max(best, y - x)\n    return best",
                "url": "https://leetcode.com/problems/longest-consecutive-sequence/solutions/41057/simple-o-n-with-explanation-just-walk-each-streak/",
                "vote_count": "1883"
            },
            {
                "language": "csharp",
                "code": "   public int longestConsecutive(int[] nums) {\n            Set<Integer> set = new HashSet<>();\n            for(int n : nums) {\n                set.add(n);\n            }\n            int best = 0;\n            for(int n : set) {\n                if(!set.contains(n - 1)) {  // only check for one direction",
                "url": "https://leetcode.com/problems/longest-consecutive-sequence/solutions/41057/simple-o-n-with-explanation-just-walk-each-streak/",
                "vote_count": "1883"
            },
            {
                "language": "python",
                "code": "    def longestConsecutive(self, nums):\n        res, left = 0, set(nums)\n        while left:\n            l = r = left.pop()\n            while l - 1 in left: left.remove(l - 1); l -= 1;\n            while r + 1 in left: left.remove(r + 1); r += 1;\n            res = max(res, r - l + 1)\n        return res",
                "url": "https://leetcode.com/problems/longest-consecutive-sequence/solutions/41057/simple-o-n-with-explanation-just-walk-each-streak/",
                "vote_count": "1883"
            },
            {
                "language": "csharp",
                "code": "[1,2, 4,5, 7,8, 10,11]",
                "url": "https://leetcode.com/problems/longest-consecutive-sequence/solutions/41057/simple-o-n-with-explanation-just-walk-each-streak/",
                "vote_count": "1883"
            },
            {
                "language": "kotlin",
                "code": "Since understanding question statement is very easy, but just take an example not given in question-\nSuppose our given array is arr[]: [14, 5, 7, 6, 984, 8, 10]\n\nSo, if we rearrange this in a sorted manner, then it looks like arr[]: [5, 6, 7, 8, 10, 14, 984]\nso we can clearly see that (5, 6, 7, 8) forming an consecutive sequence\nTherefore, answer is 4",
                "url": "https://leetcode.com/problems/longest-consecutive-sequence/solutions/2240104/c-detailed-explanation-w-three-approaches-dry-run-each-step-explained/",
                "vote_count": "167"
            },
            {
                "language": "rust",
                "code": "Time Complexity --> O(n logn) // where n is the size of the array and since we are using sorting\nSpace Complexity --> O(1) // we are not using anything extra from our side\nIt paases [ 71 / 71 ] in built test cases",
                "url": "https://leetcode.com/problems/longest-consecutive-sequence/solutions/2240104/c-detailed-explanation-w-three-approaches-dry-run-each-step-explained/",
                "vote_count": "167"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int longestConsecutive(vector<int>& arr) {\n        int n = arr.size(); // extract the size of array\n        if(n == 0) return 0; // if length of array is zero, then from here simply return 0\n        \n        sort(arr.begin(), arr.end()); // sort the array\n        \n        int mxLen = 0, currLen = 1; // put mxLen = 0, and currLen as 1\n        \n        for(int i = 1; i < n; i++) // traverse from the array\n        {\n            if(arr[i] == arr[i - 1] + 1) // this is the part of consecutive sequence\n            {\n                currLen++; // increase the curr Length by 1\n            }\n            else if(arr[i] != arr[i - 1]) // but if it is not equal\n            {\n                mxLen = max(mxLen, currLen); // update our mxLen \n                currLen = 1; // and reset the currLen with 1\n            }\n        }\n        \n        mxLen = max(mxLen, currLen); // update our mxLen \n        return mxLen; // Finally return mxLen\n    }\n};",
                "url": "https://leetcode.com/problems/longest-consecutive-sequence/solutions/2240104/c-detailed-explanation-w-three-approaches-dry-run-each-step-explained/",
                "vote_count": "167"
            },
            {
                "language": "rust",
                "code": "Time Complexity --> O(n ) // where n is the size of the array and since we are making component\nSpace Complexity --> O(n) // we are using map\nIt paases [ 71 / 71 ] in built test cases",
                "url": "https://leetcode.com/problems/longest-consecutive-sequence/solutions/2240104/c-detailed-explanation-w-three-approaches-dry-run-each-step-explained/",
                "vote_count": "167"
            },
            {
                "language": "java",
                "code": "class Solution {\npublic:\n    int parent[100001], Rank[100001]; // make parent and rank array of max size\n    \n    int find(int a) // find function used to tell us the parent of the value 'a'\n    {\n        if(parent[a] == a)\n            return a;\n        \n        return parent[a] = find(parent[a]);\n    }\n    \n    void Union(int a, int b) // By union we are making parent \n    {\n        a = find(a); // find parent of a\n        b = find(b); // find parent of b\n        \n        if(a == b) // if both parents are equal, simply return\n            return;\n        \n        if(Rank[a] > Rank[b]) // rank of a is larger, so it will become parent\n        {\n            // a would be parent\n            parent[b] = a; \n            Rank[a] += Rank[b]; // a become parent, so increase it's rank\n        }\n        else\n        {\n            // b would be parent\n            parent[a] = b;\n            Rank[b] += Rank[a]; // b become parent, so increase it's rank\n        } \n    }\n    int longestConsecutive(vector<int>& arr) {\n        int n = arr.size(); // extract the size of array\n        if(n == 0) return 0; // if length is zero simply return zero\n        \n        // since our parent and rank are global array so everytime reintiliaze them\n        for(int i = 0; i < n; i++) parent[i] = i, Rank[i] = 1;\n        \n        unordered_map<int, int> mp; // making map\n        \n        for(int i = 0; i < n; i++) // traverse from the arrat\n        {\n            // if element is already presnt into the map, just continue\n            if(mp.find(arr[i]) != mp.end()) continue;\n            \n            // if (arr[i] - 1) present in the map, we will perform union\n            if(mp.find(arr[i] - 1) != mp.end())\n            {\n                Union(mp[arr[i] - 1], i);\n            }\n            \n             // also, if (arr[i] - 1) present in the map, we will perform union\n            if(mp.find(arr[i] + 1) != mp.end())\n            {\n                Union(mp[arr[i] + 1], i);\n            }\n            \n             mp[arr[i]] = i;\n        }\n        \n        int ans = 0; // intiliaze ans as zero\n        for(int i = 0; i < n; i++)\n        {\n            ans = max(ans, Rank[i]); // take the largest component\n        }\n        \n        return ans; // finally return ans\n    }\n}; ",
                "url": "https://leetcode.com/problems/longest-consecutive-sequence/solutions/2240104/c-detailed-explanation-w-three-approaches-dry-run-each-step-explained/",
                "vote_count": "167"
            },
            {
                "language": "swift",
                "code": "Suppose our given array is arr[]: [12, 13, 2, 3, 4, 5, 8, 9, 10, 11, 78, 79, 80]\n\n1) In the first step, we make a map and for every element we put 1.\n  (Assuming that every element can be the starting point of some consecutive sequence)\n  so map looks like:-\n  \n  map\n  element (key)      |    value\n   12          |     1\n   13          |     1\n    2          |     1\n    3          |     1\n    4          |     1\n    5          |     1\n    8          |     1\n    9          |     1\n   10          |     1\n   11          |     1\n   78          |     1\n   79          |     1\n   80          |     1\n   \n2) Now, in the second step, we will see whether (arr[i] - 1) is present in our map or not.\n    If (arr[i] - 1) is present in our map, then arr[i] can't be the starting point of some consecutive sequence.\n \n so, map looks like:-\n  map\n  element (key)      |    value\n   12          |     0          (since (12 - 1 = 11) is present in map so we put zero in front of 12)\n   13          |     0          (since (13 - 1 = 12) is present in map so we put zero in front of 13)\n    2          |     1          (since (2 - 1 = 1) is not present in map so we leave 2 as it is)\n    3          |     0          (since (3 - 1 = 2) is present in map so we put zero in front of 3)\n    4          |     0          (since (4 - 1 = 3) is present in map so we put zero in front of 4)\n    5          |     0          (since (5 - 1 = 4) is present in map so we put zero in front of 5)\n    8          |     1          (since (8 - 1 = 7) is not present in map so we leave 8 as it is)\n    9          |     0          (since (9 - 1 = 8) is present in map so we put zero in front of 9)\n   10          |     0          (since (10 - 1 = 9) is present in map so we put zero in front of 10)\n   11          |     0          (since (11 - 1 = 10) is present in map so we put zero in front of 11)\n   78          |     1          (since (78 - 1 = 77) is not present in map so we leave 77 as it is)\n   79          |     0          (since (79 - 1 = 78) is present in map so we put zero in front of 79)\n   80          |     0          (since (80 - 1 = 79) is present in map so we put zero in front of 80)\n   \n3) Now, in the third step, the elements for which 1 is left in the map, for them we can definately say\n    that they are starting point of some consecutive sequence.\n Here we can see that elements 2, 8, and 78 definately starting some consecutive sequence.\n \n The only task is left to us now is to find the longest length of the consecutive sequence.\n How we are going to do that? let see-\n \n Now, at this point we are only going to care about those elements which are having value as 1 in the map.\n We also say that they are definately going to be the starting point some consecutive sequence, right.\n so, intially we define our length as 1, because they are the starting point so its definite they are having length atleast 1.\n suppose we take 2, so intially length = 1\n what we search now, we say 2 is there, ok, it's fine\n now we ask whether 3 is there or not, we say yes it is their, so we increase our length as 2\n again, we say whether 4 is there or not, and according to presence we increase our length.\n \n so if we observe everytime what we asking for, \n suppose arr[i] is being 2 and intially length is 1\n \n so if i ask whether (arr[i] + length) is present or not, \n than what (arr[i] + length) is, it is (2 + 1 = 3), we say yes 3 is there\n so we increase our length as 2\n \n now, if we ask again (arr[i] + length) what it looks like, it looks like\n arr[i] is 2, but length is 2 now so (2 + 2 = 4) is present or not, we say yes  \n so we increase our length by 1, so length becomes 3\n \n again now, if we ask again (arr[i] + length) what it looks like, it looks like\n arr[i] is 2, but length is 3 now so (2 + 3 = 5) is present or not, we say yes  \n so we increase our length by 1, so length becomes 4\n \n In this way we can say that with the help of length we find the length of the consecutive sequence.\n And out of them whatever the will give me the maximum length should be my answer.\n \n So, if we talk about our above example,\n \n elements that left with value 1 are (2, 8 and 78)\n for 2, we will see (2, 3, 4, 5) is the sequence, so length is 4\n for 8, we will see (8, 9, 10, 11, 12, 13) is the sequence, so length is 6\n and for 78, we will see (78, 79, 80) is the sequence, so length is 3\n \n so out of three of them maximum is ({4, 6, 3}) is 6\n so, 6 will be my final answer.\n \n I hope you got the concept, see commented code for better understanding.",
                "url": "https://leetcode.com/problems/longest-consecutive-sequence/solutions/2240104/c-detailed-explanation-w-three-approaches-dry-run-each-step-explained/",
                "vote_count": "167"
            },
            {
                "language": "rust",
                "code": "Time Complexity --> O(n + n + n) = O(3n) ~ O(n) \n// where n is the size of the array and since we are traversing array three times \n// 1) for putting 1 for each element (step 1)\n// 2) for improving our assumption (step 2)\n// 3) for finding sequence (step 3)\n\nSpace Complexity --> O(n) // since we are using map\nIt paases [ 71 / 71 ] in built test cases",
                "url": "https://leetcode.com/problems/longest-consecutive-sequence/solutions/2240104/c-detailed-explanation-w-three-approaches-dry-run-each-step-explained/",
                "vote_count": "167"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int longestConsecutive(vector<int>& arr) {\n        int n = arr.size(); // extract the size of the array\n        \n        unordered_map<int, int> mp; // declaring unordered map\n        \n        // Step 1)  we are giving 1 to each of the elemnt\n        // (Assuming that it may be the starting point of consecutive sequence)\n        for(int i = 0; i < n; i++)\n        {\n            mp[arr[i]] = 1;\n        }\n        \n        // step 2) validating our assumption taken in step 1\n        for(int i = 0; i < n; i++)\n        {\n            if(mp.find(arr[i] - 1) != mp.end()) // if(arr[i] - 1) is present in map\n            {\n                // then arr[i] can never be the starting point some of consecutive sequence\n                // so give value zero for that arr[i]\n                mp[arr[i]] = 0;\n            }\n        }\n        \n        // step 3) Now the elements for which value 1 is left\n        // for them we definately know they are the starting point of \n        // some consecutive sequence, using that length trick we find the maxlen\n        \n        int mxLen = 0; // this variable holds my answer\n        \n        for(int i = 0; i < n; i++) // travel in the array\n        {\n            // if value is 1, then they are starting point some of consecutive sequence\n            if(mp[arr[i]] == 1) \n            {\n                // if it is the starting point, then definately length is going to be \n                // atleast 1\n                int length = 1; \n                \n               // we dicuss it above\n                while(mp.find(arr[i] + length) != mp.end())\n                {\n                    length++;\n                }\n                \n                mxLen = max(mxLen, length); // update mxLen\n            }\n        }\n        \n        return mxLen; // Finally return mxLen\n    }\n};",
                "url": "https://leetcode.com/problems/longest-consecutive-sequence/solutions/2240104/c-detailed-explanation-w-three-approaches-dry-run-each-step-explained/",
                "vote_count": "167"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int dfs(unordered_map<int,int>& mp, int i){\n        int res = 0;\n        if(mp.find(i+1) != mp.end() && mp[i+1] == 0){\n            mp[i+1] = 1;\n            res += 1 + dfs(mp, i+1);",
                "url": "https://leetcode.com/problems/longest-consecutive-sequence/solutions/2240104/c-detailed-explanation-w-three-approaches-dry-run-each-step-explained/",
                "vote_count": "167"
            },
            {
                "language": "dart",
                "code": "public int longestConsecutive(int[] nums) {\n     Set <Integer> set = new HashSet <> ();\n     for (int num : nums)\n         set.add (num);\n     int maxLength = 0;\n     for (int num : set) {\n         if (!set.contains(num - 1)) {",
                "url": "https://leetcode.com/problems/longest-consecutive-sequence/solutions/2240104/c-detailed-explanation-w-three-approaches-dry-run-each-step-explained/",
                "vote_count": "167"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N^3), The outer loop runs exactly N times, and because currentNumber increments by 1\n    during each iteration of the while loop, it runs in O(N) time. Then, on each iteration of the while loop, an\n    O(N) operation in the array is performed. Therefore, this brute force algorithm is really three nested O(N)\n    loops, which compound multiplicatively to a cubic runtime. Where N is the size of the Array(nums).\n\n    Space Complexity : O(1), Constant space.\n\n    Using Array(Three Nested Loop). Brute Force Approach.\n\n    Note : This will give TLE.\n\n*/\n\n\n/***************************************** Approach 1 Code *****************************************/\n\nclass Solution {\nprivate: \n    bool longestConsecutive(vector<int>& nums, int target){\n        int n = nums.size();\n        for(int i=0; i<n; i++){\n            if(nums[i] == target){\n                return true;\n            }\n        }\n        return false;\n    }\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        int n = nums.size();\n        int longestConsecutiveSequence = 0;\n        for(auto num : nums){\n            int currentNumber = num;\n            int currentConsecutiveSequence = 1;\n            while(longestConsecutive(nums, currentNumber+1)){\n                currentNumber += 1;\n                currentConsecutiveSequence += 1;\n            }\n            longestConsecutiveSequence = max(longestConsecutiveSequence, currentConsecutiveSequence);\n        }\n        return longestConsecutiveSequence;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(NlogN), The main for loop does constant work N times, so the algorithm's time complexity\n    is dominated by the invocation of sorting algorithm, which will run in O(NlogN) time for any sensible\n    implementation. Where N is the size of the Array(nums).\n\n    Space Complexity : O(1), For the implementations provided here, the space complexity is constant because we\n    sort the input array in place.\n\n    Solved using Array + Sorting. Brute Better Approach.\n\n*/\n\n\n/***************************************** Approach 2 Code *****************************************/\n\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0){\n            return 0;\n        }\n        sort(nums.begin(), nums.end());\n        int currentConsecutiveSequence = 1;\n        int longestConsecutiveSequence = 0;\n        for(int i=1; i<n; i++){\n            if(nums[i] != nums[i-1]){\n                if(nums[i] == nums[i-1] + 1){\n                    currentConsecutiveSequence++;\n                }\n                else{\n                    longestConsecutiveSequence = max(longestConsecutiveSequence, currentConsecutiveSequence);\n                    currentConsecutiveSequence = 1;\n                }\n            }\n        }\n        return max(longestConsecutiveSequence, currentConsecutiveSequence);\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N), We are traversing the Array(nums) thrice which creates the time complexity O(N)\n    becuase Unordered map operating takes constant time. Where N is the size of the Array(nums).\n\n    Space Complexity : O(N), Unordered map space.\n\n    Solved using Array + Hash Table(Unordered map). Optimize Approach.\n\n*/\n\n\n/***************************************** Approach 3 Code *****************************************/\n\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        unordered_map<int, bool> map;\n        for(int i = 0; i<nums.size(); i++){\n            map[nums[i]] = true;\n        }\n        for(int i=0; i<nums.size(); i++){\n            if(map.count(nums[i]-1) > 0){\n                map[nums[i]] = false;\n            }\n        }\n        int maxlen = 0;\n        for(int i=0; i<nums.size(); i++){\n            if(map[nums[i]] == true){\n                int j=0; int count=0;\n                while(map.count(nums[i]+j) > 0){\n                    j++;\n                    count++;\n                }\n                if(count>maxlen){\n                    maxlen = count;\n                }\n            }\n        }\n        return maxlen;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N), Although the time complexity appears to be quadratic due to the while loop nested\n    within the for loop, closer inspection reveals it to be linear. Because the while loop is reached only when\n    marks the beginning of a sequence (i.e. currentNumber-1 is not present in nums), the while loop can only run\n    for N iterations throughout the entire runtime of the algorithm. This means that despite looking like O(N^2)\n    complexity, the nested loops actually run in O(N+N)=O(N) time. All other computations occur in constant\n    time, so the overall runtime is linear. Where N is the size of the Array(nums).\n\n    Space Complexity : O(N), Unordered set space.\n\n    Solved using Array + Hash Table(Unordered set). Optimise Approach.\n\n*/\n\n\n/***************************************** Approach 4 Code *****************************************/\n\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        unordered_set<int> set;\n        for(int num : nums){\n            set.insert(num);\n        }\n        int longestConsecutiveSequence = 0;\n        for(int num : nums){\n            if(set.find(num-1) == set.end()){\n                int currentNumber = num;\n                int currentConsecutiveSequence = 1;\n                while(set.find(currentNumber+1) != set.end()){\n                    currentNumber++;\n                    currentConsecutiveSequence++;\n                }\n                longestConsecutiveSequence = max(longestConsecutiveSequence, currentConsecutiveSequence);\n            }\n        }\n        return longestConsecutiveSequence;\n    }\n};",
                "url": "https://leetcode.com/problems/longest-consecutive-sequence/solutions/3171985/best-c-4-solution-hash-table-sorting-brute-force-optimize-one-stop-solution/",
                "vote_count": "82"
            },
            {
                "language": "cpp",
                "code": "int a[100000];\n\nint init = [] {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    ofstream out(\"user.out\");\n    for (string s; getline(cin, s); out << '\\n') {\n        if (s.length() == 2) {\n            out << 0;\n            continue;\n        }\n        int n = 0;\n        for (int _i = 1, _n = s.length(); _i < _n; ++_i) {\n            bool _neg = false;\n            if (s[_i] == '-') ++_i, _neg = true;\n            int v = s[_i++] & 15;\n            while ((s[_i] & 15) < 10) v = v * 10 + (s[_i++] & 15);\n            if (_neg) v = -v;\n            a[n++] = v;\n        }\n        sort(a, a + n);\n        int ans = 0;\n        for (int i = 0; i < n;) {\n            int i0 = i;\n            for (++i; i < n && a[i - 1] + 1 >= a[i]; ++i);\n            ans = max(ans, a[i - 1] - a[i0] + 1);\n        }\n        out << ans;\n    }\n    out.flush();\n    exit(0);\n    return 0;\n}();\n\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>) { return 999; }\n};",
                "url": "https://leetcode.com/problems/longest-consecutive-sequence/solutions/3171254/solution/",
                "vote_count": "30"
            }
        ]
    },
    "128": {
        "question_id": 129,
        "title": "Sum Root to Leaf Numbers",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/sum-root-to-leaf-numbers",
        "description": "You are given the root of a binary tree containing digits from 0 to 9 only.Each root-to-leaf path in the tree represents a number.For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.A leaf node is a node with no children. ",
        "examples": [
            {
                "input": "root = [1,2,3]",
                "output": "25\nExplanation:\nThe root-to-leaf path 1->2 represents the number 12.\nThe root-to-leaf path 1->3 represents the number 13.\nTherefore, sum = 12 + 13 = 25.",
                "explanation": null
            },
            {
                "input": "root = [4,9,0,5,1]",
                "output": "1026\nExplanation:\nThe root-to-leaf path 4->9->5 represents the number 495.\nThe root-to-leaf path 4->9->1 represents the number 491.\nThe root-to-leaf path 4->0 represents the number 40.\nTherefore, sum = 495 + 491 + 40 = 1026.",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [1, 1000].",
            "0 <= Node.val <= 9",
            "The depth of the tree will not exceed 10."
        ],
        "solutions": [
            {
                "language": "typescript",
                "code": "class Solution {\n    int sum=0;\n    public int sumNumbers(TreeNode root) {\n        helper(root,\"\");\n        return sum;\n    }\n    public void helper(TreeNode root,String str){\n        if(root==null){\n            return;\n        }\n        str+=root.val;\n        if(root.left==null && root.right==null){\n            sum+=Integer.parseInt(str);\n            return;\n        }\n        helper(root.left,str);\n        helper(root.right,str);\n    }\n}",
                "url": "https://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3294054/java-easy-recursion-with-explanation/",
                "vote_count": "74"
            },
            {
                "language": "kotlin",
                "code": "    public int sumNumbers(TreeNode root) {\n        return sum(root,0);\n    }\n    int sum(TreeNode node,int s){\n        if(node == null) return 0;\n        if(node.left==null && node.right==null) return s*10+node.val;\n        return sum(node.left,s*10+node.val)+sum(node.right,s*10+node.val);\n    }",
                "url": "https://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3294054/java-easy-recursion-with-explanation/",
                "vote_count": "74"
            },
            {
                "language": "dart",
                "code": "public void helper(TreeNode root, int num) {\n    if(root == null)",
                "url": "https://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3294054/java-easy-recursion-with-explanation/",
                "vote_count": "74"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        int currentSum = 0;\n        return sumNodes(root, currentSum);\n    }\n\n    int sumNodes(TreeNode* root, int currentSum){\n        if(root == NULL) return 0;\n        currentSum = currentSum * 10 + root->val;\n        if(root->left==NULL && root->right==NULL) return currentSum;\n\n        int leftSum = sumNodes(root->left, currentSum);\n        int rightSum = sumNodes(root->right, currentSum);\n        return leftSum + rightSum; \n    }\n};",
                "url": "https://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3294304/image-explanation-3-methods-recursive-bfs-o-1-space-morris-traversal-preorder/",
                "vote_count": "61"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        int totalSum = 0;\n        queue<pair<TreeNode*, int>> q; // <TreeNode*, sumSoFar>\n        q.push({root, 0});\n\n        while(!q.empty()){\n            auto [root, currentSum] = q.front(); q.pop();\n            currentSum = currentSum*10 + root->val;\n            if(root->left==NULL && root->right==NULL) totalSum += currentSum;\n\n            if(root->left) q.push({root->left, currentSum});\n            if(root->right) q.push({root->right, currentSum});\n        }\n        return totalSum;\n    }\n};",
                "url": "https://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3294304/image-explanation-3-methods-recursive-bfs-o-1-space-morris-traversal-preorder/",
                "vote_count": "61"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        TreeNode *cur = root;\n        int totalSum=0, currentSum=0, depth=0;\n        while(cur != NULL){\n            if(cur->left == NULL){ // left side is not there\n                currentSum = currentSum * 10 + cur->val; // preorder(cur->val)\n                if(cur->right == NULL) totalSum += currentSum;\n                cur = cur->right;\n            }else{ // left side is there (explore it) \n                TreeNode *prev = cur->left;\n                depth=1;\n                while(prev->right && prev->right!=cur) prev = prev->right, depth++;\n\n                if(prev->right == NULL){ // Root's Left's Rightmost node has no attachments (means first time visit)\n                    prev->right = cur;\n                    currentSum = currentSum * 10 + cur->val; // preorder(cur->val)\n                    cur = cur->left;\n                }else{ // Root's Left's Rightmost node has threaded attachments (means Root's Left Visited already)\n                    prev->right = NULL;\n                    if(prev->left == NULL) totalSum += currentSum; // that node is being visited last time\n                    currentSum = currentSum/pow(10, depth);\n                    cur = cur->right;\n                }\n            }\n        }\n        return totalSum;\n    }\n};",
                "url": "https://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3294304/image-explanation-3-methods-recursive-bfs-o-1-space-morris-traversal-preorder/",
                "vote_count": "61"
            },
            {
                "language": "kotlin",
                "code": "public int sumNumbers(TreeNode root) {\n        return sum(root,0);\n    }\n    int sum(TreeNode node,int s){\n        if(node == null) return 0;\n        if(node.left==null && node.right==null) return s*10+node.val;\n        return sum(node.left,s*10+node.val)+sum(node.right,s*10+node.val);\n    }",
                "url": "https://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3294304/image-explanation-3-methods-recursive-bfs-o-1-space-morris-traversal-preorder/",
                "vote_count": "61"
            },
            {
                "language": "rust",
                "code": "Thanks for visiting my solution.\ud83d\ude0a Keep Learning\nPlease give my solution an upvote! \ud83d\udc4d\nIt's a simple way to show your appreciation and\nkeep me motivated. Thank you! \ud83d\ude0a",
                "url": "https://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3293880/easy-solutions-in-java-python-and-c-look-at-once/",
                "vote_count": "42"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n #define ll long long\nclass Solution {\npublic:\n\n    void dfs(TreeNode *root, ll &ans , ll tmp){\n        if(root->left== NULL && root->right==NULL){\n            tmp = tmp*10 + root->val;\n            ans+=tmp;\n            return;\n        }\n        tmp = tmp*10 + root->val;\n        if(root->left) dfs(root->left,ans,tmp);\n        if(root->right) dfs(root->right,ans,tmp);\n    }\n\n    int sumNumbers(TreeNode* root) {\n        ll ans =0;\n        dfs(root,ans,0);\n        return int(ans);\n    }\n};",
                "url": "https://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3294242/c-recursive-100-beat-easy-o-n/",
                "vote_count": "27"
            },
            {
                "language": "kotlin",
                "code": "public int sumNumbers(TreeNode root) {\n        return sum(root,0);\n    }\n    int sum(TreeNode node,int s){\n        if(node == null) return 0;\n        if(node.left==null && node.right==null) return s*10+node.val;\n        return sum(node.left,s*10+node.val)+sum(node.right,s*10+node.val);\n    }",
                "url": "https://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3294242/c-recursive-100-beat-easy-o-n/",
                "vote_count": "27"
            },
            {
                "language": "kotlin",
                "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        global l\n        l=[]\n        def f(root,s):\n            if(root is None):\n                pass\n            elif(root.left is None and root.right is None):\n                s+=str(root.val)\n                l.append(s)\n            else:\n                s+=str(root.val)\n                s1=s[::]\n                f(root.left,s)\n                f(root.right,s1)\n        f(root,\"\")\n        ans=0\n        for i in l:\n            ans+=int(i)\n        return ans",
                "url": "https://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3297708/simple-dfs-using-python-by-akash-sinha/",
                "vote_count": "10"
            }
        ]
    },
    "129": {
        "question_id": 130,
        "title": "Surrounded Regions",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/surrounded-regions",
        "description": "Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.A region is captured by flipping all 'O's into 'X's in that surrounded region. ",
        "examples": [
            {
                "input": "board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]",
                "output": "[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]",
                "explanation": "Notice that an 'O' should not be flipped if:\n- It is on the border, or\n- It is adjacent to an 'O' that should not be flipped.\nThe bottom 'O' is on the border, so it is not flipped.\nThe other three 'O' form a surrounded region, so they are flipped."
            },
            {
                "input": "board = [[\"X\"]]",
                "output": "[[\"X\"]]",
                "explanation": null
            }
        ],
        "constraints": [
            "m == board.length",
            "n == board[i].length",
            "1 <= m, n <= 200",
            "board[i][j] is 'X' or 'O'."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void DFS(vector<vector<char>>& board, int i, int j, int m, int n) {\n        if(i<0 or j<0 or i>=m or j>=n or board[i][j] != 'O') return;\n        board[i][j] = '#';\n        DFS(board, i-1, j, m, n);\n        DFS(board, i+1, j, m, n);\n        DFS(board, i, j-1, m, n);\n        DFS(board, i, j+1, m, n);\n    }\n    \n    void solve(vector<vector<char>>& board) {\n      \n      //We will use boundary DFS to solve this problem\n        \n      // Let's analyze when an 'O' cannot be flipped,\n      // if it has atleast one 'O' in it's adjacent, AND ultimately this chain of adjacent 'O's is connected to some 'O' which lies on boundary of board\n        \n      //consider these two cases for clarity :\n      /*\n        O's won't be flipped          O's will be flipped\n        [X O X X X]                   [X X X X X]     \n        [X O O O X]                   [X O O O X]\n        [X O X X X]                   [X O X X X] \n        [X X X X X]                   [X X X X X]\n      \n      So we can conclude if a chain of adjacent O's is connected some O on boundary then they cannot be flipped\n      \n      */\n        \n      //Steps to Solve :\n      //1. Move over the boundary of board, and find O's \n      //2. Every time we find an O, perform DFS from it's position\n      //3. In DFS convert all 'O' to '#'      (why?? so that we can differentiate which 'O' can be flipped and which cannot be)   \n      //4. After all DFSs have been performed, board contains three elements,#,O and X\n      //5. 'O' are left over elements which are not connected to any boundary O, so flip them to 'X'\n      //6. '#' are elements which cannot be flipped to 'X', so flip them back to 'O'\n      //7. finally, Upvote the solution\ud83d\ude0a   \n        \n      \n     int m = board.size();\n        \n      if(m == 0) return;  \n        \n     int n = board[0].size();\n     \n     //Moving over firts and last column   \n     for(int i=0; i<m; i++) {\n         if(board[i][0] == 'O')\n             DFS(board, i, 0, m, n);\n         if(board[i][n-1] == 'O')\n             DFS(board, i, n-1, m, n);\n     }\n        \n        \n     //Moving over first and last row   \n     for(int j=0; j<n; j++) {\n         if(board[0][j] == 'O')\n             DFS(board, 0, j, m, n);\n         if(board[m-1][j] == 'O')\n             DFS(board, m-1, j, m, n);\n     }\n        \n     for(int i=0; i<m; i++)\n         for(int j=0; j<n; j++)\n         {\n             if(board[i][j] == 'O')\n                 board[i][j] = 'X';\n             if(board[i][j] == '#')\n                 board[i][j] = 'O';\n         }\n    }\n};",
                "url": "https://leetcode.com/problems/surrounded-regions/solutions/691675/c-beginner-friendly-boundary-dfs-inplace/",
                "vote_count": "1184"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void solve(vector<vector<char>>& b) {\n        int m = b.size(), n = b[0].size();\n        vector<vector<int>> vis(m, vector<int> (n));\n        queue<pair<int, int>> q;\n\n        // First store position of all the O's that are present at the boundary in the queue data structue\n        for(int i=0; i<m; i++)\n            for(int j=0; j<n; j++)\n                if(i==0 || j==0 || i==m-1 || j==n-1){\n                    if(b[i][j]=='O'){\n                        q.push({i, j});\n                        vis[i][j]=1;\n                    } \n                }\n\n        // Start BFS traversal and mark all the O's that are connected to these boundary element\n        while(!q.empty()){\n            auto [r, c] = q.front();\n            vis[r][c]=1;\n            q.pop();\n            for(int x=-1; x<=1; x++){\n                for(int y=-1; y<=1; y++){\n                    if(x&&y || (x==0 && y==0)) continue;\n                    int nrow = r+x, ncol = c+y;\n                    if(nrow<0 || ncol<0 || nrow>=m || ncol>=n) continue;\n                    if(vis[nrow][ncol] || b[nrow][ncol]=='X') continue;\n                    vis[nrow][ncol] = 1;\n                    q.push({nrow, ncol});\n                }\n            }\n        }\n        // check which O's are unmarked, that means they are not connected to the boundary element that's why they are unmarked\n        for(int i=0; i<m; i++){\n            for(int j=0; j<n; j++){\n                if(vis[i][j]==0 && b[i][j]=='O') b[i][j] = 'X';\n            }\n        }\n\n    }\n};\n\n// Please upvote if this solution helped you somehow!",
                "url": "https://leetcode.com/problems/surrounded-regions/solutions/3318618/dfs-bfs-easy-to-understand-c-clean-code/",
                "vote_count": "16"
            }
        ]
    },
    "130": {
        "question_id": 131,
        "title": "Palindrome Partitioning",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/palindrome-partitioning",
        "description": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. ",
        "examples": [
            {
                "input": "s = \"aab\"",
                "output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
                "explanation": null
            }
        ],
        "constraints": [],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool checkPalindrome(string str, int startIndex, int lastIndex){\n        while(startIndex <= lastIndex){\n            if(str[startIndex] != str[lastIndex])\n                return false;\n            startIndex++;\n            lastIndex--;\n        }\n        return true;\n    }\n    void palindromePartition(int index, vector<string>& ds, vector<vector<string>>& output, string str){\n        if(index == str.length()){\n            output.push_back(ds);\n            return;\n        }\n        for(int i = index; i < str.length(); i++){\n            if(checkPalindrome(str, index, i)){\n                ds.push_back(str.substr(index, i - index + 1));\n                palindromePartition(i+1, ds, output, str);\n                ds.pop_back();\n            }\n        }\n    }\n    vector<vector<string>> partition(string s) {\n        vector<vector<string>> output;\n        vector<string> ds;\n        palindromePartition(0, ds, output, s);\n        return output;\n    }\n};",
                "url": "https://leetcode.com/problems/palindrome-partitioning/solutions/3083493/day-22-beginner-friendly-solution-with-diagram-backtracking/",
                "vote_count": "113"
            }
        ]
    },
    "131": {
        "question_id": 132,
        "title": "Palindrome Partitioning II",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/palindrome-partitioning-ii",
        "description": "Given a string s, partition s such that every substring of the partition is a palindrome.Return the minimum cuts needed for a palindrome partitioning of s. ",
        "examples": [
            {
                "input": "s = \"aab\"",
                "output": "1",
                "explanation": "The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut."
            },
            {
                "input": "s = \"a\"",
                "output": "0",
                "explanation": null
            },
            {
                "input": "s = \"ab\"",
                "output": "1",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= s.length <= 2000",
            "s consists of lowercase English letters only."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int minCut(string s) {\n        int n = s.size();\n        vector<int> cut(n+1, 0);  // number of cuts for the first k characters\n        for (int i = 0; i <= n; i++) cut[i] = i-1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; i-j >= 0 && i+j < n && s[i-j]==s[i+j] ; j++) // odd length palindrome\n                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j]);\n\n            for (int j = 1; i-j+1 >= 0 && i+j < n && s[i-j+1] == s[i+j]; j++) // even length palindrome\n                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j+1]);\n        }\n        return cut[n];\n    }\n};",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42198/my-solution-does-not-need-a-table-for-palindrome-is-it-right-it-uses-only-o-n-space/",
                "vote_count": "1047"
            },
            {
                "language": "java",
                "code": "public int minCut(String s) {\n        // validate input\n        if (s == null || s.length() <= 1) {\n            return 0;\n        }\n        // dp\n        int N = s.length();\n        int[] dp = IntStream.range(0, N).toArray(); // initial value: dp[i] = i\n\n(end); start--, end++) {\n(end); start--, end++) {",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42198/my-solution-does-not-need-a-table-for-palindrome-is-it-right-it-uses-only-o-n-space/",
                "vote_count": "1047"
            },
            {
                "language": "rust",
                "code": ".......aba...\n|<-X->| ^\n|<---Y-->|",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42198/my-solution-does-not-need-a-table-for-palindrome-is-it-right-it-uses-only-o-n-space/",
                "vote_count": "1047"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        size = len(s)\n        cut = range(-1, size)",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42198/my-solution-does-not-need-a-table-for-palindrome-is-it-right-it-uses-only-o-n-space/",
                "vote_count": "1047"
            },
            {
                "language": "python",
                "code": "for (int i = 0; i <= n; i++) cut[i] = i-1;",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42198/my-solution-does-not-need-a-table-for-palindrome-is-it-right-it-uses-only-o-n-space/",
                "vote_count": "1047"
            },
            {
                "language": "lisp",
                "code": "iota(cut.begin(), cut.end(), -1);",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42198/my-solution-does-not-need-a-table-for-palindrome-is-it-right-it-uses-only-o-n-space/",
                "vote_count": "1047"
            },
            {
                "language": "java",
                "code": "class Solution {",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42198/my-solution-does-not-need-a-table-for-palindrome-is-it-right-it-uses-only-o-n-space/",
                "vote_count": "1047"
            },
            {
                "language": "cpp",
                "code": "  public int minCut(String s) {\n        if(s.length()==0)return 0;\n        int[]c=new int[s.length()+1];\n        for(int i=0;i<s.length();i++)c[i]=Integer.MAX_VALUE;\n        c[s.length()]=-1;\n        for(int i=s.length()-1;i>=0;i--){\n            for(int a=i,b=i;a>=0 && b<s.length() && s.charAt(a)==s.charAt(b);a--,b++) c[a]=Math.min(c[a],1+c[b+1]);\n            for(int a=i,b=i+1;a>=0 && b<s.length() && s.charAt(a)==s.charAt(b);a--,b++) c[a]=Math.min(c[a],1+c[b+1]);",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42198/my-solution-does-not-need-a-table-for-palindrome-is-it-right-it-uses-only-o-n-space/",
                "vote_count": "1047"
            },
            {
                "language": "python",
                "code": "a   b   a   |   c  c\n                j  i\n       j-1  |  [j, i] is palindrome\n   cut(j-1) +  1",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42213/easiest-java-dp-solution-97-36/",
                "vote_count": "422"
            },
            {
                "language": "cpp",
                "code": "public int minCut(String s) {\n    char[] c = s.toCharArray();\n    int n = c.length;\n    int[] cut = new int[n];\n    boolean[][] pal = new boolean[n][n];\n    \n    for(int i = 0; i < n; i++) {\n        int min = i;\n        for(int j = 0; j <= i; j++) {\n            if(c[j] == c[i] && (j + 1 > i - 1 || pal[j + 1][i - 1])) {\n                pal[j][i] = true;  \n                min = j == 0 ? 0 : Math.min(min, cut[j - 1] + 1);\n            }\n        }\n        cut[i] = min;\n    }\n    return cut[n - 1];\n}",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42213/easiest-java-dp-solution-97-36/",
                "vote_count": "422"
            },
            {
                "language": "php",
                "code": "public int minCut(String s) {\n    int n,min;\n    n = s.length();\n    \n    //cut[i] represents minimum number of cuts from String 0 to i",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42213/easiest-java-dp-solution-97-36/",
                "vote_count": "422"
            },
            {
                "language": "php",
                "code": "public int minCut(String s) {\n        int n = s.length();\n        boolean dp[][] = new boolean[n+1][n+1];\n        int min[] = new int[n];\n        for(int i=0; i<n; ++i) {\n            min[i] = i;\n            for(int j=0; j<=i; ++j) {\n                if(s.charAt(i) == s.charAt(j) && (j+1 > i-1 || dp[j+1][i-1])) {",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42213/easiest-java-dp-solution-97-36/",
                "vote_count": "422"
            },
            {
                "language": "lisp",
                "code": "(j + 1 >= i - 1)",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42213/easiest-java-dp-solution-97-36/",
                "vote_count": "422"
            },
            {
                "language": "cpp",
                "code": " class Solution {\n    public:\n        int minCut(string s) {\n            if(s.empty()) return 0;\n            int n = s.size();\n            vector<vector<bool>> pal(n,vector<bool>(n,false));\n            vector<int> d(n);\n            for(int i=n-1;i>=0;i--)\n            {\n                d[i]=n-i-1;\n                for(int j=i;j<n;j++)\n                {\n                    if(s[i]==s[j] && (j-i<2 || pal[i+1][j-1]))\n                    {\n                       pal[i][j]=true;\n                       if(j==n-1)\n                           d[i]=0;\n                       else if(d[j+1]+1<d[i])\n                           d[i]=d[j+1]+1;\n                    }\n                }\n            }\n            return d[0];\n        }\n    };",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42199/my-dp-solution-explanation-and-code/",
                "vote_count": "168"
            },
            {
                "language": "php",
                "code": "public static int minCut(String s) {\n    if (s.isEmpty()) return 0;\n    int n = s.length();\n    int[] dp = new int[n];\n    boolean[][] isPalindrome = new boolean[n][n];\n\n    for (int right = 0; right < s.length(); right++) {\n][right - 1])) {",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42199/my-dp-solution-explanation-and-code/",
                "vote_count": "168"
            },
            {
                "language": "cpp",
                "code": "int minCut(string s) {\n    int n = s.size();\n    if (!n) return 0;\n    vector<vector<bool>> memo(n,vector<bool>(n,false));\n    int *dp = new int[n];\n    for (int i = 0; i < n; ++i){\n        memo[i][i] = true;\n        dp[i] = i;",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42199/my-dp-solution-explanation-and-code/",
                "vote_count": "168"
            },
            {
                "language": "php",
                "code": "    public class Solution {\n       \n    public int minCut(String s) {\n        \n        if (s==null||s.length()==0) return 0;\n        //Initiation\n        int length=s.length();\n        ",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42199/my-dp-solution-explanation-and-code/",
                "vote_count": "168"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        pal = [[False for _ in range(len(s))] for _ in range(len(s))]\n        cuts = [len(s)-i-1 for i in range(len(s))]",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42199/my-dp-solution-explanation-and-code/",
                "vote_count": "168"
            },
            {
                "language": "go",
                "code": "public class Solution {\n    public int minCut(String s) {\n        int len = s.length();\n        int[] dp = new int[len + 1];\n        boolean[][] p = new boolean[len+1][len+1];\n        for (int i = 1; i <= len; i++) {\n            dp[i] = i;\n            for (int j = 1; j <= i; j++) {",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42199/my-dp-solution-explanation-and-code/",
                "vote_count": "168"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42199/my-dp-solution-explanation-and-code/",
                "vote_count": "168"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        if not s: return -1\n        n=len(s)\n        dp=[i for i in range(n)]\n        isPalindrome = [[False for _ in range(n)] for _ in range(n)] \n        for right in range(n):\n            isPalindrome[right][right]=True",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42199/my-dp-solution-explanation-and-code/",
                "vote_count": "168"
            },
            {
                "language": "go",
                "code": "  public int minCut(String s) {\n    int len = s.length();\n    boolean[] pal = new boolean[len];\n    int[] dp = new int[len];\n    for (int i = len - 1; i >= 0; i--) {\n      dp[i] = len - i - 1;\n      for (int j = len - 1; j >= i; j--) {\n        if (s.charAt(i) == s.charAt(j) && (i + 1 >= j - 1 || pal[j - 1])) {",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/42199/my-dp-solution-explanation-and-code/",
                "vote_count": "168"
            },
            {
                "language": "csharp",
                "code": "    bool isPalindrome (string & s, int i, int j){\n        while(i<j){\n            if(s[i]!=s[j]) return false;\n            i++; j--;\n        }\n        return true;\n    }\n    \n\n    int solve (string & s, int i, int j, vector<int> & dp){    \n        \n        if(i>=j or isPalindrome(s, i, j)) return 0;\n        \n        if(dp[i]!=-1) return dp[i];\n        \n        int ans = INT_MAX;\n        \n        for(int k=i; k<j; k++){\n            \n            /* \n                Instead of writing below standard line\n                We will recurse for only right part\n                Only when left part turns out to be palindrome\n    \n    Reason : If left substring becomes palindrome then there is no need to partition it further \n    (which in turn reduces the number of recursive calls)\n                \n                int temp =  solve (s, i, k, dp, palindrome) + solve (s, k+1, j, dp, palindrome) + 1;\n                \n            */\n            \n            if(isPalindrome(s, i, k)){                         \n                int temp = solve (s, k+1, j, dp) + 1;\n                ans = min (ans, temp);\n            }\n        }\n        \n        return dp[i] = ans;\n    }\n    \n    int minCut(string s) {\n        int n = s.length();\n        \n        /* I've used 1D DP here becoz only one parameter is changing i.e. `i` */\n        \n        vector<int> dp (n+1, -1);   \n            \n        return solve (s, 0, n-1, dp);\n    }",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/1364206/mcm-pattern-in-aditya-verma-format-with-some-optimizations-all-tc-passed-memoization-1-d-dp/",
                "vote_count": "109"
            },
            {
                "language": "java",
                "code": "class Solution {\npublic:\n    bool isPalindrome(int left, int right, string &s)\n    {\n        while(left < right)\n        {\n            if(s[left] != s[right])return false;",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/1364206/mcm-pattern-in-aditya-verma-format-with-some-optimizations-all-tc-passed-memoization-1-d-dp/",
                "vote_count": "109"
            },
            {
                "language": "java",
                "code": "class Solution {\n    boolean isPalindrome(String s,int start,int end){\n  while(start<end){\n   if(s.charAt(start)!=s.charAt(end))return false;\n   start++;\n   end--;\n  }\n  return true;",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/1364206/mcm-pattern-in-aditya-verma-format-with-some-optimizations-all-tc-passed-memoization-1-d-dp/",
                "vote_count": "109"
            },
            {
                "language": "python",
                "code": "# pd stores palindromic results and dp stores min_cuts results\ndp,n,pd={},len(s),{}\n        # recursive way of calculating the below func is faster/preferable here as it calculates \n       #and stores the result for inner palindrome strings as well whereas, iterative only stores \n      #the result of palin[i,j]\n        def is_palin(i,j):\n            key=(i,j)",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/1364206/mcm-pattern-in-aditya-verma-format-with-some-optimizations-all-tc-passed-memoization-1-d-dp/",
                "vote_count": "109"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        \n        @lru_cache(None)\n        def isPalindrome(l, r):  # l, r inclusive\n            if l >= r: return True\n            if s[l] != s[r]: return False\n            return isPalindrome(l+1, r-1)\n        \n        @lru_cache(None)\n        def dp(i):  # s[i..n-1]\n            if i == n:\n                return 0\n            ans = math.inf\n            for j in range(i, n):\n                if (isPalindrome(i, j)):\n                    ans = min(ans, dp(j+1) + 1)\n            return ans\n        \n        return dp(0) - 1",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/1388628/python-simple-top-down-dp-clean-concise/",
                "vote_count": "79"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        \n        @cache\n        def isPalindrome(l: int, r: int) -> bool:\n            return l >= r or (s[l] == s[r] and isPalindrome(l + 1, r - 1))\n)",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/1388628/python-simple-top-down-dp-clean-concise/",
                "vote_count": "79"
            },
            {
                "language": "java",
                "code": "BASE, MOD = 26, 10**12 + 1\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        POW = [1]*(n+1)\n        hashs = [0]*(n+1)\n        hasht = [0]*(n+1)\n        ",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/1388628/python-simple-top-down-dp-clean-concise/",
                "vote_count": "79"
            },
            {
                "language": "ruby",
                "code": "        def is_palindrome(start, end):\n            return a[start:end] == a[start:end][::-1]",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/1388628/python-simple-top-down-dp-clean-concise/",
                "vote_count": "79"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int minCut(String s) {\n        return minCutFrom(s, 0, s.length() - 1);\n    }\n    \n    private int minCutFrom(String s, int start, int end) {\n        if (start == end || isPalindrome(s, start, end)) {\n            return 0;\n        }\n        int minCut = s.length() - 1;\n        for (int i = start; i <= end; i++) {\n            if (isPalindrome(s, start, i)) {\n                minCut = Math.min(minCut, 1 + minCutFrom(s, i + 1, end));\n            }\n        }\n        return minCut;\n    }\n    \n    private boolean isPalindrome(String s, int x, int y) {\n        while (x < y) {\n            if (s.charAt(x++) != s.charAt(y--))\n                return false;\n        }\n        return true;\n    }\n}",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/590653/from-brute-force-to-top-down-dp/",
                "vote_count": "70"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    private Integer dp[][];\n    private Boolean dpIsPalindrome[][];\n    public int minCut(String s) {\n        dp = new Integer[s.length()][s.length()];\n        dpIsPalindrome = new Boolean[s.length()][s.length()];\n        return minCutFrom(s, 0, s.length() - 1);\n    }\n    \n    private int minCutFrom(String s, int start, int end) {\n        if (start == end || isPalindrome(s, start, end)) {\n            return 0;\n        }\n        \n        if (dp[start][end] != null)\n            return dp[start][end];\n        \n        int minCut = s.length() - 1;\n        for (int i = start; i <= end; i++) {\n            if (isPalindrome(s, start, i)) {\n                minCut = Math.min(minCut, 1 + minCutFrom(s, i + 1, end));\n            }\n        }\n        return dp[start][end] = minCut;\n    }\n    \n    private boolean isPalindrome(String s, int start, int end) {\n        if (start >= end)\n            return true;\n        \n        if (dpIsPalindrome[start][end] != null)\n            return dpIsPalindrome[start][end];\n        \n        return dpIsPalindrome[start][end] = (s.charAt(start) == s.charAt(end))\n            && isPalindrome(s, start + 1, end - 1);\n    }\n}",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/590653/from-brute-force-to-top-down-dp/",
                "vote_count": "70"
            },
            {
                "language": "javascript",
                "code": "if (isPalindrome(s, start, i)) {\n                minCut = Math.min(minCut, 1 + minCutFrom(s, i + 1, end));\n            }",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/590653/from-brute-force-to-top-down-dp/",
                "vote_count": "70"
            },
            {
                "language": "csharp",
                "code": "int dp[2001], palin[2001][2001];\n\nbool check(string &s, int low, int high)\n{",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/590653/from-brute-force-to-top-down-dp/",
                "vote_count": "70"
            },
            {
                "language": "ruby",
                "code": "if (start >= end)\n        return true;",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/590653/from-brute-force-to-top-down-dp/",
                "vote_count": "70"
            },
            {
                "language": "ruby",
                "code": "if(start>end)\n       return false;",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/590653/from-brute-force-to-top-down-dp/",
                "vote_count": "70"
            },
            {
                "language": "java",
                "code": "//Function to check if the string is Palindrome\nboolean isPalindrome(String str, int start, int end){\n    while(start<end){\n        if(str.charAt(start)!=str.charAt(end)){\n            return false;\n        }\n        start++;\n        end--;\n    }\n    return true;\n}\n\n\nint solve(String str, int i, int j){\n    //Base Cases\n    if(i>=j){\n        return 0;\n    }\n    if(dp[i][j]!=null){\n        return dp[i][j];\n    }\n    \n    \n    /*If the current string is palindrome then we dont need to break it into \n further sub problems as we want to minimize the cuts.*/\n    if(isPalindrome(str, i, j)){\n        dp[i][j]=0;\n        return 0;\n    }\n    \n    \n    int min = Integer.MAX_VALUE;\n    //Trying Different possible cuts between i and j\n    for(int k = i; k<=j;k++){\n        \n        /*An Optimization: We will make the partition only if the string till the partition \n  (till Kth position) is a valid palindrome. Because the question states that all \n  partition must be a valid palindrome. If we dont check this, we will have to \n  perform recursion on the left subproblem too (solve(str, i, k)) and we will waste \n  a lot of time on subproblems that is not required. Without this the code will give\n  correct answer but TLE on big test cases. */\n        if(isPalindrome(str, i, k)){\n            int partitions = 1+solve(str, k+1, j);\n            min = Math.min(min, partitions);                \n        }\n        \n        \n    }\n    \n    //Store answer in the memo table\n    dp[i][j]=min;\n    return dp[i][j];\n}\n\n\n\npublic int minCut(String s) {\n    dp = new Integer[s.length()][s.length()];\n    return solve(s, 0, s.length()-1);\n}",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/1267844/java-recursion-memoization-optimized-matrix-chain-multiplication-approach-with-code-mcm/",
                "vote_count": "64"
            },
            {
                "language": "csharp",
                "code": "    bool isPallindrome(string str,int i, int j)\n    {\n       while(i < j)\n    {\n      if(str[i] != str[j])\n        return false; \n      i++;\n      j--;",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/1267844/java-recursion-memoization-optimized-matrix-chain-multiplication-approach-with-code-mcm/",
                "vote_count": "64"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def minCut(self, s):\n        d, n = defaultdict(set), len(s)\n        \n        def helper(i, j):\n            while i >= 0 and j < n and s[i] == s[j]:\n                d[i].add(j)\n                i, j = i - 1, j + 1\n        \n        for k in range(n):\n            helper(k, k)\n            helper(k, k + 1)\n\n        @lru_cache(None)\n        def dp(i):\n            if i == -1: return -1\n            return min([dp(k-1) + 1 for k in range(0, i+1) if i in d[k]])\n        \n        return dp(n-1)",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/1388471/python-dp-solution-explained/",
                "vote_count": "34"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> adj[2005];\n    int dp[2005];\n    int help(int i,int n){\n        if(i==n){\n            return 0;\n        }\n        if(dp[i]!=-1){\n            return dp[i];\n        }\n        int ans=1e9;\n        for(auto x:adj[i]){\n            int tmp=1+help(x+1,n);\n            ans=min(ans,tmp);\n        }\n        return dp[i]=ans;\n    }\n    int minCut(string s) {\n        int n=s.size();\n        int check[n][n];      //to store palindromic status of each substring\n        for(int g=0;g<n;g++){\n            for(int i=0,j=g;j<n;i++,j++){\n                if(g==0){\n                    check[i][j]=1;\n                }\n                else if(g==1){\n                    check[i][j]=(s[i]==s[j]);\n                }\n                else{\n                    check[i][j]=(check[i+1][j-1]==1 ? (s[i]==s[j] ? 1 : 0) : 0);\n                }\n            }\n        }\n        \n        //storing all indexes j in adj[i] such that s[i]...s[j] is palindrome\n        for(int i=0;i<n;i++){\n            for(int j=i;j<n;j++){\n                if(check[i][j]){\n                    adj[i].push_back(j);\n                }\n            }\n        }\n\n        memset(dp,-1,sizeof(dp));\n        return help(0,n)-1;       \n    }  \n};",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/2224092/simple-dp-solution-c/",
                "vote_count": "11"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int minCut(string s) {\n        int n = s.size();\n        vector<int> cut(n+1, 0);  // number of cuts for the first k characters\n        for (int i = 0; i <= n; i++) cut[i] = i-1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; i-j >= 0 && i+j < n && s[i-j]==s[i+j] ; j++) // odd length palindrome\n                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j]);\n\n            for (int j = 1; i-j+1 >= 0 && i+j < n && s[i-j+1] == s[i+j]; j++) // even length palindrome\n                cut[i+j+1] = min(cut[i+j+1],1+cut[i-j+1]);\n        }\n        return cut[n];\n    }\n};",
                "url": "https://leetcode.com/problems/palindrome-partitioning-ii/solutions/2779792/c-solutions-easy-to-solve/",
                "vote_count": "10"
            }
        ]
    },
    "132": {
        "question_id": 133,
        "title": "Clone Graph",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/clone-graph",
        "description": "Given a reference of a node in a connected undirected graph.Return a deep copy (clone) of the graph.Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.class Node {    public int val;    public List<Node> neighbors;} Test case format:For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph. ",
        "examples": [
            {
                "input": "adjList = [[2,4],[1,3],[2,4],[1,3]]",
                "output": "[[2,4],[1,3],[2,4],[1,3]]",
                "explanation": "There are 4 nodes in the graph.\n1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3)."
            },
            {
                "input": "adjList = [[]]",
                "output": "[[]]",
                "explanation": "Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors."
            },
            {
                "input": "adjList = []",
                "output": "[]",
                "explanation": "This an empty graph, it does not have any nodes."
            }
        ],
        "constraints": [
            "The number of nodes in the graph is in the range [0, 100].",
            "1 <= Node.val <= 100",
            "Node.val is unique for each node.",
            "There are no repeated edges and no self-loops in the graph.",
            "The Graph is connected and all nodes can be visited starting from the given node."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    Node* cloneGraph(Node* node) {\n        if (!node) {\n            return NULL;\n        }\n        Node* copy = new Node(node -> val, {});\n        copies[node] = copy;\n        queue<Node*> todo;\n        todo.push(node);\n        while (!todo.empty()) {\n            Node* cur = todo.front();\n            todo.pop();\n            for (Node* neighbor : cur -> neighbors) {\n                if (copies.find(neighbor) == copies.end()) {\n                    copies[neighbor] = new Node(neighbor -> val, {});\n                    todo.push(neighbor);\n                }\n                copies[cur] -> neighbors.push_back(copies[neighbor]);\n            }\n        }\n        return copy;\n    }\nprivate:\n    unordered_map<Node*, Node*> copies;\n};",
                "url": "https://leetcode.com/problems/clone-graph/solutions/42313/c-bfs-dfs/",
                "vote_count": "461"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    Node* cloneGraph(Node* node) {\n        if (!node) {\n            return NULL;\n        }\n        if (copies.find(node) == copies.end()) {\n            copies[node] = new Node(node -> val, {});\n            for (Node* neighbor : node -> neighbors) {\n                copies[node] -> neighbors.push_back(cloneGraph(neighbor));\n            }\n        }\n        return copies[node];\n    }\nprivate:\n    unordered_map<Node*, Node*> copies;\n};",
                "url": "https://leetcode.com/problems/clone-graph/solutions/42313/c-bfs-dfs/",
                "vote_count": "461"
            },
            {
                "language": "kotlin",
                "code": "public class Solution {\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n        if (node == null) return null;\n        UndirectedGraphNode graph = new UndirectedGraphNode(node.label);\n        HashMap<UndirectedGraphNode, UndirectedGraphNode> mp = new HashMap<>();\n        mp.put(node, graph);\n        Queue<UndirectedGraphNode> queue = new LinkedList<>();\n        queue.offer(node);",
                "url": "https://leetcode.com/problems/clone-graph/solutions/42313/c-bfs-dfs/",
                "vote_count": "461"
            },
            {
                "language": "kotlin",
                "code": "",
                "url": "https://leetcode.com/problems/clone-graph/solutions/42313/c-bfs-dfs/",
                "vote_count": "461"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\n  if(!node) return NULL;\n  UndirectedGraphNode *p = NULL;\n  if(mp.find(node) == mp.end()){",
                "url": "https://leetcode.com/problems/clone-graph/solutions/42313/c-bfs-dfs/",
                "vote_count": "461"
            },
            {
                "language": "php",
                "code": "public class Solution {\n    private HashMap<Integer, UndirectedGraphNode> map = new HashMap<>();\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n        return clone(node);\n    }\n\n    private UndirectedGraphNode clone(UndirectedGraphNode node) {\n        if (node == null) return null;\n        \n        if (map.containsKey(node.label)) {\n            return map.get(node.label);\n        }\n        UndirectedGraphNode clone = new UndirectedGraphNode(node.label);\n        map.put(clone.label, clone);\n        for (UndirectedGraphNode neighbor : node.neighbors) {\n            clone.neighbors.add(clone(neighbor));\n        }\n        return clone;\n    }\n}",
                "url": "https://leetcode.com/problems/clone-graph/solutions/42309/depth-first-simple-java-solution/",
                "vote_count": "370"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public HashMap<Integer, Node> map = new HashMap<>();\n    \n    public Node cloneGraph(Node node) {\n        return clone(node);\n    }\n    ",
                "url": "https://leetcode.com/problems/clone-graph/solutions/42309/depth-first-simple-java-solution/",
                "vote_count": "370"
            },
            {
                "language": "csharp",
                "code": "public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n    HashMap<Integer,UndirectedGraphNode> map = new HashMap<Integer,UndirectedGraphNode>();\n    return dfs(node,map);\n}\nprivate UndirectedGraphNode dfs(UndirectedGraphNode node, HashMap<Integer,UndirectedGraphNode> map) {\n    if (node == null) return null;\n    if (map.containsKey(node.label)) {\n        return map.get(node.label);",
                "url": "https://leetcode.com/problems/clone-graph/solutions/42309/depth-first-simple-java-solution/",
                "vote_count": "370"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n        return clone(node, new HashMap<>());\n    }\n    \n    UndirectedGraphNode clone(UndirectedGraphNode src, HashMap<UndirectedGraphNode, UndirectedGraphNode> visitedBag){\n        if (src == null){",
                "url": "https://leetcode.com/problems/clone-graph/solutions/42309/depth-first-simple-java-solution/",
                "vote_count": "370"
            },
            {
                "language": "csharp",
                "code": "public HashMap<Integer, UndirectedGraphNode> map = new HashMap();\npublic UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n    if (node == null) return null;\n    if (map.containsKey(node.label)) \n        return map.get(node.label);\n    UndirectedGraphNode cloned = new UndirectedGraphNode(node.label);\n    map.put(cloned.label, cloned);\n    for(UndirectedGraphNode neighbor: node.neighbors){",
                "url": "https://leetcode.com/problems/clone-graph/solutions/42309/depth-first-simple-java-solution/",
                "vote_count": "370"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n        if (node == null) return null;\n        Map<UndirectedGraphNode,UndirectedGraphNode> map=new HashMap<>();\n        dfs(map, node);\n        return map.get(node);\n    }\n    private void dfs(Map<UndirectedGraphNode,UndirectedGraphNode> map, UndirectedGraphNode curr){",
                "url": "https://leetcode.com/problems/clone-graph/solutions/42309/depth-first-simple-java-solution/",
                "vote_count": "370"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    Map<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<>();\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n        if (node == null){\n            return null;\n        }\n        UndirectedGraphNode curr = new UndirectedGraphNode(node.label);\n        map.put(node, curr);",
                "url": "https://leetcode.com/problems/clone-graph/solutions/42309/depth-first-simple-java-solution/",
                "vote_count": "370"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n        return cloneGraph(node, new HashMap<UndirectedGraphNode, UndirectedGraphNode>());\n    }\n    \n    private UndirectedGraphNode cloneGraph(UndirectedGraphNode node, Map<UndirectedGraphNode, UndirectedGraphNode> cloneMap) {\n        if (node == null) return null;\n        UndirectedGraphNode cloned = new UndirectedGraphNode(node.label);",
                "url": "https://leetcode.com/problems/clone-graph/solutions/42309/depth-first-simple-java-solution/",
                "vote_count": "370"
            },
            {
                "language": "javascript",
                "code": "                           'I\u2019ve got nothing to say but it\u2019s okay, good morning, good morning\ud83d\ude01\ud83d\ude01'\n         ",
                "url": "https://leetcode.com/problems/clone-graph/solutions/1792834/c-easy-explanation-dfs/",
                "vote_count": "362"
            },
            {
                "language": "rust",
                "code": "1. Cloned Graph has all nodes as newnodes and don't have node as reference to given original graph.\n2. Graph has no practical edges, i.e no pointers for edges.\n         (2,3)            (1,3)<---adj list\n    (1)-------------(2)\n      |              |\n   |              |\n   |              |\n    (4)-------------(3)\n    (1,3)          (2,4)\nIf i say '1' is my starting point and how should i jump to '2' for that i have to iterate through this adjacency list.",
                "url": "https://leetcode.com/problems/clone-graph/solutions/1792834/c-easy-explanation-dfs/",
                "vote_count": "362"
            },
            {
                "language": "python",
                "code": "We need to traverse all node of original graph and as soon as we reach a node, we will make a copy node.\nAnd recur for rest of the graph.\nThis is a typical recursion type problem implemented on Graph.\nFor 'Recursion' we use basically 'DFS' or 'BFS'.\nI am using DFS",
                "url": "https://leetcode.com/problems/clone-graph/solutions/1792834/c-easy-explanation-dfs/",
                "vote_count": "362"
            },
            {
                "language": "swift",
                "code": "1. We use HashMap to solve it and using DFS.\n2. Initially our hash map will be empty and we try to map the old node with the new node or the copy node.\n3. We start with any entry point.\n4. I am using '1' as my entry point.\n\nNow lets see how its going i am starting with 1 and whenever i visited a new node i coloned it and put in there.\nWe are using DFS so algorithm is like 'it starts at the root node (select some arbitrary node as root node in the case of a graph) and explores as far as possible along each branch before backtracking.\nSo the basic idea is to start from the root or any arbitrary node and mark the node and move to the adjacentunmarked node and continue this loop until there is no unmarked adjacent node. \nThen backtrack and check for other unmarked nodes and traverse them. Finally, print the nodes in the path.'\nSo we are using HashMap to put all the visited node or old node there with clone one to.\n _________\n| HashMap |\n ----------\n|Old|Clone| \n| 1  | 1 |\n|  2 | 2 |\n|  3 | 3 |                                                     \n|  4 | 4 |                                                                                                            \n---------\n\nNow i started with 1 so i cloned it and from 1 can go to 2 and 4 so i go 2 and when i visited 2 i cloned 2 and now fro  i have two choices either go to previous one that is 1 or discover 3 i.e new node\nso accordingly to dfs i go to 3 and from 3 i can go to 4 i go there and cloned it. Now if we see fro each node we have viisted to a new node but what about 4. So here half part of Dfs is completed,\nand now its time for recursive call to go back and now from here we check from current node i can go where and where.\nAnd follow the same rules over there.\n\nBUT BEFORE STARTING ANY CLONING WE HAVE TO CHECK THAT IF WE HAVE CLONED THAT NODE ALREADY THERE OR NOT. IF NOT THAN ONLY WE CLONED IT. \n\nThats the only reason we are using hash map so that we don't need to clone again and again.\nFor every uncloned node we make a clone and iterate over the neighbors of original node using dfs traversal or bfs traversal.",
                "url": "https://leetcode.com/problems/clone-graph/solutions/1792834/c-easy-explanation-dfs/",
                "vote_count": "362"
            },
            {
                "language": "php",
                "code": "                                          'IF YOU LIKE IT THEN PLS UpVote\ud83d\ude0e\ud83d\ude0e\ud83d\ude0e'\nclass Solution {\n    public:\n    Node* dfs(Node* cur,unordered_map<Node*,Node*>& mp)\n    {\n        vector<Node*> neighbour;\n        Node* clone=new Node(cur->val);\n        mp[cur]=clone;\n            for(auto it:cur->neighbors)\n            {\n                if(mp.find(it)!=mp.end())   //already clone and stored in map\n                {\n                    neighbour.push_back(mp[it]);    //directly push back the clone node from map to neigh\n                }\n                else\n                    neighbour.push_back(dfs(it,mp));\n            }\n            clone->neighbors=neighbour;\n            return clone;\n    }\n    Node* cloneGraph(Node* node) {\n        unordered_map<Node*,Node*> mp;\n        if(node==NULL)\n            return NULL;\n        if(node->neighbors.size()==0)   //if only one node present no neighbors\n        {\n            Node* clone= new Node(node->val);\n            return clone; \n        }\n        return dfs(node,mp);\n    }\n};",
                "url": "https://leetcode.com/problems/clone-graph/solutions/1792834/c-easy-explanation-dfs/",
                "vote_count": "362"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    unordered_map<Node*,Node*> mp;\n    void  dfs(Node* node){\n        Node* copy=new Node(node->val);\n        mp[node]=copy;\n        for(auto ng: node->neighbors){",
                "url": "https://leetcode.com/problems/clone-graph/solutions/1792834/c-easy-explanation-dfs/",
                "vote_count": "362"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ",
                "url": "https://leetcode.com/problems/clone-graph/solutions/1792834/c-easy-explanation-dfs/",
                "vote_count": "362"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    \n    public Node dfs(Node node,HashMap<Node,Node> map)\n    {\n        Node clone = new Node(node.val);\n        List<Node> neighbors = new ArrayList<>();\n        map.put(node,clone);\n        ",
                "url": "https://leetcode.com/problems/clone-graph/solutions/1792834/c-easy-explanation-dfs/",
                "vote_count": "362"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    unordered_map<Node*,Node*>mp;\n    Node* cloneGraph(Node* node) {\n        if (!node) return NULL;\n        Node* head=new Node(node->val);\n        mp[node]=head;",
                "url": "https://leetcode.com/problems/clone-graph/solutions/1792834/c-easy-explanation-dfs/",
                "vote_count": "362"
            },
            {
                "language": "scala",
                "code": "Let's take an example not given in question -\nSuppose graph given to us is like : [[2,5],[1,3],[2,4],[3,5],[1,4]]\nIt should look like -\n                          1--------2\n       /         |\n         /          |\n        /           |\n       5            |\n        \\           |\n      \\          |\n       \\         |\n        4--------3\n        \nNow, We have to return the clone\nSo output should looks like: [[2,5],[1,3],[2,4],[3,5],[1,4]]",
                "url": "https://leetcode.com/problems/clone-graph/solutions/1793212/c-detailed-explanation-w-dfs-bfs-commented-code-with-extra-test-case/",
                "vote_count": "227"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    unordered_map<Node* , Node*> mp; // declaring map, to check whwther we have a copy of node or not and also to store copy\n    \n    Node* cloneGraph(Node* node) {\n        if(node == NULL) // if node is null, then simply return null\n        {\n            return NULL;\n        }\n        \n        // for a node, we will check whether we already creates a copy of thiis or not. If it is present in map that means we already creates a copy of this.\n        //But if not present in map, that means we have not a copy of this.\n        // Also, if we create a copy, then being a good neighbor, we find whether our neighbor have a copy or not, so we will travel all around our adjcant.\n        \n        if(mp.find(node) == mp.end()) // if not present in map\n        {\n            mp[node] = new Node(node -> val, {}); // make a copy\n            \n            for(auto adj: node -> neighbors) // travel in adjcant\n            {\n                mp[node] -> neighbors.push_back(cloneGraph(adj)); //add copy\n            }\n        }\n        \n        return mp[node]; // and at last, return mp[node] as till now we clone our whole graph\n        \n    }\n};",
                "url": "https://leetcode.com/problems/clone-graph/solutions/1793212/c-detailed-explanation-w-dfs-bfs-commented-code-with-extra-test-case/",
                "vote_count": "227"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    unordered_map<Node* , Node*> mp; // declaring map, to check whwther we have a copy of node or not and also to store copy\n    \n    Node* cloneGraph(Node* node) {\n        if(node == NULL) // if node is null, then simply return null\n        {\n            return NULL;\n        }\n        \n        Node* first = new Node(node -> val, {}); // make a copy of first node\n        mp[node] = first;\n        \n        queue<Node*> q; //For bfs, we create queue\n        q.push(node); // push into queue\n        \n        while(q.empty() == false) // until q. empty == false\n        {\n            Node* curr = q.front(); // extract front node\n            q.pop(); // pop that from queue\n            \n            for(auto adj: curr -> neighbors) // now travel in adjcant\n            {\n                if(mp.find(adj) == mp.end()) // if not present in map\n                {\n                    mp[adj] = new Node(adj -> val, {}); // then create copy\n                    q.push(adj); // push nto the queue\n                    \n                }\n                \n                mp[curr] -> neighbors.push_back(mp[adj]); // in current node push adjcant node\n            }\n        }\n        \n        return mp[node];\n    }\n};",
                "url": "https://leetcode.com/problems/clone-graph/solutions/1793212/c-detailed-explanation-w-dfs-bfs-commented-code-with-extra-test-case/",
                "vote_count": "227"
            },
            {
                "language": "scala",
                "code": "mp[node] = new Node(node -> val, {}); // make a copy\n\nNode(int _val)\n    {\n        val = _val;\n        neighbors = vector<Node *>();\n    }",
                "url": "https://leetcode.com/problems/clone-graph/solutions/1793212/c-detailed-explanation-w-dfs-bfs-commented-code-with-extra-test-case/",
                "vote_count": "227"
            },
            {
                "language": "java",
                "code": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    public void dfs(Node node , Node copy , Node[] visited){\n        visited[copy.val] = copy;// store the current node at it's val index which will tell us that this node is now visited\n        \n//         now traverse for the adjacent nodes of root node\n        for(Node n : node.neighbors){\n//             check whether that node is visited or not\n//              if it is not visited, there must be null\n            if(visited[n.val] == null){\n//                 so now if it not visited, create a new node\n                Node newNode = new Node(n.val);\n//                 add this node as the neighbor of the prev copied node\n                copy.neighbors.add(newNode);\n//                 make dfs call for this unvisited node to discover whether it's adjacent nodes are explored or not\n                dfs(n , newNode , visited);\n            }else{\n//                 if that node is already visited, retrieve that node from visited array and add it as the adjacent node of prev copied node\n//                 THIS IS THE POINT WHY WE USED NODE[] INSTEAD OF BOOLEAN[] ARRAY\n                copy.neighbors.add(visited[n.val]);\n            }\n        }\n        \n    }\n    public Node cloneGraph(Node node) {\n        if(node == null) return null; // if the actual node is empty there is nothing to copy, so return null\n        Node copy = new Node(node.val); // create a new node , with same value as the root node(given node)\n        Node[] visited = new Node[101]; // in this question we will create an array of Node(not boolean) why ? , because i have to add all the adjacent nodes of particular vertex, whether it's visited or not, so in the Node[] initially null is stored, if that node is visited, we will store the respective node at the index, and can retrieve that easily.\n        Arrays.fill(visited , null); // initially store null at all places\n        dfs(node , copy , visited); // make a dfs call for traversing all the vertices of the root node\n        return copy; // in the end return the copy node\n    }\n}",
                "url": "https://leetcode.com/problems/clone-graph/solutions/1793436/java-simple-code-with-heavy-comments/",
                "vote_count": "98"
            },
            {
                "language": "typescript",
                "code": " public static Node cloneGraph(Node node) {\n        if (node == null) return null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n        fillUniqueNodeMap(node, nodeMap);\n        addNeighbours(node, nodeMap, new HashSet<>());\n) {",
                "url": "https://leetcode.com/problems/clone-graph/solutions/1793436/java-simple-code-with-heavy-comments/",
                "vote_count": "98"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    Node[] visited;\n    public Node cloneGraph(Node node) {\n        if(node == null) return null;\n        visited = new Node[101];\n        return DFS(node);\n    }\n    public Node DFS(Node node){",
                "url": "https://leetcode.com/problems/clone-graph/solutions/1793436/java-simple-code-with-heavy-comments/",
                "vote_count": "98"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public Node cloneGraph(Node node) {\n        if(node == null) return node;\n        Node[] visited = new Node[101];\n        Arrays.fill(visited, null);\n        Node copy = new Node(node.val);\n        dfs(copy, node, visited);",
                "url": "https://leetcode.com/problems/clone-graph/solutions/1793436/java-simple-code-with-heavy-comments/",
                "vote_count": "98"
            }
        ]
    },
    "133": {
        "question_id": 134,
        "title": "Gas Station",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/gas-station",
        "description": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique ",
        "examples": [
            {
                "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
                "output": "3\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.",
                "explanation": null
            },
            {
                "input": "gas = [2,3,4], cost = [3,4,3]",
                "output": "-1\nExplanation:\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start.",
                "explanation": null
            }
        ],
        "constraints": [
            "n == gas.length == cost.length",
            "1 <= n <= 10^5",
            "0 <= gas[i], cost[i] <= 10^4"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int n=gas.size();\n        int total_gas=0,total_cost=0;\n        int curr_gas=0, starting_point=0;\n        for(int i=0;i<n;i++)\n        {\n            //these two variable are to check if no case is possible\n            total_gas+=gas[i];\n            total_cost+=cost[i];\n            //for checking the total present gas at index i\n            curr_gas+=gas[i]-cost[i];\n            if(curr_gas<0)\n            {\n               //there is a breakdown....so we will start from next point or index\n                starting_point=i+1;\n                //reset our fuel \n                curr_gas=0;\n            }\n        }\n        return (total_gas<total_cost)?-1:starting_point;     \n    }\n};",
                "url": "https://leetcode.com/problems/gas-station/solutions/3011141/c-easy-solution-with-explaination-in-o-n-time-complexity-beats-97/",
                "vote_count": "308"
            },
            {
                "language": "erlang",
                "code": "station|gas    |cost   |netgain|curgas\n-------|-------|-------|-------|-------\n0      |1      |3      |(2)    |(2)  \u2198\n1      |2      |4      |(2)    |(4) (2)  \u2198          -> Lowest gas",
                "url": "https://leetcode.com/problems/gas-station/solutions/3011141/c-easy-solution-with-explaination-in-o-n-time-complexity-beats-97/",
                "vote_count": "308"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        n = len(gas)\n        for i in range(n):\n            remaining = 0\n            for j in range(n):\n                k = (i + j) % n\n                remaining += gas[k] - cost[k]\n                if remaining < 0:\n                    break\n            else:\n                return i\n        return -1",
                "url": "https://leetcode.com/problems/gas-station/solutions/3011074/chatgpt-2-solutions-explained/",
                "vote_count": "55"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n     n = len(gas)\n     total_gas = 0\n     start = 0\n     remaining = 0\n     for i in range(n):\n         total_gas += gas[i] - cost[i]\n         remaining += gas[i] - cost[i]\n         if remaining < 0:\n             start = i + 1\n             remaining = 0\n     return start if total_gas >= 0 else -1",
                "url": "https://leetcode.com/problems/gas-station/solutions/3011074/chatgpt-2-solutions-explained/",
                "vote_count": "55"
            }
        ]
    },
    "134": {
        "question_id": 135,
        "title": "Candy",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/candy",
        "description": "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.You are giving candies to these children subjected to the following requirements:Each child must have at least one candy.Children with a higher rating get more candies than their neighbors.Return the minimum number of candies you need to have to distribute the candies to the children. ",
        "examples": [
            {
                "input": "ratings = [1,0,2]",
                "output": "5",
                "explanation": "You can allocate to the first, second and third child with 2, 1, 2 candies respectively."
            },
            {
                "input": "ratings = [1,2,2]",
                "output": "4",
                "explanation": "You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions."
            }
        ],
        "constraints": [
            "n == ratings.length",
            "1 <= n <= 2 * 10^4",
            "0 <= ratings[i] <= 2 * 10^4"
        ],
        "solutions": [
            {
                "language": "dart",
                "code": "  int candy(vector<int> &ratings)\n {\n  int size=ratings.size();\n  if(size<=1)\n   return size;\n  vector<int> num(size,1);\n  for (int i = 1; i < size; i++)\n  {\n   if(ratings[i]>ratings[i-1])\n    num[i]=num[i-1]+1;\n  }\n  for (int i= size-1; i>0 ; i--)\n  {\n   if(ratings[i-1]>ratings[i])\n    num[i-1]=max(num[i]+1,num[i-1]);\n  }\n  int result=0;\n  for (int i = 0; i < size; i++)\n  {\n   result+=num[i];\n  // cout<<num[i]<<\" \";\n  }\n  return result;\n }",
                "url": "https://leetcode.com/problems/candy/solutions/42769/a-simple-solution/",
                "vote_count": "592"
            },
            {
                "language": "python",
                "code": "    public int candy(int[] ratings) {\n      int n = ratings.length;\n      int[] res = new int[n];\n      Arrays.fill(res, 1);\n      for(int i = 1; i < n; i++){\n        if(ratings[i] > ratings[i - 1]){\n          res[i] = res[i - 1] + 1;            \n        }  ",
                "url": "https://leetcode.com/problems/candy/solutions/42769/a-simple-solution/",
                "vote_count": "592"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(ratings)\n        if n <= 1:",
                "url": "https://leetcode.com/problems/candy/solutions/42769/a-simple-solution/",
                "vote_count": "592"
            },
            {
                "language": "cpp",
                "code": "vector<int> num(size,1);",
                "url": "https://leetcode.com/problems/candy/solutions/42769/a-simple-solution/",
                "vote_count": "592"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int candy(int[] ratings) {\n        if(ratings.length == 0)\n            return 0;\n        int[] ans = new int[ratings.length];\n        ans[0] = 1;\n        for(int i = 1; i<ratings.length; i++){\n            if(ratings[i]>ratings[i-1])",
                "url": "https://leetcode.com/problems/candy/solutions/42769/a-simple-solution/",
                "vote_count": "592"
            },
            {
                "language": "cpp",
                "code": "int candy(vector<int>& rat) {\n        vector<int> fwd(rat.size(), 1);\n        for(int i = 1; i<rat.size(); i++) \n            if( rat[i] > rat[i-1] )    fwd[i] = fwd[i-1] + 1;\n        for(int i = rat.size()-1; i>0; i--)  \n            if( rat[i-1] > rat[i])     fwd[i-1] = max(fwd[i] + 1, fwd[i-1]);\n        return accumulate(fwd.begin(), fwd.end(), 0);\n    }",
                "url": "https://leetcode.com/problems/candy/solutions/42769/a-simple-solution/",
                "vote_count": "592"
            },
            {
                "language": "swift",
                "code": "Let take the Rating as : [1,3,6,8,9,5,3,6,8,5,4,2,2,3,7,7,9,8,6,6,6,4,2]\n\nEach child represented as rating(candy he is given)\nPeak = max(peak, valley)\n\nSee when peak is encountered we take max of the peak calculated from left and valley calculated from right.\nWhen we get any equal element it gets reset to 1 candy or if it is peak we take max(0, right valley)\n\n           (5)         (4)                         (3)\n            9           8                           9\n           /|\\         /|\\                         /|\\\n          / | \\       / | \\                (3)    / | \\\n      (4)8  |  5(2)  6  |  5(3)             7 __ 7  |  8(2)\n        /   |   \\   (2) |   \\              /|   (1) |   \\\n       /    |    \\ /    |    \\            / |    |  |    \\         (3)\n   (3)6     |     3     |     4(2)       3(2)    |  |     6 __ 6 __ 6    -> Total candy = 50\n     /      |    (1)    |      \\        /   | Reset |    (1)  (1)   |\\\n    /       |           |       \\      /    |  to 1 |          |    | \\\n(2)3        |           |        2 __ 2     |       |          |    |  4(2)\n  /         |           |       (1)  (1)    |       |        Reset  |   \\\n /          |           |                   |       |         to 1  |    \\\n1(1)        |           |                   |       |               |     2(1)\n   Peak= max(5,3)  Peak= max(3,4)    Peak= max(3,0) |         Peak= max(0,3)\n                                               Peak= max(2,3)   ",
                "url": "https://leetcode.com/problems/candy/solutions/2234434/c-o-n-time-o-1-space-full-explanation/",
                "vote_count": "307"
            },
            {
                "language": "java",
                "code": "In our code we increase the peak and add peak value untill we get the minimum actual peak.\nIn case of the decreasing part take this example.\n\n[7,5,3,2], initial candy = 4, In each iteration valley++ and candy += valley\n\n7 starting (valley = 0, candy = 4, candy configuaration  = [1,1,1,1])\n \\\n  5 (valley = 1, candy = 4+1 = 5, candy configuaration  = [2,1,1,1])\n   \\\n    3 (valley = 2, candy = 5+2 = 7, candy configuaration = [3,2,1,1])\n     \\\n      2 [valley = 3, candy = 7+3 = 10, candy configuartion = [4,3,2,1])\n   \nHere see the valley is at last equal to the minimum previous peak value.\n\nAs we have given 1 candy to all before so the peak and valley values are actually 1 less than the actual candy they should get.",
                "url": "https://leetcode.com/problems/candy/solutions/2234434/c-o-n-time-o-1-space-full-explanation/",
                "vote_count": "307"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        int n = ratings.size();\n        int candy = n, i=1;\n        while(i<n){\n            if(ratings[i] == ratings[i-1]){\n                i++;\n                continue;\n            }\n            \n            //For increasing slope\n            int peak = 0;\n            while(ratings[i] > ratings [i-1]){\n                peak++;\n                candy += peak;\n                i++;\n                if(i == n) return candy;\n            }\n            \n            //For decreasing slope\n            int valley = 0;\n            while(i<n && ratings[i] < ratings[i-1]){\n                valley++;\n                candy += valley;\n                i++;\n            }\n            candy -= min(peak, valley); //Keep only the higher peak\n        }\n        return candy;\n    }\n};",
                "url": "https://leetcode.com/problems/candy/solutions/2234434/c-o-n-time-o-1-space-full-explanation/",
                "vote_count": "307"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int candy(int[] ratings) {\n        int n = ratings.length;\n        if(n == 1) return 1;\n        Queue<int[]> queue = new PriorityQueue<>((a,b)->(a[0]==b[0])?a[1]-b[1]:a[0]-b[0]);\n        for(int i=0;i<n;i++) queue.offer(new int[]{ratings[i],i});\n        int[] candies = new int[n];\n        while(!queue.isEmpty()){",
                "url": "https://leetcode.com/problems/candy/solutions/2234434/c-o-n-time-o-1-space-full-explanation/",
                "vote_count": "307"
            },
            {
                "language": "cpp",
                "code": "    // Initialize 1 candy for each child\n    int[] candies = new int[ratings.length];\n    for (int i = 0; i < candies.length; i++) {\n        candies[i] = 1;\n    }\n    ",
                "url": "https://leetcode.com/problems/candy/solutions/2234434/c-o-n-time-o-1-space-full-explanation/",
                "vote_count": "307"
            },
            {
                "language": "csharp",
                "code": "[0, 1, 20, 9, 8, 7]",
                "url": "https://leetcode.com/problems/candy/solutions/135698/simple-solution-with-one-pass-using-o-1-space/",
                "vote_count": "283"
            },
            {
                "language": "cpp",
                "code": "        public int Candy(int[] ratings) {\n            if (ratings.Length == 0) return 0;\n            int ret = 1;\n            int up = 0, down = 0, peak = 0;\n            for (int i = 1; i < ratings.Length; i++) {\n                if (ratings[i - 1] < ratings[i]) {\n                    peak = ++up;\n                    down = 0;\n                    ret += 1 + up;\n                } else if (ratings[i - 1] == ratings[i])  {\n                    peak = up = down = 0;\n                    ret += 1;\n                } else {\n                    up = 0;\n                    down++;\n                    ret += 1 + down + (peak >= down ? -1 : 0);\n                }\n            }\n\n            return ret;\n        }",
                "url": "https://leetcode.com/problems/candy/solutions/135698/simple-solution-with-one-pass-using-o-1-space/",
                "vote_count": "283"
            },
            {
                "language": "lisp",
                "code": "ret += 1 + down + (peak >= down ? -1 : 0);",
                "url": "https://leetcode.com/problems/candy/solutions/135698/simple-solution-with-one-pass-using-o-1-space/",
                "vote_count": "283"
            },
            {
                "language": "lisp",
                "code": "ret += down + (peak >= down ? 0 : 1);",
                "url": "https://leetcode.com/problems/candy/solutions/135698/simple-solution-with-one-pass-using-o-1-space/",
                "vote_count": "283"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"",
                "url": "https://leetcode.com/problems/candy/solutions/135698/simple-solution-with-one-pass-using-o-1-space/",
                "vote_count": "283"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        // see the graph and whenever a lower point hit or flat line is hit, give them the lower value\n        int ans=1;\n        int up=0,down=0,peak=0;\n        for(int i=1;i<ratings.size();i++){",
                "url": "https://leetcode.com/problems/candy/solutions/135698/simple-solution-with-one-pass-using-o-1-space/",
                "vote_count": "283"
            },
            {
                "language": "python",
                "code": "def candy(self, ratings):\n        if len(ratings) == 0:\n            return 0 \n        result = 1\n        up = down = peak = 0\n        for i in range(1, len(ratings)):",
                "url": "https://leetcode.com/problems/candy/solutions/135698/simple-solution-with-one-pass-using-o-1-space/",
                "vote_count": "283"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def candy(self, R):\n        n, ans = len(R), [1]*len(R)\n        \n        for i in range(n-1):\n            if R[i] < R[i+1]:\n                ans[i+1] = max(1 + ans[i], ans[i+1])\n                \n        for i in range(n-2, -1, -1):\n            if R[i+1] < R[i]:\n                ans[i] = max(1 + ans[i+1], ans[i])\n        \n        return sum(ans)",
                "url": "https://leetcode.com/problems/candy/solutions/1300194/python-o-n-time-solution-explained/",
                "vote_count": "95"
            },
            {
                "language": "python",
                "code": "    def candy(rat):\n        n = len(rat)\n        left2right = [1] * n\n        right2left = [1] * n\n        for i in range(1, n):\n            if rat[i] > rat[i-1]:\n                left2right[i] = left2right[i-1]+1\n        for i in reversed(range(n-1)):",
                "url": "https://leetcode.com/problems/candy/solutions/1300194/python-o-n-time-solution-explained/",
                "vote_count": "95"
            },
            {
                "language": "cpp",
                "code": "int candy(vector<int>& r) {\n        int n = r.size();\n        vector<int> c(n, 1);\n        for (int i = 1; i < n; i++)\n            if (r[i] > r[i - 1]) c[i] = c[i - 1] + 1;\n        for (int i = n - 2; ~i; i--)\n            if (r[i] > r[i + 1]) c[i] = max(c[i], c[i + 1] + 1);\n        int res = 0;\n        for (auto t: c) res += t;\n        return res;\n    }",
                "url": "https://leetcode.com/problems/candy/solutions/1300022/candy-distribution-c-99-faster-explained/",
                "vote_count": "75"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int candy(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> l(n, 1);\n        vector<int> r(n, 1);\n        \n        for (int i = 1; i < n; i++)",
                "url": "https://leetcode.com/problems/candy/solutions/1300022/candy-distribution-c-99-faster-explained/",
                "vote_count": "75"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int candy(vector<int>& r) {\n        int n=r.size(),result=0;\n        vector<int> ans(n,1);\n        \n        for(int i=1;i<n;i++)\n        {",
                "url": "https://leetcode.com/problems/candy/solutions/1300022/candy-distribution-c-99-faster-explained/",
                "vote_count": "75"
            }
        ]
    },
    "135": {
        "question_id": 136,
        "title": "Single Number",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/single-number",
        "description": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.You must implement a solution with a linear runtime complexity and use only constant extra space. ",
        "examples": [
            {
                "input": "nums = [2,2,1]",
                "output": "1",
                "explanation": null
            },
            {
                "input": "nums = [1]",
                "output": "1",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 3 * 10^4",
            "-3 * 10^4 <= nums[i] <= 3 * 10^4",
            "Each element in the array appears twice except for one element which appears only once."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) { \n       unordered_map<int,int> a;\n    for(auto x: nums)\n     a[x]++;\n    for(auto z:a)\n     if(z.second==1)\n      return z.first;\n    return -1;\n    }\n};",
                "url": "https://leetcode.com/problems/single-number/solutions/1771720/c-easy-solutions-sorting-xor-maps-or-frequency-array/",
                "vote_count": "1058"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) { \n       sort(nums.begin(),nums.end());\n        for(int i=1;i<nums.size();i+=2)\n        {\n            if(nums[i]!=nums[i-1])\n                return nums[i-1];\n        }\n        return nums[nums.size()-1];\n    }\n};",
                "url": "https://leetcode.com/problems/single-number/solutions/1771720/c-easy-solutions-sorting-xor-maps-or-frequency-array/",
                "vote_count": "1058"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) { \n       int ans=0;\n    for(auto x:nums)\n    ans^=x;\n    return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/single-number/solutions/1771720/c-easy-solutions-sorting-xor-maps-or-frequency-array/",
                "vote_count": "1058"
            },
            {
                "language": "cpp",
                "code": "class Solution\n{\npublic:\n    int singleNumber(vector<int> &nums)\n    {\n        return accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());\n    }\n};",
                "url": "https://leetcode.com/problems/single-number/solutions/1771720/c-easy-solutions-sorting-xor-maps-or-frequency-array/",
                "vote_count": "1058"
            },
            {
                "language": "java",
                "code": "class Solution {\n  public int singleNumber(int[] nums) {\n    int result = 0;\n    int MAX_SIZE = 3 * (int) Math.pow(10, 4);\n    int TOTAL_SIZE = MAX_SIZE * 2 + 1;\n    boolean[] numOccurrence = new boolean[TOTAL_SIZE];",
                "url": "https://leetcode.com/problems/single-number/solutions/1771720/c-easy-solutions-sorting-xor-maps-or-frequency-array/",
                "vote_count": "1058"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        xor = 0\n        for num in nums:\n            xor ^= num\n        \n        return xor",
                "url": "https://leetcode.com/problems/single-number/solutions/1771771/think-it-through-time-o-n-space-o-1-python-explained/",
                "vote_count": "610"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        seen = set()",
                "url": "https://leetcode.com/problems/single-number/solutions/1771771/think-it-through-time-o-n-space-o-1-python-explained/",
                "vote_count": "610"
            },
            {
                "language": "python",
                "code": "return reduce(lambda p, n: p ^ n, nums)",
                "url": "https://leetcode.com/problems/single-number/solutions/1771771/think-it-through-time-o-n-space-o-1-python-explained/",
                "vote_count": "610"
            },
            {
                "language": "rust",
                "code": "Let's take an example not given in question -\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\n\nSo, our answer should be '7' as it appears only single time in the array. ",
                "url": "https://leetcode.com/problems/single-number/solutions/1772139/c-explained-everything-w-why-xor-works-brute-force-to-optimized-step-by-step-dry-run/",
                "vote_count": "439"
            },
            {
                "language": "rust",
                "code": "Time Complexity --> O(n) // where n is the size of the array\nSpace Complexity --> O(n) // we will store the frequency of every element\n\nIt paases [ 61 / 61 ] in built test cases",
                "url": "https://leetcode.com/problems/single-number/solutions/1772139/c-explained-everything-w-why-xor-works-brute-force-to-optimized-step-by-step-dry-run/",
                "vote_count": "439"
            },
            {
                "language": "rust",
                "code": "Suppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\nso, after storing frequency of each element in our map, our map looks like -\n5 -> 2\n1 -> 2\n3 -> 2\n4 -> 2\n7 -> 1     On traversing, we will see that it's frequency is 1, so this should be our answer.",
                "url": "https://leetcode.com/problems/single-number/solutions/1772139/c-explained-everything-w-why-xor-works-brute-force-to-optimized-step-by-step-dry-run/",
                "vote_count": "439"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int singleNumber(vector<int>& arr) {\n        int n = arr.size(); // taking the size of the array \n        \n        unordered_map<int, int> mp; // unordered map to store the frequency\n        \n        // storing frequency in the map\n        for(int i = 0; i < n; i++)\n        {\n            mp[arr[i]]++;\n        }\n        \n        int ans; // variable to store our answer\n        for(auto x: mp) // traverse from the map\n        {\n            if(x.second == 1) //if frequency of any elemennt is 1\n            {\n                ans = x.first; // store in our answer\n                break; // break the loop, as we got our answer now\n            }\n        }\n        \n        return ans; // return ans\n    }\n};",
                "url": "https://leetcode.com/problems/single-number/solutions/1772139/c-explained-everything-w-why-xor-works-brute-force-to-optimized-step-by-step-dry-run/",
                "vote_count": "439"
            },
            {
                "language": "rust",
                "code": "0 ^ 0 --> 0\n0 ^ 1 --> 1\n1 ^ 0 --> 1\n1 ^ 1 --> 0",
                "url": "https://leetcode.com/problems/single-number/solutions/1772139/c-explained-everything-w-why-xor-works-brute-force-to-optimized-step-by-step-dry-run/",
                "vote_count": "439"
            },
            {
                "language": "python",
                "code": "We know every number is appears twice except a single number which appears only single time.\n\nSee, we already discuss a thing a that xor of a same number with itself is zero, i.e A ^ A = 0\nNow, we will look some more property of xor-\n\n1) xor of a same number with itself is zero, i.e A ^ A = 0\n2) xor is commutative that means a ^ b = b ^ a.\n3) xor of any number with zero is the number itself i.e A ^ 0 = A.\n\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\nwe will rearrange the array, and take all the numbers together, then our array looks like\n                     arr[]: [1, 1, 3, 3, 4, 4, 5, 5, 7]\n      now, take xor of all numbers -\n      1 ^ 1 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 7   (rearrange the array)\n        0   ^   0   ^   0   ^   0   ^ 7   (see point number 1)\n                    7                     (see point number 3) ",
                "url": "https://leetcode.com/problems/single-number/solutions/1772139/c-explained-everything-w-why-xor-works-brute-force-to-optimized-step-by-step-dry-run/",
                "vote_count": "439"
            },
            {
                "language": "csharp",
                "code": "So, our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4] \n\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\n \u2191  \u2191\n 5 ^ 1 = 4\n \n[5, 1, 3, 1, 3, 4, 5, 7, 4]\n       \u2191                       \n    4 ^ 3 = 7 (prev answer xor current index)\n    \n[5, 1, 3, 1, 3, 4, 5, 7, 4]\n       \u2191\n    7 ^ 1 = 6 (prev answer xor current index)\n    \n[5, 1, 3, 1, 3, 4, 5, 7, 4]\n             \u2191\n    6 ^ 3 = 5 (prev answer xor current index)\n\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\n                \u2191\n    5 ^ 4 = 1  (prev answer xor current index)\n    \n[5, 1, 3, 1, 3, 4, 5, 7, 4]\n                   \u2191\n       1 ^ 5 = 4 (prev answer xor current index)\n       \n[5, 1, 3, 1, 3, 4, 5, 7, 4]\n                      \u2191\n       4 ^ 7 = 3 (prev answer xor current index)\n       \n[5, 1, 3, 1, 3, 4, 5, 7, 4]\n                         \u2191\n       3 ^ 4 = 7 (prev answer xor current index)\n       \nSo, the element which we got as left should be our answer, so the answer is '7'",
                "url": "https://leetcode.com/problems/single-number/solutions/1772139/c-explained-everything-w-why-xor-works-brute-force-to-optimized-step-by-step-dry-run/",
                "vote_count": "439"
            },
            {
                "language": "rust",
                "code": "Time Complexity --> O(n) // where n is the size of the array\nSpace Complexity --> O(1) // we are not using anything extra from our side\n\nIt paases [ 61 / 61 ] in built test cases",
                "url": "https://leetcode.com/problems/single-number/solutions/1772139/c-explained-everything-w-why-xor-works-brute-force-to-optimized-step-by-step-dry-run/",
                "vote_count": "439"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int singleNumber(vector<int>& arr) {\n        int n = arr.size(); // extracting the size of the array\n        \n        // traverse from the array\n        for(int i = 0; i < n - 1; i++)\n        {\n            arr[i + 1] = arr[i] ^ arr[i + 1]; // (prev answer xor current index)\n        }\n        \n        return arr[n- 1]; // return left over element\n    }\n};",
                "url": "https://leetcode.com/problems/single-number/solutions/1772139/c-explained-everything-w-why-xor-works-brute-force-to-optimized-step-by-step-dry-run/",
                "vote_count": "439"
            },
            {
                "language": "php",
                "code": "def singleNumber(self, nums: List[int]) -> int:\n return reduce(lambda total, el: total ^ el, nums)",
                "url": "https://leetcode.com/problems/single-number/solutions/1771791/python3-one-liner-explained/",
                "vote_count": "154"
            },
            {
                "language": "go",
                "code": "return (x := 0, [x := x ^ v for v in nums])[-1][-1]",
                "url": "https://leetcode.com/problems/single-number/solutions/1771791/python3-one-liner-explained/",
                "vote_count": "154"
            },
            {
                "language": "php",
                "code": "def singleNumber(self, nums: List[int]) -> int:\n    \"\"\" O(N)T O(1)S \"\"\"\n    return functools.reduce(operator.xor, nums)",
                "url": "https://leetcode.com/problems/single-number/solutions/1771791/python3-one-liner-explained/",
                "vote_count": "154"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int singleNumber(int[] nums) {\n        int ans=0; //since XOR with 0 returns same number \n        for(int i=0; i<nums.length; i++){\n            ans ^= nums[i];  // ans = (ans) XOR (array element at i) \n        }\n        return ans;    \n    }\n}",
                "url": "https://leetcode.com/problems/single-number/solutions/3021354/java-easy-solution-beats-100-runtime-1ms-bit-manipulation/",
                "vote_count": "111"
            },
            {
                "language": "kotlin",
                "code": "Arrays.sort(nums);\nif(nums.length==1){\n    return nums[0];\n}\nfor(int i=0;i<nums.length-1;i++){\n    for(int j=i+1;j<i+2;j++){\n        ",
                "url": "https://leetcode.com/problems/single-number/solutions/3021354/java-easy-solution-beats-100-runtime-1ms-bit-manipulation/",
                "vote_count": "111"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int singleNumber(int[] nums) {\n        Arrays.sort(nums);\n        if(nums.length==1){\n            return nums[0];\n        }\n        for(int i=0;i<nums.length-1;i+=2){\n            if(nums[i]!=nums[i+1]){\n                return nums[i];\n            }\n        }\n       return nums[nums.length-1];\n    }\n    \n}",
                "url": "https://leetcode.com/problems/single-number/solutions/3264959/well-expalined-code-in-java/",
                "vote_count": "51"
            }
        ]
    },
    "136": {
        "question_id": 137,
        "title": "Single Number II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/single-number-ii",
        "description": "Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.You must implement a solution with a linear runtime complexity and use only constant extra space. ",
        "examples": [
            {
                "input": "nums = [2,2,3,2]",
                "output": "3",
                "explanation": null
            }
        ],
        "constraints": [],
        "solutions": [
            {
                "language": "java",
                "code": "for (int i : nums) {\n    xm ^= (xm-1 & ... & x1 & i);\n    xm-1 ^= (xm-2 & ... & x1 & i);\n    .....\n    x1 ^= i;\n    \n    mask = ~(y1 & y2 & ... & ym) where yj = xj if kj = 1, and yj = ~xj if kj = 0 (j = 1 to m).\n\n    xm &= mask;\n    ......\n    x1 &= mask;\n}",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43295/detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers/",
                "vote_count": "2010"
            },
            {
                "language": "cpp",
                "code": "    public int singleNumber(int[] nums) {\n        int x1 = 0;\n         \n        for (int i : nums) {\n            x1 ^= i;\n        }\n         \n        return x1;\n    }",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43295/detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers/",
                "vote_count": "2010"
            },
            {
                "language": "cpp",
                "code": "    public int singleNumber(int[] nums) {\n        int x1 = 0, x2 = 0, mask = 0;\n         \n        for (int i : nums) {\n            x2 ^= x1 & i;\n            x1 ^= i;\n            mask = ~(x1 & x2);\n            x2 &= mask;\n            x1 &= mask;\n        }\n\n        return x1;  // Since p = 1, in binary form p = '01', then p1 = 1, so we should return x1. \n                    // If p = 2, in binary form p = '10', then p2 = 1, and we should return x2.\n                    // Or alternatively we can simply return (x1 | x2).\n    }",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43295/detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers/",
                "vote_count": "2010"
            },
            {
                "language": "cpp",
                "code": "    public int singleNumber(int[] nums) {\n        int x1 = 0, x2 = 0, x3  = 0, mask = 0;\n   \n        for (int i : nums) {\n            x3 ^= x2 & x1 & i;\n            x2 ^= x1 & i;\n            x1 ^= i;\n            mask = ~(x1 & ~x2 & x3);\n            x3 &= mask;\n            x2 &= mask;\n            x1 &= mask;\n        }\n        \n        return x1;  // Since p = 3, in binary form p = '011', then p1 = p2 = 1, so we can return either x1 or x2. \n                    // If p = 4, in binary form p = '100', only p3 = 1, which implies we can only return x3.\n                    // Or alternatively we can simply return (x1 | x2 | x3).\n    }",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43295/detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers/",
                "vote_count": "2010"
            },
            {
                "language": "cpp",
                "code": "    public int singleNumber(int[] A) {\n         int x1 = 0;\n         \n         for (int i : A) {",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43295/detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers/",
                "vote_count": "2010"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43295/detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers/",
                "vote_count": "2010"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43295/detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers/",
                "vote_count": "2010"
            },
            {
                "language": "rust",
                "code": "a b num -> a b",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43295/detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers/",
                "vote_count": "2010"
            },
            {
                "language": "cpp",
                "code": "int singleNumber(int* nums, int numsSize, int k) //k>=2\n{\n    int counter[32];\n    int i, j;\n    int res = 0;\n    \n    for(i=0; i<32; i++)\n        counter[i] = 0;",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43295/detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers/",
                "vote_count": "2010"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public int singleNumber(int[] nums) {\n     return generalSolution(nums, 3, 1);\n    }\n    public int generalSolution(int[] nums, int all_rep, int single_rep) {\n  int m = bit_length(all_rep);\n  int[] counters = new int[m];\n  for (int n : nums) {",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43295/detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers/",
                "vote_count": "2010"
            },
            {
                "language": "cpp",
                "code": "public int singleNumber(int[] A) {\n    int ones = 0, twos = 0;\n    for(int i = 0; i < A.length; i++){\n        ones = (ones ^ A[i]) & ~twos;\n        twos = (twos ^ A[i]) & ~ones;\n    }\n    return ones;\n}",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43294/challenge-me-thx/",
                "vote_count": "1073"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43294/challenge-me-thx/",
                "vote_count": "1073"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43294/challenge-me-thx/",
                "vote_count": "1073"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43294/challenge-me-thx/",
                "vote_count": "1073"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43294/challenge-me-thx/",
                "vote_count": "1073"
            },
            {
                "language": "cpp",
                "code": "/*\n    This is a case of a finite state machine.\n    States of machine- Total three (number appeared once, number appeared twice, number appeared thrice)\n    Action - Incoming bit of one\n    We will need two bits to keep track of the state. So lets take those states as 00, 01 and 10.\n    The states will transition like 00 -> 01 -> 10 with every incoming bit.\n    Now lets look at the individual bits.\n    First bit - 0 -> 0 -> 1 -> back to 0",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43294/challenge-me-thx/",
                "vote_count": "1073"
            },
            {
                "language": "",
                "code": "X=***1***1***\n\nZ=***0***0***\n\nX=***1***1***\n\nY=***0***1***",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43294/challenge-me-thx/",
                "vote_count": "1073"
            },
            {
                "language": "csharp",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43294/challenge-me-thx/",
                "vote_count": "1073"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43294/challenge-me-thx/",
                "vote_count": "1073"
            },
            {
                "language": "csharp",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43294/challenge-me-thx/",
                "vote_count": "1073"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43294/challenge-me-thx/",
                "vote_count": "1073"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int singleNumber(int arr[], int n) {\n        // Initialize result\n    int result = 0;\n \n    int x, sum;\n \n    // Iterate through every bit",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43294/challenge-me-thx/",
                "vote_count": "1073"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43294/challenge-me-thx/",
                "vote_count": "1073"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43294/challenge-me-thx/",
                "vote_count": "1073"
            },
            {
                "language": "python",
                "code": "public int singleNumber(int[] nums) {\n    int ans = 0;\n    for(int i = 0; i < 32; i++) {\n        int sum = 0;\n        for(int j = 0; j < nums.length; j++) {\n            if(((nums[j] >> i) & 1) == 1) {\n                sum++;\n                sum %= 3;\n            }\n        }\n        if(sum != 0) {\n            ans |= sum << i;\n        }\n    }\n    return ans;\n}",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43297/java-o-n-easy-to-understand-solution-easily-extended-to-any-times-of-occurance/",
                "vote_count": "873"
            },
            {
                "language": "python",
                "code": "int singleNumber(vector<int>& nums) {\n int res = 0;\n for (int i = 0; i < 32; i++) {\n  int sum = 0;\n  int mask = 1 << i;\n  for (auto n : nums) \n   if (n & mask) \n    sum++;",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43297/java-o-n-easy-to-understand-solution-easily-extended-to-any-times-of-occurance/",
                "vote_count": "873"
            },
            {
                "language": "python",
                "code": "public int singleNumber(int[] nums) {\n    int res = 0;\n    for(int i = 0; i < 32; i++){\n        int sum = 0;\n        for(int n: nums)\n            if((n >> i & 1) == 1)\n                sum++;\n        sum %= 3;\n        res |= sum<<i;",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43297/java-o-n-easy-to-understand-solution-easily-extended-to-any-times-of-occurance/",
                "vote_count": "873"
            },
            {
                "language": "python",
                "code": "if (sum != 0) {\n    ans |= sum << i;\n}",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43297/java-o-n-easy-to-understand-solution-easily-extended-to-any-times-of-occurance/",
                "vote_count": "873"
            },
            {
                "language": "python",
                "code": "if (sum == 1) {",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43297/java-o-n-easy-to-understand-solution-easily-extended-to-any-times-of-occurance/",
                "vote_count": "873"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        res = 0\n        for i in range(32):\n            s = 0\n            mask = 1 << i",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43297/java-o-n-easy-to-understand-solution-easily-extended-to-any-times-of-occurance/",
                "vote_count": "873"
            },
            {
                "language": "python",
                "code": "public int singleNumber(int[] nums) {\n    int ans = 0;\n    for(int i = 0; i < 32; i++) {\n        int sum = 0;\n        for(int j = 0; j < nums.length; j++) {\n            if(((nums[j] >> i) & 1) == 1) {",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43297/java-o-n-easy-to-understand-solution-easily-extended-to-any-times-of-occurance/",
                "vote_count": "873"
            },
            {
                "language": "python",
                "code": "current   incoming  next\na b            c    a b\n0 0            0    0 0\n0 1            0    0 1\n1 0            0    1 0\n0 0            1    0 1\n0 1            1    1 0\n1 0            1    0 0",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43296/an-general-way-to-handle-all-this-sort-of-questions/",
                "vote_count": "559"
            },
            {
                "language": "python",
                "code": "    current   incoming  next\n    a b            c    a b\n    1 0            0    1 0\n    0 1            1    1 0",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43296/an-general-way-to-handle-all-this-sort-of-questions/",
                "vote_count": "559"
            },
            {
                "language": "",
                "code": "a=a&~b&~c + ~a&b&c",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43296/an-general-way-to-handle-all-this-sort-of-questions/",
                "vote_count": "559"
            },
            {
                "language": "",
                "code": "b= ~a&b&~c+~a&~b&c",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43296/an-general-way-to-handle-all-this-sort-of-questions/",
                "vote_count": "559"
            },
            {
                "language": "dart",
                "code": "01 10 => 1\n00 => 0",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43296/an-general-way-to-handle-all-this-sort-of-questions/",
                "vote_count": "559"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\n    \n    public int singleNumber(int[] nums) {\n        //we need to implement a tree-time counter(base 3) that if a bit appears three time ,it will be zero.\n        //#curent  income  ouput\n        //# ab      c/c       ab/ab\n        //# 00      1/0       01/00\n        //# 01      1/0       10/01\n        //# 10      1/0       00/10\n        // a=~abc+a~b~c;\n        // b=~a~bc+~ab~c;\n        int a=0;\n        int b=0;\n        for(int c:nums){\n            int ta=(~a&b&c)|(a&~b&~c);\n            b=(~a&~b&c)|(~a&b&~c);\n            a=ta;\n        }\n        //we need find the number that is 01,10 => 1, 00 => 0.\n        return a|b;\n        \n    }\n}",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43296/an-general-way-to-handle-all-this-sort-of-questions/",
                "vote_count": "559"
            },
            {
                "language": "",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43296/an-general-way-to-handle-all-this-sort-of-questions/",
                "vote_count": "559"
            },
            {
                "language": "lisp",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43296/an-general-way-to-handle-all-this-sort-of-questions/",
                "vote_count": "559"
            },
            {
                "language": "kotlin",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43296/an-general-way-to-handle-all-this-sort-of-questions/",
                "vote_count": "559"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43296/an-general-way-to-handle-all-this-sort-of-questions/",
                "vote_count": "559"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43296/an-general-way-to-handle-all-this-sort-of-questions/",
                "vote_count": "559"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43296/an-general-way-to-handle-all-this-sort-of-questions/",
                "vote_count": "559"
            },
            {
                "language": "swift",
                "code": "ai is the ith bit of a ",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43296/an-general-way-to-handle-all-this-sort-of-questions/",
                "vote_count": "559"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/single-number-ii/solutions/43296/an-general-way-to-handle-all-this-sort-of-questions/",
                "vote_count": "559"
            }
        ]
    },
    "137": {
        "question_id": 138,
        "title": "Copy List with Random Pointer",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/copy-list-with-random-pointer",
        "description": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.Return the head of the copied linked list.The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:val: an integer representing Node.valrandom_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.Your code will only be given the head of the original linked list. ",
        "examples": [
            {
                "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
                "output": "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
                "explanation": null
            },
            {
                "input": "head = [[1,1],[2,1]]",
                "output": "[[1,1],[2,1]]",
                "explanation": null
            },
            {
                "input": "head = [[3,null],[3,0],[3,null]]",
                "output": "[[3,null],[3,0],[3,null]]",
                "explanation": null
            }
        ],
        "constraints": [
            "0 <= n <= 1000",
            "-10^4 <= Node.val <= 10^4",
            "Node.random is null or is pointing to some node in the linked list."
        ],
        "solutions": [
            {
                "language": "java",
                "code": "public RandomListNode copyRandomList(RandomListNode head) {\n  RandomListNode iter = head, next;\n\n  // First round: make copy of each node,\n  // and link them together side-by-side in a single list.\n  while (iter != null) {\n    next = iter.next;\n\n    RandomListNode copy = new RandomListNode(iter.label);\n    iter.next = copy;\n    copy.next = next;\n\n    iter = next;\n  }\n\n  // Second round: assign random pointers for the copy nodes.\n  iter = head;\n  while (iter != null) {\n    if (iter.random != null) {\n      iter.next.random = iter.random.next;\n    }\n    iter = iter.next.next;\n  }\n\n  // Third round: restore the original list, and extract the copy list.\n  iter = head;\n  RandomListNode pseudoHead = new RandomListNode(0);\n  RandomListNode copy, copyIter = pseudoHead;\n\n  while (iter != null) {\n    next = iter.next.next;\n\n    // extract the copy\n    copy = iter.next;\n    copyIter.next = copy;\n    copyIter = copy;\n\n    // restore the original list\n    iter.next = next;\n\n    iter = next;\n  }\n\n  return pseudoHead.next;\n}",
                "url": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/43491/a-solution-with-constant-space-complexity-o-1-and-linear-time-complexity-o-n/",
                "vote_count": "1751"
            },
            {
                "language": "ruby",
                "code": "def copyRandomList(self, head):\n\n    # Insert each node's copy right after it, already copy .label\n    node = head\n    while node:\n        copy = RandomListNode(node.label)\n        copy.next = node.next",
                "url": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/43491/a-solution-with-constant-space-complexity-o-1-and-linear-time-complexity-o-n/",
                "vote_count": "1751"
            },
            {
                "language": "java",
                "code": "    public Node copyRandomList(Node head) {\n        if (head == null) return null;\n        Node cur = head;\n        while (cur != null) {\n            Node next = cur.next;\n            cur.next = new Node(cur.val, next, null);\n            cur = next;",
                "url": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/43491/a-solution-with-constant-space-complexity-o-1-and-linear-time-complexity-o-n/",
                "vote_count": "1751"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        map<Node*, Node*> m;\n        int i=0;\n        Node* ptr = head;\n        while (ptr) {\n            m[ptr] =new Node(ptr->val);\n            ptr = ptr->next;\n        }\n        ptr = head;\n        while (ptr) {\n            m[ptr]->next = m[ptr->next];\n            m[ptr]->random = m[ptr->random];\n            ptr = ptr->next;\n        }\n        return m[head];\n    }\n};",
                "url": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/811151/extremely-simple-solution-using-c/",
                "vote_count": "525"
            },
            {
                "language": "rust",
                "code": "Node* copyRandomList(Node* head) {\n    if(!head || !head->next)return head;\n    Node* mylist=new Node(-1);\n    \n    unordered_map<Node *,Node *> mp;\n    \n    Node *t=head,*x=mylist;",
                "url": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/811151/extremely-simple-solution-using-c/",
                "vote_count": "525"
            },
            {
                "language": "ruby",
                "code": "Node* node=head;\nwhile(node){\n Node* temp=node->next;\n node->next=new Node(node->val);\n node->next->next=temp;\n node=temp;\n}",
                "url": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/1059181/c-three-pass-o-n-0ms-beats-100-explanation-with-example/",
                "vote_count": "256"
            },
            {
                "language": "rust",
                "code": "node=head;\nwhile(node){\n if(node->random)\n  node->next->random=node->random->next;\n node=node->next->next; // go to next old node\n}",
                "url": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/1059181/c-three-pass-o-n-0ms-beats-100-explanation-with-example/",
                "vote_count": "256"
            },
            {
                "language": "rust",
                "code": "Node* ans=new Node(0); // first node is a dummy node\nNode* helper=ans;\n\nwhile(head){\n // Copy the alternate added nodes from the old linklist\n helper->next=head->next;\n helper=helper->next;\n\n // Restoring the old linklist, by removing the alternative newly added nodes\n head->next=head->next->next;\n head=head->next; // go to next alternate node   \n}\nreturn ans->next; // Since first node is a dummy node",
                "url": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/1059181/c-three-pass-o-n-0ms-beats-100-explanation-with-example/",
                "vote_count": "256"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        \n        // STEP 1: PASS 1\n        // Creating a copy (except random pointer) of each old node and insert it next to the old node it's copied from.\n        // That is, it will create new alternative nodes which are a copy (except random pointer) of its previous node.\n        Node* node=head;\n        while(node){\n            Node* temp=node->next;\n            node->next=new Node(node->val);\n            node->next->next=temp;\n            node=temp;\n        }\n        \n        // STEP 2: PASS 2\n        // Now copy the random pointer (if exists) of the old nodes to their copy new nodes.\n        node=head;\n        while(node){\n            if(node->random)\n                node->next->random=node->random->next;\n            node=node->next->next; // go to next old node\n        }\n        \n        //STEP 3: PASS 3\n        // Copy the alternative nodes into \"ans\" link list using the \"helper\" pointer along with restoring the old link list.\n        Node* ans=new Node(0); // first node is a dummy node\n        Node* helper=ans;\n    \n        while(head){\n            // Copy the alternate added nodes from the old linklist\n            helper->next=head->next;\n            helper=helper->next;\n            \n            // Restoring the old linklist, by removing the alternative newly added nodes\n            head->next=head->next->next;\n            head=head->next; // go to next alternate node   \n        }\n        return ans->next; // Since first node is a dummy node\n    }\n};",
                "url": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/1059181/c-three-pass-o-n-0ms-beats-100-explanation-with-example/",
                "vote_count": "256"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n public:\n  Node* copyRandomList(Node* head) {\n    if (head == nullptr)\n      return nullptr;\n    if (map.count(head))\n      return map[head];\n\n    Node* newNode = new Node(head->val);\n    map[head] = newNode;\n    newNode->next = copyRandomList(head->next);\n    newNode->random = copyRandomList(head->random);\n    return newNode;\n  }\n\n private:\n  unordered_map<Node*, Node*> map;\n};",
                "url": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3171263/solution/",
                "vote_count": "43"
            }
        ]
    },
    "138": {
        "question_id": 139,
        "title": "Word Break",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/word-break",
        "description": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.Note that the same word in the dictionary may be reused multiple times in the segmentation. ",
        "examples": [
            {
                "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
                "output": "true",
                "explanation": "Return true because \"leetcode\" can be segmented as \"leet code\"."
            },
            {
                "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
                "output": "true",
                "explanation": "Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\nNote that you are allowed to reuse a dictionary word."
            },
            {
                "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
                "output": "false",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= s.length <= 300",
            "1 <= wordDict.length <= 1000",
            "1 <= wordDict[i].length <= 20",
            "s and wordDict[i] consist of only lowercase English letters.",
            "All the strings of wordDict are unique."
        ],
        "solutions": [
            {
                "language": "typescript",
                "code": "class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        // put all words into a hashset\n        Set<String> set = new HashSet<>(wordDict);\n        return wb(s, set);\n    }\n    private boolean wb(String s, Set<String> set) {\n        int len = s.length();\n        if (len == 0) {\n            return true;\n        }\n        for (int i = 1; i <= len; ++i) {\n            if (set.contains(s.substring(0, i)) && wb(s.substring(i), set)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
                "url": "https://leetcode.com/problems/word-break/solutions/169383/solved-the-time-complexity-of-the-brute-force-method-should-be-o-2-n-and-prove-it-below/",
                "vote_count": "1182"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());\n        vector<int> memo(s.size(), -1);\n        return check(s, wordSet, 0, memo);\n    }\n    bool check(string s, unordered_set<string>& wordSet, int start, vector<int>& memo) {",
                "url": "https://leetcode.com/problems/word-break/solutions/169383/solved-the-time-complexity-of-the-brute-force-method-should-be-o-2-n-and-prove-it-below/",
                "vote_count": "1182"
            },
            {
                "language": "typescript",
                "code": "public class Solution {\n    public boolean wordBreak(String s, Set<String> dict) {\n        \n        boolean[] f = new boolean[s.length() + 1];\n        \n        f[0] = true;\n        \n        \n        /* First DP\n        for(int i = 1; i <= s.length(); i++){\n            for(String str: dict){\n                if(str.length() <= i){\n                    if(f[i - str.length()]){\n                        if(s.substring(i-str.length(), i).equals(str)){\n                            f[i] = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        }*/\n        \n        //Second DP\n        for(int i=1; i <= s.length(); i++){\n            for(int j=0; j < i; j++){\n                if(f[j] && dict.contains(s.substring(j, i))){\n                    f[i] = true;\n                    break;\n                }\n            }\n        }\n        \n        return f[s.length()];\n    }\n}",
                "url": "https://leetcode.com/problems/word-break/solutions/43790/java-implementation-using-dp-in-two-ways/",
                "vote_count": "664"
            },
            {
                "language": "typescript",
                "code": "public boolean wordBreak(String s, List<String> wordDict) {\n    boolean[] dp = new boolean[s.length() + 1];\n    Set<String> set = new HashSet<>();\n    set.addAll(wordDict);\n\n    dp[0] = true;\n    for (int i = 1; i <= s.length(); i++) {\n        for (int j = i - 1; j >= 0; j--) {\n            dp[i] = dp[j] && set.contains(s.substring(j, i));",
                "url": "https://leetcode.com/problems/word-break/solutions/43790/java-implementation-using-dp-in-two-ways/",
                "vote_count": "664"
            },
            {
                "language": "typescript",
                "code": "/**\n * Initial recursion + memoization solution in Java.\n *\n * @author Haoyang Fan\n * @version 1.0\n * @since 02-01-2019\n */",
                "url": "https://leetcode.com/problems/word-break/solutions/43790/java-implementation-using-dp-in-two-ways/",
                "vote_count": "664"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public class TrieNode {\n        boolean isWord;\n        TrieNode[] c;\n        \n        public TrieNode(){\n            isWord = false;\n            c = new TrieNode[128];",
                "url": "https://leetcode.com/problems/word-break/solutions/43790/java-implementation-using-dp-in-two-ways/",
                "vote_count": "664"
            },
            {
                "language": "typescript",
                "code": "",
                "url": "https://leetcode.com/problems/word-break/solutions/43790/java-implementation-using-dp-in-two-ways/",
                "vote_count": "664"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n\n    public boolean wordBreak(String s, List<String> wordDict) {\n        \n        boolean[] f = new boolean[s.length() + 1];\n        \n        f[0] = true;\n        \n.length(), i);",
                "url": "https://leetcode.com/problems/word-break/solutions/43790/java-implementation-using-dp-in-two-ways/",
                "vote_count": "664"
            },
            {
                "language": "typescript",
                "code": "public class Solution {\n    public boolean wordBreak(String s, Set<String> wordDict) {\n        if(s == null || s.length() == 0){\n            return true;\n        }\n        int n = s.length();\n        boolean [] dp = new boolean[n+1];\n        dp[0] = true ;",
                "url": "https://leetcode.com/problems/word-break/solutions/43790/java-implementation-using-dp-in-two-ways/",
                "vote_count": "664"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        n = len(s)\n        wordSet = set(wordDict)\n\n        @lru_cache(None)\n        def dp(start):\n            if start == n:  # Found a valid way to break words\n                return True\n\n            for end in range(start + 1, n + 1):  # O(N^2)\n                word = s[start:end]  # O(N)\n                if word in wordSet and dp(end):\n                    return True\n            return False\n\n        return dp(0)",
                "url": "https://leetcode.com/problems/word-break/solutions/1455100/python-3-solutions-top-down-dp-bottom-up-dp-then-optimised-with-trie-clean-concise/",
                "vote_count": "264"
            },
            {
                "language": "rust",
                "code": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        wordSet = set(wordDict)\n        n = len(s)\n        \n        dp = [False] * (n+1)\n        dp[n] = True\n        for i in range(n-1, -1, -1):\n            for j in range(i+1, n+1):\n                if dp[j] and s[i:j] in wordSet:\n                    dp[i] = True\n                    break\n        \n        return dp[0]",
                "url": "https://leetcode.com/problems/word-break/solutions/1455100/python-3-solutions-top-down-dp-bottom-up-dp-then-optimised-with-trie-clean-concise/",
                "vote_count": "264"
            },
            {
                "language": "ruby",
                "code": "class TrieNode:\n    def __init__(self):\n        self.isWord = False\n        self.child = defaultdict(TrieNode)\n    \n    def addWord(self, word):\n        cur = self\n        for c in word:\n            cur = cur.child[c]\n        cur.isWord = True\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        root = TrieNode()\n        for word in wordDict:\n            root.addWord(word)\n            \n        n = len(s)\n        dp = [False] * (n+1)\n        dp[n] = True\n        \n        for i in range(n-1, -1, -1):\n            cur = root\n            for j in range(i+1, n+1):\n                c = s[j-1]\n                if c not in cur.child: break  # s[i:j] not exist in our trie\n                cur = cur.child[c]\n                if cur.isWord and dp[j]:\n                    dp[i] = True\n                    break\n        \n        return dp[0]",
                "url": "https://leetcode.com/problems/word-break/solutions/1455100/python-3-solutions-top-down-dp-bottom-up-dp-then-optimised-with-trie-clean-concise/",
                "vote_count": "264"
            },
            {
                "language": "java",
                "code": "    for(String word:wordDict){\n        addWord(word,root);\n    }",
                "url": "https://leetcode.com/problems/word-break/solutions/1455100/python-3-solutions-top-down-dp-bottom-up-dp-then-optimised-with-trie-clean-concise/",
                "vote_count": "264"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        wordDict=set(wordDict) # to handle lookup time\n        n=len(s)\n        @lru_cache(None)\n        def dfs(i):\n            nonlocal n\n            if i>=n:",
                "url": "https://leetcode.com/problems/word-break/solutions/1455100/python-3-solutions-top-down-dp-bottom-up-dp-then-optimised-with-trie-clean-concise/",
                "vote_count": "264"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n public:\n  bool wordBreak(string s, vector<string>& wordDict) {\n    const int n = s.length();\n    const int maxLength = getMaxLength(wordDict);\n    const unordered_set<string> wordSet{begin(wordDict), end(wordDict)};\n    vector<int> dp(n + 1);\n    dp[0] = true;\n\n    for (int i = 1; i <= n; ++i)\n      for (int j = i - 1; j >= 0; --j) {\n        if (i - j > maxLength)\n          break;\n        if (dp[j] && wordSet.count(s.substr(j, i - j))) {\n          dp[i] = true;\n          break;\n        }\n      }\n\n    return dp[n];\n  }\n\n private:\n  int getMaxLength(const vector<string>& wordDict) {\n    return max_element(begin(wordDict), end(wordDict),\n                       [](const auto& a, const auto& b) {\n                         return a.length() < b.length();\n                       })\n        ->length();\n  }\n};",
                "url": "https://leetcode.com/problems/word-break/solutions/3171265/solution/",
                "vote_count": "30"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(2^N), Given a string of length N, there are N+1 ways to split it into two parts. At each\n    step, we have a choice: to split or not to split. In the worse case, when all choices are to be checked, that\n    results in O(2^N).\n\n    Space Complexity : O(N), The depth of the recursion tree can go upto N.\n    \n    Solved using String + Backtracking + Hash Table.\n\n*/\n\n\n/***************************************** Approach 1 First Code *****************************************/\n\nclass Solution {\nprivate:\n    bool wordBreak(string s, unordered_set<string> &set){\n        if(s.size() == 0){\n            return true;\n        }\n        for(int i=0; i<s.size(); i++){\n            if(set.count(s.substr(0, i+1)) && wordBreak(s.substr(i+1), set)){\n                return true;\n            }\n        }\n        return false;\n    }\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\n        return wordBreak(s, set);\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(2^N), Given a string of length N, there are N+1 ways to split it into two parts. At each\n    step, we have a choice: to split or not to split. In the worse case, when all choices are to be checked, that\n    results in O(2^N).\n\n    Space Complexity : O(N), The depth of the recursion tree can go upto N.\n    \n    Solved using String + Backtracking + Hash Table.\n\n*/\n\n\n/***************************************** Approach 1 Second Code *****************************************/\n\nclass Solution {\nprivate:\n    bool wordBreak(string s, unordered_set<string> &set, int start){\n        if(start == s.size()){\n            return true;\n        }\n        for(int i=start; i<s.size(); i++){\n            if(set.count(s.substr(start, i+1-start)) && wordBreak(s, set, i+1)){\n                return true;\n            }\n        }\n        return false;\n    }\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\n        return wordBreak(s, set, 0);\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^3), Size of recursion tree can go up to N^2.\n\n    Space Complexity : O(N), The depth of the recursion tree can go upto N.\n    \n    Solved using String + DP(Memoisation) + Hash Table.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\nprivate:\n    bool wordBreak(string s, unordered_set<string> &set, vector<int> &memo, int start){\n        if(start == s.size()){\n            return true;\n        }\n        if(memo[start] != -1){\n            return memo[start];\n        }\n        for(int i=start; i<s.size(); i++){\n            if(set.count(s.substr(start, i+1-start)) && wordBreak(s, set, memo, i+1)){\n                memo[start] = true;\n                return true;\n            }\n        }\n        return memo[start] = false;\n    }\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        vector<int> memo(s.size(), -1);\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\n        return wordBreak(s, set, memo, 0);\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^3), There are two nested loops, and substring computation at each iteration. Overall\n    that results in O(N^3) time complexity.\n\n    Space Complexity : O(N), Length of dp array is N+1.\n    \n    Solved using String + DP(Tabulation) + Hash Table.\n\n*/\n\n\n/***************************************** Approach 3 *****************************************/\n\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        vector<bool> dp(s.size()+1, 0);\n        dp[0] = true;\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\n        for(int i=1; i<=s.size(); i++){\n            for(int j=0; j<i; j++){\n                if(dp[j] && set.count(s.substr(j, i-j))){\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[s.size()];\n    }\n};",
                "url": "https://leetcode.com/problems/word-break/solutions/3226285/best-c-3-solution-dp-memoization-tabulation-backtracking-brute-force-optimize/",
                "vote_count": "20"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string>word_set(wordDict.begin(),wordDict.end());\n        int n=s.size();\n        vector<bool>dp(n+1,0);\n        dp[0]=1;\n        for(int i=0;i<n;i++){\n            if(!dp[i])continue;\n            for(int j=i+1;j<=n;j++){\n                if( word_set.count(s.substr(i,j-i)))\n                dp[j]=1;\n            }\n        }\n        return dp[n];\n    }\n};",
                "url": "https://leetcode.com/problems/word-break/solutions/3106264/simple-c-dp-short/",
                "vote_count": "13"
            },
            {
                "language": "cpp",
                "code": " bool wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string>word_set(wordDict.begin(),wordDict.end());\n        int n=s.size();\n        vector<bool>dp(n+1,0);\n        dp[0]=1;\n        for(int i=0;i<n;i++){\n            if(!dp[i])continue;\n            for(int j=i+1;j<=n;j++){\n                if( word_set.count(s.substr(i,j-i)))\n                dp[j]=1;\n            }\n        }\n        return dp[n];\n    }",
                "url": "https://leetcode.com/problems/word-break/solutions/3107044/c-template-for-word-break-i-ii-concatenated-words/",
                "vote_count": "11"
            },
            {
                "language": "cpp",
                "code": "vector<string> wordBreak(string s, vector<string>& wordDict) {\n        int n=s.size();\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\n         vector<vector<string>>dp(n+1,vector<string>());\n         dp[0].push_back(\"\");\n    \n          for(int i = 0; i < n; ++i){\n            for(int j = i+1; j <= n; ++j){\n                string temp = s.substr(i, j-i);\n                if(word_Set.count(temp)){\n                    for(auto x : dp[i]){\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);  \n                    }\n                }\n            }\n        }\n         return dp[n];\n    }",
                "url": "https://leetcode.com/problems/word-break/solutions/3107044/c-template-for-word-break-i-ii-concatenated-words/",
                "vote_count": "11"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\n        unordered_set<string>word_set(words.begin(),words.end());\n        vector<string>ans;\n        for(auto w:words){\n            int n=w.size();\n            vector<bool>dp(n+1,false);\n            dp[0]=1;\n            for(int i=0;i<n;i++){\n                if(!dp[i])continue;\n                for(int j=i+1;j<=n;j++){\n                    if(j-i<n and word_set.count(w.substr(i,j-i)))\n                    dp[j]=1;\n                }\n            }\n            if(dp[n]==1)ans.push_back(w);\n        }\n       return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/word-break/solutions/3107044/c-template-for-word-break-i-ii-concatenated-words/",
                "vote_count": "11"
            }
        ]
    },
    "139": {
        "question_id": 140,
        "title": "Word Break II",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/word-break-ii",
        "description": "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.Note that the same word in the dictionary may be reused multiple times in the segmentation. ",
        "examples": [
            {
                "input": "s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]",
                "output": "[\"cats and dog\",\"cat sand dog\"]",
                "explanation": null
            },
            {
                "input": "s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]",
                "output": "[\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]",
                "explanation": "Note that you are allowed to reuse a dictionary word."
            },
            {
                "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
                "output": "[]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= s.length <= 20",
            "1 <= wordDict.length <= 1000",
            "1 <= wordDict[i].length <= 10",
            "s and wordDict[i] consist of only lowercase English letters.",
            "All the strings of wordDict are unique."
        ],
        "solutions": [
            {
                "language": "typescript",
                "code": "public List<String> wordBreak(String s, Set<String> wordDict) {\n    return DFS(s, wordDict, new HashMap<String, LinkedList<String>>());\n}       \n\n// DFS function returns an array including all substrings derived from s.\nList<String> DFS(String s, Set<String> wordDict, HashMap<String, LinkedList<String>>map) {\n    if (map.containsKey(s)) \n        return map.get(s);\n        \n    LinkedList<String>res = new LinkedList<String>();     \n    if (s.length() == 0) {\n        res.add(\"\");\n        return res;\n    }               \n    for (String word : wordDict) {\n        if (s.startsWith(word)) {\n            List<String>sublist = DFS(s.substring(word.length()), wordDict, map);\n            for (String sub : sublist) \n                res.add(word + (sub.isEmpty() ? \"\" : \" \") + sub);               \n        }\n    }       \n    map.put(s, res);\n    return res;\n}",
                "url": "https://leetcode.com/problems/word-break-ii/solutions/44167/my-concise-java-solution-based-on-memorized-dfs/",
                "vote_count": "611"
            },
            {
                "language": "typescript",
                "code": "public class Solution {\n    HashMap<String,List<String>> map = new HashMap<String,List<String>>();\n    public List<String> wordBreak(String s, Set<String> wordDict) {\n        List<String> res = new ArrayList<String>();\n        if(s == null || s.length() == 0) {\n            return res;\n        }",
                "url": "https://leetcode.com/problems/word-break-ii/solutions/44167/my-concise-java-solution-based-on-memorized-dfs/",
                "vote_count": "611"
            },
            {
                "language": "typescript",
                "code": "",
                "url": "https://leetcode.com/problems/word-break-ii/solutions/44167/my-concise-java-solution-based-on-memorized-dfs/",
                "vote_count": "611"
            },
            {
                "language": "typescript",
                "code": "public List<String> wordBreak(String s, List<String> wordDict) {\n    return backtrack(s,wordDict,new HashMap<String, List<String>>());\n}\n// backtrack returns an array including all substrings derived from s.\npublic List<String> backtrack(String s, List<String> wordDict, Map<String,List<String>> mem){\n    if(mem.containsKey(s)) return mem.get(s);\n    List<String> result = new ArrayList<String>();\n    for(String word: wordDict)",
                "url": "https://leetcode.com/problems/word-break-ii/solutions/44167/my-concise-java-solution-based-on-memorized-dfs/",
                "vote_count": "611"
            },
            {
                "language": "typescript",
                "code": "public class Solution {\n    public List<String> wordBreak(String s, List<String> wordDict) {\n        return memDFS(s, wordDict, new HashMap<String, List<String>>());\n    }\n    \n    private List<String> memDFS(String s, List<String> wordDict, Map<String, List<String>> map) {\n        if (map.containsKey(s)) return map.get(s);\n        List<String> res = new ArrayList<>();",
                "url": "https://leetcode.com/problems/word-break-ii/solutions/44167/my-concise-java-solution-based-on-memorized-dfs/",
                "vote_count": "611"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n        //insert all the words in the set\n        unordered_set<string> set;\n        vector<string> res;\n        for(auto word:wordDict)\n            set.insert(word);\n        //to store the current string \n        string curr=\"\";\n        findHelper(0,s,curr,set,res);\n        return res;\n    }\n    \n    void findHelper(int ind,string s,string curr,unordered_set<string> set,vector<string>& res)\n    {\n        if(ind==s.length())\n        {\n            //we have reached end\n            curr.pop_back(); //remove the trailing space\n            res.push_back(curr);\n        }\n        string str=\"\";\n        for(int i=ind;i<s.length();i++)\n        {\n            //get every substring and check if it exists in set\n            str.push_back(s[i]);\n            if(set.count(str))\n            {\n                //we have got a word in dict \n                //explore more and get other substrings\n                findHelper(i+1,s,curr+str+\" \",set,res);\n            }\n        }\n    }\n};",
                "url": "https://leetcode.com/problems/word-break-ii/solutions/1241504/c-0ms-solution-commented-fully/",
                "vote_count": "89"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void solve(string s, vector<string>& res, unordered_set<string>& st, vector<string>&temp){\n        if(s.length() == 0){\n            string str = \"\";\n            for(auto it:temp){\n                str += it + \" \";\n            }\n            str.pop_back();\n            res.push_back(str);\n            return;\n        }\n        for(int i=0;i<s.length(); i++){\n            if(st.count(s.substr(0, i+1))){\n                temp.push_back(s.substr(0, i+1));\n                solve(s.substr(i+1), res, st, temp);\n                temp.pop_back();\n            }\n        }\n    }\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n        vector<string>res, temp;\n        unordered_set<string>st(wordDict.begin(), wordDict.end());\n        \n        solve(s, res, st, temp);\n        return res;\n    }\n};",
                "url": "https://leetcode.com/problems/word-break-ii/solutions/2996989/solution/",
                "vote_count": "28"
            },
            {
                "language": "csharp",
                "code": " vector<string> wordBreak(string s, vector<string>& wordDict) {\n        vector<string> ans;\n        set<string> dict (wordDict.begin(), wordDict.end());\n        f(0, s, \"\", ans, dict);\n        return ans;\n    }\n\n void f(int ind, string &s, string temp, vector<string>& ans, set<string>& dict) {\n        if(ind == s.length()) {\n            temp.pop_back(); // pop the trailing space\n            ans.push_back(temp);\n            return;\n        }\n        \n        string cur = \"\";\n        for(int i = ind; i < s.length(); i++) {\n            cur.push_back(s[i]);\n            if(dict.find(cur) != dict.end()) {\n                f(i+1, s, temp + cur + \" \", ans, dict); // adding current substring \n            }\n        }\n    }",
                "url": "https://leetcode.com/problems/word-break-ii/solutions/2617582/0-ms-efficient-c-solution-simple-recursion/",
                "vote_count": "14"
            }
        ]
    },
    "140": {
        "question_id": 141,
        "title": "Linked List Cycle",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/linked-list-cycle",
        "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.Return true if there is a cycle in the linked list. Otherwise, return false. ",
        "examples": [
            {
                "input": "head = [3,2,0,-4], pos = 1",
                "output": "true",
                "explanation": "There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed)."
            },
            {
                "input": "head = [1,2], pos = 0",
                "output": "true",
                "explanation": "There is a cycle in the linked list, where the tail connects to the 0th node."
            },
            {
                "input": "head = [1], pos = -1",
                "output": "false",
                "explanation": "There is no cycle in the linked list."
            }
        ],
        "constraints": [
            "The number of the nodes in the list is in the range [0, 10^4].",
            "-10^5 <= Node.val <= 10^5",
            "pos is -1 or a valid index in the linked-list."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "1. Easy C++\n2. Line by Line Explanation with Comments.\n3. Detailed Explanation \u2705\n4. Linked list problem, 2 pointer , fast slow / turtle hare algorithm.\n5. Please Upvote if it helps\u2b06\ufe0f\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \u2b07\ufe0f\n // \ud83d\ude09If you Like the repository don't foget to star & fork the repository\ud83d\ude09",
                "url": "https://leetcode.com/problems/linked-list-cycle/solutions/1829489/c-easy-to-understand-2-pointer-fast-slow/",
                "vote_count": "398"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n \n  // if head is NULL then return false;\n        if(head == NULL)\n            return false;\n        \n  // making two pointers fast and slow and assignning them to head\n        ListNode *fast = head;\n        ListNode *slow = head;\n        \n  // till fast and fast-> next not reaches NULL\n  // we will increment fast by 2 step and slow by 1 step\n        while(fast != NULL && fast ->next != NULL)\n        {\n            fast = fast->next->next;\n            slow = slow->next;\n            \n   \n   // At the point if fast and slow are at same address\n   // this means linked list has a cycle in it.\n            if(fast == slow)\n                return true;\n        }\n        \n  // if traversal reaches to NULL this means no cycle.\n        return false;\n    }\n};",
                "url": "https://leetcode.com/problems/linked-list-cycle/solutions/1829489/c-easy-to-understand-2-pointer-fast-slow/",
                "vote_count": "398"
            },
            {
                "language": "ruby",
                "code": "class Solution\n{\npublic:\n    bool hasCycle(ListNode *head)\n    {\n        auto walker = head, runner = head;\n        while (runner && runner->next)\n        {",
                "url": "https://leetcode.com/problems/linked-list-cycle/solutions/1829489/c-easy-to-understand-2-pointer-fast-slow/",
                "vote_count": "398"
            },
            {
                "language": "ruby",
                "code": " while(fast != NULL && fast ->next != NULL)\n {\n          fast = fast->next;\n         if(fast == NULL) break;\n         else if( fast == slow) return true;\n         fast = fast->next;\n         slow = slow->next;",
                "url": "https://leetcode.com/problems/linked-list-cycle/solutions/1829489/c-easy-to-understand-2-pointer-fast-slow/",
                "vote_count": "398"
            },
            {
                "language": "ruby",
                "code": "const hasCycle = (head) => {\n  let fast = head;\n  while (fast && fast.next) {\n    head = head.next;\n    fast = fast.next.next;\n    if (head === fast) return true;\n  }\n  return false;\n};",
                "url": "https://leetcode.com/problems/linked-list-cycle/solutions/1829768/javascript-easy-to-understand-slow-fast-pointers-detailed-explanation/",
                "vote_count": "233"
            },
            {
                "language": "javascript",
                "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */",
                "url": "https://leetcode.com/problems/linked-list-cycle/solutions/1829768/javascript-easy-to-understand-slow-fast-pointers-detailed-explanation/",
                "vote_count": "233"
            },
            {
                "language": "rust",
                "code": "",
                "url": "https://leetcode.com/problems/linked-list-cycle/solutions/1829768/javascript-easy-to-understand-slow-fast-pointers-detailed-explanation/",
                "vote_count": "233"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/linked-list-cycle/solutions/1829768/javascript-easy-to-understand-slow-fast-pointers-detailed-explanation/",
                "vote_count": "233"
            },
            {
                "language": "ruby",
                "code": "",
                "url": "https://leetcode.com/problems/linked-list-cycle/solutions/1829768/javascript-easy-to-understand-slow-fast-pointers-detailed-explanation/",
                "vote_count": "233"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/linked-list-cycle/solutions/1829768/javascript-easy-to-understand-slow-fast-pointers-detailed-explanation/",
                "vote_count": "233"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/linked-list-cycle/solutions/1829768/javascript-easy-to-understand-slow-fast-pointers-detailed-explanation/",
                "vote_count": "233"
            },
            {
                "language": "javascript",
                "code": "const hasCycle = (head) => {\n   let slow = new ListNode(-1), fast = new ListNode(-1);\n   slow = head;\n   fast = head;\n   while (fast !== null) {\n        fast = fast.next;\n        if (slow === fast) return true;\n        slow = slow.next;",
                "url": "https://leetcode.com/problems/linked-list-cycle/solutions/1829768/javascript-easy-to-understand-slow-fast-pointers-detailed-explanation/",
                "vote_count": "233"
            },
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        ListNode *slow = head, *fast = head;\n        while (fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) return true;\n        }\n        \n        return false;\n    }\n};",
                "url": "https://leetcode.com/problems/linked-list-cycle/solutions/1829641/c-my-first-c-code-explained/",
                "vote_count": "114"
            },
            {
                "language": "kotlin",
                "code": "Method 1\n\n//Using hashing\n//Here we will chech if the node we have visisted is present or not if we have visited it then it mean there is cycle.\n\n//Time complexity: O(n)\n//Space complexity: O(n)",
                "url": "https://leetcode.com/problems/linked-list-cycle/solutions/1829641/c-my-first-c-code-explained/",
                "vote_count": "114"
            },
            {
                "language": "kotlin",
                "code": "",
                "url": "https://leetcode.com/problems/linked-list-cycle/solutions/1829641/c-my-first-c-code-explained/",
                "vote_count": "114"
            },
            {
                "language": "javascript",
                "code": "var hasCycle = function(head) {\n    let fast = head;\n\n    while (fast && fast.next) {\n        head = head.next;\n        fast = fast.next.next;\n        if (head == fast) return true;\n    }",
                "url": "https://leetcode.com/problems/linked-list-cycle/solutions/1829641/c-my-first-c-code-explained/",
                "vote_count": "114"
            },
            {
                "language": "kotlin",
                "code": "while(head){\n            if(head->val == INT_MIN)     return true;\n            head->val = INT_MIN;\n            head = head->next;\n        }\n        return false;",
                "url": "https://leetcode.com/problems/linked-list-cycle/solutions/1829641/c-my-first-c-code-explained/",
                "vote_count": "114"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n  ListNode *floydcycle(ListNode *head)\n  {\n      if(head==NULL)\n      {return NULL;}\n\n      ListNode *slow=head;\n      ListNode *fast=head;\n      \n      while(slow!=NULL && fast!=NULL)\n      {\n          fast=fast->next;\n          if(fast!=NULL)\n          fast=fast->next;\n          slow=slow->next;\n          if(slow==fast)\n          return slow;\n      }\n      return NULL;\n\n  }\n    bool hasCycle(ListNode *head) {\n     return floydcycle(head);\n    }\n};",
                "url": "https://leetcode.com/problems/linked-list-cycle/solutions/3171266/solution/",
                "vote_count": "41"
            }
        ]
    },
    "141": {
        "question_id": 142,
        "title": "Linked List Cycle II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/linked-list-cycle-ii",
        "description": "Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.Do not modify the linked list. ",
        "examples": [
            {
                "input": "head = [3,2,0,-4], pos = 1",
                "output": "tail connects to node index 1",
                "explanation": "There is a cycle in the linked list, where tail connects to the second node."
            },
            {
                "input": "head = [1,2], pos = 0",
                "output": "tail connects to node index 0",
                "explanation": "There is a cycle in the linked list, where tail connects to the first node."
            },
            {
                "input": "head = [1], pos = -1",
                "output": "no cycle",
                "explanation": "There is no cycle in the linked list."
            }
        ],
        "constraints": [
            "The number of the nodes in the list is in the range [0, 10^4].",
            "-10^5 <= Node.val <= 10^5",
            "pos is -1 or a valid index in the linked-list."
        ],
        "solutions": [
            {
                "language": "",
                "code": "Time  Complexity: O(N)\nSpace Complexity: O(1)",
                "url": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/1701128/c-java-python-slow-and-fast-image-explanation-beginner-friendly/",
                "vote_count": "822"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def detectCycle(self, head):\n        slow = fast = head\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n            if slow == fast: break\n        else: return None  # if not (fast and fast.next): return None\n        while head != slow:\n            head, slow = head.next, slow.next\n        return head",
                "url": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/1701128/c-java-python-slow-and-fast-image-explanation-beginner-friendly/",
                "vote_count": "822"
            },
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head, *fast = head;\n        while (fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) break;\n        }\n        if (!(fast && fast->next)) return NULL;\n        while (head != slow) {\n            head = head->next;\n            slow = slow->next;\n        }\n        return head;\n    }\n};",
                "url": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/1701128/c-java-python-slow-and-fast-image-explanation-beginner-friendly/",
                "vote_count": "822"
            },
            {
                "language": "kotlin",
                "code": "public class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) break;\n        }\n        if (fast == null || fast.next == null) return null;\n        while (head != slow) {\n            head = head.next;\n            slow = slow.next;\n        }\n        return head;\n    }\n}",
                "url": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/1701128/c-java-python-slow-and-fast-image-explanation-beginner-friendly/",
                "vote_count": "822"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/1701128/c-java-python-slow-and-fast-image-explanation-beginner-friendly/",
                "vote_count": "822"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return None\n        if head.next is head:",
                "url": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/1701128/c-java-python-slow-and-fast-image-explanation-beginner-friendly/",
                "vote_count": "822"
            },
            {
                "language": "rust",
                "code": "1 -> 2 -> 3 -> 4 -> 5 -> 2",
                "url": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/3274329/clean-codes-full-explanation-floyd-s-cycle-finding-algorithm-c-java-python3/",
                "vote_count": "122"
            },
            {
                "language": "",
                "code": "N*c+b=2*b\nN*c=b",
                "url": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/3274412/c-easy-solution-floyd-cycle-approach-heavily-commented/",
                "vote_count": "10"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(!head||!head->next)return nullptr;\n        ListNode*hare=head,*tor=head;\n  //we will find the intersecting point of hare and tor\n        do{\n            hare=hare->next->next;\n            tor=tor->next;\n        }while(tor!=hare&&hare&&hare->next);\n  \n  //check if the cycle is there or not\n        if(!hare||!hare->next){\n            return nullptr;\n        }\n        else{\n  //if present then we will take tor to the head\n            tor=head;\n   //while they dont meet again we will increment distance by one \n            while(hare!=tor){\n                hare=hare->next;\n                tor=tor->next;\n            }\n        }\n  //returning the tor\n        return tor;\n    }\n};",
                "url": "https://leetcode.com/problems/linked-list-cycle-ii/solutions/3274412/c-easy-solution-floyd-cycle-approach-heavily-commented/",
                "vote_count": "10"
            }
        ]
    },
    "142": {
        "question_id": 143,
        "title": "Reorder List",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/reorder-list",
        "description": "You are given the head of a singly linked-list. The list can be represented as:L0 \u2192 L1 \u2192 \u2026 \u2192 Ln - 1 \u2192 LnReorder the list to be on the following form:L0 \u2192 Ln \u2192 L1 \u2192 Ln - 1 \u2192 L2 \u2192 Ln - 2 \u2192 \u2026You may not modify the values in the list's nodes. Only nodes themselves may be changed. ",
        "examples": [
            {
                "input": "head = [1,2,3,4]",
                "output": "[1,4,2,3]",
                "explanation": null
            },
            {
                "input": "head = [1,2,3,4,5]",
                "output": "[1,5,2,4,3]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is in the range [1, 5 * 10^4].",
            "1 <= Node.val <= 1000"
        ],
        "solutions": [
            {
                "language": "typescript",
                "code": "public void reorderList(ListNode head) {\n            if(head==null||head.next==null) return;\n            \n            //Find the middle of the list\n            ListNode p1=head;\n            ListNode p2=head;\n            while(p2.next!=null&&p2.next.next!=null){ \n                p1=p1.next;\n                p2=p2.next.next;\n            }\n            \n            //Reverse the half after middle  1->2->3->4->5->6 to 1->2->3->6->5->4\n            ListNode preMiddle=p1;\n            ListNode preCurrent=p1.next;\n            while(preCurrent.next!=null){\n                ListNode current=preCurrent.next;\n                preCurrent.next=current.next;\n                current.next=preMiddle.next;\n                preMiddle.next=current;\n            }\n            \n            //Start reorder one by one  1->2->3->6->5->4 to 1->6->2->5->3->4\n            p1=head;\n            p2=preMiddle.next;\n            while(p1!=preMiddle){\n                preMiddle.next=p2.next;\n                p2.next=p1.next;\n                p1.next=p2;\n                p1=p2.next;\n                p2=preMiddle.next;\n            }\n        }",
                "url": "https://leetcode.com/problems/reorder-list/solutions/44992/java-solution-with-3-steps/",
                "vote_count": "587"
            },
            {
                "language": "java",
                "code": "    public void reorderList(ListNode head) {\n        if (head == null) {\n            return;\n        }\n        \n        // Find the middle node\n        ListNode slow = head, fast = head.next;\n        while (fast != null && fast.next != null) {",
                "url": "https://leetcode.com/problems/reorder-list/solutions/44992/java-solution-with-3-steps/",
                "vote_count": "587"
            },
            {
                "language": "csharp",
                "code": "public void reorderList(ListNode head) {\n        HashMap<Integer,ListNode> map = new HashMap<>();\n        for(int i = 1;head != null;head = head.next,i++){\n            map.put(i,head);\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        for(int i = 1,j = map.size();i <= j;i++,j--){   //1,2,3,4",
                "url": "https://leetcode.com/problems/reorder-list/solutions/44992/java-solution-with-3-steps/",
                "vote_count": "587"
            },
            {
                "language": "java",
                "code": "    public void ReorderList(ListNode head) \n    {\n        if (head == null) return;\n        ListNode head2 = Split(head);\n        head2 = Reverse(head2);\n        Merge(head, head2);\n    }\n    ",
                "url": "https://leetcode.com/problems/reorder-list/solutions/44992/java-solution-with-3-steps/",
                "vote_count": "587"
            },
            {
                "language": "java",
                "code": "    public void reorderList(ListNode head) {\n        \n        Stack<ListNode> stack = new Stack<>();\n        ListNode curr = head;\n        while (curr != null) {\n            stack.push(curr);\n            curr = curr.next;",
                "url": "https://leetcode.com/problems/reorder-list/solutions/44992/java-solution-with-3-steps/",
                "vote_count": "587"
            },
            {
                "language": "java",
                "code": "    public void reorderList(ListNode head) {\n        if (head == null) {\n            return;\n        }\n\n        //find preMiddle of the list\n        ListNode left = head;\n        ListNode right = head;",
                "url": "https://leetcode.com/problems/reorder-list/solutions/44992/java-solution-with-3-steps/",
                "vote_count": "587"
            },
            {
                "language": "java",
                "code": " public void reorderList(ListNode head) {\n  if(head == null) return;\n\n  ListNode slow = head, fast = head;\n  while(fast.next != null && fast.next.next != null){",
                "url": "https://leetcode.com/problems/reorder-list/solutions/44992/java-solution-with-3-steps/",
                "vote_count": "587"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def reorderList(self, head):\n        #step 1: find middle\n        if not head: return []\n        slow, fast = head, head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        #step 2: reverse second half\n        prev, curr = None, slow.next\n        while curr:\n            nextt = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nextt    \n        slow.next = None\n        \n        #step 3: merge lists\n        head1, head2 = head, prev\n        while head2:\n            nextt = head1.next\n            head1.next = head2\n            head1 = head2\n            head2 = nextt",
                "url": "https://leetcode.com/problems/reorder-list/solutions/801883/python-3-steps-to-success-explained/",
                "vote_count": "535"
            },
            {
                "language": "python",
                "code": "        head1 ,head2 = head, prev\n        while head1 and head2:\n            nxt1 = head1.next\n            nxt2 = head2.next\n\n            head1.next = head2\n            head1 = nxt1",
                "url": "https://leetcode.com/problems/reorder-list/solutions/801883/python-3-steps-to-success-explained/",
                "vote_count": "535"
            },
            {
                "language": "python",
                "code": "h1 = head\nh2 = reverseHead\nwhile h2.next:\n    temp = h2.next\n    h2.next = h1.next\n    h1.next = h2\n    h1 = h1.next.next\n    h2 = temp",
                "url": "https://leetcode.com/problems/reorder-list/solutions/801883/python-3-steps-to-success-explained/",
                "vote_count": "535"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void reorderList(ListNode* head) {\n        if ((!head) || (!head->next) || (!head->next->next)) return; // Edge cases\n        \n        stack<ListNode*> my_stack;\n        ListNode* ptr = head;\n        int size = 0;\n        while (ptr != NULL) // Put all nodes in stack\n        {\n            my_stack.push(ptr);\n            size++;\n            ptr = ptr->next;\n        }\n        \n        ListNode* pptr = head;\n        for (int j=0; j<size/2; j++) // Between every two nodes insert the one in the top of the stack\n        {\n            ListNode *element = my_stack.top();\n            my_stack.pop();\n            element->next = pptr->next;\n            pptr->next = element;\n            pptr = pptr->next->next;\n        }\n        pptr->next = NULL;\n    }\n};",
                "url": "https://leetcode.com/problems/reorder-list/solutions/802119/c-really-simple-solution-using-stack-with-explanations/",
                "vote_count": "377"
            },
            {
                "language": "cpp",
                "code": "#define nul     NULL\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        if (!head) {\n            return;\n        }",
                "url": "https://leetcode.com/problems/reorder-list/solutions/802119/c-really-simple-solution-using-stack-with-explanations/",
                "vote_count": "377"
            },
            {
                "language": "rust",
                "code": "//Upvote  and Comment\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        //base case i.e if the linked list has zero,one or two elments just return it\n        if(!head || !head->next || !head->next->next) return;\n        \n        //Find the penultimate node i.e second last node of the linkedlist\n        ListNode* penultimate = head;\n        while (penultimate->next->next) penultimate = penultimate->next;\n        \n        // Link the penultimate with the second element\n        penultimate->next->next = head->next;\n        head->next = penultimate->next;\n        \n        //Again set the penultimate to the the last \n        penultimate->next = NULL;\n        \n        // Do the above steps rcursive\n        reorderList(head->next->next);\n    }\n};",
                "url": "https://leetcode.com/problems/reorder-list/solutions/1640556/c-easy-to-solve-beginner-friendly-with-detailed-explanation-and-dry-run/",
                "vote_count": "127"
            },
            {
                "language": "csharp",
                "code": "Linked list:[1,2,3,4,5]\n* search for the central element, which will be three in our case\n* split the list in two halfes that will be [1,2,3] and [4,5]\n* Now reverse the second half that will be [5,4]\n* Now merge both the halfes \n[1,2,3]\n [5,4]\n=>[1,5,2,4,3]\n\n**See told you it's easy to understand**",
                "url": "https://leetcode.com/problems/reorder-list/solutions/1640556/c-easy-to-solve-beginner-friendly-with-detailed-explanation-and-dry-run/",
                "vote_count": "127"
            },
            {
                "language": "rust",
                "code": "//Upvote and Comment\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        // base case : linkedlist is empty\n        if (!head) return;\n        \n        // finding the middle with the help of two pointer approach\n        ListNode *tmp = head, *half = head, *prev = NULL;\n        while (tmp->next && tmp->next->next) {\n            tmp = tmp->next->next;\n            half = half->next;\n        }\n        \n        // adding one bit in case of lists with even length\n        if (tmp->next) half = half->next;\n        \n        // Now reverse the second half\n        while (half) {\n            tmp = half->next;\n            half->next = prev;\n            prev = half;\n            half = tmp;\n        }\n        half = prev;\n        \n        // After reversing the second half, let's merge both the halfes\n        while (head && half) {\n            tmp = head->next;\n            prev = half->next;\n            head->next = half;\n            half->next = tmp;\n            head = tmp;\n            half = prev;\n        }\n        \n        // Base case : closing when we had even length arrays\n        if (head && head->next) head->next->next = NULL;\n    }\n};",
                "url": "https://leetcode.com/problems/reorder-list/solutions/1640556/c-easy-to-solve-beginner-friendly-with-detailed-explanation-and-dry-run/",
                "vote_count": "127"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    ListNode* getMiddle(ListNode* head){\n        ListNode* slow=head;\n        ListNode* fast=head;\n        while(fast && fast->next){\n           slow=slow->next;\n           fast=fast->next->next;   ",
                "url": "https://leetcode.com/problems/reorder-list/solutions/1640556/c-easy-to-solve-beginner-friendly-with-detailed-explanation-and-dry-run/",
                "vote_count": "127"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void reorderList(ListNode* head) {\n        vector<ListNode*> arr;\n        for(auto iter = head; iter; iter = iter -> next)\n            arr.push_back(iter);\n        \n  // pointers to start and end of list. Re-order in alternating fashion from both end\n        int L = 1, R = size(arr)-1;\n        for(int i = 0; i < size(arr); i++, head = head -> next) \n            if(i & 1)                             // odd iteration:\n                head -> next = arr[L++];          //        - pick node from L & update L ptr\n            else                                  // even iteration\n                head -> next = arr[R--];          //        - pick node from R & update R ptr\n        \n        head -> next = nullptr;\n    }\n};",
                "url": "https://leetcode.com/problems/reorder-list/solutions/1641006/c-python-simple-solutions-w-explanation-2-pointers-o-n-inplace-o-1-space-approaches/",
                "vote_count": "111"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def reorderList(self, head):\n        arr, Iter = [], head\n        while Iter:\n            arr.append(Iter)\n            Iter = Iter.next\n        \n        L, R = 1, len(arr)-1\n        for i in range(len(arr)):\n            if i & 1:\n                head.next = arr[L]\n                L += 1\n            else:\n                head.next = arr[R]\n                R -= 1\n            head = head.next\n        head.next = None",
                "url": "https://leetcode.com/problems/reorder-list/solutions/1641006/c-python-simple-solutions-w-explanation-2-pointers-o-n-inplace-o-1-space-approaches/",
                "vote_count": "111"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n // 876. Middle of the Linked List - returns the mid of list using slow-fast pointer approach\n    ListNode* middleNode(ListNode* head) {\n        auto slow = head, fast = head;\n        while(fast && fast -> next)\n            slow = slow -> next,\n            fast = fast -> next -> next;            // fast moves at 2x speed\n        return slow;                                // slow ends up at mid\n    }\n // 206. Reverse Linked List - reverses and returns the head of reversed list\n    ListNode* reverseList(ListNode* head) {\n        ListNode *prev = nullptr;\n        while(head) {\n            auto nextNode = head -> next;           // store next node before reversing next ptr of cur\n            head -> next = prev;                    // reverse the next ptr to previous node\n            prev = head;                            // update previous node as cur\n            head = nextNode;                        // move to orignal next node\n        }\n        return prev;                                // returns head of reversed list\n    }\n    void reorderList(ListNode* head) {\n        if(!head || !head -> next) return;\n        auto mid = middleNode(head);\n        auto R = reverseList(mid), L = head -> next;\n        for(int i = 0; L != R; i++, head = head -> next)     // re-order in alternating fashion \n            if(i & 1) {                              \n                head -> next = L;\n                L = L -> next;\n            }\n            else {\n                head -> next = R;\n                R = R -> next;\n            }\n    }\n};",
                "url": "https://leetcode.com/problems/reorder-list/solutions/1641006/c-python-simple-solutions-w-explanation-2-pointers-o-n-inplace-o-1-space-approaches/",
                "vote_count": "111"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def reorderList(self, head):\n        def middleNode(head):\n            slow, fast = head, head\n            while fast and fast.next:\n                slow = slow.next\n                fast = fast.next.next\n            return slow\n        \n        def reverseList(head):\n            prev = None\n            while head:\n                nextNode = head.next\n                head.next = prev\n                prev, head = head, nextNode\n            return prev\n\n        if not head or not head.next: return\n        R, L, i = reverseList(middleNode(head)), head.next, 0\n        while L != R:\n            if i & 1:\n                head.next, L = L, L.next\n            else:\n                head.next, R = R, R.next\n            head, i = head.next, i + 1",
                "url": "https://leetcode.com/problems/reorder-list/solutions/1641006/c-python-simple-solutions-w-explanation-2-pointers-o-n-inplace-o-1-space-approaches/",
                "vote_count": "111"
            },
            {
                "language": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public void reorderList(ListNode head) {\n        // if head will be null or head.next will be null simply return ;\n        if(head==null || head.next==null)return ;\n\n  //finding middle element\n        ListNode slow = head;\n        ListNode fast= head;\n        while(fast!=null && fast.next!=null){\n            slow=slow.next;\n            fast=fast.next.next;\n        }\n       \n// reversing the second half of the list\n       ListNode newNode = reverseList(slow.next);\n      // breaking the list from the middle\n        slow.next=null;\n   //merging both list\n       //first half list pointer\n       ListNode curr = head;\n       //second half list pointer\n       ListNode dummy = newNode;\n       while(head!=null && dummy!=null){\n             //pointer to store next element of curr(1st half list)\n           ListNode temp = curr.next;\n           //link element of 1st half to that of second half\n           curr.next=dummy;\n           //pointer to store next element of dummy(2nd half list)\n           ListNode temp2=dummy.next;\n           //link the rest of the first half list\n           dummy.next=temp;\n           //increment curr and dummy pointer to do the same thing again and again util we reach end of the any one list or both list\n           curr=temp;\n           dummy=temp2;\n       }\n\n    }\n\n   // method to reverse the linkedList\n    public ListNode reverseList(ListNode node){\n        ListNode prev = null;\n        ListNode curr = node;\n        ListNode next = null;\n        while(curr!=null){\n            next=curr.next;\n            curr.next=prev;\n            prev=curr;\n            curr=next;\n        }\n         \n        return prev;\n    }\n}",
                "url": "https://leetcode.com/problems/reorder-list/solutions/3148599/easily-expalined-step-by-step-code-100-beats-and-0ms-runtime/",
                "vote_count": "29"
            }
        ]
    },
    "143": {
        "question_id": 144,
        "title": "Binary Tree Preorder Traversal",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/binary-tree-preorder-traversal",
        "description": "Given the root of a binary tree, return the preorder traversal of its nodes' values. ",
        "examples": [
            {
                "input": "root = [1,null,2,3]",
                "output": "[1,2,3]",
                "explanation": null
            },
            {
                "input": "root = []",
                "output": "[]",
                "explanation": null
            },
            {
                "input": "root = [1]",
                "output": "[1]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [0, 100].",
            "-100 <= Node.val <= 100"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int>ans;\n    vector<int> preorderTraversal(TreeNode* root) {\n        if(root){\n            ans.push_back(root->val);\n            preorderTraversal(root->left);\n            preorderTraversal(root->right);\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022021/c-easy-beats100-3-approach-with-explaination/",
                "vote_count": "85"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode* root) {\n        vector<int> ans;\n        stack<TreeNode*>st;\n        while (root || !st.empty()) {\n            if (root) {\n                ans.push_back(root -> val);\n                if (root -> right) {\n                    st.push(root -> right);\n                }\n                root = root -> left;\n            } else {\n                root = st.top();\n                st.pop();\n            }\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022021/c-easy-beats100-3-approach-with-explaination/",
                "vote_count": "85"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode* root) {\n        vector<int> nodes;\n        while (root) {\n            if (root -> left) {\n                TreeNode* pre = root -> left;\n                while (pre -> right && pre -> right != root) {\n                    pre = pre -> right;\n                }\n                if (!pre -> right) {\n                    pre -> right = root;\n                    nodes.push_back(root -> val);\n                    root = root -> left;\n                } else {\n                    pre -> right = NULL;\n                    root = root -> right;\n                }\n            } else {\n                nodes.push_back(root -> val);\n                root = root -> right;\n            }\n        }\n        return nodes;\n    }\n};",
                "url": "https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022021/c-easy-beats100-3-approach-with-explaination/",
                "vote_count": "85"
            }
        ]
    },
    "144": {
        "question_id": 145,
        "title": "Binary Tree Postorder Traversal",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/binary-tree-postorder-traversal",
        "description": "Given the root of a binary tree, return the postorder traversal of its nodes' values. ",
        "examples": [
            {
                "input": "root = [1,null,2,3]",
                "output": "[3,2,1]",
                "explanation": null
            },
            {
                "input": "root = []",
                "output": "[]",
                "explanation": null
            },
            {
                "input": "root = [1]",
                "output": "[1]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of the nodes in the tree is in the range [0, 100].",
            "-100 <= Node.val <= 100"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "public List<Integer> preorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    Deque<TreeNode> stack = new ArrayDeque<>();\n    TreeNode p = root;\n    while(!stack.isEmpty() || p != null) {\n        if(p != null) {\n            stack.push(p);\n            result.add(p.val);  // Add before going to children\n            p = p.left;\n        } else {\n            TreeNode node = stack.pop();\n            p = node.right;   \n        }\n    }\n    return result;\n}",
                "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/solutions/45551/preorder-inorder-and-postorder-iteratively-summarization/",
                "vote_count": "1518"
            },
            {
                "language": "cpp",
                "code": "public List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    Deque<TreeNode> stack = new ArrayDeque<>();\n    TreeNode p = root;\n    while(!stack.isEmpty() || p != null) {\n        if(p != null) {\n            stack.push(p);\n            p = p.left;\n        } else {\n            TreeNode node = stack.pop();\n            result.add(node.val);  // Add after all left children\n            p = node.right;   \n        }\n    }\n    return result;\n}",
                "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/solutions/45551/preorder-inorder-and-postorder-iteratively-summarization/",
                "vote_count": "1518"
            },
            {
                "language": "cpp",
                "code": "public List<Integer> postorderTraversal(TreeNode root) {\n    LinkedList<Integer> result = new LinkedList<>();\n    Deque<TreeNode> stack = new ArrayDeque<>();\n    TreeNode p = root;\n    while(!stack.isEmpty() || p != null) {\n        if(p != null) {\n            stack.push(p);\n            result.addFirst(p.val);  // Reverse the process of preorder\n            p = p.right;             // Reverse the process of preorder\n        } else {\n            TreeNode node = stack.pop();\n            p = node.left;           // Reverse the process of preorder\n        }\n    }\n    return result;\n}",
                "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/solutions/45551/preorder-inorder-and-postorder-iteratively-summarization/",
                "vote_count": "1518"
            },
            {
                "language": "typescript",
                "code": "public class Solution {\n    // Important, when you pop a node, ensure its children are traversed.\n    public List<Integer> postorderTraversal(TreeNode root) {\n        Stack<TreeNode> s = new Stack();\n        List<Integer> ans = new ArrayList<Integer>();\n        TreeNode cur = root;",
                "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/solutions/45551/preorder-inorder-and-postorder-iteratively-summarization/",
                "vote_count": "1518"
            },
            {
                "language": "csharp",
                "code": "//inorder\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res=new ArrayList<>();\n        if (root==null) return res;\n\n        Stack<TreeNode> stack=new Stack<>();\n        TreeNode curr=root;",
                "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/solutions/45551/preorder-inorder-and-postorder-iteratively-summarization/",
                "vote_count": "1518"
            },
            {
                "language": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }",
                "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/solutions/45551/preorder-inorder-and-postorder-iteratively-summarization/",
                "vote_count": "1518"
            },
            {
                "language": "cpp",
                "code": "public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> list = new ArrayList<Integer>();\n        if (root == null) {\n            return list;\n        }\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        TreeNode cur = root;\n        while (cur != null || !stack.isEmpty()) {",
                "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/solutions/45551/preorder-inorder-and-postorder-iteratively-summarization/",
                "vote_count": "1518"
            },
            {
                "language": "java",
                "code": "public List<Integer> postorderTraversal(TreeNode root) {\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        List<Integer> list = new ArrayList<Integer>();\n        TreeNode pre = null;\n        TreeNode current = root;\n        while(current != null || !stack.isEmpty()) {\n            while(current != null) {\n                stack.push(current);",
                "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/solutions/45551/preorder-inorder-and-postorder-iteratively-summarization/",
                "vote_count": "1518"
            },
            {
                "language": "python",
                "code": "def postorder_traversal_iteratively(self, root: 'TreeNode'):\n    if not root:\n        return []\n    stack, res = [root], []\n    # used to record whether left or right child has been visited\n    last = None\n\n    while stack:\n\n):",
                "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/solutions/45551/preorder-inorder-and-postorder-iteratively-summarization/",
                "vote_count": "1518"
            },
            {
                "language": "cpp",
                "code": "public List<Integer> postorderTraversal(TreeNode root) {\n LinkedList<Integer> res = new LinkedList<Integer>();\n if(root == null){\n  return res;\n }\n Stack<TreeNode> stack = new Stack<TreeNode>();\n while(!stack.isEmpty() || root != null){\n  while(root != null){\n   stack.push(root);",
                "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/solutions/45551/preorder-inorder-and-postorder-iteratively-summarization/",
                "vote_count": "1518"
            }
        ]
    },
    "145": {
        "question_id": 146,
        "title": "LRU Cache",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.Implement the LRUCache class:LRUCache(int capacity) Initialize the LRU cache with positive size capacity.int get(int key) Return the value of the key if the key exists, otherwise return -1.void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.The functions get and put must each run in O(1) average time complexity. ",
        "examples": [
            {
                "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4",
                "output": "LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= capacity <= 3000",
            "0 <= key <= 10^4",
            "0 <= value <= 10^5",
            "At most 2 * 10^5 calls will be made to get and put."
        ],
        "solutions": [
            {
                "language": "java",
                "code": "import java.util.Hashtable;\n\n\npublic class LRUCache {\n\nclass DLinkedNode {\n  int key;\n  int value;\n  DLinkedNode pre;\n  DLinkedNode post;\n}\n\n/**\n * Always add the new node right after head;\n */\nprivate void addNode(DLinkedNode node) {\n    \n  node.pre = head;\n  node.post = head.post;\n\n  head.post.pre = node;\n  head.post = node;\n}\n\n/**\n * Remove an existing node from the linked list.\n */\nprivate void removeNode(DLinkedNode node){\n  DLinkedNode pre = node.pre;\n  DLinkedNode post = node.post;\n\n  pre.post = post;\n  post.pre = pre;\n}\n\n/**\n * Move certain node in between to the head.\n */\nprivate void moveToHead(DLinkedNode node){\n  this.removeNode(node);\n  this.addNode(node);\n}\n\n// pop the current tail. \nprivate DLinkedNode popTail(){\n  DLinkedNode res = tail.pre;\n  this.removeNode(res);\n  return res;\n}\n\nprivate Hashtable<Integer, DLinkedNode> \n  cache = new Hashtable<Integer, DLinkedNode>();\nprivate int count;\nprivate int capacity;\nprivate DLinkedNode head, tail;\n\npublic LRUCache(int capacity) {\n  this.count = 0;\n  this.capacity = capacity;\n\n  head = new DLinkedNode();\n  head.pre = null;\n\n  tail = new DLinkedNode();\n  tail.post = null;\n\n  head.post = tail;\n  tail.pre = head;\n}\n\npublic int get(int key) {\n\n  DLinkedNode node = cache.get(key);\n  if(node == null){\n    return -1; // should raise exception here.\n  }\n\n  // move the accessed node to the head;\n  this.moveToHead(node);\n\n  return node.value;\n}\n\n\npublic void put(int key, int value) {\n  DLinkedNode node = cache.get(key);\n\n  if(node == null){\n\n    DLinkedNode newNode = new DLinkedNode();\n    newNode.key = key;\n    newNode.value = value;\n\n    this.cache.put(key, newNode);\n    this.addNode(newNode);\n\n    ++count;\n\n    if(count > capacity){\n      // pop the tail\n      DLinkedNode tail = this.popTail();\n      this.cache.remove(tail.key);\n      --count;\n    }\n  }else{\n    // update the value.\n    node.value = value;\n    this.moveToHead(node);\n  }\n}\n\n}",
                "url": "https://leetcode.com/problems/lru-cache/solutions/45911/java-hashtable-double-linked-list-with-a-touch-of-pseudo-nodes/",
                "vote_count": "1171"
            },
            {
                "language": "csharp",
                "code": "class LRUCache {\n  \n  Node head = new Node(0, 0), tail = new Node(0, 0);\n  Map<Integer, Node> map = new HashMap();\n  int capacity;\n  \n  public LRUCache(int _capacity) {\n    capacity = _capacity;\n    head.next = tail;",
                "url": "https://leetcode.com/problems/lru-cache/solutions/45911/java-hashtable-double-linked-list-with-a-touch-of-pseudo-nodes/",
                "vote_count": "1171"
            },
            {
                "language": "java",
                "code": "class LRUCache {\n    LinkedNodeList list;\n    Map<Integer, Node> map;\n    Integer cap;\n    public LRUCache(int capacity) {\n        list = new LinkedNodeList();\n        map = new HashMap(capacity);\n        cap = capacity;",
                "url": "https://leetcode.com/problems/lru-cache/solutions/45911/java-hashtable-double-linked-list-with-a-touch-of-pseudo-nodes/",
                "vote_count": "1171"
            },
            {
                "language": "kotlin",
                "code": "public class LRUCache {\n    private Map<Integer, DLinkNode> cache;\n    DLinkNode tail = null;\n    DLinkNode head = null;\n    int capacity;",
                "url": "https://leetcode.com/problems/lru-cache/solutions/45911/java-hashtable-double-linked-list-with-a-touch-of-pseudo-nodes/",
                "vote_count": "1171"
            },
            {
                "language": "cpp",
                "code": "class Node {\npublic:\n    int key, value;\n    Node *prev, *next;\n    Node() : key(0), value(0), prev(NULL), next(NULL) {}\n    Node(int k, int v): key(k), value(v), prev(NULL), next(NULL) {}\n};",
                "url": "https://leetcode.com/problems/lru-cache/solutions/45911/java-hashtable-double-linked-list-with-a-touch-of-pseudo-nodes/",
                "vote_count": "1171"
            },
            {
                "language": "python",
                "code": "class Node:\ndef __init__(self, k, v):\n    self.key = k\n    self.val = v\n    self.prev = None\n    self.next = None\n\nclass LRUCache:\ndef __init__(self, capacity):\n    self.capacity = capacity\n    self.dic = dict()\n    self.head = Node(0, 0)\n    self.tail = Node(0, 0)\n    self.head.next = self.tail\n    self.tail.prev = self.head\n\ndef get(self, key):\n    if key in self.dic:\n        n = self.dic[key]\n        self._remove(n)\n        self._add(n)\n        return n.val\n    return -1\n\ndef set(self, key, value):\n    if key in self.dic:\n        self._remove(self.dic[key])\n    n = Node(key, value)\n    self._add(n)\n    self.dic[key] = n\n    if len(self.dic) > self.capacity:\n        n = self.head.next\n        self._remove(n)\n        del self.dic[n.key]\n\ndef _remove(self, node):\n    p = node.prev\n    n = node.next\n    p.next = n\n    n.prev = p\n\ndef _add(self, node):\n    p = self.tail.prev\n    p.next = node\n    self.tail.prev = node\n    node.prev = p\n    node.next = self.tail",
                "url": "https://leetcode.com/problems/lru-cache/solutions/45926/python-dict-double-linkedlist/",
                "vote_count": "712"
            },
            {
                "language": "python",
                "code": "class LRUCache:\n    def __init__(self, MSize):\n        self.size = MSize\n        self.cache = {}\n        self.next, self.before = {}, {}\n        self.head, self.tail = '#', '$'\n        self.connect(self.head, self.tail)",
                "url": "https://leetcode.com/problems/lru-cache/solutions/45926/python-dict-double-linkedlist/",
                "vote_count": "712"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/lru-cache/solutions/45926/python-dict-double-linkedlist/",
                "vote_count": "712"
            },
            {
                "language": "python",
                "code": "from collections import OrderedDict\n\nclass LRUCache(object):\n    def __init__(self, capacity):\n        self.array = OrderedDict()",
                "url": "https://leetcode.com/problems/lru-cache/solutions/45926/python-dict-double-linkedlist/",
                "vote_count": "712"
            },
            {
                "language": "python",
                "code": "class Node:\n    def __init__(self, k, v):\n        self.key = k\n        self.val = v\n        self.prev = None\n        self.next = None\n\nclass LRUCache:",
                "url": "https://leetcode.com/problems/lru-cache/solutions/45926/python-dict-double-linkedlist/",
                "vote_count": "712"
            },
            {
                "language": "ruby",
                "code": "class Node:\n    def __init__(self, key=None, val=None):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None",
                "url": "https://leetcode.com/problems/lru-cache/solutions/45926/python-dict-double-linkedlist/",
                "vote_count": "712"
            },
            {
                "language": "ruby",
                "code": "",
                "url": "https://leetcode.com/problems/lru-cache/solutions/45926/python-dict-double-linkedlist/",
                "vote_count": "712"
            },
            {
                "language": "cpp",
                "code": "class LRUCache\n{\n    public:\n        list<pair<int,int>> l;\n        unordered_map<int,list<pair<int, int>>::iterator> m;\n        int size;\n        LRUCache(int capacity)\n        {\n            size=capacity;\n        }\n        int get(int key)\n        {\n            if(m.find(key)==m.end())\n                return -1;\n            l.splice(l.begin(),l,m[key]);\n            return m[key]->second;\n        }\n        void put(int key, int value)\n        {\n            if(m.find(key)!=m.end())\n            {\n                l.splice(l.begin(),l,m[key]);\n                m[key]->second=value;\n                return;\n            }\n            if(l.size()==size)\n            {\n                auto d_key=l.back().first;\n                l.pop_back();\n                m.erase(d_key);\n            }\n            l.push_front({key,value});\n            m[key]=l.begin();\n        }\n};",
                "url": "https://leetcode.com/problems/lru-cache/solutions/792449/simple-c-solution-with-detailed-explanation/",
                "vote_count": "321"
            },
            {
                "language": "ruby",
                "code": "class LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.values = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.values:\n            return -1\n        else:\n            self.values[key] = self.values.pop(key)\n            return self.values[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.values:\n            if len(self.values) == self.capacity:\n                self.values.popitem(last=False)\n        else:\n            self.values.pop(key)\n        self.values[key] = value",
                "url": "https://leetcode.com/problems/lru-cache/solutions/2606056/python-explained-steps-clean-code-best-method/",
                "vote_count": "80"
            },
            {
                "language": "cpp",
                "code": "class LRUCache {\npublic:\n    inline static int M[10001];\n    inline static int16_t L[10002][2];\n    int cap, size = 0;\n    const int NONE = 10001;\n    int head = NONE, tail = NONE;\n    \n    LRUCache(int capacity) : cap(capacity) {\n        memset(M, 0xff, sizeof M);\n    }\n    \n    inline void erase(int key) {\n        const int pre = L[key][0];\n        const int nxt = L[key][1];\n        L[pre][1] = nxt;\n        L[nxt][0] = pre;\n        if (head == key) head = nxt;\n        if (tail == key) tail = pre;\n    }\n    \n    inline void push_front(int key) {\n        L[key][0] = NONE;\n        L[key][1] = head;\n        L[head][0] = key;\n        head = key;\n        if (tail == NONE)\n            tail = key;\n    }\n    \n    inline int pop_back() {\n        int ret = tail;\n        tail = L[tail][0];\n        L[tail][1] = NONE;\n        if (tail == NONE)\n            head = NONE;\n        return ret;\n    }\n    \n    int get(int key) {\n        if (M[key] == -1) return -1;\n        erase(key);\n        push_front(key);\n        return M[key];\n    }\n    \n    void put(int key, int value) {\n        if (M[key] != -1) {\n            erase(key);\n        } else {\n            if (size == cap) {\n                int poped = pop_back();\n                M[poped] = -1;\n                size -= 1;\n            }\n            size += 1;\n        }\n        push_front(key);\n        M[key] = value;\n    }\n};\n\n#include <unistd.h>\nstatic char buf[20000000];\n\nint mgetchar() {\n    static int pos = 0;\n    pos++;\n    return buf[pos-1] == '\\0' ? EOF : buf[pos-1];\n}\n\nint getmethod() {\n    int c = mgetchar();\n    while (mgetchar() != '\"');\n    return c;\n}\n\nint getinput(vector<int>& ret) {\n    int c;\n    while((c = mgetchar()) != EOF && c != '[');\n    while ((c = mgetchar()) != EOF) {\n        if (c == '\"')\n            ret.push_back(getmethod());\n        else if (c == ']')\n            return 1;\n    }\n    return 0;\n}\n\nint getone() {\n    while(mgetchar() != '[');\n    int ans = 0, c;\n    while((c = mgetchar()) != ']') {\n        if (isdigit(c))\n            ans = ans * 10 + c - '0';\n    }\n    return ans;\n}\n\npair<int,int> gettwo() {\n    while(mgetchar() != '[');\n    pair<int,int> ans;\n    int c;\n    while((c = mgetchar()) != ',') {\n        if (isdigit(c))\n            ans.first = ans.first * 10 + c - '0';\n    }\n    while((c = mgetchar()) != ']') {\n        if (isdigit(c))\n            ans.second = ans.second * 10 + c - '0';\n    }\n    return ans;\n}\n\nvoid getpara(FILE *fp, vector<int>& funcs) {\n    while(mgetchar() != '[');\n    fprintf(fp, \"[\");\n    LRUCache lru(getone());\n    for (int i = 0; i < funcs.size(); i++) {\n        auto f = funcs[i];\n        if (f == 'L') {\n            fprintf(fp, \"null\");\n        } else if (f == 'g') {\n            int v = lru.get(getone());\n            fprintf(fp, \"%d\", v);\n        } else {\n            pair<int,int> v = gettwo();\n            lru.put(v.first, v.second);\n            fprintf(fp, \"null\");\n        }\n        if (i + 1 < funcs.size())\n            fprintf(fp, \",\");\n    }\n    while(mgetchar() != ']');\n    fprintf(fp, \"]\\n\");\n}\n\nint main() {\n    int n = read(0, buf, 20000000);\n    buf[n] = '\\0';\n\n    FILE *fp = fopen(\"user.out\", \"w\");\n    vector<int> funcs;\n    while (getinput(funcs)) {\n        getpara(fp, funcs);\n        funcs.clear();\n    }\n    fclose(fp);\n}",
                "url": "https://leetcode.com/problems/lru-cache/solutions/3171305/solution/",
                "vote_count": "28"
            },
            {
                "language": "cpp",
                "code": "LRUCache(int capacity) {\n        ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);\n    }",
                "url": "https://leetcode.com/problems/lru-cache/solutions/2603579/tle-issue-solved/",
                "vote_count": "19"
            },
            {
                "language": "cpp",
                "code": "class LRUCache {\npublic:\n    int cap, size;\n    unordered_map<int, list<pair<int, int>>::iterator> mp;\n    list<pair<int, int>> dq;\n    LRUCache(int capacity) {\n        ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);\n        cap = capacity;\n        size = 0;\n    }\n    \n    int get(int key) {\n        if(mp.find(key) == mp.end())\n            return -1;\n        int val = mp[key]->second;\n        dq.erase(mp[key]);\n        dq.push_front({key, val});\n        mp[key] = dq.begin();\n        return val;\n    }\n    \n    void put(int key, int value) {\n        if(mp.find(key) != mp.end()) {\n            dq.erase(mp[key]);\n            size--;\n        }\n        dq.push_front({key, value});\n        mp[key] = dq.begin();\n        size++;\n        \n        if(size > cap) {\n            int k = dq.back().first;\n            mp.erase(k);\n            dq.pop_back();\n            size--;\n        }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */",
                "url": "https://leetcode.com/problems/lru-cache/solutions/2603579/tle-issue-solved/",
                "vote_count": "19"
            }
        ]
    },
    "146": {
        "question_id": 147,
        "title": "Insertion Sort List",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/insertion-sort-list",
        "description": "Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head.The steps of the insertion sort algorithm:Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.It repeats until no input elements remain.The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration. ",
        "examples": [
            {
                "input": "head = [4,2,1,3]",
                "output": "[1,2,3,4]",
                "explanation": null
            },
            {
                "input": "head = [-1,5,3,4,0]",
                "output": "[-1,0,3,4,5]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is in the range [1, 5000].",
            "-5000 <= Node.val <= 5000"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "public ListNode insertionSortList(ListNode head) {\n  if( head == null ){\n   return head;\n  }\n  \n  ListNode helper = new ListNode(0); //new starter of the sorted list\n  ListNode cur = head; //the node will be inserted\n  ListNode pre = helper; //insert node between pre and pre.next\n  ListNode next = null; //the next node will be inserted\n  //not the end of input list\n  while( cur != null ){\n   next = cur.next;\n   //find the right place to insert\n   while( pre.next != null && pre.next.val < cur.val ){\n    pre = pre.next;\n   }\n   //insert between pre and pre.next\n   cur.next = pre.next;\n   pre.next = cur;\n   pre = helper;\n   cur = next;\n  }\n  \n  return helper.next;\n }",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/46420/an-easy-and-clear-way-to-sort-o-1-space/",
                "vote_count": "377"
            },
            {
                "language": "java",
                "code": "public ListNode insertionSortList(ListNode head) {\n     ListNode dummy = new ListNode(0);\n     ListNode prev = dummy;\n\n    while (head != null) {\n        ListNode temp = head.next;\n        ",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/46420/an-easy-and-clear-way-to-sort-o-1-space/",
                "vote_count": "377"
            },
            {
                "language": "rust",
                "code": "    ListNode *h=new ListNode(0);\n    ListNode *cur=head;",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/46420/an-easy-and-clear-way-to-sort-o-1-space/",
                "vote_count": "377"
            },
            {
                "language": "ruby",
                "code": "ListNode *insertionSortList(ListNode *head) {\n    ListNode result(INT_MIN);\n    \n    while (head) {\n        ListNode* iter = &result;\n        while (iter->next && iter->next->val < head->val) {\n            iter = iter->next;\n        }",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/46420/an-easy-and-clear-way-to-sort-o-1-space/",
                "vote_count": "377"
            },
            {
                "language": "kotlin",
                "code": "public ListNode insertionSortList(ListNode head) {\n        if(head == null) return head;\n        ListNode prev = new ListNode(0);\n        prev.next = head;\n        ListNode curr = head;\n        while(curr.next != null){",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/46420/an-easy-and-clear-way-to-sort-o-1-space/",
                "vote_count": "377"
            },
            {
                "language": "rust",
                "code": "Given 1 -> 3 -> 2 -> 4 - > null\n\ndummy0 -> 1 -> 3 -> 2 -> 4 - > null\n               |    |\n              ptr toInsert\n-- locate ptr = 3 by (ptr.val > ptr.next.val)\n-- locate toInsert = ptr.next\n\ndummy0 -> 1 -> 3 -> 2 -> 4 - > null\n          |         |\n   toInsertPre     toInsert\n-- locate preInsert = 1 by preInsert.next.val > toInsert.val\n-- insert toInsert between preInsert and preInsert.next",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/190913/java-python-with-explanations/",
                "vote_count": "138"
            },
            {
                "language": "kotlin",
                "code": "    public ListNode insertionSortList(ListNode ptr) {    \n        if (ptr == null || ptr.next == null)\n            return ptr;\n        \n        ListNode preInsert, toInsert, dummyHead = new ListNode(0);\n        dummyHead.next = ptr;\n\n        while (ptr != null && ptr.next != null) {\n            if (ptr.val <= ptr.next.val) {\n                ptr = ptr.next;\n            } else {      \n                toInsert = ptr.next;\n                // Locate preInsert.\n                preInsert = dummyHead;\n                while (preInsert.next.val < toInsert.val) {\n                    preInsert = preInsert.next;\n                }\n                ptr.next = toInsert.next;\n                // Insert toInsert after preInsert.\n                toInsert.next = preInsert.next;\n                preInsert.next = toInsert;\n            }\n        }\n        \n        return dummyHead.next;\n    }",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/190913/java-python-with-explanations/",
                "vote_count": "138"
            },
            {
                "language": "python",
                "code": "     def insertionSortList(self, head):\n\n        dummyHead = ListNode(0)\n        dummyHead.next = nodeToInsert = head\n        \n        while head and head.next:\n            if head.val > head.next.val:\n                # Locate nodeToInsert.\n                nodeToInsert = head.next\n                # Locate nodeToInsertPre.\n                nodeToInsertPre = dummyHead\n                while nodeToInsertPre.next.val < nodeToInsert.val:\n                    nodeToInsertPre = nodeToInsertPre.next\n                    \n                head.next = nodeToInsert.next\n                # Insert nodeToInsert between nodeToInsertPre and nodeToInsertPre.next.\n                nodeToInsert.next = nodeToInsertPre.next\n                nodeToInsertPre.next = nodeToInsert\n            else:\n                head = head.next\n            \n        return dummyHead.next",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/190913/java-python-with-explanations/",
                "vote_count": "138"
            },
            {
                "language": "ruby",
                "code": "def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next: return head\n        curr, new_head = head, ListNode(0)\n        # link the next of new head to the head\n        new_curr, new_head.next = new_head, head\n        # loop through the list\n        while curr:\n            # check if the values are not ascending",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/190913/java-python-with-explanations/",
                "vote_count": "138"
            },
            {
                "language": "kotlin",
                "code": "var insertionSortList = function (head) {\n  let dummyHead = new ListNode();\n  let nodeToInsert = head;\n  dummyHead.next = nodeToInsert;\n\n  while (head && head.next) {\n    if (head.val > head.next.val) {\n      // pick up `nodeToInsert`",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/190913/java-python-with-explanations/",
                "vote_count": "138"
            },
            {
                "language": "java",
                "code": "for i = 0 to n\n cur = A[i] and j = i - 1\n while j >= 0 and arr[j] > cur:\n  arr[j+1] = arr[j]                     // shift right till we find greater than cur\n  j = j-1\n arr[j+1] = cur                            // insert cur at correct pos",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/1629811/c-python-java-2-simple-solution-w-explanation-swap-values-pointer-manipulation-approaches/",
                "vote_count": "57"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    ListNode* insertionSortList(ListNode* head) {\n        for(auto cur = head; cur; cur = cur -> next) \n            for(auto j = head; j != cur; j = j -> next) \n                if(j -> val > cur -> val) \n                    swap(j -> val, cur -> val);\n        return head;    \n    }\n};",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/1629811/c-python-java-2-simple-solution-w-explanation-swap-values-pointer-manipulation-approaches/",
                "vote_count": "57"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def insertionSortList(self, head):\n        cur = head\n        while cur:\n            j = head\n            while j != cur:\n                if j.val > cur.val: \n                    j.val, cur.val = cur.val, j.val\n                j = j.next\n            cur = cur.next\n        return head",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/1629811/c-python-java-2-simple-solution-w-explanation-swap-values-pointer-manipulation-approaches/",
                "vote_count": "57"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public ListNode insertionSortList(ListNode head) {\n        for(ListNode cur = head; cur != null; cur = cur.next) \n            for(ListNode j = head; j != cur; j = j.next) \n                if(j.val > cur.val)\n                    j.val = j.val ^ cur.val ^ (cur.val = j.val);         // swap       \n        return head;\n    }\n}",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/1629811/c-python-java-2-simple-solution-w-explanation-swap-values-pointer-manipulation-approaches/",
                "vote_count": "57"
            },
            {
                "language": "dart",
                "code": "Consider that we are at cur=2 and we found its correct position is before the node j=3\n\n    jPrev     j            curPrev    cur\n      1   \u2192  '3'  \u2192   4   \u2192   5   \u2192   '2'   \u2192   6              =>   1   \u2192   2   \u2192   3   \u2192   4   \u2192   5   \u2192   6\n\n\n                   2\ufe0f\u20e3\n      \u21b1    \u2192      \u2192      \u2192      \u2192     \u21b4                                                         curPrev    cur\n=>    1   \u2508  '3'  \u2192   4   \u2192   5   \u2508  '2'  \u2508   6               =>    1   \u2192   2   \u2192   3   \u2192   4   \u2192   5   \u2192   6\n              \u2b11   \u2190     \u2190    \u2193       \u21b2       \u2191\n             1\ufe0f\u20e3           \u21b3    \u2192    \u2192    \u2b0f  \n                           3\ufe0f\u20e3",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/1629811/c-python-java-2-simple-solution-w-explanation-swap-values-pointer-manipulation-approaches/",
                "vote_count": "57"
            },
            {
                "language": "rust",
                "code": "class Solution {\npublic:\n    ListNode* insertionSortList(ListNode* head) {\n        auto dummy = new ListNode(INT_MIN, head);\n        for(auto curPrev = head, cur = head -> next; cur;) {\n            auto jPrev = dummy, j = jPrev -> next, curNext = cur -> next;\n            if(cur -> val > curPrev -> val)           // cur already at correct position...so no need to update cur\n                curPrev = cur;                        // only case where curPrev will need to be updated\n            else {\n                while(j -> val < cur -> val)\n                    jPrev = j, j = j -> next;\n                cur -> next = j;                      //  1\ufe0f\u20e3\n                jPrev -> next = cur;                  //  2\ufe0f\u20e3\n                curPrev -> next = curNext;            //  3\ufe0f\u20e3    \n            }\n            cur = curNext;                            // move to next node now     \n        }\n        return dummy -> next;\n    }\n};",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/1629811/c-python-java-2-simple-solution-w-explanation-swap-values-pointer-manipulation-approaches/",
                "vote_count": "57"
            },
            {
                "language": "rust",
                "code": "",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/1629811/c-python-java-2-simple-solution-w-explanation-swap-values-pointer-manipulation-approaches/",
                "vote_count": "57"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def insertionSortList(self, head):\n        dummy, cur_prev, cur = ListNode(-1, head), head, head.next\n        while cur:\n            j_prev, j, cur_next = dummy, dummy.next, cur.next\n            if cur.val > cur_prev.val:\n                cur_prev = cur\n            else:                \n                while j.val < cur.val:\n                    j_prev, j = j, j.next\n                cur.next = j\n                j_prev.next = cur\n                cur_prev.next = cur_next\n            cur = cur_next\n        return dummy.next",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/1629811/c-python-java-2-simple-solution-w-explanation-swap-values-pointer-manipulation-approaches/",
                "vote_count": "57"
            },
            {
                "language": "ruby",
                "code": "class Solution {\n    public ListNode insertionSortList(ListNode head) {\n        ListNode dummy = new ListNode(-1, head), curPrev = head, cur = head.next;\n        while(cur != null) {\n            ListNode jPrev = dummy, j = jPrev.next, curNext = cur.next;\n            if(cur.val > curPrev.val) curPrev = cur;\n            else {\n                while(j.val < cur.val) {\n                    jPrev = j; \n                    j = j.next;\n                }\n                cur.next = j;\n                jPrev.next = cur;\n                curPrev.next = curNext;\n            }\n            cur = curNext;\n        }\n        return dummy.next;\n    }\n}",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/1629811/c-python-java-2-simple-solution-w-explanation-swap-values-pointer-manipulation-approaches/",
                "vote_count": "57"
            },
            {
                "language": "ruby",
                "code": "def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next: return head\n        curr, new_head = head, ListNode(-sys.maxsize)\n        # consider the elements of new list as stream of incoming integers\n        while curr:\n            new_curr, prev = new_head, None\n            # iterate in the new list until we find an element > curr value\n            while new_curr and curr.val > new_curr.val:",
                "url": "https://leetcode.com/problems/insertion-sort-list/solutions/1629811/c-python-java-2-simple-solution-w-explanation-swap-values-pointer-manipulation-approaches/",
                "vote_count": "57"
            }
        ]
    },
    "147": {
        "question_id": 148,
        "title": "Sort List",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/sort-list",
        "description": "Given the head of a linked list, return the list after sorting it in ascending order. ",
        "examples": [
            {
                "input": "head = [4,2,1,3]",
                "output": "[1,2,3,4]",
                "explanation": null
            },
            {
                "input": "head = [-1,5,3,4,0]",
                "output": "[-1,0,3,4,5]",
                "explanation": null
            },
            {
                "input": "head = []",
                "output": "[]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is in the range [0, 5 * 10^4].",
            "-10^5 <= Node.val <= 10^5"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "public class Solution {\n  \n  public ListNode sortList(ListNode head) {\n    if (head == null || head.next == null)\n      return head;\n        \n    // step 1. cut the list to two halves\n    ListNode prev = null, slow = head, fast = head;\n    \n    while (fast != null && fast.next != null) {\n      prev = slow;\n      slow = slow.next;\n      fast = fast.next.next;\n    }\n    \n    prev.next = null;\n    \n    // step 2. sort each half\n    ListNode l1 = sortList(head);\n    ListNode l2 = sortList(slow);\n    \n    // step 3. merge l1 and l2\n    return merge(l1, l2);\n  }\n  \n  ListNode merge(ListNode l1, ListNode l2) {\n    ListNode l = new ListNode(0), p = l;\n    \n    while (l1 != null && l2 != null) {\n      if (l1.val < l2.val) {\n        p.next = l1;\n        l1 = l1.next;\n      } else {\n        p.next = l2;\n        l2 = l2.next;\n      }\n      p = p.next;\n    }\n    \n    if (l1 != null)\n      p.next = l1;\n    \n    if (l2 != null)\n      p.next = l2;\n    \n    return l.next;\n  }\n\n}",
                "url": "https://leetcode.com/problems/sort-list/solutions/46714/java-merge-sort-solution/",
                "vote_count": "806"
            },
            {
                "language": "javascript",
                "code": "var sortList = function(head) {\n    if (!head || !head.next) return head;\n    let slow = head;\n    let fast = head.next;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }",
                "url": "https://leetcode.com/problems/sort-list/solutions/46714/java-merge-sort-solution/",
                "vote_count": "806"
            },
            {
                "language": "cpp",
                "code": "/**\n * Merge sort use bottom-up policy, \n * so Space Complexity is O(1)\n * Time Complexity is O(NlgN)\n * stable sort\n*/\nclass Solution {\npublic:\n ListNode *sortList(ListNode *head) {\n  if(!head || !(head->next)) return head;\n  \n  //get the linked list's length\n  ListNode* cur = head;\n  int length = 0;\n  while(cur){\n   length++;\n   cur = cur->next;\n  }\n  \n  ListNode dummy(0);\n  dummy.next = head;\n  ListNode *left, *right, *tail;\n  for(int step = 1; step < length; step <<= 1){\n   cur = dummy.next;\n   tail = &dummy;\n   while(cur){\n    left = cur;\n    right = split(left, step);\n    cur = split(right,step);\n    tail = merge(left, right, tail);\n   }\n  }\n  return dummy.next;\n }\nprivate:\n /**\n  * Divide the linked list into two lists,\n     * while the first list contains first n ndoes\n  * return the second list's head\n  */\n ListNode* split(ListNode *head, int n){\n  //if(!head) return NULL;\n  for(int i = 1; head && i < n; i++) head = head->next;\n  \n  if(!head) return NULL;\n  ListNode *second = head->next;\n  head->next = NULL;\n  return second;\n }\n /**\n   * merge the two sorted linked list l1 and l2,\n   * then append the merged sorted linked list to the node head\n   * return the tail of the merged sorted linked list\n  */\n ListNode* merge(ListNode* l1, ListNode* l2, ListNode* head){\n  ListNode *cur = head;\n  while(l1 && l2){\n   if(l1->val > l2->val){\n    cur->next = l2;\n    cur = l2;\n    l2 = l2->next;\n   }\n   else{\n    cur->next = l1;\n    cur = l1;\n    l1 = l1->next;\n   }\n  }\n  cur->next = (l1 ? l1 : l2);\n  while(cur->next) cur = cur->next;\n  return cur;\n }\n};",
                "url": "https://leetcode.com/problems/sort-list/solutions/46712/bottom-to-up-not-recurring-with-o-1-space-complextity-and-o-nlgn-time-complextity/",
                "vote_count": "753"
            },
            {
                "language": "java",
                "code": "public ListNode sortList(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        int n = 0;\n        while (head != null) {\n            head = head.next;\n            n++;\n        }",
                "url": "https://leetcode.com/problems/sort-list/solutions/46712/bottom-to-up-not-recurring-with-o-1-space-complextity-and-o-nlgn-time-complextity/",
                "vote_count": "753"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None: return None\n        ",
                "url": "https://leetcode.com/problems/sort-list/solutions/46712/bottom-to-up-not-recurring-with-o-1-space-complextity-and-o-nlgn-time-complextity/",
                "vote_count": "753"
            },
            {
                "language": "java",
                "code": "public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) return head;\n        \n        ListNode cur = head;\n        int length = 0;",
                "url": "https://leetcode.com/problems/sort-list/solutions/46712/bottom-to-up-not-recurring-with-o-1-space-complextity-and-o-nlgn-time-complextity/",
                "vote_count": "753"
            },
            {
                "language": "java",
                "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */",
                "url": "https://leetcode.com/problems/sort-list/solutions/46712/bottom-to-up-not-recurring-with-o-1-space-complextity-and-o-nlgn-time-complextity/",
                "vote_count": "753"
            },
            {
                "language": "csharp",
                "code": "1. Easy C++\n2. Line by Line Explanation with Comments.\n3. Detailed Explanation \u2705\n4. Please Upvote if it helps\u2b06\ufe0f\n5. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \u2b07\ufe0f\n // \ud83d\ude09If you Like the repository don't foget to star & fork the repository\ud83d\ude09 ",
                "url": "https://leetcode.com/problems/sort-list/solutions/1795126/c-merge-sort-2-pointer-easy-to-understand/",
                "vote_count": "327"
            },
            {
                "language": "erlang",
                "code": "1. Using 2pointer / fast-slow pointer find the middle node of the list.\n2. Now call mergeSort for 2 halves.\n3. Merge the Sort List (divide and conqueror Approach)",
                "url": "https://leetcode.com/problems/sort-list/solutions/1795126/c-merge-sort-2-pointer-easy-to-understand/",
                "vote_count": "327"
            },
            {
                "language": "rust",
                "code": "       // \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09Please upvote if it helps \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        //If List Contain a Single or 0 Node\n        if(head == NULL || head ->next == NULL)\n            return head;\n        \n        \n        ListNode *temp = NULL;\n        ListNode *slow = head;\n        ListNode *fast = head;\n        \n        // 2 pointer appraoach / turtle-hare Algorithm (Finding the middle element)\n        while(fast !=  NULL && fast -> next != NULL)\n        {\n            temp = slow;\n            slow = slow->next;          //slow increment by 1\n            fast = fast ->next ->next;  //fast incremented by 2\n            \n        }   \n        temp -> next = NULL;            //end of first left half\n        \n        ListNode* l1 = sortList(head);    //left half recursive call\n        ListNode* l2 = sortList(slow);    //right half recursive call\n        \n        return mergelist(l1, l2);         //mergelist Function call\n            \n    }\n    \n    //MergeSort Function O(n*logn)\n    ListNode* mergelist(ListNode *l1, ListNode *l2)\n    {\n        ListNode *ptr = new ListNode(0);\n        ListNode *curr = ptr;\n        \n        while(l1 != NULL && l2 != NULL)\n        {\n            if(l1->val <= l2->val)\n            {\n                curr -> next = l1;\n                l1 = l1 -> next;\n            }\n            else\n            {\n                curr -> next = l2;\n                l2 = l2 -> next;\n            }\n        \n        curr = curr ->next;\n        \n        }\n        \n        //for unqual length linked list\n        \n        if(l1 != NULL)\n        {\n            curr -> next = l1;\n            l1 = l1->next;\n        }\n        \n        if(l2 != NULL)\n        {\n            curr -> next = l2;\n            l2 = l2 ->next;\n        }\n        \n        return ptr->next;\n    }\n};",
                "url": "https://leetcode.com/problems/sort-list/solutions/1795126/c-merge-sort-2-pointer-easy-to-understand/",
                "vote_count": "327"
            },
            {
                "language": "java",
                "code": "class Solution {\n    private ListNode mergeSort(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n        \n        // split list\n        ListNode slow = head;\n        ListNode fast = head.next;",
                "url": "https://leetcode.com/problems/sort-list/solutions/1795126/c-merge-sort-2-pointer-easy-to-understand/",
                "vote_count": "327"
            },
            {
                "language": "kotlin",
                "code": "    public ListNode sortList(ListNode head) {\n        if(head == null || head.next ==null) return head;\n        ListNode slow=head,fast =head.next;\n        while(fast!=null && fast.next !=null){\n            slow=slow.next;\n            fast = fast.next.next;\n        } ListNode l2 = sortList(slow.next);",
                "url": "https://leetcode.com/problems/sort-list/solutions/1795126/c-merge-sort-2-pointer-easy-to-understand/",
                "vote_count": "327"
            },
            {
                "language": "scala",
                "code": "Let's take an example not given in question -\nSuppose head of linked list given to us is like, head: [3,-9,8,67,9]\n\nthen answer should like [-9,3,8,9,67] after sorting it in ascending order.",
                "url": "https://leetcode.com/problems/sort-list/solutions/1795343/c-detailed-explanation-w-comments-easy-to-understand-code/",
                "vote_count": "63"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    // function that divides linked list into half parts, and after sorting use to merge them\n    void mergesorting(ListNode** head) \n    {\n        ListNode* curr = *head; // make a current pointer \n        ListNode* first; // for the first half\n        ListNode* second; // for the second half\n        \n        // if linked list is null or just having a single elemrnt then simple return. because we don't have to do anything\n        if(curr == NULL || curr -> next == NULL)\n            return;\n        \n        findmid(curr, &first,&second); // function used to find mid in b/w the\n        \n        //again call merrge sorting for first half, so it again divides first half into two and for that again....till when only one element is left\n        mergesorting(&first); \n        \n        //again call merrge sorting for second half, so it again divides second half into two and for that again....till when only one element is left\n        mergesorting(&second);\n        \n        *head = merge(first,second); // and at last merge oyr first half and second half\n    }\n    \n    // function to find mid, we use hare and tortise meethod to find mid\n    void findmid(ListNode* curr, ListNode** first, ListNode** second)\n    {\n        ListNode* slow = curr; // make a slow pointer\n        ListNode* fast = curr -> next; // make a fast pointer\n        \n        // then we move our fast upto it not become null, means not reach on last position\n        while(fast != NULL)\n        {\n            fast = fast -> next;\n            if(fast != NULL)\n            {\n                fast = fast -> next;\n                slow = slow -> next;\n            }\n        }\n        \n        // after this assign curr to first\n        *first = curr;\n        *second = slow -> next; // second to slow next\n        slow -> next = NULL; // and put slow next to null\n    }\n    \n    // function used to merge first and second pointer\n    ListNode* merge(ListNode* first, ListNode* second)\n    {\n        ListNode* answer = NULL; // define answer to null\n        \n        if(first == NULL) // if first is null, then what to merge...nothing\n        {\n            return second; // return second\n        }\n        \n        if(second == NULL) // if second is null, then what to merge...nothing\n        {\n            return first; // return first\n        }\n        \n        // if value of first is less than value of second,then give answer to first\n        if(first -> val <= second -> val) \n        {\n            answer = first;\n            answer -> next = merge(first -> next, second); // and again call merge for answer's next\n        }\n        else // else give answer to second\n        {\n            answer = second;\n            answer -> next = merge(first, second -> next); // and again call merge for answer's next\n        }\n        \n        return answer; // finally return answer\n    }\n    ListNode* sortList(ListNode* head) {\n        // paasing pointer as reference, so that changes are reflected\n        mergesorting(&head); \n        \n        return head;\n    }\n};",
                "url": "https://leetcode.com/problems/sort-list/solutions/1795343/c-detailed-explanation-w-comments-easy-to-understand-code/",
                "vote_count": "63"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public ListNode sortList(ListNode head) {\n        ArrayList<Integer> list = new ArrayList<>();\n        while(head != null){\n            list.add(head.val);\n            head = head.next;\n        }\n        Collections.sort(list);",
                "url": "https://leetcode.com/problems/sort-list/solutions/1795343/c-detailed-explanation-w-comments-easy-to-understand-code/",
                "vote_count": "63"
            },
            {
                "language": "kotlin",
                "code": "    public ListNode sortList(ListNode head) {\n        if(head == null || head.next ==null) return head;\n        ListNode slow=head,fast =head.next;\n        while(fast!=null && fast.next !=null){\n            slow=slow.next;\n            fast = fast.next.next;\n        } ListNode l2 = sortList(slow.next);",
                "url": "https://leetcode.com/problems/sort-list/solutions/1795343/c-detailed-explanation-w-comments-easy-to-understand-code/",
                "vote_count": "63"
            },
            {
                "language": "cpp",
                "code": "int init=[](){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    ofstream out(\"user.out\");\n    cout.rdbuf(out.rdbuf());\n\n    for(string s; getline(cin, s); cout<<'\\n'){\n        stringstream ss(s.substr(1, s.size()-2));\n        vector<int> tokens;\n        string inter;\n\n        while(getline(ss,inter, ','))\n            tokens.push_back(stoi(inter));\n        \n        sort(tokens.begin(),tokens.end());\n\n        cout << '[';\n        for(int i=0;i<tokens.size();++i){\n            cout<<tokens[i];\n            if(i!=tokens.size()-1) cout<<',';\n        }\n        cout << ']';\n    }\n    exit(0);\n    return 0;\n}();\n\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n    return head;      \n    }\n};",
                "url": "https://leetcode.com/problems/sort-list/solutions/3171343/solution/",
                "vote_count": "29"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # Base Case: If the length of the linked list is less than or equal to 1, then the list is already sorted\n        if not head or not head.next:\n            return head\n\n        # Split the linked list into two halves using \"slow and fast pointer\" technique to find the midpoint of the linked list\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        # The midpoint of the linked list is slow.next\n        mid = slow.next\n        # Set slow.next to None to separate the left and right halves of the linked list\n        slow.next = None\n\n        # Recursively sort the left and right halves of the linked list\n        left = self.sortList(head)\n        right = self.sortList(mid)\n\n        # Merge the two sorted halves of the linked list\n        dummy = ListNode(0)\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        # Append the remaining nodes of the left or right half to the end of the sorted list\n        curr.next = left or right\n\n        return dummy.next",
                "url": "https://leetcode.com/problems/sort-list/solutions/3206790/148-solution-with-step-by-step-explanation/",
                "vote_count": "14"
            }
        ]
    },
    "148": {
        "question_id": 149,
        "title": "Max Points on a Line",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/max-points-on-a-line",
        "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line. ",
        "examples": [
            {
                "input": "points = [[1,1],[2,2],[3,3]]",
                "output": "3",
                "explanation": null
            },
            {
                "input": "points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]",
                "output": "4",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= points.length <= 300",
            "points[i].length == 2",
            "-10^4 <= xi, yi <= 10^4",
            "All the points are unique."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxPoints(vector<vector<int>>& pt) {\n        int ans=1; \n        int n=pt.size();\n       // slope of every point with selected point\n        for(int i=0;i<n-1;i++){\n            map<double,int> mp;\n            for(int j=i+1;j<n;j++){\n                //calculating the slope\n                double x = (double)(pt[j][1]-pt[i][1])/(double)(pt[j][0]-pt[i][0]);\n                if(pt[j][1]-pt[i][1]<0 &&(pt[j][0]-pt[i][0])==0 ) //infinite slop for Perpendicular line\n                mp[abs(x)]++; \n                else\n               //storing the slop into map\n                    mp[x]++;\n            }\n            // same slope w.r.t.that selected point\n            int temp = 0;\n            for(auto it:mp)\n                temp = max(temp, it.second+1);    // +1 for the current point(point itself)\n            ans = max(temp, ans);\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/max-points-on-a-line/solutions/3016390/c-easy-beats-approx-100-explanation/",
                "vote_count": "178"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int maxPoints(int[][] points) {\n        int max=0;\n        // x -> x[0],x[1]  (x1,y1)\n        for(int[] x:points)\n        {\n            Map<Double,Integer> map= new HashMap<>();\n            // y -> y[0],y[1]  (x2,y2)\n            for(int[] y:points){\n                if(x==y)\n                  continue;\n                \n                double slope=0;\n                // if (x2 - x1 == 0) \n                if(y[0]-x[0]==0)\n                   slope=Double.POSITIVE_INFINITY; \n                else\n                   // slope = (y2 - y1) / (x2 - x1)\n                   slope = (y[1]-x[1])/(double)(y[0]-x[0]);\n                \n                map.put(slope,map.getOrDefault(slope,0)+1);\n                max=Math.max(max,map.get(slope));\n            }\n        }\n        return max+1;\n    }\n}",
                "url": "https://leetcode.com/problems/max-points-on-a-line/solutions/3016303/java-c-javascript-beats-90-map-o-n-2-time/",
                "vote_count": "13"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    // Function to find the maximum number of points that lie on the same straight line\n    int maxPoints(vector<vector<int>>& points) {\n        // Get the number of points\n        int n = points.size();\n\n        // Edge case: 0 or 1 points\n        if (n <= 1) return n;\n\n        // Initialize the maximum number of points to 2 (the minimum possible)\n        int ans = 2;\n\n        // Iterate through all pairs of points\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Initialize the total number of points on the same straight line as points[i] and points[j] to 2 (points[i] and points[j])\n                int total = 2;\n\n                // Iterate through all other points\n                for (int k = 0; k < n; k++) {\n                    // Skip points i and j\n                    if (k == i || k == j) continue;\n\n                    // Check if point k lies on the same straight line as points i and j\n                    if ((points[j][1] - points[i][1]) * (points[i][0] - points[k][0]) == (points[i][1] - points[k][1]) * (points[j][0] - points[i][0])) {\n                        // Point k lies on the same straight line as points i and j, increment the total\n                        total++;\n                    }\n                }\n                // Update the maximum number of points\n                ans = max(ans, total);\n            }\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/max-points-on-a-line/solutions/3015881/easiest-soln-goldman-sachs-well-explained/",
                "vote_count": "12"
            }
        ]
    },
    "149": {
        "question_id": 150,
        "title": "Evaluate Reverse Polish Notation",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/evaluate-reverse-polish-notation",
        "description": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.Evaluate the expression. Return an integer that represents the value of the expression.Note that:The valid operators are '+', '-', '*', and '/'.Each operand may be an integer or another expression.The division between two integers always truncates toward zero.There will not be any division by zero.The input represents a valid arithmetic expression in a reverse polish notation.The answer and all the intermediate calculations can be represented in a 32-bit integer. ",
        "examples": [
            {
                "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
                "output": "9",
                "explanation": "((2 + 1) * 3) = 9"
            },
            {
                "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
                "output": "6",
                "explanation": "(4 + (13 / 5)) = 6"
            },
            {
                "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
                "output": "22",
                "explanation": "((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22"
            }
        ],
        "constraints": [
            "1 <= tokens.length <= 10^4",
            "tokens[i] is either an operator: \"+\", \"-\", \"*\", or \"/\", or an integer in the range [-200, 200]."
        ],
        "solutions": []
    },
    "150": {
        "question_id": 151,
        "title": "Reverse Words in a String",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/reverse-words-in-a-string",
        "description": "Given an input string s, reverse the order of the words.A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.Return a string of the words in reverse order concatenated by a single space.Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces. ",
        "examples": [
            {
                "input": "s = \"the sky is blue\"",
                "output": "\"blue is sky the\"",
                "explanation": null
            },
            {
                "input": "s = \"  hello world  \"",
                "output": "\"world hello\"",
                "explanation": "Your reversed string should not contain leading or trailing spaces."
            },
            {
                "input": "s = \"a good   example\"",
                "output": "\"example good a\"",
                "explanation": "You need to reduce multiple spaces between two words to a single space in the reversed string."
            }
        ],
        "constraints": [
            "1 <= s.length <= 10^4",
            "s contains English letters (upper-case and lower-case), digits, and spaces ' '.",
            "There is at least one word in s."
        ],
        "solutions": []
    },
    "151": {
        "question_id": 152,
        "title": "Maximum Product Subarray",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/maximum-product-subarray",
        "description": "Given an integer array nums, find a subarray that has the largest product, and return the product.The test cases are generated so that the answer will fit in a 32-bit integer. ",
        "examples": [
            {
                "input": "nums = [2,3,-2,4]",
                "output": "6",
                "explanation": "[2,3] has the largest product 6."
            },
            {
                "input": "nums = [-2,0,-1]",
                "output": "0",
                "explanation": "The result cannot be 2, because [-2,-1] is not a subarray."
            }
        ],
        "constraints": [
            "1 <= nums.length <= 2 * 10^4",
            "-10 <= nums[i] <= 10",
            "The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "int maxProduct(int A[], int n) {\n    // store the result that is the max we have found so far\n    int r = A[0];\n\n    // imax/imin stores the max/min product of\n    // subarray that ends with the current number A[i]\n    for (int i = 1, imax = r, imin = r; i < n; i++) {\n        // multiplied by a negative makes big number smaller, small number bigger\n        // so we redefine the extremums by swapping them\n        if (A[i] < 0)\n            swap(imax, imin);\n\n        // max/min product for the current number is either the current number itself\n        // or the max/min by the previous number times the current one\n        imax = max(A[i], imax * A[i]);\n        imin = min(A[i], imin * A[i]);\n\n        // the newly computed max value is a candidate for our global result\n        r = max(r, imax);\n    }\n    return r;\n}",
                "url": "https://leetcode.com/problems/maximum-product-subarray/solutions/48230/possibly-simplest-solution-with-o-n-time-complexity/",
                "vote_count": "2888"
            },
            {
                "language": "python",
                "code": "...\ncandidates = (A[i], imax * A[i], imin * A[i])\nimax = max(candidates)\nimin = min(candidates)\n...",
                "url": "https://leetcode.com/problems/maximum-product-subarray/solutions/48230/possibly-simplest-solution-with-o-n-time-complexity/",
                "vote_count": "2888"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int maxProduct(int[] nums) {\n        int prod = 1;\n        int result = Integer.MIN_VALUE;\n        \n        for (int i = 0; i < nums.length; i++) {",
                "url": "https://leetcode.com/problems/maximum-product-subarray/solutions/48230/possibly-simplest-solution-with-o-n-time-complexity/",
                "vote_count": "2888"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/maximum-product-subarray/solutions/48230/possibly-simplest-solution-with-o-n-time-complexity/",
                "vote_count": "2888"
            },
            {
                "language": "python",
                "code": "public int maxProduct(int[] nums) {\nint maxSum = nums[0];\nint currentMax = nums[0];\nint currentMin = nums[0];\n\nfor (int i = 1; i < nums.length; i++) {\n    if (nums[i] < 0){\n        int tmp = currentMax;",
                "url": "https://leetcode.com/problems/maximum-product-subarray/solutions/48230/possibly-simplest-solution-with-o-n-time-complexity/",
                "vote_count": "2888"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int maxProduct(int[] nums) {\n        int max = Integer.MIN_VALUE, imax = 1, imin = 1;\n        for(int i=0; i<nums.length; i++){\n            if(nums[i] < 0){ int tmp = imax; imax = imin; imin = tmp;}\n            imax = Math.max(imax*nums[i], nums[i]);\n            imin = Math.min(imin*nums[i], nums[i]);\n            ",
                "url": "https://leetcode.com/problems/maximum-product-subarray/solutions/48230/possibly-simplest-solution-with-o-n-time-complexity/",
                "vote_count": "2888"
            },
            {
                "language": "python",
                "code": "    def maxProduct(self, A):\n        B = A[::-1]\n        for i in range(1, len(A)):\n            A[i] *= A[i - 1] or 1\n            B[i] *= B[i - 1] or 1\n        return max(A + B)",
                "url": "https://leetcode.com/problems/maximum-product-subarray/solutions/183483/java-c-python-it-can-be-more-simple/",
                "vote_count": "1156"
            },
            {
                "language": "cpp",
                "code": "    int maxProduct(vector<int> A) {\n        int n = A.size(), res = A[0], l = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            l =  (l ? l : 1) * A[i];\n            r =  (r ? r : 1) * A[n - 1 - i];\n            res = max(res, max(l, r));\n        }\n        return res;\n    }",
                "url": "https://leetcode.com/problems/maximum-product-subarray/solutions/183483/java-c-python-it-can-be-more-simple/",
                "vote_count": "1156"
            },
            {
                "language": "cpp",
                "code": "    public int maxProduct(int[] A) {\n        int n = A.length, res = A[0], l = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            l =  (l == 0 ? 1 : l) * A[i];\n            r =  (r == 0 ? 1 : r) * A[n - 1 - i];\n            res = Math.max(res, Math.max(l, r));\n        }\n        return res;\n    }",
                "url": "https://leetcode.com/problems/maximum-product-subarray/solutions/183483/java-c-python-it-can-be-more-simple/",
                "vote_count": "1156"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        prefix, suffix, max_so_far = 0, 0, float('-inf')\n        for i in range(len(nums)):\n            prefix = (prefix or 1) * nums[i]\n            suffix = (suffix or 1) * nums[~i]\n            max_so_far = max(max_so_far, prefix, suffix)\n        return max_so_far",
                "url": "https://leetcode.com/problems/maximum-product-subarray/solutions/183483/java-c-python-it-can-be-more-simple/",
                "vote_count": "1156"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int maxProduct(int[] nums) {\n        \n        int max = nums[0], min = nums[0], ans = nums[0];\n        \n        for (int i = 1; i < nums.length; i++) {\n            \n            int temp = max;  // store the max because before updating min your max will already be updated\n            \n            max = Math.max(Math.max(max * nums[i], min * nums[i]), nums[i]);\n            min = Math.min(Math.min(temp * nums[i], min * nums[i]), nums[i]);\n            \n            if (max > ans) {\n                ans = max;\n            }\n        }\n        \n        return ans;\n\n    }\n}",
                "url": "https://leetcode.com/problems/maximum-product-subarray/solutions/1608862/java-3-solutions-detailed-explanation-using-image/",
                "vote_count": "424"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int maxProduct(int[] nums) {\n        \n        int max = nums[0], min = nums[0], ans = nums[0];\n        int n = nums.length;\n        \n        for (int i = 1; i < n; i++) {\n        \n   // Swapping min and max\n            if (nums[i] < 0){\n                int temp = max;\n                max = min;\n                min = temp;\n            }\n                \n\n\n            max = Math.max(nums[i], max * nums[i]);\n            min = Math.min(nums[i], min * nums[i]);\n\n\n            ans = Math.max(ans, max);\n        }\n        \n        return ans;\n\n    }\n}",
                "url": "https://leetcode.com/problems/maximum-product-subarray/solutions/1608862/java-3-solutions-detailed-explanation-using-image/",
                "vote_count": "424"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int maxProduct(int[] nums) {\n        \n        int n = nums.length;\n        int l=1,r=1;\n        int ans=nums[0];\n        \n        for(int i=0;i<n;i++){\n            \n   //if any of l or r become 0 then update it to 1\n            l = l==0 ? 1 : l;\n            r = r==0 ? 1 : r;\n            \n            l *= nums[i];   //prefix product\n            r *= nums[n-1-i];    //suffix product\n            \n            ans = Math.max(ans,Math.max(l,r));\n            \n        }\n        \n        return ans;\n\n    }\n}",
                "url": "https://leetcode.com/problems/maximum-product-subarray/solutions/1608862/java-3-solutions-detailed-explanation-using-image/",
                "vote_count": "424"
            },
            {
                "language": "java",
                "code": "/*\n\n    Time Complexity : O(N^2), Where N is the size of the array. Here total number of iterations are : N*(N\u20131)/2\n    which creates the time complexity.\n\n    Space complexity : O(1), Constant space.\n\n    Solved using Array(Two Nested Loop). Brute Force Approach.\n\n    Note : This will give TLE.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int n = nums.size();\n        int maxProduct = INT_MIN;\n        for(int i=0; i<n; i++){\n            int product = 1;\n            for(int j=i; j<n; j++){\n                product *= nums[j];\n                if(product > maxProduct){\n                    maxProduct = product;\n                }\n            }\n        }\n        return maxProduct;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N), Where N is the size of the Array(nums). Here we are traversing each element of Array\n    (nums) which creates the time complexity.\n\n    Space Complexity : O(1), Constant space.\n\n    Solved using Dynamic Programming Approach(Space Optimization). Optimized Approach.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int n = nums.size();\n        int minProduct = 1;\n        int maxProduct = 1;\n        int ans = INT_MIN;\n        for(int i=0; i<n; i++){\n            if(nums[i] < 0){\n                swap(maxProduct, minProduct);\n            }\n            maxProduct = max(maxProduct*nums[i], nums[i]);\n            minProduct = min(minProduct*nums[i], nums[i]);\n            ans = max(ans, maxProduct);\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/maximum-product-subarray/solutions/3186637/best-c-2-solution-dp-brute-force-optimize-one-stop-solution/",
                "vote_count": "57"
            },
            {
                "language": "csharp",
                "code": "// By traversing left to right we have an answer maxi1.\nmaxi1 = -720 , which is clearly not the max prod value.",
                "url": "https://leetcode.com/problems/maximum-product-subarray/solutions/3321410/c-kadane-s-algo-full-explanation/",
                "vote_count": "54"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int maxi = INT_MIN;\n        int prod=1;\n\n        for(int i=0;i<nums.size();i++)\n        {\n          prod*=nums[i];\n          maxi=max(prod,maxi);\n          if(prod==0)\n           prod=1;\n        }\n        prod=1;\n        for(int i=nums.size()-1;i>=0;i--)\n        {\n          prod*=nums[i];\n\n          maxi=max(prod,maxi);\n          if(prod==0)\n           prod=1;\n        }\n        return maxi;\n    }\n};",
                "url": "https://leetcode.com/problems/maximum-product-subarray/solutions/3321410/c-kadane-s-algo-full-explanation/",
                "vote_count": "54"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n         int maxi = nums[0];\n        int mini = nums[0];\n        int ans = nums[0];\n        for(int i = 1;i < nums.size();i++){\n            if(nums[i] < 0){\n                swap(maxi,mini);\n            }\n            maxi = max(nums[i],maxi*nums[i]);\n            mini = min(nums[i],mini*nums[i]);\n            ans = max(ans,maxi);\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/maximum-product-subarray/solutions/3176155/solution/",
                "vote_count": "46"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int n = nums.size();\n        //currMaxProductSubarr: This variable keeps track of the maximum product of a subarray that ends at the current index. For each element in the input array, we update the value of currMaxProductSubarr based on the maximum product that can be obtained by considering the current element and the maximum and minimum product of the subarray that ends at the previous index.\n        int currMaxProductSubarr = nums[0];\n        //currMinProductSubarr: This variable keeps track of the minimum product of a subarray that ends at the current index. As with currMaxProductSubarr, we update the value of currMinProductSubarr at each index based on the minimum product that can be obtained by considering the current element and the maximum and minimum product of the subarray that ends at the previous index.\n        int currMinProductSubarr = nums[0];\n        //maxProductAns: This variable keeps track of the maximum product obtained so far. At each index, we compare the value of currMaxProductSubarr with the current value of maxProductAns and update maxProductAns if currMaxProductSubarr is greater than the current value of maxProductAns. By doing so, we ensure that maxProductAns always stores the maximum product obtained from any subarray in nums up to the current index.\n        int maxProductAns = nums[0];\n        for (int i = 1; i < n; i++) {\n            int temp = currMaxProductSubarr;\n            //The maximum product of a subarray can be obtained by considering three possibilities:\n                //The current element nums[i] alone forms a subarray with the maximum product. In this case, the maximum product of the subarray that ends at the current index is simply nums[i].\n                //The current element nums[i] is positive and can be added to the existing subarray that ends at the previous index with the maximum product. In this case, the maximum product of the subarray that ends at the current index is the product of the current element nums[i] and the maximum product of the subarray that ends at the previous index, i.e., currMaxProductSubarr * nums[i].\n                //The current element nums[i] is negative and can be added to the existing subarray that ends at the previous index with the minimum product. In this case, the maximum product of the subarray that ends at the current index is the product of the current element nums[i] and the minimum product of the subarray that ends at the previous index, i.e., currMinProductSubarr * nums[i].\n            currMaxProductSubarr = max({nums[i], currMaxProductSubarr * nums[i], currMinProductSubarr * nums[i]});\n            //The minimum product of a subarray can be obtained by considering three possibilities:\n                //The current element nums[i] alone forms a subarray with the minimum product. In this case, the minimum product of the subarray that ends at the current index is simply nums[i].\n                //The current element nums[i] is positive and can be added to the existing subarray that ends at the previous index with the minimum product. In this case, the minimum product of the subarray that ends at the current index is the product of the current element nums[i] and the minimum product of the subarray that ends at the previous index, i.e., currMinProductSubarr * nums[i].\n                //The current element nums[i] is negative and can be added to the existing subarray that ends at the previous index with the maximum product. In this case, the minimum product of the subarray that ends at the current index is the product of the current element nums[i] and the maximum product of the subarray that ends at the previous index, i.e., temp * nums[i].\n            currMinProductSubarr = min({nums[i], temp * nums[i], currMinProductSubarr * nums[i]});\n            maxProductAns = max(maxProductAns, currMaxProductSubarr);\n        }\n        return maxProductAns;\n    }\n};",
                "url": "https://leetcode.com/problems/maximum-product-subarray/solutions/3227249/c-o-n-time-and-o-1-space-easiest-beginner-friendly-sol/",
                "vote_count": "30"
            }
        ]
    },
    "152": {
        "question_id": 153,
        "title": "Find Minimum in Rotated Sorted Array",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array",
        "description": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:[4,5,6,7,0,1,2] if it was rotated 4 times.[0,1,2,4,5,6,7] if it was rotated 7 times.Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].Given the sorted rotated array nums of unique elements, return the minimum element of this array.You must write an algorithm that runs in O(log n) time. ",
        "examples": [
            {
                "input": "nums = [3,4,5,1,2]",
                "output": "1",
                "explanation": "The original array was [1,2,3,4,5] rotated 3 times."
            },
            {
                "input": "nums = [4,5,6,7,0,1,2]",
                "output": "0",
                "explanation": "The original array was [0,1,2,4,5,6,7] and it was rotated 4 times."
            },
            {
                "input": "nums = [11,13,15,17]",
                "output": "11",
                "explanation": "The original array was [11,13,15,17] and it was rotated 4 times. "
            }
        ],
        "constraints": [
            "n == nums.length",
            "1 <= n <= 5000",
            "-5000 <= nums[i] <= 5000",
            "All the integers of nums are unique.",
            "nums is sorted and rotated between 1 and n times."
        ],
        "solutions": [
            {
                "language": "python",
                "code": "class Solution:\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # set left and right bounds\n        left, right = 0, len(nums)-1\n                \n        # left and right both converge to the minimum index;\n        # DO NOT use left <= right because that would loop forever\n        while left < right:\n            # find the middle value between the left and right bounds (their average);\n   # can equivalently do: mid = left + (right - left) // 2,\n   # if we are concerned left + right would cause overflow (which would occur\n   # if we are searching a massive array using a language like Java or C that has\n   # fixed size integer types)\n            mid = (left + right) // 2\n                        \n            # the main idea for our checks is to converge the left and right bounds on the start\n            # of the pivot, and never disqualify the index for a possible minimum value.\n\n            # in normal binary search, we have a target to match exactly,\n            # and would have a specific branch for if nums[mid] == target.\n            # we do not have a specific target here, so we just have simple if/else.\n                        \n            if nums[mid] > nums[right]:\n                # we KNOW the pivot must be to the right of the middle:\n                # if nums[mid] > nums[right], we KNOW that the\n                # pivot/minimum value must have occurred somewhere to the right\n                # of mid, which is why the values wrapped around and became smaller.\n\n                # example:  [3,4,5,6,7,8,9,1,2] \n                # in the first iteration, when we start with mid index = 4, right index = 9.\n                # if nums[mid] > nums[right], we know that at some point to the right of mid,\n                # the pivot must have occurred, which is why the values wrapped around\n                # so that nums[right] is less then nums[mid]\n\n                # we know that the number at mid is greater than at least\n                # one number to the right, so we can use mid + 1 and\n                # never consider mid again; we know there is at least\n                # one value smaller than it on the right\n                left = mid + 1\n\n            else:\n                # here, nums[mid] <= nums[right]:\n                # we KNOW the pivot must be at mid or to the left of mid:\n                # if nums[mid] <= nums[right], we KNOW that the pivot was not encountered\n                # to the right of middle, because that means the values would wrap around\n                # and become smaller (which is caught in the above if statement).\n                # this leaves the possible pivot point to be at index <= mid.\n                            \n                # example: [8,9,1,2,3,4,5,6,7]\n                # in the first iteration, when we start with mid index = 4, right index = 9.\n                # if nums[mid] <= nums[right], we know the numbers continued increasing to\n                # the right of mid, so they never reached the pivot and wrapped around.\n                # therefore, we know the pivot must be at index <= mid.\n\n                # we know that nums[mid] <= nums[right].\n                # therefore, we know it is possible for the mid index to store a smaller\n                # value than at least one other index in the list (at right), so we do\n                # not discard it by doing right = mid - 1. it still might have the minimum value.\n                right = mid\n                \n        # at this point, left and right converge to a single index (for minimum value) since\n        # our if/else forces the bounds of left/right to shrink each iteration:\n\n        # when left bound increases, it does not disqualify a value\n        # that could be smaller than something else (we know nums[mid] > nums[right],\n        # so nums[right] wins and we ignore mid and everything to the left of mid).\n\n        # when right bound decreases, it also does not disqualify a\n        # value that could be smaller than something else (we know nums[mid] <= nums[right],\n        # so nums[mid] wins and we keep it for now).\n\n        # so we shrink the left/right bounds to one value,\n        # without ever disqualifying a possible minimum\n        return nums[left]",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/solutions/158940/beat-100-very-simple-python-very-detailed-explanation/",
                "vote_count": "1049"
            },
            {
                "language": "python",
                "code": "if nums[mid]>nums[right]:\n    left = mid+1\nelse:\n    right = mid",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/solutions/158940/beat-100-very-simple-python-very-detailed-explanation/",
                "vote_count": "1049"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/solutions/158940/beat-100-very-simple-python-very-detailed-explanation/",
                "vote_count": "1049"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/solutions/158940/beat-100-very-simple-python-very-detailed-explanation/",
                "vote_count": "1049"
            },
            {
                "language": "java",
                "code": "   public int findMin(int[] nums) {\n        if (null == nums || nums.length == 0) {\n            return -1;\n        }\n        \n        int l = 0, r = nums.length - 1;\n        while (l < r) {\n            int mid = (l + r) / 2;",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/solutions/158940/beat-100-very-simple-python-very-detailed-explanation/",
                "vote_count": "1049"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int n = nums.size();\n        int low=0, high=n-1;\n        \n        while(low<high){\n            if(nums[low] <= nums[high]) return nums[low];\n            int mid = low + (high-low)/2;\n            if(nums[low] > nums[mid]){\n                high=mid;\n            } else if(nums[mid] > nums[high]) {\n                low=mid+1;\n            } \n        }\n        if(nums[low] <= nums[high]) return nums[low];\n        return -1;\n    }\n};",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/solutions/3176170/solution/",
                "vote_count": "45"
            }
        ]
    },
    "153": {
        "question_id": 154,
        "title": "Find Minimum in Rotated Sorted Array II",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii",
        "description": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,4,4,5,6,7] might become:[4,5,6,7,0,1,4] if it was rotated 4 times.[0,1,4,4,5,6,7] if it was rotated 7 times.Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].Given the sorted rotated array nums that may contain duplicates, return the minimum element of this array.You must decrease the overall operation steps as much as possible. ",
        "examples": [
            {
                "input": "nums = [1,3,5]",
                "output": "1",
                "explanation": null
            }
        ],
        "constraints": [],
        "solutions": [
            {
                "language": "dart",
                "code": "class Solution {\npublic:\n    int findMin(vector<int> &num) {\n        int lo = 0;\n        int hi = num.size() - 1;\n        int mid = 0;\n        \n        while(lo < hi) {\n            mid = lo + (hi - lo) / 2;\n            \n            if (num[mid] > num[hi]) {\n                lo = mid + 1;\n            }\n            else if (num[mid] < num[hi]) {\n                hi = mid;\n            }\n            else { // when num[mid] and num[hi] are same\n                hi--;\n            }\n        }\n        return num[lo];\n    }\n};",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/solutions/48808/my-pretty-simple-code-to-solve-it/",
                "vote_count": "687"
            },
            {
                "language": "kotlin",
                "code": "",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/solutions/48808/my-pretty-simple-code-to-solve-it/",
                "vote_count": "687"
            },
            {
                "language": "cpp",
                "code": "int lo = 0, hi = n - 1;\nwhile(lo < hi) {\n    int mid = lo + (hi - lo) / 2;\n    if (nums[mid] < nums[hi])",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/solutions/48808/my-pretty-simple-code-to-solve-it/",
                "vote_count": "687"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/solutions/48808/my-pretty-simple-code-to-solve-it/",
                "vote_count": "687"
            },
            {
                "language": "python",
                "code": "nums[lo] <= nums[mi] <= nums[hi], min is nums[lo]\nnums[lo] > nums[mi] <= nums[hi], (lo, mi] is not sorted, min is inside\nnums[lo] <= nums[mi] > nums[hi], (mi, hi] is not sorted, min is inside\nnums[lo] > nums[mi] > nums[hi], impossible",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/solutions/167981/beats-100-binary-search-with-explanations/",
                "vote_count": "465"
            },
            {
                "language": "cpp",
                "code": "    public int findMin(int[] nums) {\n        \n        int lo = 0, hi = nums.length - 1;\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (nums[mi] > nums[hi]) { \n                lo = mi + 1;\n            }\n            else if (nums[mi] < nums[lo]) { \n                hi = mi;\n                lo++;\n            }\n            else { // nums[lo] <= nums[mi] <= nums[hi] \n                hi--;\n            }\n        }\n        \n        return nums[lo];\n    }",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/solutions/167981/beats-100-binary-search-with-explanations/",
                "vote_count": "465"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int findMin(int[] nums) {\n        // clarification:  nums == null ??\n        \n        int lo = 0, hi = nums.length - 1;\n        ",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/solutions/167981/beats-100-binary-search-with-explanations/",
                "vote_count": "465"
            },
            {
                "language": "cpp",
                "code": "int findMin(vector<int>& nums) {\n        int left = 0, right = nums.size()-1;\n        while (left < right) {\n            int mid = left+(right-left)/2;\n            if (nums[left] > nums[mid]){ \n                left++;",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/solutions/167981/beats-100-binary-search-with-explanations/",
                "vote_count": "465"
            },
            {
                "language": "javascript",
                "code": "            else { // nums[lo] <= nums[mi] <= nums[hi] \n                lo++;\n            }",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/solutions/167981/beats-100-binary-search-with-explanations/",
                "vote_count": "465"
            },
            {
                "language": "javascript",
                "code": "            else { // nums[lo] <= nums[mi] <= nums[hi] ",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/solutions/167981/beats-100-binary-search-with-explanations/",
                "vote_count": "465"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int findMin(int[] nums) {\n        int i = 0;\n        int j = nums.length - 1;\n        int min = nums[i];\n        while(i<=j) {\n            min = Math.min(min, Math.min(nums[i++], nums[j--]));\n        }",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/solutions/167981/beats-100-binary-search-with-explanations/",
                "vote_count": "465"
            },
            {
                "language": "erlang",
                "code": "",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/solutions/167981/beats-100-binary-search-with-explanations/",
                "vote_count": "465"
            },
            {
                "language": "javascript",
                "code": "           else { // nums[lo] <= nums[mi] <= nums[hi] \n                hi--;\n            }",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/solutions/167981/beats-100-binary-search-with-explanations/",
                "vote_count": "465"
            },
            {
                "language": "ruby",
                "code": "",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/solutions/167981/beats-100-binary-search-with-explanations/",
                "vote_count": "465"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int findMin(int[] nums) {\n        int lo = 0, hi = nums.length - 1;\n        \n        if (nums[lo] < nums[hi]) return nums[lo];\n        \n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            \n            if (nums[mid] > nums[hi]) {\n                lo = mid + 1;\n            } else if (nums[mid] < nums[hi]) {\n                hi = mid;\n            } else {\n                hi--;\n            }\n        }\n        \n        return nums[hi];\n    }\n}",
                "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/solutions/1535534/beats-100-binary-search-with-clear-explanation/",
                "vote_count": "122"
            }
        ]
    },
    "154": {
        "question_id": 155,
        "title": "Min Stack",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/min-stack",
        "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.Implement the MinStack class:MinStack() initializes the stack object.void push(int val) pushes the element val onto the stack.void pop() removes the element on the top of the stack.int top() gets the top element of the stack.int getMin() retrieves the minimum element in the stack.You must implement a solution with O(1) time complexity for each function. ",
        "examples": [
            {
                "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\nOutput\n[null,null,null,null,-3,null,0,-2]\n\nExplanation\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2",
                "output": "MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\nOutput\n[null,null,null,null,-3,null,0,-2]\n\nExplanation\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2",
                "explanation": null
            }
        ],
        "constraints": [
            "-2^31 <= val <= 2^31 - 1",
            "Methods pop, top and getMin operations will always be called on non-empty stacks.",
            "At most 3 * 10^4 calls will be made to push, pop, top, and getMin."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "class MinStack {\n private Node head;\n        \n    public void push(int x) {\n        if (head == null) \n            head = new Node(x, x, null);\n        else \n            head = new Node(x, Math.min(x, head.min), head);\n    }\n    \n    public void pop() {\n        head = head.next;\n    }\n    \n    public int top() {\n        return head.val;\n    }\n    \n    public int getMin() {\n        return head.min;\n    }\n        \n    private class Node {\n        int val;\n        int min;\n        Node next;\n            \n        private Node(int val, int min, Node next) {\n            this.val = val;\n            this.min = min;\n            this.next = next;\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/min-stack/solutions/49010/clean-6ms-java-solution/",
                "vote_count": "2446"
            },
            {
                "language": "csharp",
                "code": "public void push(int x) {\n    if(head == null) \n        head = new Node(x, x, null);\n    else ",
                "url": "https://leetcode.com/problems/min-stack/solutions/49010/clean-6ms-java-solution/",
                "vote_count": "2446"
            },
            {
                "language": "cpp",
                "code": "class MinStack {\n    int min = Integer.MAX_VALUE;\n    Stack<Integer> stack = new Stack<Integer>();\n    public void push(int x) {\n        // only push the old minimum value when the current \n        // minimum value changes after pushing the new value x\n        if(x <= min){          \n            stack.push(min);\n            min=x;\n        }\n        stack.push(x);\n    }\n\n    public void pop() {\n        // if pop operation could result in the changing of the current minimum value, \n        // pop twice and change the current minimum value to the last minimum value.\n        if(stack.pop() == min) min=stack.pop();\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getMin() {\n        return min;\n    }\n}",
                "url": "https://leetcode.com/problems/min-stack/solutions/49014/java-accepted-solution-using-one-stack/",
                "vote_count": "1260"
            },
            {
                "language": "cpp",
                "code": "class MinStack {\n    Stack<Integer> stack = new Stack<>();\n    int min = Integer.MAX_VALUE;\n\n    public void push(int x) {",
                "url": "https://leetcode.com/problems/min-stack/solutions/49014/java-accepted-solution-using-one-stack/",
                "vote_count": "1260"
            },
            {
                "language": "cpp",
                "code": "public class MinStack {\n\n    Stack<Integer> stack, min;\n\n    public MinStack() {",
                "url": "https://leetcode.com/problems/min-stack/solutions/49014/java-accepted-solution-using-one-stack/",
                "vote_count": "1260"
            },
            {
                "language": "cpp",
                "code": "public class MinStack {\n    long min;\n    Stack<Long> stack;\n\n    public MinStack(){\n        stack=new Stack<>();\n    }\n    \n    public void push(int x) {\n        if (stack.isEmpty()){\n            stack.push(0L);\n            min=x;\n        }else{\n            stack.push(x-min);//Could be negative if min value needs to change\n            if (x<min) min=x;\n        }\n    }\n\n    public void pop() {\n        if (stack.isEmpty()) return;\n        \n        long pop=stack.pop();\n        \n        if (pop<0)  min=min-pop;//If negative, increase the min value\n        \n    }\n\n    public int top() {\n        long top=stack.peek();\n        if (top>0){\n            return (int)(top+min);\n        }else{\n           return (int)(min);\n        }\n    }\n\n    public int getMin() {\n        return (int)min;\n    }\n}",
                "url": "https://leetcode.com/problems/min-stack/solutions/49031/share-my-java-solution-with-only-one-stack/",
                "vote_count": "669"
            },
            {
                "language": "cpp",
                "code": "class MinStack\n{\n    static class Element\n    {\n        final int value;\n        final int min;\n        Element(final int value, final int min)",
                "url": "https://leetcode.com/problems/min-stack/solutions/49031/share-my-java-solution-with-only-one-stack/",
                "vote_count": "669"
            },
            {
                "language": "cpp",
                "code": "class MinStack {\n    long min;\n    Stack<Long> stack;\n    \n    /** initialize your data structure here. */\n    public MinStack() {\n        stack = new Stack<>();\n    }",
                "url": "https://leetcode.com/problems/min-stack/solutions/49031/share-my-java-solution-with-only-one-stack/",
                "vote_count": "669"
            },
            {
                "language": "cpp",
                "code": "public class MinStack {\n    long min = Integer.MAX_VALUE;\n    Stack<Long> stack = new Stack<>();\n    public MinStack() {\n        \n    }\n    \n    public void push(int x) {",
                "url": "https://leetcode.com/problems/min-stack/solutions/49031/share-my-java-solution-with-only-one-stack/",
                "vote_count": "669"
            },
            {
                "language": "cpp",
                "code": "class MinStack {\nprivate:\n    stack<int> s1;\n    stack<int> s2;\npublic:\n    void push(int x) {\n     s1.push(x);\n     if (s2.empty() || x <= getMin())  s2.push(x);     \n    }\n    void pop() {\n     if (s1.top() == getMin())  s2.pop();\n     s1.pop();\n    }\n    int top() {\n     return s1.top();\n    }\n    int getMin() {\n     return s2.top();\n    }\n};",
                "url": "https://leetcode.com/problems/min-stack/solutions/49016/c-using-two-stacks-quite-short-and-easy-to-understand/",
                "vote_count": "498"
            },
            {
                "language": "",
                "code": "if (x <= getMin())  s2.push(x);",
                "url": "https://leetcode.com/problems/min-stack/solutions/49016/c-using-two-stacks-quite-short-and-easy-to-understand/",
                "vote_count": "498"
            },
            {
                "language": "php",
                "code": " if (s2.empty()||x <= getMin())  s2.push(x);",
                "url": "https://leetcode.com/problems/min-stack/solutions/49016/c-using-two-stacks-quite-short-and-easy-to-understand/",
                "vote_count": "498"
            },
            {
                "language": "cpp",
                "code": "class MinStack {\npublic:\n    stack<pair<int,int>> stk;\npublic:\n    /** initialize your data structure here. */\n    MinStack() {\n        \n    }",
                "url": "https://leetcode.com/problems/min-stack/solutions/49016/c-using-two-stacks-quite-short-and-easy-to-understand/",
                "vote_count": "498"
            },
            {
                "language": "javascript",
                "code": "[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"pop\",\"top\",\"push\",\"getMin\"]\n[[],[5],[-2],[3],[-10],[20],[],[],[],[],[30],[]]",
                "url": "https://leetcode.com/problems/min-stack/solutions/1209254/c-simple-code-with-one-stack/",
                "vote_count": "283"
            },
            {
                "language": "javascript",
                "code": "[null,null,null,null,null,null,-10,null,null,3,null,-2]",
                "url": "https://leetcode.com/problems/min-stack/solutions/1209254/c-simple-code-with-one-stack/",
                "vote_count": "283"
            },
            {
                "language": "cpp",
                "code": "class MinStack {\npublic:\n    vector< pair<int,int> > s;\n \n    MinStack() { }\n    \n    void push(int val) {\n        if(s.empty())\n            s.push_back({val,val});\n        else\n            s.push_back({val,min(s.back().second,val)});    \n    }\n    \n    void pop() { s.pop_back(); }\n    \n    int top() { return s.back().first; }\n    \n    int getMin() { return s.back().second; }\n};",
                "url": "https://leetcode.com/problems/min-stack/solutions/1209254/c-simple-code-with-one-stack/",
                "vote_count": "283"
            },
            {
                "language": "python",
                "code": "The Time complexity of each operation is O(1)\nThe Space complexity is O(N)",
                "url": "https://leetcode.com/problems/min-stack/solutions/1209254/c-simple-code-with-one-stack/",
                "vote_count": "283"
            },
            {
                "language": "csharp",
                "code": "class MinStack {\n    vector<int> s, minIdx;\npublic:\n    void push(int val) {",
                "url": "https://leetcode.com/problems/min-stack/solutions/1209254/c-simple-code-with-one-stack/",
                "vote_count": "283"
            },
            {
                "language": "cpp",
                "code": " class MinStack {\n public:\n  stack<int>s;\n  multiset<int>m;   \n\n  void push(int val) {//insert elements on both set and stack\n   s.push(val); \n   m.insert(val);\n  }\n\n  void pop() {//poping elements on both set and stack\n   int top = s.top();\n   s.pop();\n   m.erase(m.find(top)); \n  }\n\n  int top() { //return stack top\n   return s.top();\n  }\n\n  int getMin() {// return set first element \n   return *m.begin();\n  }\n };",
                "url": "https://leetcode.com/problems/min-stack/solutions/1539330/c-99-74-faster-simple-better-and-optimal-solutions-using-stacks/",
                "vote_count": "122"
            },
            {
                "language": "csharp",
                "code": " class MinStack {\n public:\n  stack<int>s,minKeeper;\n  void push(int val) {\n   s.push(val); // push val in stack\n\n   if(minKeeper.size()==0||val<=minKeeper.top()){//push in when empty or lesser than current minElement\n    minKeeper.push(val);\n   }\n  }\n\n  void pop() {\n\n   if(minKeeper.top() == s.top())//pop when last element was min element \n    minKeeper.pop();\n   s.pop();\n  }\n\n  int top() {//return top of stack\n   return s.top();\n  }\n\n  int getMin() {//return top of minKeeper\n   return minKeeper.top();\n  }\n };",
                "url": "https://leetcode.com/problems/min-stack/solutions/1539330/c-99-74-faster-simple-better-and-optimal-solutions-using-stacks/",
                "vote_count": "122"
            },
            {
                "language": "csharp",
                "code": " class MinStack {\n public:\n  stack<int>s;\n  int minElement = INT_MAX;//initalize with max value\n\n  void push(int val) {\n   if(minElement>=val){// whenever val is lesser than current minElement, store current minElement in stack and make val as current minElement\n    s.push(minElement);\n     minElement = val;\n   }\n     s.push(val);\n  }\n\n  void pop() {\n   if(minElement==s.top()){//top is minElement then previous element will be previous minElement, so pop and store current top as current MinElement\n    s.pop();\n    minElement = s.top();\n   }\n   s.pop();\n  }\n\n  int top() {// return stack top\n   return s.top();\n  }\n\n  int getMin() {//return minElement\n   return minElement;\n  }\n };",
                "url": "https://leetcode.com/problems/min-stack/solutions/1539330/c-99-74-faster-simple-better-and-optimal-solutions-using-stacks/",
                "vote_count": "122"
            },
            {
                "language": "lisp",
                "code": "  if(Useful == true)\n   upvote();\n  else\n   comment();",
                "url": "https://leetcode.com/problems/min-stack/solutions/1539330/c-99-74-faster-simple-better-and-optimal-solutions-using-stacks/",
                "vote_count": "122"
            },
            {
                "language": "cpp",
                "code": "class MinStack {\npublic:\n    typedef struct node{\n        int v;\n        int minUntilNow;\n        node* next;\n    }node;\n\n    MinStack() : topN(nullptr){\n        \n    }\n    \n    void push(int val) {\n        node* n = new node;\n        n->v = n->minUntilNow = val;\n        n->next = nullptr;\n        \n        if(topN == nullptr){\n            topN = n;\n        }\n\n        else{\n            n->minUntilNow = min(n->v,topN->minUntilNow);\n            n->next = topN;\n            topN = n;\n        }\n    }\n    \n    void pop() {\n        topN = topN->next;\n    }\n    \n    int top() {\n        return topN->v;\n    }\n    \n    int getMin() {\n        return topN->minUntilNow;\n    }\n\n    private:\n    node* topN;\n};",
                "url": "https://leetcode.com/problems/min-stack/solutions/3176175/solution/",
                "vote_count": "42"
            }
        ]
    },
    "155": {
        "question_id": 160,
        "title": "Intersection of Two Linked Lists",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/intersection-of-two-linked-lists",
        "description": "Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.For example, the following two linked lists begin to intersect at node c1:The test cases are generated such that there are no cycles anywhere in the entire linked structure.Note that the linked lists must retain their original structure after the function returns.Custom Judge:The inputs to the judge are given as follows (your program is not given these inputs):intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.listA - The first linked list.listB - The second linked list.skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted. ",
        "examples": [
            {
                "input": "intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3",
                "output": "Intersected at '8'",
                "explanation": "The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory."
            },
            {
                "input": "intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1",
                "output": "Intersected at '2'",
                "explanation": "The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B."
            },
            {
                "input": "intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2",
                "output": "No intersection",
                "explanation": "From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null."
            }
        ],
        "constraints": [
            "The number of nodes of listA is in the m.",
            "The number of nodes of listB is in the n.",
            "1 <= m, n <= 3 * 10^4",
            "1 <= Node.val <= 10^5",
            "0 <= skipA <\u00a0m",
            "0 <= skipB <\u00a0n",
            "intersectVal is 0 if listA and listB do not intersect.",
            "intersectVal == listA[skipA] == listB[skipB] if listA and listB intersect."
        ],
        "solutions": [
            {
                "language": "java",
                "code": "public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    //boundary check\n    if(headA == null || headB == null) return null;\n    \n    ListNode a = headA;\n    ListNode b = headB;\n    \n    //if a & b have different len, then we will stop the loop after second iteration\n    while( a != b){\n     //for the end of first iteration, we just reset the pointer to the head of another linkedlist\n        a = a == null? headB : a.next;\n        b = b == null? headA : b.next;    \n    }\n    \n    return a;\n}",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "       a\nA:     a1 \u2192 a2 \u2192 a3\n                   \u2198\n                     c1 \u2192 c2 \u2192 c3 \u2192 null\n                   \u2197            \nB:     b1 \u2192 b2 \u2192 b3\n       b",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "javascript",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/49785/java-solution-without-knowing-the-difference-in-len/",
                "vote_count": "3843"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n  ListNode *temp;\n  while(headA != NULL){\n   temp = headB;\n   while(temp != NULL){\n    if(headA == temp){\n     return headA;\n    }\n    temp = temp -> next;\n   }\n   headA = headA -> next;\n  }\n  return NULL;\n }\n};",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/1093014/c-four-different-solutions/",
                "vote_count": "594"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n  unordered_map<ListNode*, int> m;\n  while(headA != NULL){\n   m[headA]++;\n   headA = headA -> next;\n  }\n  while(headB != NULL){\n   if(m[headB] > 0){\n    return headB;\n   }\n   headB = headB -> next;\n  }\n  return NULL;\n }\n};",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/1093014/c-four-different-solutions/",
                "vote_count": "594"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n  int n = 0;\n  int m = 0;\n  ListNode* ptr1 = headA;\n  ListNode* ptr2 = headB;\n  while(ptr1 != NULL){\n   n++;\n   ptr1 = ptr1 -> next;\n  }\n  while(ptr2 != NULL){\n   m++;\n   ptr2 = ptr2 -> next;\n  }\n  int t = abs(n - m);\n  if(n > m){\n   while(t){\n    headA = headA -> next;\n    t--;\n   }\n  }\n  else{\n   while(t){\n    headB = headB -> next;\n    t--;\n   }\n  }\n  while(headA != NULL and headB != NULL){\n   if(headA == headB){\n    return headA;\n   }\n   headA = headA -> next;\n   headB = headB -> next;\n  }\n  return NULL;\n }\n};",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/1093014/c-four-different-solutions/",
                "vote_count": "594"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n  ListNode *ptr1 = headA;\n  ListNode *ptr2 = headB;\n  while(ptr1 != ptr2){\n   if(ptr1 == NULL){\n    ptr1 = headB;\n   }\n   else{\n    ptr1 = ptr1 -> next;\n   }\n   if(ptr2 == NULL){\n    ptr2 = headA;\n   }\n   else{\n    ptr2 = ptr2 -> next;\n   }\n  }\n  return ptr1;\n }\n};",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/1093014/c-four-different-solutions/",
                "vote_count": "594"
            },
            {
                "language": "cpp",
                "code": "public:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *answer=nullptr,*iter = headA;\n        \n        while(iter!=nullptr)\n        {\n            iter->val *= -1;",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/1093014/c-four-different-solutions/",
                "vote_count": "594"
            },
            {
                "language": "javascript",
                "code": "var getIntersectionNode = function(headA, headB) {\n    let a = headA, b = headB\n    while (a !== b) {\n        a = !a ? headB : a.next\n        b = !b ? headA : b.next\n    }\n    return a\n};",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/1092898/js-python-java-c-easy-o-1-extra-space-solution-w-visual-explanation/",
                "vote_count": "364"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a, b = headA, headB\n        while (a != b):\n            a = headB if not a else a.next\n            b = headA if not b else b.next\n        return a",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/1092898/js-python-java-c-easy-o-1-extra-space-solution-w-visual-explanation/",
                "vote_count": "364"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA, b = headB;\n        while (a != b) {\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n    }\n}",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/1092898/js-python-java-c-easy-o-1-extra-space-solution-w-visual-explanation/",
                "vote_count": "364"
            },
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *a = headA, *b = headB;\n        while (a != b) {\n            a = !a ? headB : a->next;\n            b = !b ? headA : b->next;\n        }\n        return a;\n    }\n};",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/1092898/js-python-java-c-easy-o-1-extra-space-solution-w-visual-explanation/",
                "vote_count": "364"
            },
            {
                "language": "erlang",
                "code": "Runtime: 88 ms, faster than 12.02% of C++ online submissions for Intersection of Two Linked Lists.\nMemory Usage: 14.4 MB, less than 95.78% of C++ online submissions for Intersection of Two Linked Lists.",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/1092898/js-python-java-c-easy-o-1-extra-space-solution-w-visual-explanation/",
                "vote_count": "364"
            },
            {
                "language": "cpp",
                "code": "while(a!=b)\n{\n  a=a==NULL ? headB : a->next;\n  b=b==NULL ? headA : b->next;\n}",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/1092898/js-python-java-c-easy-o-1-extra-space-solution-w-visual-explanation/",
                "vote_count": "364"
            },
            {
                "language": "ruby",
                "code": " while (a !== b) {\n        a = !a ? headB : a.next\n        b = !b ? headA : b.next\n    }",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/1092898/js-python-java-c-easy-o-1-extra-space-solution-w-visual-explanation/",
                "vote_count": "364"
            },
            {
                "language": "",
                "code": "",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/1092898/js-python-java-c-easy-o-1-extra-space-solution-w-visual-explanation/",
                "vote_count": "364"
            },
            {
                "language": "java",
                "code": "public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    ListNode ptrA = headA, ptrB = headB;\n    while (ptrA != ptrB) { // loop until we found the first common node\n        ptrA = ptrA == null ? headB : ptrA.next; // once we're done with A, move to B\n        ptrB = ptrB == null ? headA : ptrB.next; // once we're done with B, move to A\n }\n return ptrA;\n}",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2116221/visual-explanation-one-pass-java/",
                "vote_count": "329"
            },
            {
                "language": "scala",
                "code": "Visualization of this solution:\nCase 1 (Have Intersection & Same Len):\n\n       a\nA:     a1 \u2192 a2 \u2192 a3\n                   \u2198\n                     c1 \u2192 c2 \u2192 c3 \u2192 null\n                   \u2197            \nB:     b1 \u2192 b2 \u2192 b3\n1 traversal; if both lists have different lengths, this solution will terminate in no more than 2 traversals -- in the second traversal, swapping a and b synchronizes a and b before the end of the second traversal. By synchronizing a and b I mean both have the same remaining steps in the second traversal so that it's guaranteed for them to reach the first intersection node, or reach null at the same time (technically speaking, in the same iteration) -- see Case 2 (Have Intersection & Different Len) and Case 4 (Have No Intersection & Different Len).\n it can resolve most of the doubts posted previously.",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/2116221/visual-explanation-one-pass-java/",
                "vote_count": "329"
            },
            {
                "language": "cpp",
                "code": " int init = []\n{\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::ofstream out(\"user.out\");\n    for(string s; getline(std::cin, s);)\n    {\n        if(s[0] != '0') out << \"Intersected at '\" << s << \"'\\n\";\n        else out << \"No intersection\\n\";\n        for(int i = 0; i < 4; ++i) getline(std::cin, s);\n    }\n    out.flush();\n    exit(0);\n    return 0;\n}();\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        unordered_map<ListNode*,int>mpp;\n    for (auto p = headA ; p!=NULL ; p = p->next){\n        mpp[p]=p->val;\n    }\n    for (auto p = headB ; p!=NULL ; p = p->next){\n        if (mpp.find(p)!=mpp.end()) return p;\n    }\n    return NULL;\n    }\n};",
                "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/solutions/3176186/solution/",
                "vote_count": "28"
            }
        ]
    },
    "156": {
        "question_id": 162,
        "title": "Find Peak Element",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/find-peak-element",
        "description": "A peak element is an element that is strictly greater than its neighbors.Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.You may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.You must write an algorithm that runs in O(log n) time. ",
        "examples": [
            {
                "input": "nums = [1,2,3,1]",
                "output": "2",
                "explanation": "3 is a peak element and your function should return the index number 2"
            },
            {
                "input": "nums = [1,2,1,3,5,6,4]",
                "output": "5",
                "explanation": "Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6"
            }
        ],
        "constraints": [
            "1 <= nums.length <= 1000",
            "-2^31 <= nums[i] <= 2^31 - 1",
            "nums[i] != nums[i + 1] for all valid i."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "int start = 0;\nint end = n-1;\n\nwhile(start <= end) {\n int mid = start + (end - start)/2;\n if(nums[mid] > nums[mid-1] && nums[mid] > nums[mid+1]) return mid;   // if mid == peak ( case 2 )\n else if(nums[mid] < nums[mid-1]) end = mid - 1; // downward slope and search space left side ( case 1)\n else if(nums[mid] < nums[mid+1]) start = mid + 1; // upward slope and search space right side ( case 3 )\n}",
                "url": "https://leetcode.com/problems/find-peak-element/solutions/1290642/intuition-behind-conditions-complete-explanation-diagram-binary-search/",
                "vote_count": "526"
            },
            {
                "language": "kotlin",
                "code": "  if(nums.length == 1) return 0; // single element\n        \n        int n = nums.length;\n        \n  // check if 0th/n-1th index is the peak element\n        if(nums[0] > nums[1]) return 0;\n        if(nums[n-1] > nums[n-2]) return n-1;\n  \n  // search in the remaining array\n        int start = 1;\n        int end = n-2;\n        \n        while(start <= end) {\n            int mid = start + (end - start)/2;\n            if(nums[mid] > nums[mid-1] && nums[mid] > nums[mid+1]) return mid;\n            else if(nums[mid] < nums[mid-1]) end = mid - 1;\n            else if(nums[mid] < nums[mid+1]) start = mid + 1;\n        }\n        return -1; // dummy return statement",
                "url": "https://leetcode.com/problems/find-peak-element/solutions/1290642/intuition-behind-conditions-complete-explanation-diagram-binary-search/",
                "vote_count": "526"
            },
            {
                "language": "cpp",
                "code": "int findPeakElement(vector<int>& nums) {\n        int n=size(nums), l=0, h=n-1;\n        while(l < h){ // l<=h when u are expecting to return from loop itself",
                "url": "https://leetcode.com/problems/find-peak-element/solutions/1290642/intuition-behind-conditions-complete-explanation-diagram-binary-search/",
                "vote_count": "526"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N), because in the worst case we traverse the <= N element. Where N is the size of the\n    Array(nums).\n                    \n    Space Complexity : O(1), the space complexity is constant.\n\n    Solved using Linear Search.\n\n*/\n\n\n/***************************************** Approach 1 First Code *****************************************/\n\nclass Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        int n = nums.size();\n        for(int i=0; i<n-1; i++){\n            if(nums[i] > nums[i+1]){\n                return i;\n            }\n        }\n        return n-1;\n    }\n};\n\n\n\n\n\n\n/***************************************** Approach 1 Second Code *****************************************/\n\nclass Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        return max_element(nums.begin(), nums.end()) - nums.begin();\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\n    is logarithmic.\n\n    Space Complexity : O(logN), Recursion stack space.\n\n    Solved using Binary Search (Recursive Approach).\n\n*/\n\n\n/***************************************** Approach 2 First Code *****************************************/\n\nclass Solution {\nprivate: \n    int recursive_binary_search(vector<int>& nums, int low, int high){\n        if(low == high){\n            return low;\n        }\n        int mid = (low + high) >> 1;\n        if(nums[mid] > nums[mid+1]){\n            return recursive_binary_search(nums, low, mid);\n        }\n        else{\n            return recursive_binary_search(nums, mid+1, high);\n        }\n    }\npublic:\n    int findPeakElement(vector<int>& nums) {\n        return recursive_binary_search(nums, 0, nums.size()-1);\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\n    is logarithmic.\n\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\n    constant.\n\n    Solved using Binary Search (Iterative Approach).\n\n*/\n\n\n/***************************************** Approach 3 First Code *****************************************/\n\nclass Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        int n = nums.size();\n        int low = 0;\n        int high = nums.size()-1;\n        while(low < high){\n            int mid = (low + high) >> 1;\n            if(nums[mid] > nums[mid+1]){\n                high = mid;\n            }\n            else{\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n};",
                "url": "https://leetcode.com/problems/find-peak-element/solutions/3189138/best-c-3-solution-binary-search-iterative-recursive-brute-force-optimize/",
                "vote_count": "40"
            }
        ]
    },
    "157": {
        "question_id": 164,
        "title": "Maximum Gap",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.You must write an algorithm that runs in linear time and uses linear extra space. ",
        "examples": [
            {
                "input": "nums = [3,6,9,1]",
                "output": "3",
                "explanation": "The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3."
            },
            {
                "input": "nums = [10]",
                "output": "0",
                "explanation": "The array contains less than 2 elements, therefore return 0."
            }
        ],
        "constraints": [
            "1 <= nums.length <= 10^5",
            "0 <= nums[i] <= 10^9"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "public class Solution {\npublic int maximumGap(int[] num) {\n    if (num == null || num.length < 2)\n        return 0;\n    // get the max and min value of the array\n    int min = num[0];\n    int max = num[0];\n    for (int i:num) {\n        min = Math.min(min, i);\n        max = Math.max(max, i);\n    }\n    // the minimum possibale gap, ceiling of the integer division\n    int gap = (int)Math.ceil((double)(max - min)/(num.length - 1));\n    int[] bucketsMIN = new int[num.length - 1]; // store the min value in that bucket\n    int[] bucketsMAX = new int[num.length - 1]; // store the max value in that bucket\n    Arrays.fill(bucketsMIN, Integer.MAX_VALUE);\n    Arrays.fill(bucketsMAX, Integer.MIN_VALUE);\n    // put numbers into buckets\n    for (int i:num) {\n        if (i == min || i == max)\n            continue;\n        int idx = (i - min) / gap; // index of the right position in the buckets\n        bucketsMIN[idx] = Math.min(i, bucketsMIN[idx]);\n        bucketsMAX[idx] = Math.max(i, bucketsMAX[idx]);\n    }\n    // scan the buckets for the max gap\n    int maxGap = Integer.MIN_VALUE;\n    int previous = min;\n    for (int i = 0; i < num.length - 1; i++) {\n        if (bucketsMIN[i] == Integer.MAX_VALUE && bucketsMAX[i] == Integer.MIN_VALUE)\n            // empty bucket\n            continue;\n        // min value minus the previous value is the current gap\n        maxGap = Math.max(maxGap, bucketsMIN[i] - previous);\n        // update previous bucket value\n        previous = bucketsMAX[i];\n    }\n    maxGap = Math.max(maxGap, max - previous); // updata the final max value gap\n    return maxGap;\n}",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/50643/bucket-sort-java-solution-with-explanation-o-n-time-and-space/",
                "vote_count": "505"
            },
            {
                "language": "python",
                "code": "1. if min==max, we can return 0 directly.\n2. the length of bucketMin and bucketMax is n rather than n-1. So max can be put in bucket.\n3. to check if bucket is empty, check if(bucketMin[i]!=Integer.MAX_VALUE) is ok\n4. do not need maxGap, gap is enough.\n\n\n    public int maximumGap(int[] nums) {\n            if(nums==null || nums.length<2)",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/50643/bucket-sort-java-solution-with-explanation-o-n-time-and-space/",
                "vote_count": "505"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximumGap(vector<int>& nums) {\n        int n = nums.size();\n        if (n < 2) return 0;\n        auto lu = minmax_element(nums.begin(), nums.end());\n        int l = *lu.first, u = *lu.second;",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/50643/bucket-sort-java-solution-with-explanation-o-n-time-and-space/",
                "vote_count": "505"
            },
            {
                "language": "python",
                "code": "class Solution:\n# @param num, a list of integer\n# @return an integer\ndef maximumGap(self, num):\n if len(num) < 2:\n  return 0\n imin = imax = num[0]\n for i in num:\n  imin = min(imin,i)",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/50643/bucket-sort-java-solution-with-explanation-o-n-time-and-space/",
                "vote_count": "505"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maximumGap(self, nums):\n        lo, hi, n = min(nums), max(nums), len(nums)\n        if n <= 2 or hi == lo: return hi - lo\n        B = defaultdict(list)\n        for num in nums:\n            ind = n-2 if num == hi else (num - lo)*(n-1)//(hi-lo)\n            B[ind].append(num)\n            \n        cands = [[min(B[i]), max(B[i])] for i in range(n-1) if B[i]]\n        return max(y[0]-x[1] for x,y in zip(cands, cands[1:]))",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/1240543/python-bucket-sort-explained/",
                "vote_count": "193"
            },
            {
                "language": "",
                "code": "0: [3, 6, 4, 13]\n1: [14, 15, 19]",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/1240543/python-bucket-sort-explained/",
                "vote_count": "193"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        mi, ma, n = min(nums), max(nums), len(nums)\n        if mi == ma: return 0  # All elements are the same\n        bucketSize = math.ceil((ma - mi) / (n - 1))\n        minBucket = [math.inf] * n\n        maxBucket = [-math.inf] * n\n        for x in nums:\n            idx = (x - mi) // bucketSize\n            minBucket[idx] = min(minBucket[idx], x)\n            maxBucket[idx] = max(maxBucket[idx], x)\n\n        maxGap = bucketSize  # Maximum gap is always greater or equal to bucketSize\n        prev = maxBucket[0]  # We always have 0th bucket\n        for i in range(1, n):\n            if minBucket[i] == math.inf: continue  # Skip empty bucket\n            maxGap = max(maxGap, minBucket[i] - prev)\n            prev = maxBucket[i]\n        return maxGap",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/1241681/java-python-bucket-idea-with-picture-clean-concise-o-n/",
                "vote_count": "154"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int maximumGap(int[] nums) {\n        int min = nums[0], max = nums[0], n = nums.length;\n        for (int x : nums) {\n            min = Math.min(min, x);\n            max = Math.max(max, x);\n        }\n        if (min == max) return 0; // All elements are the same\n        int bucketSize = (int) Math.ceil((double) (max - min) / (n - 1));\n        int[] minBucket = new int[n];\n        int[] maxBucket = new int[n];\n        Arrays.fill(minBucket, Integer.MAX_VALUE);\n        Arrays.fill(maxBucket, Integer.MIN_VALUE);\n        for (int x : nums) {\n            int idx = (x - min) / bucketSize;\n            minBucket[idx] = Math.min(x, minBucket[idx]);\n            maxBucket[idx] = Math.max(x, maxBucket[idx]);\n        }\n        int maxGap = bucketSize; // Maximum gap is always greater or equal to bucketSize\n        int previous = maxBucket[0]; // We always have 0th bucket\n        for (int i = 1; i < n; i++) {\n            if (minBucket[i] == Integer.MAX_VALUE) continue; // Skip empty bucket\n            maxGap = Math.max(maxGap, minBucket[i] - previous);\n            previous = maxBucket[i];\n        }\n        return maxGap;\n    }\n}",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/1241681/java-python-bucket-idea-with-picture-clean-concise-o-n/",
                "vote_count": "154"
            },
            {
                "language": "python",
                "code": "# if elements are uniformly distributed in array\na, a+d , a+2d........a+(n-1)d --- eqn1  ,where d = diff = gap\nwhere min = a so  max = a+(n-1)d = min + (n-1)gap\n# gap = (max-min)/d\n# let  |----|----|----|----|    a sorted uniform distributed arr and   | =  a number",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/1241681/java-python-bucket-idea-with-picture-clean-concise-o-n/",
                "vote_count": "154"
            },
            {
                "language": "java",
                "code": "int maximumGap(vector<int>& nums) {\n        const int n = nums.size();\n        if(n<=1) return 0;\n        int maxE = *max_element(nums.begin(),nums.end());\n        int minE = *min_element(nums.begin(),nums.end());\n        double len = double(maxE-minE)/double(n-1);\n        vector<int> maxA(n,INT_MIN);\n        vector<int> minA(n,INT_MAX);\n        for(int i=0; i<n; i++) {\n            int index = (nums[i]-minE)/len;\n            maxA[index] = max(maxA[index],nums[i]);\n            minA[index] = min(minA[index],nums[i]);\n        }\n        int gap = 0, prev = maxA[0];\n        for(int i=1; i<n; i++) {\n            if(minA[i]==INT_MAX) continue;\n            gap = max(gap,minA[i]-prev);\n            prev = maxA[i];\n        }\n        return gap;\n    }",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/50644/pigeon-hole-principle/",
                "vote_count": "113"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/50644/pigeon-hole-principle/",
                "vote_count": "113"
            },
            {
                "language": "java",
                "code": "public class Solution {\npublic int maximumGap(int[] nums) {\n    if (nums == null || nums.length < 2) {\n        return 0;\n    }\n    \n    // m is the maximal number in nums\n    int m = nums[0];\n    for (int i = 1; i < nums.length; i++) {\n        m = Math.max(m, nums[i]);\n    }\n    \n    int exp = 1; // 1, 10, 100, 1000 ...\n    int R = 10; // 10 digits\n\n    int[] aux = new int[nums.length];\n    \n    while (m / exp > 0) { // Go through all digits from LSB to MSB\n        int[] count = new int[R];\n        \n        for (int i = 0; i < nums.length; i++) {\n            count[(nums[i] / exp) % 10]++;\n        }\n        \n        for (int i = 1; i < count.length; i++) {\n            count[i] += count[i - 1];\n        }\n        \n        for (int i = nums.length - 1; i >= 0; i--) {\n            aux[--count[(nums[i] / exp) % 10]] = nums[i];\n        }\n        \n        for (int i = 0; i < nums.length; i++) {\n            nums[i] = aux[i];\n        }\n        exp *= 10;\n    }\n    \n    int max = 0;\n    for (int i = 1; i < aux.length; i++) {\n        max = Math.max(max, aux[i] - aux[i - 1]);\n    }\n     \n    return max;\n}",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/50642/radix-sort-solution-in-java-with-explanation/",
                "vote_count": "111"
            },
            {
                "language": "java",
                "code": "public int maximumGap(int[] nums) {\n         if (nums == null || nums.length < 2) return 0;\n         \n         int len = nums.length;\n         int[] bk = new int[len];\n         int e = 1;\n         \n         for (int i = 0; i < 8; i++) {",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/50642/radix-sort-solution-in-java-with-explanation/",
                "vote_count": "111"
            },
            {
                "language": "python",
                "code": "    for (int i = nums.length - 1; i >= 0; i--) {\n        aux[--count[(nums[i] / exp) % 10]] = nums[i];\n    }",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/50642/radix-sort-solution-in-java-with-explanation/",
                "vote_count": "111"
            },
            {
                "language": "java",
                "code": "class Solution {\npublic:\n    void countSort(vector<int> &nums,int n,int exp){\n        int output[n];\n        int i,count[10] = {0};\n        for(i=0;i<n;i++)\n            count[(nums[i]/exp)%10]++;\n        for(i=1;i<10;i++)",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/50642/radix-sort-solution-in-java-with-explanation/",
                "vote_count": "111"
            },
            {
                "language": "javascript",
                "code": "var maximumGap = function(nums) {\n    if (nums.length < 2) return 0\n    let hi = 0, lo = 2e9, ans = 0\n    for (let n of nums)\n        hi = Math.max(hi, n), lo = Math.min(lo, n)\n    let bsize = ~~((hi - lo) / (nums.length - 1)) || 1,\n        buckets = Array.from({length: ~~((hi - lo) / bsize) + 1}, () => [])\n    for (let n of nums)\n        buckets[~~((n - lo) / bsize)].push(n)\n    let currhi = 0\n    for (let b of buckets) {\n        if (!b.length) continue\n        let prevhi = currhi || b[0], currlo = b[0]\n        for (let n of b) \n            currhi = Math.max(currhi, n), currlo = Math.min(currlo, n)\n        ans = Math.max(ans, currlo - prevhi)\n    }\n    return ans\n};",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/1240838/js-python-java-c-simple-bucket-sort-solution-w-explanation/",
                "vote_count": "65"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        if len(nums) < 2: return 0\n        hi, lo, ans = max(nums), min(nums), 0\n        bsize = (hi - lo) // (len(nums) - 1) or 1\n        buckets = [[] for _ in range(((hi - lo) // bsize) + 1)]\n        for n in nums:\n            buckets[(n - lo) // bsize].append(n)\n        currhi = 0\n        for b in buckets:\n            if not len(b): continue\n            prevhi, currlo = currhi or b[0], b[0]\n            for n in b: \n                currhi, currlo = max(currhi, n), min(currlo, n)\n            ans = max(ans, currlo - prevhi)\n        return ans",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/1240838/js-python-java-c-simple-bucket-sort-solution-w-explanation/",
                "vote_count": "65"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int maximumGap(int[] nums) {\n        if (nums.length < 2) return 0;\n        int hi = 0, lo = Integer.MAX_VALUE, ans = 0;\n        for (int n : nums) {\n            hi = Math.max(hi, n);\n            lo = Math.min(lo, n);\n        }\n        int bsize = Math.max((hi - lo) / (nums.length - 1), 1);\n        List<List<Integer>> buckets = new ArrayList<>();\n        for (int i = (hi - lo) / bsize; i >= 0; i--)\n            buckets.add(new ArrayList<>());\n        for (int n : nums)\n            buckets.get((n - lo) / bsize).add(n);\n        int currhi = 0;\n        for (List<Integer> b : buckets) {\n            if (b.isEmpty()) continue;\n            int prevhi = currhi > 0 ? currhi : b.get(0), currlo = b.get(0);\n            for (int n : b) {\n                currhi = Math.max(currhi, n);\n                currlo = Math.min(currlo, n);\n            }\n            ans = Math.max(ans, currlo - prevhi);\n        }\n        return ans;\n    }\n}",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/1240838/js-python-java-c-simple-bucket-sort-solution-w-explanation/",
                "vote_count": "65"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximumGap(vector<int>& nums) {\n        if (nums.size() < 2) return 0;\n        int hi = 0, lo = INT_MAX, ans = 0;\n        for (auto& n : nums)\n            hi = max(hi, n), lo = min(lo, n);\n        int bsize = max(int((hi - lo) / (nums.size() - 1)), 1);\n        vector<vector<int>> buckets((hi - lo) / bsize + 1, vector<int>());\n        for (auto& n : nums)\n            buckets[(n - lo) / bsize].push_back(n);\n        int currhi = 0;\n        for (auto& b : buckets) {\n            if (b.empty()) continue;\n            int prevhi = currhi ? currhi : b[0], currlo = b[0];\n            for (auto& n : b)\n                currhi = max(currhi, n), currlo = min(currlo, n);\n            ans = max(ans, currlo - prevhi);\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/1240838/js-python-java-c-simple-bucket-sort-solution-w-explanation/",
                "vote_count": "65"
            },
            {
                "language": "javascript",
                "code": "var maximumGap = function(nums) {\n    if (nums.length < 2) return 0\n    let hi = 0, lo = 2e9, ans = 0\n    for (let n of nums)\n        hi = Math.max(hi, n), lo = Math.min(lo, n)\n    let bsize = ~~((hi - lo) / (nums.length - 1)) || 1,\n        buckets = Array.from({length: ~~((hi - lo) / bsize) + 1}, () => [])\n    for (let n of nums)\n        buckets[~~((n - lo) / bsize)].push(n)\n    let currhi = 0\n    for (let b of buckets) {\n        if (!b.length) continue\n        let prevhi = currhi || b[0], currlo = b[0]\n        for (let n of b) \n            currhi = Math.max(currhi, n), currlo = Math.min(currlo, n)\n        ans = Math.max(ans, currlo - prevhi)\n    }\n    return ans\n};",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/1240841/maximum-gap-js-python-java-c-simple-bucket-sort-solution-w-explanation/",
                "vote_count": "32"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        if len(nums) < 2: return 0\n        hi, lo, ans = max(nums), min(nums), 0\n        bsize = (hi - lo) // (len(nums) - 1) or 1\n        buckets = [[] for _ in range(((hi - lo) // bsize) + 1)]\n        for n in nums:\n            buckets[(n - lo) // bsize].append(n)\n        currhi = 0\n        for b in buckets:\n            if not len(b): continue\n            prevhi, currlo = currhi or b[0], b[0]\n            for n in b: \n                currhi, currlo = max(currhi, n), min(currlo, n)\n            ans = max(ans, currlo - prevhi)\n        return ans",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/1240841/maximum-gap-js-python-java-c-simple-bucket-sort-solution-w-explanation/",
                "vote_count": "32"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int maximumGap(int[] nums) {\n        if (nums.length < 2) return 0;\n        int hi = 0, lo = Integer.MAX_VALUE, ans = 0;\n        for (int n : nums) {\n            hi = Math.max(hi, n);\n            lo = Math.min(lo, n);\n        }\n        int bsize = Math.max((hi - lo) / (nums.length - 1), 1);\n        List<List<Integer>> buckets = new ArrayList<>();\n        for (int i = (hi - lo) / bsize; i >= 0; i--)\n            buckets.add(new ArrayList<>());\n        for (int n : nums)\n            buckets.get((n - lo) / bsize).add(n);\n        int currhi = 0;\n        for (List<Integer> b : buckets) {\n            if (b.isEmpty()) continue;\n            int prevhi = currhi > 0 ? currhi : b.get(0), currlo = b.get(0);\n            for (int n : b) {\n                currhi = Math.max(currhi, n);\n                currlo = Math.min(currlo, n);\n            }\n            ans = Math.max(ans, currlo - prevhi);\n        }\n        return ans;\n    }\n}",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/1240841/maximum-gap-js-python-java-c-simple-bucket-sort-solution-w-explanation/",
                "vote_count": "32"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximumGap(vector<int>& nums) {\n        if (nums.size() < 2) return 0;\n        int hi = 0, lo = INT_MAX, ans = 0;\n        for (auto& n : nums)\n            hi = max(hi, n), lo = min(lo, n);\n        int bsize = max(int((hi - lo) / (nums.size() - 1)), 1);\n        vector<vector<int>> buckets((hi - lo) / bsize + 1, vector<int>());\n        for (auto& n : nums)\n            buckets[(n - lo) / bsize].push_back(n);\n        int currhi = 0;\n        for (auto& b : buckets) {\n            if (b.empty()) continue;\n            int prevhi = currhi ? currhi : b[0], currlo = b[0];\n            for (auto& n : b)\n                currhi = max(currhi, n), currlo = min(currlo, n);\n            ans = max(ans, currlo - prevhi);\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/1240841/maximum-gap-js-python-java-c-simple-bucket-sort-solution-w-explanation/",
                "vote_count": "32"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        nums = sorted(nums)\n        greatest = 0\n        for i in range(len(nums) - 1):\n            greatest = max(nums[i+1] - nums[i], greatest)\n        return greatest",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/1240841/maximum-gap-js-python-java-c-simple-bucket-sort-solution-w-explanation/",
                "vote_count": "32"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximumGap(vector<int>& nums) {\n        if(nums.size()<2) return 0;\n        \n        int maxi = -1, mini = INT_MAX, n = nums.size();\n        for(auto u : nums) maxi = max(maxi,u), mini = min(mini,u);\n        // Since there will be n-1 gaps in between the numbers, this will be the average gap between\n        // any two numbers in the array.\n        // NOTE : Its very important to take the upper value of average gap, or else we will have a runtime error\n        // in the index of bucket that we will find in the next step.\n        int avg_gap = (int)ceil((double)(maxi-mini)/(n-1));\n        // To handle cases where all the elements are same!!!\n        if(avg_gap == 0) return 0;      \n        /*\n        Now, we can allot all the numbers a bucket, by dividing them with this average gap. Now it \n        can be easily observed that by dividing any numbers with this average gap, it is sure to fall \n        in one of the (n-1) buckets that will be formed. \n        Taking the example 1, \n                \n                [3, 6, 9, 1]      =>    avg gap = ceil[(9-1)/3] ~= 3\n        Now we have to find the maximum gap, therefore, it will be >= average gap.\n        Alloting the buckets : [[arr[i]-min]/average_gap], for all numbers of the array, this formula will result\n                               in numbers that lie in a range, and thus the result for each can be considered as \n                               the bucket index.\n                               \n                [3-1]/3 = 0\n                [6-1]/3 = 1\n                [9-1]/3 = 2\n                [1-1]/3 = 0\n            \n              0        1      2\n            1___3    ____6  ____9\n            \n            Now as we said, the maximum gap will be greater than or equal to the average gap, therefore, the answer\n            will not lie within a bucket because its gap between the maximum and minimum element will always be\n            less than the average gap, for reference, consider in bucket 2nd, we had the bucket fully filled, then\n            in that case, we would have 4 as the minimum and 6 as maximum and there difference be 2. So, even in \n            worst case, we have a difference 1 less than the average. So, for the question, we only need to check\n            in between the buckets. Thus we only compare the difference between the maximum of one bucket and \n            minimum of next.\n        */\n        \n        // Allocating the buckets and storing the maximum and minimum of each bucket \n        vector <int> bucket_max(n,-1), bucket_min(n,INT_MAX);\n        for(int i = 0; i<n; i++){\n            int index = (nums[i]-mini)/avg_gap;\n            bucket_min[index] = min(bucket_min[index],nums[i]);\n            bucket_max[index] = max(bucket_max[index],nums[i]);\n        }\n        \n        // After filling the min and max arrays, we just need to compare...\n        int prev = mini, ans = 0;\n        for(int i = 0; i<bucket_min.size(); i++){\n            if(bucket_max[i] == -1) continue;\n            ans = max(ans,bucket_min[i]-prev);\n            prev = bucket_max[i];\n        }\n        // We need to compare with the last element which is maximum...\n        ans = max(ans,maxi-prev);\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/maximum-gap/solutions/1663928/c-linear-time-space-using-buckets-w-explanation/",
                "vote_count": "10"
            }
        ]
    },
    "158": {
        "question_id": 165,
        "title": "Compare Version Numbers",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/compare-version-numbers",
        "description": "Given two version numbers, version1 and version2, compare them.Version numbers consist of one or more revisions joined by a dot '.'. Each revision consists of digits and may contain leading zeros. Every revision contains at least one character. Revisions are 0-indexed from left to right, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example 2.5.33 and 0.1 are valid version numbers.To compare version numbers, compare their revisions in left-to-right order. Revisions are compared using their integer value ignoring any leading zeros. This means that revisions 1 and 001 are considered equal. If a version number does not specify a revision at an index, then treat the revision as 0. For example, version 1.0 is less than version 1.1 because their revision 0s are the same, but their revision 1s are 0 and 1 respectively, and 0 < 1.Return the following:If version1 < version2, return -1.If version1 > version2, return 1.Otherwise, return 0. ",
        "examples": [
            {
                "input": "version1 = \"1.01\", version2 = \"1.001\"",
                "output": "0",
                "explanation": "Ignoring leading zeroes, both \"01\" and \"001\" represent the same integer \"1\"."
            },
            {
                "input": "version1 = \"1.0\", version2 = \"1.0.0\"",
                "output": "0",
                "explanation": "version1 does not specify revision 2, which means it is treated as \"0\"."
            },
            {
                "input": "version1 = \"0.1\", version2 = \"1.1\"",
                "output": "-1",
                "explanation": "version1's revision 0 is \"0\", while version2's revision 0 is \"1\". 0 < 1, so version1 < version2."
            }
        ],
        "constraints": [
            "1 <= version1.length, version2.length <= 500",
            "version1 and version2\u00a0only contain digits and '.'.",
            "version1 and version2\u00a0are valid version numbers.",
            "All the given revisions in\u00a0version1 and version2\u00a0can be stored in\u00a0a\u00a032-bit integer."
        ],
        "solutions": [
            {
                "language": "typescript",
                "code": "public int compareVersion(String version1, String version2) {\n    String[] levels1 = version1.split(\"\\\\.\");\n    String[] levels2 = version2.split(\"\\\\.\");\n    \n    int length = Math.max(levels1.length, levels2.length);\n    for (int i=0; i<length; i++) {\n     Integer v1 = i < levels1.length ? Integer.parseInt(levels1[i]) : 0;\n     Integer v2 = i < levels2.length ? Integer.parseInt(levels2[i]) : 0;\n     int compare = v1.compareTo(v2);\n     if (compare != 0) {\n      return compare;\n     }\n    }\n    \n    return 0;\n}",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/50774/accepted-small-java-solution/",
                "vote_count": "424"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\n    public int compareVersion(String version1, String version2) {\n        int temp1 = 0,temp2 = 0;\n        int len1 = version1.length(),len2 = version2.length();\n        int i = 0,j = 0;\n        while(i<len1 || j<len2) {\n            temp1 = 0;\n            temp2 = 0;\n            while(i<len1 && version1.charAt(i) != '.') {",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/50774/accepted-small-java-solution/",
                "vote_count": "424"
            },
            {
                "language": "javascript",
                "code": "\"2.10000000000000000000000000000.0\" \"2.1\"",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/50774/accepted-small-java-solution/",
                "vote_count": "424"
            },
            {
                "language": "dart",
                "code": "public int compareVersion(String version1, String version2) {\n        String[] array1 = version1.split(\"\\\\.\");\n        String[] array2 = version2.split(\"\\\\.\");",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/50774/accepted-small-java-solution/",
                "vote_count": "424"
            },
            {
                "language": "csharp",
                "code": "int compareVersion(string version1, string version2) {\n    int i = 0; \n    int j = 0;\n    int n1 = version1.size(); \n    int n2 = version2.size();\n    \n    int num1 = 0;\n    int num2 = 0;\n    while(i<n1 || j<n2)\n    {\n        while(i<n1 && version1[i]!='.'){\n            num1 = num1*10+(version1[i]-'0');\n            i++;\n        }\n        \n        while(j<n2 && version2[j]!='.'){\n            num2 = num2*10+(version2[j]-'0');;\n            j++;\n        }\n        \n        if(num1>num2) return 1;\n        else if(num1 < num2) return -1;\n        \n        num1 = 0;\n        num2 = 0;\n        i++;\n        j++;\n    }\n    \n    return 0;\n}",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/50767/my-2ms-easy-solution-with-c-c/",
                "vote_count": "246"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    \n    // Corner case 1: '01' vs '1'\n    // Corner case 2: '1.0' vs '1'\n    \n    int compareVersion(string version1, string version2) {\n        ",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/50767/my-2ms-easy-solution-with-c-c/",
                "vote_count": "246"
            },
            {
                "language": "cpp",
                "code": "    int n1=version1.size();\n    int n2=version2.size();\n    long int i=0,j=0,a=0,b=0;\n    ",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/50767/my-2ms-easy-solution-with-c-c/",
                "vote_count": "246"
            },
            {
                "language": "csharp",
                "code": "int compareVersion(string version1, string version2)\n{\n    int iLength1 = version1.size(), iLength2 = version2.size();\n    string sVersion1, sVersion2;\n    int iStart1 = 0, iStart2 = 0, iPoint1 = 0, iPoint2 = 0, iVersion1, iVersion2;\n    while(iStart1 < iLength1 || iStart2 < iLength2)\n    {\n        if(iStart1 >= iLength1)",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/50767/my-2ms-easy-solution-with-c-c/",
                "vote_count": "246"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n  int compareVersion( const string& version1, const string& version2 ) {\n    const int n1 = version1.size(), n2 = version2.size();\n\n    for ( int i = 0, j = 0; i < n1 || j < n2; ++i, ++j ) {\n      const int istart = i, jstart = j;\n      for ( ; i < n1 && version1[ i ] != '.'; ++i )\n        ;",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/50767/my-2ms-easy-solution-with-c-c/",
                "vote_count": "246"
            },
            {
                "language": "python",
                "code": "def compareVersion(self, version1, version2):\n        versions1 = [int(v) for v in version1.split(\".\")]\n        versions2 = [int(v) for v in version2.split(\".\")]\n        for i in range(max(len(versions1),len(versions2))):\n            v1 = versions1[i] if i < len(versions1) else 0\n            v2 = versions2[i] if i < len(versions2) else 0\n            if v1 > v2:\n                return 1\n            elif v1 < v2:\n                return -1;\n        return 0;",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/50952/python-10-lines-solution/",
                "vote_count": "139"
            },
            {
                "language": "python",
                "code": "from itertools import zip_longest\n\nclass Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/50952/python-10-lines-solution/",
                "vote_count": "139"
            },
            {
                "language": "php",
                "code": "    def compareVersion(self, version1: str, version2: str) -> int:\n        v1 = [int(i) for i in version1.split('.')]\n        v2 = [int(i) for i in version2.split('.')]\n\n        diff = len(v1) - len(v2)\n        v1 += [0] * -diff\n        v2 += [0] * diff",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/50952/python-10-lines-solution/",
                "vote_count": "139"
            },
            {
                "language": "python",
                "code": "        v1 = [int(v) for v in version1.split('.')] \n        v2 = [int(v) for v in version2.split('.')] \n        \n        for i in range(len(v1)):\n            if i == len(v2):\n                return 1 if any( v != 0 for v in v1[i:]) else 0",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/50952/python-10-lines-solution/",
                "vote_count": "139"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        d1 = collections.defaultdict(lambda:0)\n        d2 = collections.defaultdict(lambda:0)\n        \n        for i,v in enumerate(version1.split('.')):\n            d1[i] = int(v)\n        for i,v in enumerate(version2.split('.')):",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/50952/python-10-lines-solution/",
                "vote_count": "139"
            },
            {
                "language": "go",
                "code": "    def compareVersion(self, version1: str, version2: str) -> int:\n        v1, v2 = version1.split('.'), version2.split('.')\n        l1, l2 = len(v1), len(v2)\n        for i in range(max(l1, l2)):\n            a1, a2 = int(v1[i]) if i < l1 else 0, int(v2[i]) if i < l2 else 0\n            if a1 < a2: return -1",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/50952/python-10-lines-solution/",
                "vote_count": "139"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/50952/python-10-lines-solution/",
                "vote_count": "139"
            },
            {
                "language": "swift",
                "code": "Suppose our strings given to us is s1 = \"1.1.0.3.5.06\" and s2 = \"1.1.0.00003.5.00005\"\n\ns1 = \"1.1.0.3.5.06\"                       s2 = \"1.1.0.00003.5.00005\"\n       \u2191                                         \u2191\n    For the first dot number generated from s1 is, number1 = 1 &\n    For the first dot number generated from s2 is, number2 = 1\n    Since both them are equal, so we can't comment anything,\n    therefore we will move further\n    \ns1 = \"1.1.0.3.5.06\"                       s2 = \"1.1.0.00003.5.00005\"\n         \u2191                                         \u2191\n   For the second dot number generated from s1 is, number1 = 1 &\n      For the second dot number generated from s2 is, number2 = 1\n      Since both them also equal, so we can not comment anything,\n      therefore we will move further\n   \ns1 = \"1.1.0.3.5.06\"                       s2 = \"1.1.0.00003.5.00005\"\n           \u2191                                         \u2191\n     For the third dot number generated from s1 is, number1 = 0 &\n        For the third dot number generated from s2 is, number2 = 0\n        Since both again equal, so we can not comment anything,\n        therefore we will move further\n     \ns1 = \"1.1.0.3.5.06\"                       s2 = \"1.1.0.00003.5.00005\"\n             \u2191                                             \u2191\n    For the fourth dot number generated from s1 is, number1 = 3 &\n          For the fourth dot number generated from s2 is, number2 = 00003\n    //One Important thing is to observe here is, \n    //no matter how many leading zeroes are their, if numbers are same then we will proceed further\n          Since both again equal, so we can not comment anything,\n          therefore we will move further\n    \ns1 = \"1.1.0.3.5.06\"                       s2 = \"1.1.0.00003.5.00005\"\n               \u2191                                             \u2191\n      For the fifth dot number generated from s1 is, number1 = 5 &\n            For the fifth dot number generated from s2 is, number2 = 5\n      Since both again equal, so we can not comment anything,\n      therefore we will move further\n      \ns1 = \"1.1.0.3.5.06 \"                       s2 = \"1.1.0.00003.5.00005 \"\n                   \u2191                                                 \u2191\n       And lastly number generated from s1 is, number1 = 06 &\n       number generated from s1 is, number2  = 00005\n       since number1 > number2 , therefore we will return 1 as our answer.\n\nTherefore, Our answer should be 1.",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/1797276/easy-c-intuitive-solution-fast-simple/",
                "vote_count": "77"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    int compareVersion(string version1, string version2) {   \n        int i = 0, j = 0, n1 = version1.size(), n2 = version2.size(), num1 = 0, num2 = 0; \n        while(i<n1 || j<n2)\n        {\n            while(i<n1 && version1[i]!='.')\n            {\n                num1 = num1*10+(version1[i]-'0');\n                i++;\n            }\n            while(j<n2 && version2[j]!='.')\n            {\n                num2 = num2*10+(version2[j]-'0');\n                j++;\n            }\n            if(num1>num2)\n            {\n                return 1;\n            }\n            if(num1 < num2) \n            {\n                return -1;\n            }\n            i++;\n            j++;\n            num1 = 0;\n            num2 = 0;\n        }\n        return 0; \n    }\n};",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/1797276/easy-c-intuitive-solution-fast-simple/",
                "vote_count": "77"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def compareVersion(self, v1: str, v2: str) -> int:\n        v1, v2 = list(map(int, v1.split('.'))), list(map(int, v2.split('.')))  \n        for rev1, rev2 in zip_longest(v1, v2, fillvalue=0):\n            if rev1 == rev2:\n                continue\n\n            return -1 if rev1 < rev2 else 1 \n\n        return 0",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/1797594/python3-solution-explained/",
                "vote_count": "57"
            },
            {
                "language": "kotlin",
                "code": "from typing import List\n\nclass Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        def parse(ver: str) -> List[int]:\n            return [int(k) for k in ver.split('.')]\n        \n        v1, v2 = parse(version1), parse(version2)",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/1797594/python3-solution-explained/",
                "vote_count": "57"
            },
            {
                "language": "go",
                "code": "class Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        version1=version1.split(\".\")\n        version2=version2.split(\".\")\n        bool,i,n,m=False,0,min(len(version1),len(version2)),max(len(version1),len(version2))\n        while i<n:",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/1797594/python3-solution-explained/",
                "vote_count": "57"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public int compareVersion(String version1, String version2) {\n        \n        String[] v1Array = version1.split(\"[.]\");\n        String[] v2Array = version2.split(\"[.]\");\n        int maxLen = Math.max(v1Array.length,v2Array.length);\n        for(int i=0;i<maxLen;i++)\n        {",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/1797594/python3-solution-explained/",
                "vote_count": "57"
            },
            {
                "language": "php",
                "code": "def compareVersion(self, version1: str, version2: str) -> int:\n    return next(((i1 > i2) - (i1 < i2) for r1, r2 in zip_longest(version1.split('.'), version2.split('.'), fillvalue=0) if (i1 := int(r1)) != (i2 := int(r2))), 0)",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/1797594/python3-solution-explained/",
                "vote_count": "57"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def compareVersion(self, version1, version2):\n        s1 = [int(i) for i in version1.split(\".\")]\n        s2 = [int(i) for i in version2.split(\".\")]\n        \n        l1, l2 = len(s1), len(s2)\n        if l1 < l2: s1 += [0]*(l2-l1) \n        else: s2 += [0]*(l1 - l2)\n            \n        return (s1 > s2) - (s1 < s2)",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/837727/python-easy-split-solution-explained/",
                "vote_count": "49"
            },
            {
                "language": "typescript",
                "code": "public int compareVersion(String version1, String version2) {\n        String[] str1 = version1.split(\"\\\\.\");\n        String[] str2 = version2.split(\"\\\\.\");\n        int max = Math.max(str1.length,str2.length);\n        for(int i=0;i<max;i++){\n            int num1 = i >= str1.length ? 0 : Integer.parseInt(str1[i]);\n            int num2 = i >= str2.length ? 0 : Integer.parseInt(str2[i]);\n            if(num1 < num2) return -1;\n            if(num1 > num2) return 1;\n        }\n\n        return 0;\n    }",
                "url": "https://leetcode.com/problems/compare-version-numbers/solutions/1797472/java-concise-solution/",
                "vote_count": "14"
            }
        ]
    },
    "159": {
        "question_id": 166,
        "title": "Fraction to Recurring Decimal",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/fraction-to-recurring-decimal",
        "description": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.If the fractional part is repeating, enclose the repeating part in parentheses.If multiple answers are possible, return any of them.It is guaranteed that the length of the answer string is less than 104 for all the given inputs. ",
        "examples": [
            {
                "input": "numerator = 1, denominator = 2",
                "output": "\"0.5\"",
                "explanation": null
            },
            {
                "input": "numerator = 2, denominator = 1",
                "output": "\"2\"",
                "explanation": null
            },
            {
                "input": "numerator = 4, denominator = 333",
                "output": "\"0.(012)\"",
                "explanation": null
            }
        ],
        "constraints": [
            "-2^31 <=\u00a0numerator, denominator <= 2^31 - 1",
            "denominator != 0"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "public class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        if (numerator == 0) {\n            return \"0\";\n        }\n        StringBuilder res = new StringBuilder();\n        // \"+\" or \"-\"\n        res.append(((numerator > 0) ^ (denominator > 0)) ? \"-\" : \"\");\n        long num = Math.abs((long)numerator);\n        long den = Math.abs((long)denominator);\n        \n        // integral part\n        res.append(num / den);\n        num %= den;\n        if (num == 0) {\n            return res.toString();\n        }\n        \n        // fractional part\n        res.append(\".\");\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\n        map.put(num, res.length());\n        while (num != 0) {\n            num *= 10;\n            res.append(num / den);\n            num %= den;\n            if (map.containsKey(num)) {\n                int index = map.get(num);\n                res.insert(index, \"(\");\n                res.append(\")\");\n                break;\n            }\n            else {\n                map.put(num, res.length());\n            }\n        }\n        return res.toString();\n    }\n}",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51106/my-clean-java-solution/",
                "vote_count": "528"
            },
            {
                "language": "cpp",
                "code": "    long remainder = num % den;",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51106/my-clean-java-solution/",
                "vote_count": "528"
            },
            {
                "language": "dart",
                "code": "",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51106/my-clean-java-solution/",
                "vote_count": "528"
            },
            {
                "language": "go",
                "code": "res.append(((numerator > 0) ^ (denominator > 0)) ? \"-\" : \"\");",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51106/my-clean-java-solution/",
                "vote_count": "528"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        StringBuilder result = new StringBuilder();\n        String sign = (numerator < 0 == denominator < 0 || numerator == 0) ? \"\" : \"-\";\n        long num = Math.abs((long) numerator);\n        long den = Math.abs((long) denominator);\n        result.append(sign);\n        result.append(num / den);",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51106/my-clean-java-solution/",
                "vote_count": "528"
            },
            {
                "language": "cpp",
                "code": "// upgraded parameter types\nstring fractionToDecimal(int64_t n, int64_t d) {\n    // zero numerator\n    if (n == 0) return \"0\";\n\n    string res;\n    // determine the sign\n    if (n < 0 ^ d < 0) res += '-';\n\n    // remove sign of operands\n    n = abs(n), d = abs(d);\n\n    // append integral part\n    res += to_string(n / d);\n\n    // in case no fractional part\n    if (n % d == 0) return res;\n\n    res += '.';\n\n    unordered_map<int, int> map;\n\n    // simulate the division process\n    for (int64_t r = n % d; r; r %= d) {\n\n        // meet a known remainder\n        // so we reach the end of the repeating part\n        if (map.count(r) > 0) {\n            res.insert(map[r], 1, '(');\n            res += ')';\n            break;\n        }\n\n        // the remainder is first seen\n        // remember the current position for it\n        map[r] = res.size();\n\n        r *= 10;\n\n        // append the quotient digit\n        res += to_string(r / d);\n    }\n\n    return res;\n}",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51109/accepted-cpp-solution-with-explainations/",
                "vote_count": "311"
            },
            {
                "language": "python",
                "code": "class Solution:\n    # @return a string\n    def fractionToDecimal(self, n, d):\n        res = ''\n        if n == 0:\n            return str(n)",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51109/accepted-cpp-solution-with-explainations/",
                "vote_count": "311"
            },
            {
                "language": "go",
                "code": "public String fractionToDecimal(int numerator, int denominator) {\n    if (denominator == 0)\n        return \"NaN\";\n    if (numerator == 0)\n        return \"0\";\n    StringBuilder result = new StringBuilder();\n    Long n = new Long(numerator);\n    Long d = new Long(denominator);",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51109/accepted-cpp-solution-with-explainations/",
                "vote_count": "311"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    std::string fractionToDecimal(long long numerator, long long denominator) {\n        if (!numerator)\n            return \"0\";\n  std::string str = numerator < 0 ^ denominator < 0 ? \"-\" : \"\";",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51109/accepted-cpp-solution-with-explainations/",
                "vote_count": "311"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    string fractionToDecimal(int numerator, int denominator) {\n        if (!numerator) {\n            return \"0\";\n        }\n        string ans;\n        if (numerator > 0 ^ denominator > 0) {\n            ans += '-';\n        }\n        long n = labs(numerator), d = labs(denominator), r = n % d;\n        ans += to_string(n / d);\n        if (!r) {\n            return ans;\n        }\n        ans += '.';\n        unordered_map<long, int> rs;\n        while (r) {\n            if (rs.find(r) != rs.end()) {\n                ans.insert(rs[r], \"(\");\n                ans += ')';\n                break;\n            }\n            rs[r] = ans.size();\n            r *= 10;\n            ans += to_string(r / d);\n            r %= d;\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51160/c-unordered-map/",
                "vote_count": "228"
            },
            {
                "language": "cpp",
                "code": "long long rmd = numer - integral * denom;",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51160/c-unordered-map/",
                "vote_count": "228"
            },
            {
                "language": "cpp",
                "code": "long long rmd = numer % denom;",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51160/c-unordered-map/",
                "vote_count": "228"
            },
            {
                "language": "lisp",
                "code": "",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51160/c-unordered-map/",
                "vote_count": "228"
            },
            {
                "language": "lisp",
                "code": "",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51160/c-unordered-map/",
                "vote_count": "228"
            },
            {
                "language": "python",
                "code": "class Solution:\n# @return a string\ndef fractionToDecimal(self, numerator, denominator):\n    n, remainder = divmod(abs(numerator), abs(denominator))\n    sign = '-' if numerator*denominator < 0 else ''\n    result = [sign+str(n), '.']\n    stack = []\n    while remainder not in stack:\n        stack.append(remainder)\n        n, remainder = divmod(remainder*10, abs(denominator))\n        result.append(str(n))\n\n    idx = stack.index(remainder)\n    result.insert(idx+2, '(')\n    result.append(')')\n    return ''.join(result).replace('(0)', '').rstrip('.')",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51110/do-not-use-python-as-cpp-here-s-a-short-version-python-code/",
                "vote_count": "115"
            },
            {
                "language": "python",
                "code": "def fractionToDecimal(self, numerator, denominator):\n\n    n, remainder = divmod(abs(numerator), abs(denominator))",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51110/do-not-use-python-as-cpp-here-s-a-short-version-python-code/",
                "vote_count": "115"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def fractionToDecimal(self, numerator, denominator):\n\n        n, remainder = divmod(abs(numerator), abs(denominator))\n        sign = '-' if numerator * denominator < 0 else ''\n        integer = sign + str(n)\n        if remainder == 0: return integer\n        ",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51110/do-not-use-python-as-cpp-here-s-a-short-version-python-code/",
                "vote_count": "115"
            },
            {
                "language": "kotlin",
                "code": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        if not denominator:\n            return \"NaN\"\n        ans=[]",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51110/do-not-use-python-as-cpp-here-s-a-short-version-python-code/",
                "vote_count": "115"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        if numerator % denominator == 0:\n            return str(numerator//denominator)\n        sign = '' if numerator * denominator >= 0 else '-'\n        numerator, denominator = abs(numerator), abs(denominator)\n        res = sign + str(numerator//denominator) + '.'\n        numerator %= denominator\n        i, part = 0, ''\n        m = {numerator:i}\n        while numerator % denominator:\n            numerator *= 10\n            i += 1\n            rem = numerator % denominator\n            part += str(numerator // denominator)\n            if rem in m:\n                part = part[:m[rem]]+'('+part[m[rem]:]+')'\n                return res + part\n            m[rem] = i\n            numerator = rem\n        return res + part",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51187/python-easy-to-understand-solution/",
                "vote_count": "92"
            },
            {
                "language": "csharp",
                "code": "def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        # corner case\n        if denominator == 0:\n            return \"Invalid\"\n       if numerator == 0:\n            return \"0\"\n        if numerator % denominator == 0:\n            return str(numerator // denominator)",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/51187/python-easy-to-understand-solution/",
                "vote_count": "92"
            },
            {
                "language": "dart",
                "code": "//Code: \nint q = num / den;\nint r = num % den;\nans += q;\nif(r == 0) return ans;",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/1669777/accepted-simple-solution-with-step-by-step-detailed-explaination/",
                "vote_count": "74"
            },
            {
                "language": "javascript",
                "code": "//Code:\nwhile(r != 0)\n r *= 10;\n q = r / den;\n r = r % den;\n ans += q;",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/1669777/accepted-simple-solution-with-step-by-step-detailed-explaination/",
                "vote_count": "74"
            },
            {
                "language": "cpp",
                "code": "//Code :\nunordered_map<int, int> mp;\nwhile(r != 0)\n if(mp(r) is in map)\n  int pos = mp[r];\n  ans.insert(pos, \"(\");\n  ans += ')';\n  break;\n else\n  mp[r] = ans.length();\n  r *= 10;\n  q = r / den;\n  r = r % den;\n  ans += q;",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/1669777/accepted-simple-solution-with-step-by-step-detailed-explaination/",
                "vote_count": "74"
            },
            {
                "language": "cpp",
                "code": "long num = labs(numerator), den = labs(denominator);\nlong q = num / den;\nlong r = num % den;",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/1669777/accepted-simple-solution-with-step-by-step-detailed-explaination/",
                "vote_count": "74"
            },
            {
                "language": "cpp",
                "code": "unordered_map<long, int> mp;",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/1669777/accepted-simple-solution-with-step-by-step-detailed-explaination/",
                "vote_count": "74"
            },
            {
                "language": "javascript",
                "code": "if (numerator > 0 ^ denominator > 0) \n ans += '-';",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/1669777/accepted-simple-solution-with-step-by-step-detailed-explaination/",
                "vote_count": "74"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    string fractionToDecimal(int numerator, int denominator) {\n        if(!numerator) return \"0\";\n        string ans = \"\";\n        if (numerator > 0 ^ denominator > 0) ans += '-';\n        long num = labs(numerator), den = labs(denominator);\n        long q = num / den;\n        long r = num % den;\n        ans += to_string(q);\n        \n        if(r == 0) return ans;\n        \n        ans += '.';\n        unordered_map<long, int> mp;\n        while(r != 0){\n            if(mp.find(r) != mp.end()){\n                int pos = mp[r];\n                ans.insert(pos, \"(\");\n                ans += ')';\n                break;\n            }\n            else{\n                mp[r] = ans.length();\n                r *= 10;\n                q = r / den;\n                r = r % den;\n                ans += to_string(q);\n            }\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/1669777/accepted-simple-solution-with-step-by-step-detailed-explaination/",
                "vote_count": "74"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        StringBuilder ans = new StringBuilder();\n        if ((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0))\n            ans.append(\"-\");\n        \n        long num = (long) Math.abs((long) numerator);\n        long den = (long) Math.abs((long) denominator);",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/1669777/accepted-simple-solution-with-step-by-step-detailed-explaination/",
                "vote_count": "74"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    string fractionToDecimal(int n, int d) {\n     \n        string ans = \"\";\n       \n        \n        // Handling Negative Case\n        if((n<0 && d>0) || (n>0 && d<0 ))\n            ans+= '-';\n        \n        // To avoid Edge Cases Mentioned Below store Numerator and Denominator\n        // in Long long datatype ans remainder as well\n        \n        long long a = abs(n);\n        long long b = abs(d);\n        \n        // Calculation Integral Part Of Answer\n        long long num = abs(a/b);\n        \n        // Storing that to our ans string\n        ans += to_string(num);\n        \n        // Calculate Remainder\n        long long rem = abs(a%b);\n        \n        \n        // IF remainder is zero , there wont be decimal part so return ans\n        if(rem == 0)\n            return ans;\n        \n        ans.push_back('.');\n        \n        // Now We will calculate decimal part\n        // we will store mapping of remainder with its appearing index \n        // ex : 1/10 => rem = 1 its index will be 0\n        \n        string dec = \"\";\n        unordered_map<int, int> mp;\n       \n        \n        while(rem)\n        {\n            // iF We come across any remainder which is present in mapping \n            // it means the recurring part start from that remainder and we will get its index \n            // and process the result\n            if(mp.find(rem) != mp.end())\n            {\n                int index  = mp[rem];\n                string recurring = dec.substr(index);\n                dec.erase(index);\n                dec += '(' + recurring + ')';\n                break;\n            }\n            // If Remainder dont exist in map we will continue dividing and storing next remainder till it becomes zero\n            else\n            {\n                mp[rem] = dec.size();\n                dec += to_string(rem*10/b);\n                rem = (rem*10)%b;\n            }\n        }\n        \n        ans += dec;\n        return ans;\n        \n        \n        // Pls Upvote If You Like It\n    }\n};\n\n// Some Good Test Cases\n// 4\n// 333\n\n// -1\n// -2147483648\n\n// 1\n// 17\n\n// 45\n// 499\n\n// -2147483648\n// -1",
                "url": "https://leetcode.com/problems/fraction-to-recurring-decimal/solutions/2549071/c-handling-edge-cases-easily-with-full-explanation-using-hashmap/",
                "vote_count": "13"
            }
        ]
    },
    "160": {
        "question_id": 167,
        "title": "Two Sum II - Input Array Is Sorted",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted",
        "description": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.The tests are generated such that there is exactly one solution. You may not use the same element twice.Your solution must use only constant extra space. ",
        "examples": [
            {
                "input": "numbers = [2,7,11,15], target = 9",
                "output": "[1,2]",
                "explanation": "The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2]."
            },
            {
                "input": "numbers = [2,3,4], target = 6",
                "output": "[1,3]",
                "explanation": "The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3]."
            },
            {
                "input": "numbers = [-1,0], target = -1",
                "output": "[1,2]",
                "explanation": "The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2]."
            }
        ],
        "constraints": [
            "2 <= numbers.length <= 3 * 10^4",
            "-1000 <= numbers[i] <= 1000",
            "numbers is sorted in non-decreasing order.",
            "-1000 <= target <= 1000",
            "The tests are generated such that there is exactly one solution."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "public int[] twoSum(int[] nums, int target) {\n int l = 0, r = nums.length - 1;\n \n while (nums[l] + nums[r] != target) {\n  if (nums[l] + nums[r] < target) l++;\n  else r--;\n }\n\n return new int[] {l+1, r+1};\n}",
                "url": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solutions/2128501/two-pointers-visual-explanation-java/",
                "vote_count": "147"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for(int i=0; i<nums.length; i++){\n            int low = i+1;\n            int high = nums.length -1;\n            int mid;\n            int complement = target - nums[i];\n            ",
                "url": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solutions/2128501/two-pointers-visual-explanation-java/",
                "vote_count": "147"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int p1 = 0;\n        int p2 = nums.length-1;\n        int[] ans = new int[2];\n        \n        while(p1 < p2){\n            int sum = nums[p1]+nums[p2];     \n            if(sum == target){\n                ans[0] = p1+1;\n                ans[1] = p2+1;\n                break;\n            }\n            else if(sum > target){\n                p2--;\n            }\n            else{\n                p1++;\n            }\n        }\n        return ans;\n    }\n}",
                "url": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solutions/3276269/easy-to-understand-beats-99/",
                "vote_count": "22"
            }
        ]
    },
    "161": {
        "question_id": 168,
        "title": "Excel Sheet Column Title",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/excel-sheet-column-title",
        "description": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.For example:A -> 1B -> 2C -> 3...Z -> 26AA -> 27AB -> 28 ... ",
        "examples": [
            {
                "input": "columnNumber = 1",
                "output": "\"A\"",
                "explanation": null
            },
            {
                "input": "columnNumber = 28",
                "output": "\"AB\"",
                "explanation": null
            },
            {
                "input": "columnNumber = 701",
                "output": "\"ZY\"",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= columnNumber <= 2^31 - 1"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "return n == 0 ? \"\" : convertToTitle(--n / 26) + (char)('A' + (n % 26));",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/51398/my-1-lines-code-in-java-c-and-python/",
                "vote_count": "373"
            },
            {
                "language": "cpp",
                "code": "return n == 0 ? \"\" : convertToTitle(n / 26) + (char) (--n % 26 + 'A');",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/51398/my-1-lines-code-in-java-c-and-python/",
                "vote_count": "373"
            },
            {
                "language": "cpp",
                "code": "return n == 0 ? \"\" : convertToTitle((n - 1) / 26) + (char) ((n - 1) % 26 + 'A');",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/51398/my-1-lines-code-in-java-c-and-python/",
                "vote_count": "373"
            },
            {
                "language": "python",
                "code": "return \"\" if num == 0 else self.convertToTitle((num - 1) / 26) + chr((num - 1) % 26 + ord('A'))",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/51398/my-1-lines-code-in-java-c-and-python/",
                "vote_count": "373"
            },
            {
                "language": "java",
                "code": "public String convertToTitle(int n) {\n        StringBuffer sb = new StringBuffer();\n        while(n>0){\n            char tmp = (char)((n%26==0?26:n%26)+64);\n            sb.append(tmp);\n            n =(n%26==0? n/26-1: n/26);\n        }\n        return sb.reverse().toString();",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/51398/my-1-lines-code-in-java-c-and-python/",
                "vote_count": "373"
            },
            {
                "language": "python",
                "code": "return self.convertToTitle((num - 1) / 26) + chr((num - 1) % 26 + ord('A')) if num else \"\"",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/51398/my-1-lines-code-in-java-c-and-python/",
                "vote_count": "373"
            },
            {
                "language": "python",
                "code": "return \"\" if num == 0 else self.convertToTitle((num - 1) // 26) + chr((num - 1) % 26 + ord('A'))",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/51398/my-1-lines-code-in-java-c-and-python/",
                "vote_count": "373"
            },
            {
                "language": "rust",
                "code": "0 -> A\n25 -> Z\n26 -> BA",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/441430/detailed-explanation-here-s-why-we-need-n-at-first-of-every-loop-java-python-c/",
                "vote_count": "358"
            },
            {
                "language": "rust",
                "code": "1 -> A\n26 -> Z\n27 -> AA",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/441430/detailed-explanation-here-s-why-we-need-n-at-first-of-every-loop-java-python-c/",
                "vote_count": "358"
            },
            {
                "language": "typescript",
                "code": "for String ABZ and its corresponding number n:\nn = (A+1) * 26^2 + (B+1) * 26^1 + (Z+1) * 26^0",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/441430/detailed-explanation-here-s-why-we-need-n-at-first-of-every-loop-java-python-c/",
                "vote_count": "358"
            },
            {
                "language": "",
                "code": "both sides -1\nn-1 = (A+1) * 26^2 + (B+1) * 26^1 + Z",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/441430/detailed-explanation-here-s-why-we-need-n-at-first-of-every-loop-java-python-c/",
                "vote_count": "358"
            },
            {
                "language": "erlang",
                "code": "(n-1)%26 =  Z                                                  (1)\n(n-1)/26 = (A+1) * 26^1 + (B+1) * 26^0                         (2)",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/441430/detailed-explanation-here-s-why-we-need-n-at-first-of-every-loop-java-python-c/",
                "vote_count": "358"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public String convertToTitle(int n) {\n        StringBuilder sb = new StringBuilder();\n        while(n > 0){\n            n--;\n            int curr = n%26;\n            n /= 26;\n            sb.append((char)(curr+'A'));\n        }\n        return sb.reverse().toString();\n    }\n}",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/441430/detailed-explanation-here-s-why-we-need-n-at-first-of-every-loop-java-python-c/",
                "vote_count": "358"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def convertToTitle(self, n: int) -> str:\n        ans = []\n        while(n > 0):\n            n -= 1\n            curr = n % 26\n            n = int(n / 26)\n            ans.append(chr(curr + ord('A')))\n        \n        return ''.join(ans[::-1])",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/441430/detailed-explanation-here-s-why-we-need-n-at-first-of-every-loop-java-python-c/",
                "vote_count": "358"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string convertToTitle(int n) {\n        string ans;\n        while(n > 0) {\n            n--;\n            int curr = n % 26;\n            n = n / 26;\n            ans.push_back(curr + 'A');\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n        \n    }\n};",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/441430/detailed-explanation-here-s-why-we-need-n-at-first-of-every-loop-java-python-c/",
                "vote_count": "358"
            },
            {
                "language": "erlang",
                "code": "A   1     AA    26+ 1     BA  2\u00d726+ 1     ...     ZA  26\u00d726+ 1     AAA  1\u00d726\u00b2+1\u00d726+ 1\nB   2     AB    26+ 2     BB  2\u00d726+ 2     ...     ZB  26\u00d726+ 2     AAB  1\u00d726\u00b2+1\u00d726+ 2\n.   .     ..    .....     ..  .......     ...     ..  ........     ...  .............   \n.   .     ..    .....     ..  .......     ...     ..  ........     ...  .............\n.   .     ..    .....     ..  .......     ...     ..  ........     ...  .............\nZ  26     AZ    26+26     BZ  2\u00d726+26     ...     ZZ  26\u00d726+26     AAZ  1\u00d726\u00b2+1\u00d726+26",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/51404/python-solution-with-explanation/",
                "vote_count": "358"
            },
            {
                "language": "python",
                "code": "class Solution:\n    # @return a string\n    def convertToTitle(self, num):\n        capitals = [chr(x) for x in range(ord('A'), ord('Z')+1)]\n        result = []\n        while num > 0:\n            result.append(capitals[(num-1)%26])\n            num = (num-1) // 26\n        result.reverse()\n        return ''.join(result)",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/51404/python-solution-with-explanation/",
                "vote_count": "358"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def convertToTitle(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        result = ''\n        distance = ord('A') ",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/51404/python-solution-with-explanation/",
                "vote_count": "358"
            },
            {
                "language": "csharp",
                "code": "def convertToTitle(x):\n    result = []\n    while x > 0:\n        result.append(string.ascii_uppercase[(x - 1) % 26])\n        x = (x - 1) // 26",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/51404/python-solution-with-explanation/",
                "vote_count": "358"
            },
            {
                "language": "dart",
                "code": "def convertToTitle(num):\n        result = []\n        while num > 0:\n            result.append(chr((num-1)%26+ord('A')))\n            num = (num-1) // 26\n        result.reverse()\n        return ''.join(result)",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/51404/python-solution-with-explanation/",
                "vote_count": "358"
            },
            {
                "language": "csharp",
                "code": "    def convertToTitle(self, columnNumber: int) -> str:\n        ans = []\n        while columnNumber:\n            columnNumber, r = divmod(columnNumber - 1, 26)\n            ans.append(chr(r + ord('A')))\n        return \"\".join(reversed(ans))",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/51404/python-solution-with-explanation/",
                "vote_count": "358"
            },
            {
                "language": "python",
                "code": "    def convertToTitle(self, n):\n        res, caps = '', [chr(i + 65) for i in xrange(26)]\n        while n:\n            n, rem = divmod(n - 1, 26)\n            res = caps[rem] + res\n        return res",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/51404/python-solution-with-explanation/",
                "vote_count": "358"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def convertToTitle(self, n: int) -> str:\n        res = \"\"\n        while n:\n            res += chr(ord(\"A\") + (n - 1) % 26)\n            n = (n - 1) // 26\n        \n        return res[::-1]",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/51404/python-solution-with-explanation/",
                "vote_count": "358"
            },
            {
                "language": "python",
                "code": "class Solution:\n    # @return a string\n    def convertToTitle(self, num):\n        capitals = [chr(x) for x in range(ord('A'), ord('Z')+1)]\n        result = ''\n        while num:\n            result = (capitals[(num-1)%26]) + result\n            num = (num-1) // 26\n        return result",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/51404/python-solution-with-explanation/",
                "vote_count": "358"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def convertToTitle(self, n: int) -> str:\n        letters, title = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', []\n        while n:\n            title.append(letters[(n - 1) % 26])\n            n = (n - 1) // 26\n        return ''.join(reversed(title))",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/51404/python-solution-with-explanation/",
                "vote_count": "358"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public String convertToTitle(int columnNumber) {\n        // Create an empty string for storing the characters...\n        StringBuilder output = new StringBuilder();\n        // Run a while loop while columnNumber is positive...\n        while(columnNumber > 0){\n            // Subtract 1 from columnNumber...\n            columnNumber--;\n            // Get current character by doing modulo of columnNumber by 26...\n            char c = (char) (columnNumber % 26 + 'A');\n            // Divide columnNumber by 26...\n            columnNumber /= 26;\n            // Append the character into output...\n            output.append(c);\n        }\n        // Reverse the output string...\n        // Bcause we have found characters from right to left...\n        output.reverse();\n        // Return the reversed string.\n        return output.toString();\n    }\n}",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/2448578/easy-0-ms-100-fully-explained-java-c-python-python3/",
                "vote_count": "52"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string convertToTitle(int columnNumber) {\n        // Create an empty string for storing the characters...\n        string output;\n        // Run a while loop while columnNumber is positive...\n        while(columnNumber > 0){\n            // Subtract 1 from columnNumber...\n            columnNumber--;\n            // Get current character by doing modulo of columnNumber by 26...\n            int m = columnNumber % 26;\n            // Divide columnNumber by 26...\n            columnNumber /= 26;\n            output += 'A' + m;\n        }\n        // Reverse the output string...\n        // Bcause we have found characters from right to left...\n        reverse(output.begin(),output.end());\n        // Return the reversed string.\n        return output;\n    }\n};",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/2448578/easy-0-ms-100-fully-explained-java-c-python-python3/",
                "vote_count": "52"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        # Create an empty string for storing the characters...\n        output = \"\"\n        # Run a while loop while columnNumber is positive...\n        while columnNumber > 0:\n            # Subtract 1 from columnNumber and get current character by doing modulo of columnNumber by 26...\n            output = chr(ord('A') + (columnNumber - 1) % 26) + output\n            # Divide columnNumber by 26...\n            columnNumber = (columnNumber - 1) // 26\n        # Return the output string.\n        return output",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/2448578/easy-0-ms-100-fully-explained-java-c-python-python3/",
                "vote_count": "52"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public String convertToTitle(int columnNumber) {\n        String ans = \"\";\n        while (columnNumber>0){\n            columnNumber--;\n            ans = (char) ('A'+ (columnNumber%26)) + ans;\n            columnNumber = columnNumber/26;\n        }\n        return ans;\n    }\n}",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/2970322/very-easy-3-line-java-solution/",
                "vote_count": "25"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public String convertToTitle(int n) {\n      String result = \"\";\n       \n       while(n > 0) {\n           n --;\n           result = (char)('A' + (n % 26)) + result;\n           n = n / 26;\n       }\n       return result;\n    }\n}",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/2674844/java-easy-solution-without-stringbuilder/",
                "vote_count": "24"
            },
            {
                "language": "javascript",
                "code": "// target: AXY\ncolumnNumber = (26^2)*(A) + (26^1)*(X) + (26^0)*(Y)",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/3035652/c-solution-with-detailed-explanation/",
                "vote_count": "11"
            },
            {
                "language": "javascript",
                "code": "// target: AXY\ncolumnNumber: (26^2)*(A+1) + (26^1)*(X+1) + (26^0)*(Y+1)",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/3035652/c-solution-with-detailed-explanation/",
                "vote_count": "11"
            },
            {
                "language": "javascript",
                "code": "columnNumber = (26^2)*(A+1) + (26^1)*(X+1) + (26^0)*(Y+1)  \n// to retrieve Y\n    // 26^0 is just 1, so there is (1)*(Y+1)\n    // to retrieve Y, subtract 1 from both side, then divide both side by 26, the remainder will be Y\n\n// Subtracting 1 from both sides\ncolumnNumber-1 = (26^2)*(A+1) + (26^1)*(X+1) + Y\n\n// dividing both sides by 26\ncolumnNumber-1 = (26^1)*(A+1) + (26^0)*(X+1)\nrem = Y\n\n// If you observe, we have just reduced our problem size, we have to continue this process until we run out of numbers(i.e: columnNumber becomes 0)",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/3035652/c-solution-with-detailed-explanation/",
                "vote_count": "11"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string convertToTitle(int columnNumber) {\n        // base(10) -> base(26)   \n        string column = \"\";\n        int rem;\n\n        while(columnNumber){\n            rem = (--columnNumber)%26;  // similar to subtracting 1 from both sides and obtaining the remainder\n            columnNumber /= 26;\n\n            column = char('A' + rem) + column;\n        }\n\n        return column;\n    }\n};",
                "url": "https://leetcode.com/problems/excel-sheet-column-title/solutions/3035652/c-solution-with-detailed-explanation/",
                "vote_count": "11"
            }
        ]
    },
    "162": {
        "question_id": 169,
        "title": "Majority Element",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/majority-element",
        "description": "Given an array nums of size n, return the majority element.The majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the majority element always exists in the array. ",
        "examples": [
            {
                "input": "nums = [3,2,3]",
                "output": "3",
                "explanation": null
            }
        ],
        "constraints": [],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        unordered_map<int,int> a;\n        for(int i:nums)\n            a[i]++;\n        int maxval=nums[0];\n        for(auto x:a)\n        {\n            if(x.second>a[maxval])\n                maxval=x.first;\n        }\n        return maxval;\n    }\n};",
                "url": "https://leetcode.com/problems/majority-element/solutions/1787619/c-multiple-approaches-hashmaps-sorting-votingalgo/",
                "vote_count": "278"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int n=nums.size();\n        return nums[n/2];\n    }\n};",
                "url": "https://leetcode.com/problems/majority-element/solutions/1787619/c-multiple-approaches-hashmaps-sorting-votingalgo/",
                "vote_count": "278"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int majority,count=0;\n        for(int i=0;i<nums.size();i++)\n        {\n            if(count)\n            {\n                count+=(nums[i]==majority ? 1 : -1);\n            }\n            else\n            {\n                majority=nums[i];\n                count=1;\n            }\n        }\n        return majority;\n    }\n};",
                "url": "https://leetcode.com/problems/majority-element/solutions/1787619/c-multiple-approaches-hashmaps-sorting-votingalgo/",
                "vote_count": "278"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int majorityElement(vector<int>& arr) {\n        int ele=arr[0];\n        int count=0;\n        for(int i=0;i<arr.size();i++){\n            if(count==0)ele=arr[i];\n            count+=(ele==arr[i])?1:-1;\n        }\n        return ele;\n    }\n};",
                "url": "https://leetcode.com/problems/majority-element/solutions/3109595/100-faster-c-with-explanation-o-1-space/",
                "vote_count": "109"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        \n        int n = nums.size();\n         int k = ceil(n/2);\n\n        unordered_map<int,int>m1;\n        for(int i=0;i<nums.size();i++){\n            m1[nums[i]]++;\n        }\n        int g=0;\n        for(auto it:m1){\n         if(it.second > k){\n            g=it.first;\n         }  \n        }\n        return g;\n    }\n};",
                "url": "https://leetcode.com/problems/majority-element/solutions/3176192/solution/",
                "vote_count": "45"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        \n        int k=nums.size()/2;\n        int n=nums.size();\n        \n        sort(nums.begin(),nums.end());\n        \n        return nums[n/2];\n        \n    }\n};",
                "url": "https://leetcode.com/problems/majority-element/solutions/3346654/c-easy-approach-using-sort/",
                "vote_count": "11"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        count=0\n        result=0\n        for n in nums:\n            if count==0:\n                result=n\n            if n==result:\n                count+=1\n            else:\n                count-=1\n        return result\n    #please upvote me it would encourage me alot\n\n\n        \n        ",
                "url": "https://leetcode.com/problems/majority-element/solutions/3288207/awesome-logic-o-n/",
                "vote_count": "11"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        return nums[len(nums) // 2]",
                "url": "https://leetcode.com/problems/majority-element/solutions/3226883/simple-two-line-python-o-1-space-and-o-nlogn-time-complexity/",
                "vote_count": "10"
            }
        ]
    },
    "163": {
        "question_id": 171,
        "title": "Excel Sheet Column Number",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/excel-sheet-column-number",
        "description": "Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.For example:A -> 1B -> 2C -> 3...Z -> 26AA -> 27AB -> 28 ... ",
        "examples": [
            {
                "input": "columnTitle = \"A\"",
                "output": "1",
                "explanation": null
            },
            {
                "input": "columnTitle = \"AB\"",
                "output": "28",
                "explanation": null
            },
            {
                "input": "columnTitle = \"ZY\"",
                "output": "701",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= columnTitle.length <= 7",
            "columnTitle consists only of uppercase English letters.",
            "columnTitle is in the range [\"A\", \"FXSHRXW\"]."
        ],
        "solutions": [
            {
                "language": "java",
                "code": "public class Solution {\n    public int titleToNumber(String s) {\n        if (s == null) return -1;\n        int sum = 0;\n        // for each loop so we don't need to mess with index values.\n        for (char c : s.toUpperCase().toCharArray()) {\n            sum *= 26;\n            sum += c - 'A' + 1;\n        }\n        return sum;\n    }\n}",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/52154/concise-java-solution-with-explanation/",
                "vote_count": "306"
            },
            {
                "language": "cpp",
                "code": "public int titleToNumber(String columnTitle) {\n        int n = columnTitle.length();\n        \n        int columnNumber = 0;\n        \n        for(int i = 0;i < n;i++){\n            int currentColumn = columnTitle.charAt(i) - 'A' + 1;\n            columnNumber = columnNumber * 26 + currentColumn;\n        }",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/52154/concise-java-solution-with-explanation/",
                "vote_count": "306"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/52154/concise-java-solution-with-explanation/",
                "vote_count": "306"
            },
            {
                "language": "python",
                "code": "// C++ Easy and Concise Code\nclass Solution {\npublic:\n    int titleToNumber(string s) {\n        \n        int n=s.length();\n        //if length of string is 1 then just return its index val in alphabets eg: B-2, D-4, E-5, Z-26 etc.\n        if(n==1){\n            return s[0]-'A'+1;",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/52154/concise-java-solution-with-explanation/",
                "vote_count": "306"
            },
            {
                "language": "cpp",
                "code": "    public int titleToNumber(String columnTitle) {\n        char[] arr = columnTitle.toCharArray();\n        int n = arr.length;\n        int res = 0;\n\n        for(int i = 0; i < n; i++){\n            res += (arr[i] - 'A' + 1)*Math.pow(26, n-1-i);",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/52154/concise-java-solution-with-explanation/",
                "vote_count": "306"
            },
            {
                "language": "python",
                "code": "class Solution {\n   public int titleToNumber(String columnTitle) {\n       int idx=columnTitle.length();\n       int sum=0;\n       for(int i=0;i<idx;i++){\n           sum+=Math.pow(26,idx-1-i) * ((int)(columnTitle.charAt(i) -64));\n       }\n       return sum;",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/52154/concise-java-solution-with-explanation/",
                "vote_count": "306"
            },
            {
                "language": "csharp",
                "code": "1. Easy C++\n2. Line by Line Explanation with Comments.\n3. Detailed Explanation \u2705\n4. 4 Lines 0ms , 100 % faster.\n5. Please Upvote if it helps\u2b06\ufe0f\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \u2b07\ufe0f\n // \ud83d\ude09If you Like the repository don't foget to star the repository\ud83d\ude09 ",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/1790101/c-4-lines-easy-to-understand-0ms-100/",
                "vote_count": "297"
            },
            {
                "language": "rust",
                "code": "1. There are 26 letters in our alphabet and we start counting from 1, not zero.\n   So 'Z' is 26.\n2. The rest of the combinations start from a base 26\n\nAA --> 26*1+ 1 = 27 (A == 1)\nAB --> 26*1+ 2 = 28 (B == 2)\nAC -->26*1 + 3 = 29 (C == 3)\n.....\n\nSo we can write like this:\n\nresult = 0\nd = s[i](char) - 'A' + 1 (we used  s[i] -  'A' to convert the letter to a number like it's going to be C)\nresult = result* 26 + d\n\nIf the given input is only one letter, it will automatically take the value s[i] - 'A' + 1 as the first result is 0.",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/1790101/c-4-lines-easy-to-understand-0ms-100/",
                "vote_count": "297"
            },
            {
                "language": "swift",
                "code": "1. For every additional digit of the string, we multiply the value of the digit by 26^n\n2. here n is the number of digits it is away from the one's place.\n3. This is similar to how the number 254 could be broken down as this:\n  (2 x 10 x 10) + (5 x 10) + (4).\n4. The reason we use 26 instead of 10 is because 26 is our base.\n\nFor s = \"BCM\" the final solution would be (2 x 26 x 26) + (3 x 26) + (13)\n\nWe could do this process iteratively. Start at looking at the first digit \"B\". Add the int equivalent of \"B\" to the running sum and continue. \nEvery time we look at the following digit multiply our running sum by 26 before adding the next digit to signify we are changing places. Example below:\n\n\"B\" = 2\n\"BC\" = (2)26 + 3\n\"BCM\" = (2(26) + 3)26 + 13",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/1790101/c-4-lines-easy-to-understand-0ms-100/",
                "vote_count": "297"
            },
            {
                "language": "csharp",
                "code": "       // \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09Please upvote if it helps \ud83d\ude09\ud83d\ude09\ud83d\ude09\ud83d\ude09\nclass Solution {\npublic:\n    int titleToNumber(string columnTitle) {\n        int result = 0;\n        for(char c : columnTitle)\n        {\n   //d = s[i](char) - 'A' + 1 (we used  s[i] -  'A' to convert the letter to a number like it's going to be C)\n\n            int d = c - 'A' + 1;\n            result = result * 26 + d;\n        }\n        return result;\n    }\n};",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/1790101/c-4-lines-easy-to-understand-0ms-100/",
                "vote_count": "297"
            },
            {
                "language": "csharp",
                "code": "class Solution {\nprivate:\n    long helper(string &s, int idx) {\n        if (!idx)\n            return s[idx] - 'A' + 1;\n        return 26 * helper(s, idx - 1) + s[idx] - 'A' + 1;\n    }",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/1790101/c-4-lines-easy-to-understand-0ms-100/",
                "vote_count": "297"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/1790101/c-4-lines-easy-to-understand-0ms-100/",
                "vote_count": "297"
            },
            {
                "language": "cpp",
                "code": "  public static int titleToNumber(String columnTitle) {\n        int res=0;\n        for(char ch:columnTitle.toCharArray()){\n            res = res * 26 + (ch - 'A') + 1;\n        }\n        return res;\n    }",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/1790101/c-4-lines-easy-to-understand-0ms-100/",
                "vote_count": "297"
            },
            {
                "language": "cpp",
                "code": "public int titleToNumber(String columnTitle) {\n        int n = columnTitle.length();\n        int columnNumber = 0;\n        \n        for(int i = 0;i < n;i++){\n            int currentColumn = columnTitle.charAt(i) - 'A' + 1;\n            columnNumber = columnNumber * 26 + currentColumn;\n        }",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/1790101/c-4-lines-easy-to-understand-0ms-100/",
                "vote_count": "297"
            },
            {
                "language": "cpp",
                "code": "public int titleToNumber(String columnTitle) {\n    columnTitle = columnTitle.toLowerCase();\n    int result = 0;\n    for(int i=0; i < columnTitle.length(); i++){\n        char c = columnTitle.charAt(i);\n        int num = c - 'a' + 1;\n        int power = columnTitle.length() - i - 1;\n        result += num * Math.pow(26, power);",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/1790101/c-4-lines-easy-to-understand-0ms-100/",
                "vote_count": "297"
            },
            {
                "language": "cpp",
                "code": "    int result = 0; ",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/1790101/c-4-lines-easy-to-understand-0ms-100/",
                "vote_count": "297"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        ans, pos = 0, 0\n        for letter in reversed(columnTitle):\n            digit = ord(letter)-64\n            ans += digit * 26**pos\n            pos += 1\n            \n        return ans",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/1790567/python3-clean-solution-explained/",
                "vote_count": "135"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        val = 0\n        for i, c in enumerate(reversed(columnTitle.upper())):\n            val += (26**i) * (ord(c) - ord('A') + 1)\n            \n        return val\n``",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/1790567/python3-clean-solution-explained/",
                "vote_count": "135"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        col_num = 0\n        for char in columnTitle:\n            col_num = col_num * 26 + (ord(char) - 64)\n        return col_num",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/1790567/python3-clean-solution-explained/",
                "vote_count": "135"
            },
            {
                "language": "csharp",
                "code": "class Solution {\nprivate:\n    long helper(string &s, int idx) {\n        if (!idx)\n            return s[idx] - 'A' + 1;\n        return 26 * helper(s, idx - 1) + s[idx] - 'A' + 1;\n    }\npublic:\n    int titleToNumber(string columnTitle) {",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/1790567/python3-clean-solution-explained/",
                "vote_count": "135"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int titleToNumber(String columnTitle) {\n        int power = 1;\n        int result = 0;\n        for(int i = columnTitle.length()-1 ; i >= 0; i--, power *= 26)\n            result += (columnTitle.charAt(i)-'A'+1) * power;\n        return result;",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/1790567/python3-clean-solution-explained/",
                "vote_count": "135"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        res = 0\n        for c in columnTitle:\n            d = ord(c) - ord('A') + 1\n            res = res * 26 + d\n        return res",
                "url": "https://leetcode.com/problems/excel-sheet-column-number/solutions/1790567/python3-clean-solution-explained/",
                "vote_count": "135"
            }
        ]
    },
    "164": {
        "question_id": 172,
        "title": "Factorial Trailing Zeroes",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/factorial-trailing-zeroes",
        "description": "Given an integer n, return the number of trailing zeroes in n!.Note that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1. ",
        "examples": [
            {
                "input": "n = 3",
                "output": "0",
                "explanation": "3! = 6, no trailing zero."
            },
            {
                "input": "n = 5",
                "output": "1",
                "explanation": "5! = 120, one trailing zero."
            },
            {
                "input": "n = 0",
                "output": "0",
                "explanation": null
            }
        ],
        "constraints": [
            "0 <= n <= 10^4"
        ],
        "solutions": [
            {
                "language": "kotlin",
                "code": "    return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);",
                "url": "https://leetcode.com/problems/factorial-trailing-zeroes/solutions/52371/my-one-line-solutions-in-3-languages/",
                "vote_count": "643"
            },
            {
                "language": "kotlin",
                "code": "    return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);",
                "url": "https://leetcode.com/problems/factorial-trailing-zeroes/solutions/52371/my-one-line-solutions-in-3-languages/",
                "vote_count": "643"
            },
            {
                "language": "python",
                "code": "    return 0 if n == 0 else n / 5 + self.trailingZeroes(n / 5)",
                "url": "https://leetcode.com/problems/factorial-trailing-zeroes/solutions/52371/my-one-line-solutions-in-3-languages/",
                "vote_count": "643"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\n    public int trailingZeroes(int n) {\n        int count = 0;\n        while (n != 0) {\n            int tmp = n / 5;\n            count += tmp;",
                "url": "https://leetcode.com/problems/factorial-trailing-zeroes/solutions/52371/my-one-line-solutions-in-3-languages/",
                "vote_count": "643"
            },
            {
                "language": "kotlin",
                "code": "",
                "url": "https://leetcode.com/problems/factorial-trailing-zeroes/solutions/52371/my-one-line-solutions-in-3-languages/",
                "vote_count": "643"
            },
            {
                "language": "cpp",
                "code": "int trailingZeroes(int n) {\n    int result = 0;\n    for(long long i=5; n/i>0; i*=5){\n        result += (n/i);\n    }\n    return result;\n}",
                "url": "https://leetcode.com/problems/factorial-trailing-zeroes/solutions/52373/simple-c-c-solution-with-detailed-explaination/",
                "vote_count": "584"
            },
            {
                "language": "python",
                "code": "int trailingZeroes(int n) {\n    int sum=0;\n int tmp=0;\n while(n/5>0)\n {\n  tmp=n/5;\n  sum+=tmp;\n  n=tmp;\n    }",
                "url": "https://leetcode.com/problems/factorial-trailing-zeroes/solutions/52373/simple-c-c-solution-with-detailed-explaination/",
                "vote_count": "584"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int trailingZeroes(int n) {\n        int res = 0;\n        while (n) n /= 5, res += n;\n        return res;\n    }\n};",
                "url": "https://leetcode.com/problems/factorial-trailing-zeroes/solutions/52373/simple-c-c-solution-with-detailed-explaination/",
                "vote_count": "584"
            }
        ]
    },
    "165": {
        "question_id": 173,
        "title": "Binary Search Tree Iterator",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/binary-search-tree-iterator",
        "description": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.int next() Moves the pointer to the right, then returns the number at the pointer.Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called. ",
        "examples": [
            {
                "input": "[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\nOutput\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\nExplanation\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False",
                "output": "BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\nOutput\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\nExplanation\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [1, 10^5].",
            "0 <= Node.val <= 10^6",
            "At most 10^5 calls will be made to hasNext, and next.",
            "Could you implement next() and hasNext() to run in average O(1) time and use\u00a0O(h) memory, where h is the height of the tree?"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "public class BSTIterator {\n    private Stack<TreeNode> stack = new Stack<TreeNode>();\n    \n    public BSTIterator(TreeNode root) {\n        pushAll(root);\n    }\n\n    /** @return whether we have a next smallest number */\n    public boolean hasNext() {\n        return !stack.isEmpty();\n    }\n\n    /** @return the next smallest number */\n    public int next() {\n        TreeNode tmpNode = stack.pop();\n        pushAll(tmpNode.right);\n        return tmpNode.val;\n    }\n    \n    private void pushAll(TreeNode node) {\n        for (; node != null; stack.push(node), node = node.left);\n    }\n}",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/52525/my-solutions-in-3-languages-with-stack/",
                "vote_count": "897"
            },
            {
                "language": "cpp",
                "code": "class BSTIterator {\n    stack<TreeNode *> myStack;\npublic:\n    BSTIterator(TreeNode *root) {\n        pushAll(root);\n    }\n\n    /** @return whether we have a next smallest number */\n    bool hasNext() {\n        return !myStack.empty();\n    }\n\n    /** @return the next smallest number */\n    int next() {\n        TreeNode *tmpNode = myStack.top();\n        myStack.pop();\n        pushAll(tmpNode->right);\n        return tmpNode->val;\n    }\n\nprivate:\n    void pushAll(TreeNode *node) {\n        for (; node != NULL; myStack.push(node), node = node->left);\n    }\n};",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/52525/my-solutions-in-3-languages-with-stack/",
                "vote_count": "897"
            },
            {
                "language": "ruby",
                "code": "class BSTIterator:\n    # @param root, a binary search tree's root node\n    def __init__(self, root):\n        self.stack = list()\n        self.pushAll(root)\n\n    # @return a boolean, whether we have a next smallest number\n    def hasNext(self):\n        return self.stack\n\n    # @return an integer, the next smallest number\n    def next(self):\n        tmpNode = self.stack.pop()\n        self.pushAll(tmpNode.right)\n        return tmpNode.val\n        \n    def pushAll(self, node):\n        while node is not None:\n            self.stack.append(node)\n            node = node.left",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/52525/my-solutions-in-3-languages-with-stack/",
                "vote_count": "897"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        Stack<TreeNode> stack = new Stack();\n        List<Integer> res = new ArrayList();\n        while (root != null || !stack.isEmpty()) {",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/52525/my-solutions-in-3-languages-with-stack/",
                "vote_count": "897"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/52525/my-solutions-in-3-languages-with-stack/",
                "vote_count": "897"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/52525/my-solutions-in-3-languages-with-stack/",
                "vote_count": "897"
            },
            {
                "language": "java",
                "code": "/**\n * Definition for binary tree\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\npublic class BSTIterator {\n    \n    private Stack<TreeNode> stack;\n    public BSTIterator(TreeNode root) {\n        stack = new Stack<>();\n        TreeNode cur = root;\n        while(cur != null){\n            stack.push(cur);\n            if(cur.left != null)\n                cur = cur.left;\n            else\n                break;\n        }\n    }\n\n    /** @return whether we have a next smallest number */\n    public boolean hasNext() {\n        return !stack.isEmpty();\n    }\n\n    /** @return the next smallest number */\n    public int next() {\n        TreeNode node = stack.pop();\n        TreeNode cur = node;\n        // traversal right branch\n        if(cur.right != null){\n            cur = cur.right;\n            while(cur != null){\n                stack.push(cur);\n                if(cur.left != null)\n                    cur = cur.left;\n                else\n                    break;\n            }\n        }\n        return node.val;\n    }\n}\n\n/**\n * Your BSTIterator will be called like this:\n * BSTIterator i = new BSTIterator(root);\n * while (i.hasNext()) v[f()] = i.next();\n */",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/52526/ideal-solution-using-stack-java/",
                "vote_count": "441"
            },
            {
                "language": "cpp",
                "code": "public class BSTIterator {\n    private final Stack<TreeNode> stack;\n    \n    public BSTIterator(TreeNode root) {\n        stack = new Stack<>();\n        TreeNode cur = root;\n        while (cur != null) {\n            stack.push(cur);",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/52526/ideal-solution-using-stack-java/",
                "vote_count": "441"
            },
            {
                "language": "cpp",
                "code": "public class BSTIterator {\n\nStack<TreeNode> stack;\npublic BSTIterator(TreeNode root) {\n    stack = new Stack<>();\n    fillStack(root);\n}",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/52526/ideal-solution-using-stack-java/",
                "vote_count": "441"
            },
            {
                "language": "cpp",
                "code": "/**\n * Definition for binary tree\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/52526/ideal-solution-using-stack-java/",
                "vote_count": "441"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        Stack<TreeNode> stack = new Stack();\n        List<Integer> res = new ArrayList();\n        while (root != null || !stack.isEmpty()) {",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/52526/ideal-solution-using-stack-java/",
                "vote_count": "441"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/52526/ideal-solution-using-stack-java/",
                "vote_count": "441"
            },
            {
                "language": "cpp",
                "code": " public class BSTIterator {\n        \n        private TreeNode current; \n        private Stack<TreeNode> stack;\n        public BSTIterator(TreeNode root) {\n            current = root;\n            stack = new Stack<TreeNode>();\n        }",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/52526/ideal-solution-using-stack-java/",
                "vote_count": "441"
            },
            {
                "language": "java",
                "code": "class BSTIterator {\n    \n    Deque<TreeNode> stack = new ArrayDeque<>();\n    public BSTIterator(TreeNode root) {\n        TreeNode curr = root;\n        while(curr != null){\n            stack.push(curr);\n            curr = curr.left;",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/52526/ideal-solution-using-stack-java/",
                "vote_count": "441"
            },
            {
                "language": "java",
                "code": "public BSTIterator(TreeNode root) {\n    if (root != null) {\n        push(root);\n    }\n}",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/52526/ideal-solution-using-stack-java/",
                "vote_count": "441"
            },
            {
                "language": "cpp",
                "code": "class BSTIterator {\npublic:\n    stack<TreeNode*> s;\n    BSTIterator(TreeNode* root) {\n        partialInorder(root);\n    }\n    \n    void partialInorder(TreeNode* root){\n        while(root != NULL){\n            s.push(root);\n            root = root->left;\n        }\n    }\n    \n    int next() {\n        TreeNode* top = s.top();\n        s.pop();\n        partialInorder(top->right);\n        return top->val;\n    }\n    \n    bool hasNext() {\n        return !s.empty();\n    }\n};",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/1430547/c-simple-solution-using-stack-o-h-time-complexity-with-diagrammatic-explanation/",
                "vote_count": "154"
            },
            {
                "language": "csharp",
                "code": "BSTIterator(TreeNode* root) {\n    TreeNode* p=root;\n    while(p=NULL)\n    {  s.push(p);p=p->left;}",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/1430547/c-simple-solution-using-stack-o-h-time-complexity-with-diagrammatic-explanation/",
                "vote_count": "154"
            },
            {
                "language": "java",
                "code": "1. Brute force way - You can do in-order traversal and put each element into an ArrayList (additional space). \n Then use that to check hasNext() or next() element. However, that approach will use extra space of O(n).\n2. This approach:\n a) Here we will use our own Stack (basically do in-order traversal Iteratively, instead of recursively). \n    Reason, being we have more control here and no need to use extra space of O(n) for ArrayList to store all elements first. \n b) We get space of O(h) only instead of O(n). [h: is height of tree] ",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/1965120/easy-iterative-using-stack-space-o-h-instead-of-o-n/",
                "vote_count": "96"
            },
            {
                "language": "cpp",
                "code": "// 15 ms, faster than 82.33% \nclass BSTIterator {\n Stack<TreeNode> stack;\n public BSTIterator(TreeNode root) {\n  stack = new Stack<>();\n  TreeNode node = root;\n  updateStack(node);                                      // update stack\n }\n public int next() {\n  TreeNode toRemove = stack.pop();\n  updateStack(toRemove.right);                             // before return node, first update stack further        \n  return toRemove.val;\n }\n public boolean hasNext() {\n  return !stack.isEmpty();    \n }\n // -------------------\n public void updateStack(TreeNode node){\n  while(node != null){\n   stack.add(node);\n   node = node.left;\n  }\n }\n}",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/1965120/easy-iterative-using-stack-space-o-h-instead-of-o-n/",
                "vote_count": "96"
            },
            {
                "language": "cpp",
                "code": "class BSTIterator {\nprivate:\n    TreeNode* ptr;\n    vector<int>v;\n    int i;\n    void inorder(TreeNode* ptr , vector<int> &v){\n        if(ptr == NULL) return ;\n        ",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/1965120/easy-iterative-using-stack-space-o-h-instead-of-o-n/",
                "vote_count": "96"
            },
            {
                "language": "cpp",
                "code": "class BSTIterator {\npublic:\n     stack<TreeNode*> st;\n    BSTIterator(TreeNode *root) {\n        Lefttree(root);\n    }\n    \n    bool hasNext() {\n    return st.empty() ? false : true;\n    }\n    \n    int next() {\n        TreeNode* top = st.top();\n        st.pop();\n        if (top->right != NULL)\n            Lefttree(top->right);  \n     return top->val;\n    }\n    \n    void Lefttree(TreeNode* root)\n    {\n        TreeNode* p = root;\n        while (p)\n        {\n            st.push(p);\n            p = p->left;\n        }\n    }\n};",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/1965170/c-solution-using-inorder-tc-o-h-instead-of-o-n/",
                "vote_count": "50"
            },
            {
                "language": "java",
                "code": "class BSTIterator {\n    Stack<TreeNode> st;\n    public BSTIterator(TreeNode root) {\n        st = new Stack<>();\n        addAllLeft(root);\n    }\n    public void addAllLeft(TreeNode root){\n        while(root != null){\n            st.push(root);\n            root = root.left;\n        }\n    }\n    public int next() {\n        TreeNode topValue = st.pop();\n        addAllLeft(topValue.right);\n        return topValue.val;\n    }\n    \n    public boolean hasNext() {\n        return st.size() != 0;\n    }\n}",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/1965329/may-be-you-understand/",
                "vote_count": "49"
            },
            {
                "language": "csharp",
                "code": "Approach:\n        basically, we need to implement a inorder traversal.\n        we are going to perform iterative DFS for that we need stack\n        we are going to start from the root and keep pushing the left nodes to the stack\n\n        next():\n            we are going to pop the top element from the stack and return it\n            if the popped element has a right child, we are going to push the right child to the stack\n            if the popped element has no right child, we are going to return the popped element",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/1965329/may-be-you-understand/",
                "vote_count": "49"
            },
            {
                "language": "kotlin",
                "code": "",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/1965329/may-be-you-understand/",
                "vote_count": "49"
            },
            {
                "language": "cpp",
                "code": "class BSTIterator {\nprivate:\n    TreeNode* ptr;\n    vector<int>v;\n    int i;\n    void inorder(TreeNode* ptr , vector<int> &v){\n        if(ptr == NULL) return ;\n        ",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/1965329/may-be-you-understand/",
                "vote_count": "49"
            },
            {
                "language": "cpp",
                "code": "Deque<TreeNode> stack = new LinkedList<>(); // we can also use new ArrayDeque();",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/1965329/may-be-you-understand/",
                "vote_count": "49"
            },
            {
                "language": "typescript",
                "code": "public boolean hasNext() {\n        return !st.isEmpty();",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/1965329/may-be-you-understand/",
                "vote_count": "49"
            },
            {
                "language": "csharp",
                "code": "class BSTIterator {\n\n    private int i = 0;\n    public ArrayList<Integer> list;\n    \n    public BSTIterator(TreeNode root) {\n        list = new ArrayList<Integer>();",
                "url": "https://leetcode.com/problems/binary-search-tree-iterator/solutions/1965329/may-be-you-understand/",
                "vote_count": "49"
            }
        ]
    },
    "166": {
        "question_id": 174,
        "title": "Dungeon Game",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/dungeon-game",
        "description": "The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess.The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.Return the knight's minimum initial health so that he can rescue the princess.Note that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned. ",
        "examples": [
            {
                "input": "dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]",
                "output": "7",
                "explanation": "The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN."
            },
            {
                "input": "dungeon = [[0]]",
                "output": "1",
                "explanation": null
            }
        ],
        "constraints": [
            "m == dungeon.length",
            "n == dungeon[i].length",
            "1 <= m, n <= 200",
            "-1000 <= dungeon[i][j] <= 1000"
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "[[-10]]                     : ans  = 1 + (-(-10)) = 11 (explanation to first point mentioned)\n[[10]]                      : ans  = 1 as we still need 1 health at first place to get there (explanation to second point mentioned)\n[[-2,-3,3,-5,-10]]          : ans = 1 + (-(-17)) = 18 same as 1st case\n[[2,3,3,5,10]]              : ans = 1 same as 2nd test case, explanation to second point mentioned to asking question",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/",
                "vote_count": "1890"
            },
            {
                "language": "cpp",
                "code": "int getVal(vector<vector<int>> &mat, int i=0, int j=0)\n    {\n        int n = mat.size();\n        int m = mat[0].size();\n        // Base case : we have crossed the matrix, ie. out of bound\n        /// if current row crosses then my row is below the princess or \n        /// if current column crosses then my column is ahead the column of princess\n        /// and beacause we can go only down and right so we wont be able reach princess\n        if(i == n || j == m)    return 1e9; \n        \n  // Base Case : we have reached our destination ie. last cell\n        /// we reached princess , cheers return this cost;\n        if(i == n-1 and j == m-1)   \n            return (mat[i][j] <= 0) ? -mat[i][j] + 1 : 1;\n        \n        /// now we must try all possible paths , we ask our right and and down cell\n        int IfWeGoRight = getVal(mat , i , j+1);\n        int IfWeGoDown = getVal(mat , i+1 , j);\n        \n        /// min of either values and then cost of this cell\n        int minHealthRequired =  min(IfWeGoRight , IfWeGoDown) -mat[i][j];\n        \n        /// point 2 as explained \n        return ( minHealthRequired <= 0 ) ? 1 : minHealthRequired;      \n    }\n    \n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\n        return getVal(dungeon);     \n    }",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/",
                "vote_count": "1890"
            },
            {
                "language": "cpp",
                "code": "int getVal(vector<vector<int>> &mat, vector<vector<int>> &dp , int i=0, int j=0)\n    {\n        int n = mat.size();\n        int m = mat[0].size();    \n        \n        if(i == n || j == m)    return 1e9; \n        \n        if(i == n-1 and j == m-1)\n            return (mat[i][j] <= 0) ? -mat[i][j] + 1 : 1;\n        \n        /// if we know the answer for this cell then no need to recalculate those, simply return those values \n        if( dp[i][j] != 1e9)\n            return dp[i][j];\n        \n        int IfWeGoRight = getVal(mat , dp , i , j+1);\n        int IfWeGoDown = getVal(mat , dp , i+1 , j);\n        \n        int minHealthRequired =  min(IfWeGoRight , IfWeGoDown) -mat[i][j];\n        \n        /// before returning the values, we must store the answers for this cell which we hacve calculated\n        /// in next recurssive call this value will be used to save some computation, aka repetative work which we are doing.\n        dp[i][j] = ( minHealthRequired <= 0 ) ? 1 : minHealthRequired;      \n        return dp[i][j];\n    }\n    \n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\n        \n        int n = dungeon.size();\n        int m = dungeon[0].size();\n        \n        vector<vector<int>> dp(n , vector<int>(m , 1e9));\n        \n        return getVal(dungeon, dp);     \n    }",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/",
                "vote_count": "1890"
            },
            {
                "language": "cpp",
                "code": "int calculateMinimumHP(vector<vector<int> > &dungeon) {\n\n        int n = dungeon.size();\n        int m = dungeon[0].size();\n\n        vector<vector<int> > dp(n + 1, vector<int>(m + 1, 1e9));\n        dp[n][m - 1] = 1;\n        dp[n - 1][m] = 1;\n        \n        for (int i = n - 1; i >= 0; i--) \n        {\n            for (int j = m - 1; j >= 0; j--) \n            {\n                int need = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];                \n                // store this value\n                dp[i][j] = need <= 0 ? 1 : need;\n            }\n        }\n        return dp[0][0];\n    }",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/",
                "vote_count": "1890"
            },
            {
                "language": "",
                "code": "dp[m][n-1] = 1;\ndp[m-1][n] = 1;",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/",
                "vote_count": "1890"
            },
            {
                "language": "java",
                "code": "    public int calculateMinimumHP(int[][] dungeon) {",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/",
                "vote_count": "1890"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int calculateMinimumHP(int[][] dungeon) {\n        int m = dungeon.length;\n        int n = dungeon[0].length;",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/",
                "vote_count": "1890"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\n        int n = dungeon.size(), m = dungeon[0].size();\n        vector<int> dp(m+1, INT_MAX);\n        dp[m] = 1;\n        dp[m-1] = 1;",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/745340/post-dedicated-to-beginners-of-dp-or-have-no-clue-how-to-start/",
                "vote_count": "1890"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int calculateMinimumHP(vector<vector<int> > &dungeon) {\n        int M = dungeon.size();\n        int N = dungeon[0].size();\n        // hp[i][j] represents the min hp needed at position (i, j)\n        // Add dummy row and column at bottom and right side\n        vector<vector<int> > hp(M + 1, vector<int>(N + 1, INT_MAX));\n        hp[M][N - 1] = 1;\n        hp[M - 1][N] = 1;\n        for (int i = M - 1; i >= 0; i--) {\n            for (int j = N - 1; j >= 0; j--) {\n                int need = min(hp[i + 1][j], hp[i][j + 1]) - dungeon[i][j];\n                hp[i][j] = need <= 0 ? 1 : need;\n            }\n        }\n        return hp[0][0];\n    }\n};",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/52774/c-dp-solution/",
                "vote_count": "365"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\n        int n=dungeon.size(),m=dungeon[0].size();\n        vector<int> dp(n+1,INT_MAX);\n        dp[n-1]=1;\n        for(int j=m-1;j>=0;j--){\n            for(int i=n-1;i>=0;i--){",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/52774/c-dp-solution/",
                "vote_count": "365"
            },
            {
                "language": "cpp",
                "code": " class Solution {\n    public:\n      int calculateMinimumHP(vector<vector<int> > &dungeon) {\n        int m = dungeon.size(), n = dungeon[0].size();\n        dungeon[m - 1][n - 1] = dungeon[m - 1][n - 1] > 0 ? 1 : abs(dungeon[m - 1][n - 1]) + 1;\n        for (int i = n-2; i >= 0; --i)\n          dungeon[m - 1][i] = max(dungeon[m - 1][i + 1] - dungeon[m - 1][i],1);",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/52774/c-dp-solution/",
                "vote_count": "365"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int calculateMinimumHP(int[][] dungeon) {\n        int m = dungeon.length;\n        int n = dungeon[0].length;\n        \n        \n        int[][] dp = new int[m+1][n+1];\n        for(int[] a : dp)",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/52774/c-dp-solution/",
                "vote_count": "365"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def calculateMinimumHP(self, dungeon):\n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[float(\"inf\")]*(n+1) for _ in range(m+1)]\n        dp[m-1][n], dp[m][n-1] = 1, 1\n            \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                dp[i][j] = max(min(dp[i+1][j],dp[i][j+1])-dungeon[i][j],1)\n        \n        return dp[0][0]",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/698271/python-short-dp-7-lines-o-mn-top-down-explained/",
                "vote_count": "330"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def calculateMinimumHP(self, a: List[List[int]]) -> int:\n        R, C = len(a), len(a[0])\n        hi = [sum([r for r in row if r<0]+[0]) for row in a]\n        if not hi:return 1\n        else: hi = sum(hi)\n        lo, hi = 1, -hi+1",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/698271/python-short-dp-7-lines-o-mn-top-down-explained/",
                "vote_count": "330"
            },
            {
                "language": "python",
                "code": "def calculateMinimumHP(self, dungeon):\n    @cache\n    def dp(i,j):\n        if (i,j) in ((m-1,n),(m,n-1)): return 1\n        if i == m or j == n: return inf\n        return max(min(dp(i+1,j),dp(i,j+1))-dungeon[i][j],1)\n\n    m, n = len(dungeon), len(dungeon[0])",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/698271/python-short-dp-7-lines-o-mn-top-down-explained/",
                "vote_count": "330"
            },
            {
                "language": "go",
                "code": "def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\n        m,n = len(dungeon),len(dungeon[0])\n        dp = [[-1e6]*(n+1) for _ in range(m+1)]\n        dp[m][-2] = 0\n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                dp[i][j] = max(dp[i+1][j],dp[i][j+1]) + dungeon[i][j]\n                if dp[i][j]>0:",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/698271/python-short-dp-7-lines-o-mn-top-down-explained/",
                "vote_count": "330"
            },
            {
                "language": "kotlin",
                "code": "-2   -3    3\n-5  -10   1\n10   30  -5  <-  when we arrive here our health will be reduced by 5.\n    So we need minimum 6 health to survive when we reach here. val = (1- (-5) = 6)\n\nIf this value was positive we dont need to worry and the minimum energy we need is 1. \nSuppose the value was +5 then 1-5 = -4.  -4<1 => so ans is 1. i.e max(1,val).",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/698376/c-beginner-friendly-dp-explanation-and-idea/",
                "vote_count": "100"
            },
            {
                "language": "rust",
                "code": "-2  -3   3  m      m -> denotes max \n-5  10   1  m\n10  30  -5  1   -> note: we have two value as 1 for the last element (I will explain this as we proceed)\n m   m   1 m\n \n suppose the dimensions of dungeon matirx was \"r x c\", for our dp will be \" r+1 x c+1\".\n We will start our iteration \n from the value -5 that is the cell our princess is located.\n We first have to see which value is minimum from that cell (the one on the right or bottom).\n i.e. which cell requres less health to travel to\n for this cell is (one which holds the princess):\n val = min of dp[i+1][j] and dp[i][j+1] (min of bottom and right).\n so val = min(1,1) = 1;\n Also we have to reduce the health required to stay in the current cell.\n val = val - dungeon[i][j] = 1 - (-5) = 6;\n Now as i explained earlier:\n dp[i][j] = max(1,val)   => if val is negetive that means we dont have to spend health on this cell so it should be kept minimum i.e. 1.\n \n So we had to keep both values 1 as instead of max as for calculating the health for princess' cell we only need 1 health minimum. \n \n Now let's see for 2nd row 3rd column (one above the princess)\n val = min(m,6) - 1;   (6 because the dp holds value 6 for princess' cell which was calculated earlier)\n val = 5.\n dp[1][2] = 5; So when we are at this cell we need health atleast 5. \n As we will gain 1 health and then move on to the princess's cell giving up  5  health and thus in this way we can calculate all the values. Code contains further explanation.",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/698376/c-beginner-friendly-dp-explanation-and-idea/",
                "vote_count": "100"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\n        int r = dungeon.size();   // no of rows\n        if(r == 0) return 0; // if empty then return 0\n        int c = dungeon[0].size();  // no of columns\n  // DP with r+1 x c+1 dimension and all values initialized to INT_MAX\n        vector<vector<int>>dp(r+1,vector<int>(c+1,INT_MAX));\n  // Initializing the cell to the bottom and right of princess' cell with value 1.\n        dp[r-1][c] = 1;\n        dp[r][c-1] = 1;\n  Iterating over dp excluding the additional row and column we added.\n        for(int i=r-1;i>=0;i--){\n            for(int j=c-1;j>=0;j--){\n                int val = min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j];  // value is minimum health to land on next - health need to stay\n                dp[i][j] = max(1,val); // minimum value required is 1. maximum is the +ve value we calculated.\n            }\n        }\n        \n        return dp[0][0];  // The first element contains the minimum health needed to rescue the princess.\n    }\n};",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/698376/c-beginner-friendly-dp-explanation-and-idea/",
                "vote_count": "100"
            },
            {
                "language": "swift",
                "code": "if (minimum_in_path[i - 1][j] >= minimum_in_path[i][j - 1]) {\n dp[i][j] = dp[i - 1][j] + nums[i][j];\n minimum_in_path[i][j] = min(minimum_in_path[i - 1][j], dp[i][j]);\n}\nelse {\n // Same as above but use indexes [i][j - 1] instead of [i - 1][j]\n dp[i][j] = dp[i][j - 1] + nums[i][j];\n minimum_in_path[i][j] = min(minimum_in_path[i][j - 1], dp[i][j]);\n}",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/1500016/why-you-can-t-go-from-top-left-to-bottom-right-explained/",
                "vote_count": "74"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    int min(int x, int y) {\n        if(x<y) return x;\n        return y;",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/1500016/why-you-can-t-go-from-top-left-to-bottom-right-explained/",
                "vote_count": "74"
            },
            {
                "language": "java",
                "code": "def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\n    r = len(dungeon)\n    c = len(dungeon[0])\n    dp = [[None]*c for _ in range(r)]\n    \n    def calc(i,j):",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/1500016/why-you-can-t-go-from-top-left-to-bottom-right-explained/",
                "vote_count": "74"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\n        dp = [[[1,1+dungeon[0][0]]]] if dungeon[0][0]>=0 else [[[1-dungeon[0][0], 1]]]\n        m = len(dungeon)\n        n = len(dungeon[0])",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/1500016/why-you-can-t-go-from-top-left-to-bottom-right-explained/",
                "vote_count": "74"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def calculateMinimumHP(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dpNeedHP = [[math.inf] * (n+1) for _ in range(m+1)]\n        dpNeedHP[m][n-1] = 1\n        dpNeedHP[m-1][n] = 1\n        for r in range(m-1, -1, -1):\n            for c in range(n-1, -1, -1):\n                need = min(dpNeedHP[r+1][c], dpNeedHP[r][c+1]) - grid[r][c]\n                dpNeedHP[r][c] = 1 if need <= 0 else need\n        return dpNeedHP[0][0]",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/1498367/c-python-2-solutions-binary-search-dp-clean-concise/",
                "vote_count": "67"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\n        int row = dungeon.size(), col = dungeon[0].size();\n        vector<int> dpNeedHP(col + 1, 1e5);\n        dpNeedHP[col - 1] = dpNeedHP[col] = 1;",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/1498367/c-python-2-solutions-binary-search-dp-clean-concise/",
                "vote_count": "67"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/1498367/c-python-2-solutions-binary-search-dp-clean-concise/",
                "vote_count": "67"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    //this recursive fuction will return the min amount of health that the knight needs in the future\n    //to rescue the queen\n    int future(int row,int col,vector<vector<int>>& arr,vector<vector<int>>&dp)\n    {\n        int r=arr.size();\n        int c=arr[0].size();\n        //base case: if the knight goes out of the dungeon\n        if(row>=r || col>=c)\n            return 1e9;//very large number so that the knight does not choose this future health\n\n        if(row==r-1 && col==c-1)//knight has reached the queen\n        {\n            if(arr[row][col]>=0)//knight will not recure any additional health as he will gain health\n                return dp[row][col]= 1;\n            else //knight must enter this cell with additional health of +1 to survive\n                return dp[row][col]= abs(arr[row][col])+1;\n        }\n        if(dp[row][col]!=-1)\n            return dp[row][col];\n        int future_health_left=future(row,col+1,arr,dp);//the min amount of health he will need to survive the left path\n        int future_health_down=future(row+1,col,arr,dp);//the min amount of health he will need to survive the down path\n        int future_health=min(future_health_down,future_health_left);//he will go to the path that will require the minimum health\n        int health_gain=arr[row][col];//the health he gained or lost in this cell\n        int health_needed=future_health-health_gain;//the min health he requires to survive cell as well as his chosen path\n        if(health_needed>0)//he needed additional health to survive this cell as well as this chosen future path\n            return dp[row][col]= health_needed;\n        else//he gained health in this cell and he did not require health \n            return dp[row][col]= 1;\n    }\n    int calculateMinimumHP(vector<vector<int>>&arr) \n    {\n        int r=arr.size();\n        int c=arr[0].size();\n        vector<vector<int>>dp(r,vector<int>(c,-1));//stores the future required health\n        return future(0,0,arr,dp);\n    }\n};",
                "url": "https://leetcode.com/problems/dungeon-game/solutions/3055960/handwritten-step-by-step-in-detail-dry-run-fully-commented-recursive-approach/",
                "vote_count": "10"
            }
        ]
    },
    "167": {
        "question_id": 179,
        "title": "Largest Number",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/largest-number",
        "description": "Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.Since the result may be very large, so you need to return a string instead of an integer. ",
        "examples": [
            {
                "input": "nums = [10,2]",
                "output": "\"210\"",
                "explanation": null
            },
            {
                "input": "nums = [3,30,34,5,9]",
                "output": "\"9534330\"",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 100",
            "0 <= nums[i] <= 10^9"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    string largestNumber(vector<int> &num) {\n        vector<string> arr;\n        for(auto i:num)\n            arr.push_back(to_string(i));\n        sort(begin(arr), end(arr), [](string &s1, string &s2){ return s1+s2>s2+s1; });\n        string res;\n        for(auto s:arr)\n            res+=s;\n        while(res[0]=='0' && res.length()>1)\n            res.erase(0,1);\n        return  res;\n    }\n};",
                "url": "https://leetcode.com/problems/largest-number/solutions/53157/a-simple-c-solution/",
                "vote_count": "439"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    struct comp {\n        bool operator() (int a, int b) {\n            string comb1 = to_string(a) + to_string(b);\n            string comb2 = to_string(b) + to_string(a);\n            return comb1 > comb2;\n        }\n    } mycomp;",
                "url": "https://leetcode.com/problems/largest-number/solutions/53157/a-simple-c-solution/",
                "vote_count": "439"
            },
            {
                "language": "dart",
                "code": "public String largestNumber(int[] num) {\n    int len = num.length;\n    String[] cache = new String[len];\n    String res = \"\";\n\n    for (int i = 0; i < len; i++) \n        cache[i] = String.valueOf(num[i]);",
                "url": "https://leetcode.com/problems/largest-number/solutions/53157/a-simple-c-solution/",
                "vote_count": "439"
            },
            {
                "language": "csharp",
                "code": "string largestNumber(vector<int>& nums) {\n    if (all_of(nums.begin(), nums.end(), [](int num){return num == 0;})) return \"0\";\n    vector<string> strs;\n    transform(nums.begin(), nums.end(), back_inserter(strs), [](int num){return to_string(num);});\n    sort(strs.begin(), strs.end(), [](string &l, string &r){return l+r > r+l;});\n    return accumulate(strs.begin(), strs.end(), string(\"\"));\n}",
                "url": "https://leetcode.com/problems/largest-number/solutions/53157/a-simple-c-solution/",
                "vote_count": "439"
            },
            {
                "language": "cpp",
                "code": "string largestNumber(vector<int>& nums) {\n vector<string> vec;\n for (auto num : nums)\n  vec.push_back(to_string(num));\n sort(vec.begin(), vec.end(), [](const string &a, const string &b) \n { \n  int i = 0, j = 0;\n  int tag1 = 0, tag2 = 0;",
                "url": "https://leetcode.com/problems/largest-number/solutions/53157/a-simple-c-solution/",
                "vote_count": "439"
            },
            {
                "language": "javascript",
                "code": "String s1 = \"9\";\nString s2 = \"31\";\n\nString case1 =  s1 + s2; // 931\nString case2 = s2 + s1; // 319",
                "url": "https://leetcode.com/problems/largest-number/solutions/53158/my-java-solution-to-share/",
                "vote_count": "404"
            },
            {
                "language": "dart",
                "code": "public class Solution {\n     public String largestNumber(int[] num) {\n  if(num == null || num.length == 0)\n      return \"\";\n  \n  // Convert int array to String array, so we can sort later on\n  String[] s_num = new String[num.length];\n  for(int i = 0; i < num.length; i++)\n      s_num[i] = String.valueOf(num[i]);\n   \n  // Comparator to decide which string should come first in concatenation\n  Comparator<String> comp = new Comparator<String>(){\n      @Override\n      public int compare(String str1, String str2){\n          String s1 = str1 + str2;\n    String s2 = str2 + str1;\n    return s2.compareTo(s1); // reverse order here, so we can do append() later\n      }\n      };\n  \n  Arrays.sort(s_num, comp);\n  // An extreme edge case by lc, say you have only a bunch of 0 in your int array\n  if(s_num[0].charAt(0) == '0')\n   return \"0\";\n            \n  StringBuilder sb = new StringBuilder();\n  for(String s: s_num)\n         sb.append(s);\n  \n  return sb.toString();\n  \n }\n}",
                "url": "https://leetcode.com/problems/largest-number/solutions/53158/my-java-solution-to-share/",
                "vote_count": "404"
            },
            {
                "language": "rust",
                "code": "Arrays.sort( s_num, (s1, s2) -> (s1+s2).compareTo(s2+s1) );",
                "url": "https://leetcode.com/problems/largest-number/solutions/53158/my-java-solution-to-share/",
                "vote_count": "404"
            },
            {
                "language": "kotlin",
                "code": "sort the opposite way\nreturn s2.compareTo(s1);\n\nwhich makes this easier\nif(Snum[0]==\"0\") return \"0\"; //if intteger was 0. the string has to be \"0\"\n\nand this faster\nsb.append(s);",
                "url": "https://leetcode.com/problems/largest-number/solutions/53158/my-java-solution-to-share/",
                "vote_count": "404"
            },
            {
                "language": "rust",
                "code": "Arrays.sort(s_num, (s1, s2) -> (s2 + s1).compareTo(s1 + s2));",
                "url": "https://leetcode.com/problems/largest-number/solutions/53158/my-java-solution-to-share/",
                "vote_count": "404"
            },
            {
                "language": "dart",
                "code": "class Solution {\n    public String largestNumber(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return \"\";\n        }\n        \n        final Queue<String> queue = new PriorityQueue<>(nums.length, \n            (left, right) -> Long.valueOf(right + left).compareTo(Long.valueOf(left + right))",
                "url": "https://leetcode.com/problems/largest-number/solutions/53158/my-java-solution-to-share/",
                "vote_count": "404"
            },
            {
                "language": "go",
                "code": "Comparator<String> cmp = new Comparator<String>() {\n    @Override\n    public int compare(String str1, String str2) {\n sb1.delete(0, sb1.length()).append(str1).append(str2);\n        sb2.delete(0, sb2.length()).append(str2).append(str1);",
                "url": "https://leetcode.com/problems/largest-number/solutions/53158/my-java-solution-to-share/",
                "vote_count": "404"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public String largestNumber(int[] nums) {\n        ArrayList<String> list = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++)\n            list.add(Integer.toString(nums[i]));\n        Collections.sort(list,(a,b) -> (int)(Long.parseLong(b+a) - Long.parseLong(a+b)) );\n        StringBuilder sb = new StringBuilder();\n        for(String x:list) {",
                "url": "https://leetcode.com/problems/largest-number/solutions/53158/my-java-solution-to-share/",
                "vote_count": "404"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public String largestNumber(int[] nums) {\n       if (nums == null || nums.length == 0) {\n           return \"\";\n       }\n       String[] s_num = new String[nums.length];\n       for (int i = 0; i < nums.length; i++) {\n           s_num[i] = String.valueOf(nums[i]);",
                "url": "https://leetcode.com/problems/largest-number/solutions/53158/my-java-solution-to-share/",
                "vote_count": "404"
            },
            {
                "language": "python",
                "code": "# build-in function\ndef largestNumber1(self, nums):\n    if not any(nums):\n        return \"0\"\n    return \"\".join(sorted(map(str, nums), cmp=lambda n1, n2: -1 if n1+n2>n2+n1 else (1 if n1+n2<n2+n1 else 0)))\n    \n# bubble sort\ndef largestNumber2(self, nums):\n    for i in xrange(len(nums), 0, -1):\n        for j in xrange(i-1):\n            if not self.compare(nums[j], nums[j+1]):\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return str(int(\"\".join(map(str, nums))))\n    \ndef compare(self, n1, n2):\n    return str(n1) + str(n2) > str(n2) + str(n1)\n    \n# selection sort\ndef largestNumber3(self, nums):\n    for i in xrange(len(nums), 0, -1):\n        tmp = 0\n        for j in xrange(i):\n            if not self.compare(nums[j], nums[tmp]):\n                tmp = j\n        nums[tmp], nums[i-1] = nums[i-1], nums[tmp]\n    return str(int(\"\".join(map(str, nums))))\n    \n# insertion sort\ndef largestNumber4(self, nums):\n    for i in xrange(len(nums)):\n        pos, cur = i, nums[i]\n        while pos > 0 and not self.compare(nums[pos-1], cur):\n            nums[pos] = nums[pos-1]  # move one-step forward\n            pos -= 1\n        nums[pos] = cur\n    return str(int(\"\".join(map(str, nums))))\n\n# merge sort        \ndef largestNumber5(self, nums):\n    nums = self.mergeSort(nums, 0, len(nums)-1)\n    return str(int(\"\".join(map(str, nums))))\n    \ndef mergeSort(self, nums, l, r):\n    if l > r:\n        return \n    if l == r:\n        return [nums[l]]\n    mid = l + (r-l)//2\n    left = self.mergeSort(nums, l, mid)\n    right = self.mergeSort(nums, mid+1, r)\n    return self.merge(left, right)\n    \ndef merge(self, l1, l2):\n    res, i, j = [], 0, 0\n    while i < len(l1) and j < len(l2):\n        if not self.compare(l1[i], l2[j]):\n            res.append(l2[j])\n            j += 1\n        else:\n            res.append(l1[i])\n            i += 1\n    res.extend(l1[i:] or l2[j:])\n    return res\n    \n# quick sort, in-place\ndef largestNumber(self, nums):\n    self.quickSort(nums, 0, len(nums)-1)\n    return str(int(\"\".join(map(str, nums)))) \n\ndef quickSort(self, nums, l, r):\n    if l >= r:\n        return \n    pos = self.partition(nums, l, r)\n    self.quickSort(nums, l, pos-1)\n    self.quickSort(nums, pos+1, r)\n    \ndef partition(self, nums, l, r):\n    low = l\n    while l < r:\n        if self.compare(nums[l], nums[r]):\n            nums[l], nums[low] = nums[low], nums[l]\n            low += 1\n        l += 1\n    nums[low], nums[r] = nums[r], nums[low]\n    return low",
                "url": "https://leetcode.com/problems/largest-number/solutions/53298/python-different-solutions-bubble-insertion-selection-merge-quick-sorts/",
                "vote_count": "389"
            },
            {
                "language": "ruby",
                "code": "class Wrapper:\n    def __init__(self, val):\n        self.val = str(val)\n        \n    def __lt__(self, other):\n        return int(self.val+other.val) < int(other.val+self.val)\n    \nclass Solution:",
                "url": "https://leetcode.com/problems/largest-number/solutions/53298/python-different-solutions-bubble-insertion-selection-merge-quick-sorts/",
                "vote_count": "389"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        nums = list(map(str, nums))\n        cmp = lambda x, y: ((x+y) > (y+x)) - ((x+y) < (y+x))\n        nums = sorted(nums, key=cmp_to_key(cmp))\n        return str(int(''.join(nums[::-1])))",
                "url": "https://leetcode.com/problems/largest-number/solutions/53298/python-different-solutions-bubble-insertion-selection-merge-quick-sorts/",
                "vote_count": "389"
            },
            {
                "language": "csharp",
                "code": "bool compare(string a,string b){\n    return a+b > b+a;\n}\n\nclass Solution {\npublic:\n    string largestNumber(vector<int>& nums) {\n \n        vector<string> container;\n  \n        for(int i : nums)  container.push_back(to_string(i));\n        \n        sort(container.begin(),container.end(),compare);\n        \n        string result;\n        \n        for(int i=0;i<container.size();i++)  result+=container[i];\n        \n        return result[0]=='0'? \"0\" : result;\n    }\n};",
                "url": "https://leetcode.com/problems/largest-number/solutions/863453/beats-98-60-easy-understanding-c/",
                "vote_count": "81"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\nstatic bool comp(string& a, string& b)\n{\n    return a+b>b+a;\n}\n    string largestNumber(vector<int>& nums) {\n        int n=nums.size();\n        vector<string> v;\n        for(int i:nums)\n        v.push_back(to_string(i));\n        sort(v.begin(), v.end(), comp);\n        string s=\"\";\n        for(auto a:v)\n        s+=a;\n        int i=0;\n        while(i<s.size()-1 && s[i]=='0')\n        i++;\n        return s.substr(i, s.size());\n    }\n};",
                "url": "https://leetcode.com/problems/largest-number/solutions/2992571/easy-solution-short-simple-best-method-easy-to-understand/",
                "vote_count": "17"
            }
        ]
    },
    "168": {
        "question_id": 187,
        "title": "Repeated DNA Sequences",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/repeated-dna-sequences",
        "description": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.For example, \"ACGAATTCCG\" is a DNA sequence.When studying DNA, it is useful to identify repeated sequences within the DNA.Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order. ",
        "examples": [
            {
                "input": "s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"",
                "output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
                "explanation": null
            }
        ],
        "constraints": [],
        "solutions": [
            {
                "language": "typescript",
                "code": "public List<String> findRepeatedDnaSequences(String s) {\n    Set seen = new HashSet(), repeated = new HashSet();\n    for (int i = 0; i + 9 < s.length(); i++) {\n        String ten = s.substring(i, i + 10);\n        if (!seen.add(ten))\n            repeated.add(ten);\n    }\n    return new ArrayList(repeated);\n}",
                "url": "https://leetcode.com/problems/repeated-dna-sequences/solutions/53855/7-lines-simple-java-o-n/",
                "vote_count": "464"
            },
            {
                "language": "dart",
                "code": "class Solution {\n public List<String> findRepeatedDnaSequences(String s) {\n  if(s == null || s.length() < 10) {\n   return Collections.emptyList();",
                "url": "https://leetcode.com/problems/repeated-dna-sequences/solutions/53855/7-lines-simple-java-o-n/",
                "vote_count": "464"
            },
            {
                "language": "go",
                "code": "class Solution {\n    public List<String> findRepeatedDnaSequences(String s) {\n        int len = s.length(), cur = 0;\n        if(len < 10) return new ArrayList();\n        \n        Set seen = new HashSet();\n        Set repeated = new HashSet();\n        HashMap<Character, Integer> map = new HashMap<Character, Integer>();",
                "url": "https://leetcode.com/problems/repeated-dna-sequences/solutions/53855/7-lines-simple-java-o-n/",
                "vote_count": "464"
            },
            {
                "language": "csharp",
                "code": "public List<String> findRepeatedDnaSequences(String s) {\n    Set<Integer> words = new HashSet<>();\n    Set<Integer> doubleWords = new HashSet<>();\n    List<String> rv = new ArrayList<>();\n    char[] map = new char[26];\n    //map['A' - 'A'] = 0;\n    map['C' - 'A'] = 1;\n    map['G' - 'A'] = 2;\n    map['T' - 'A'] = 3;\n\n    for(int i = 0; i < s.length() - 9; i++) {\n        int v = 0;\n        for(int j = i; j < i + 10; j++) {\n            v <<= 2;\n            v |= map[s.charAt(j) - 'A'];\n        }\n        if(!words.add(v) && doubleWords.add(v)) {\n            rv.add(s.substring(i, i + 10));\n        }\n    }\n    return rv;\n}",
                "url": "https://leetcode.com/problems/repeated-dna-sequences/solutions/53867/clean-java-solution-hashmap-bits-manipulation/",
                "vote_count": "366"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/repeated-dna-sequences/solutions/53867/clean-java-solution-hashmap-bits-manipulation/",
                "vote_count": "366"
            },
            {
                "language": "",
                "code": "",
                "url": "https://leetcode.com/problems/repeated-dna-sequences/solutions/53867/clean-java-solution-hashmap-bits-manipulation/",
                "vote_count": "366"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/repeated-dna-sequences/solutions/53867/clean-java-solution-hashmap-bits-manipulation/",
                "vote_count": "366"
            },
            {
                "language": "",
                "code": "",
                "url": "https://leetcode.com/problems/repeated-dna-sequences/solutions/53867/clean-java-solution-hashmap-bits-manipulation/",
                "vote_count": "366"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/repeated-dna-sequences/solutions/53867/clean-java-solution-hashmap-bits-manipulation/",
                "vote_count": "366"
            },
            {
                "language": "kotlin",
                "code": "",
                "url": "https://leetcode.com/problems/repeated-dna-sequences/solutions/53867/clean-java-solution-hashmap-bits-manipulation/",
                "vote_count": "366"
            },
            {
                "language": "lisp",
                "code": "",
                "url": "https://leetcode.com/problems/repeated-dna-sequences/solutions/53867/clean-java-solution-hashmap-bits-manipulation/",
                "vote_count": "366"
            },
            {
                "language": "scala",
                "code": "",
                "url": "https://leetcode.com/problems/repeated-dna-sequences/solutions/53867/clean-java-solution-hashmap-bits-manipulation/",
                "vote_count": "366"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public List<String> findRepeatedDnaSequences(String s) {\n        List<String> result = new ArrayList<>();\n        Set<Integer> word = new HashSet<>();\n        Set<Integer> secondWord = new HashSet<>();\n        int[] map = new int[26];\n        map['C' - 'A'] = 1;\n        map['G' - 'A'] = 2;",
                "url": "https://leetcode.com/problems/repeated-dna-sequences/solutions/53867/clean-java-solution-hashmap-bits-manipulation/",
                "vote_count": "366"
            },
            {
                "language": "python",
                "code": "v <<= 2;\nv |= map[sc[i] - 'A'];\nv &= 0xfffff;",
                "url": "https://leetcode.com/problems/repeated-dna-sequences/solutions/53867/clean-java-solution-hashmap-bits-manipulation/",
                "vote_count": "366"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<String> findRepeatedDnaSequences(String s) {\n     if(s.length() < 11) return new ArrayList<>();\n        Set<Integer> words1 = new HashSet<>();\n        Set<Integer> words2 = new HashSet<>();\n        List<String> res = new ArrayList<>();\n        char[] map = new char[26];\n        map['A' - 'A'] = 0;",
                "url": "https://leetcode.com/problems/repeated-dna-sequences/solutions/53867/clean-java-solution-hashmap-bits-manipulation/",
                "vote_count": "366"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<string> findRepeatedDnaSequences(string s) {\n        unordered_set<int> seen;\n        unordered_set<int> dup;\n        vector<string> result;\n        vector<char> m(26);\n        m['A' - 'A'] = 0;",
                "url": "https://leetcode.com/problems/repeated-dna-sequences/solutions/53867/clean-java-solution-hashmap-bits-manipulation/",
                "vote_count": "366"
            },
            {
                "language": "csharp",
                "code": "int cur = 0;\nfor(int i = 0; i < 10; i++){\n    cur = (cur << 2) | code[s.charAt(i) - 'A'];\n}",
                "url": "https://leetcode.com/problems/repeated-dna-sequences/solutions/53867/clean-java-solution-hashmap-bits-manipulation/",
                "vote_count": "366"
            }
        ]
    },
    "169": {
        "question_id": 188,
        "title": "Best Time to Buy and Sell Stock IV",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv",
        "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.Find the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). ",
        "examples": [
            {
                "input": "k = 2, prices = [2,4,1]",
                "output": "2",
                "explanation": "Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2."
            },
            {
                "input": "k = 2, prices = [3,2,6,5,0,3]",
                "output": "7",
                "explanation": "Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3."
            }
        ],
        "constraints": [
            "1 <= k <= 100",
            "1 <= prices.length <= 1000",
            "0 <= prices[i] <= 1000"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "    public int maxProfit(int k, int[] prices) {\n        int len = prices.length;\n        if (k >= len / 2) return quickSolve(prices);\n        \n        int[][] t = new int[k + 1][len];\n        for (int i = 1; i <= k; i++) {\n            int tmpMax =  -prices[0];\n            for (int j = 1; j < len; j++) {\n                t[i][j] = Math.max(t[i][j - 1], prices[j] + tmpMax);\n                tmpMax =  Math.max(tmpMax, t[i - 1][j - 1] - prices[j]);\n            }\n        }\n        return t[k][len - 1];\n    }\n    \n\n    private int quickSolve(int[] prices) {\n        int len = prices.length, profit = 0;\n        for (int i = 1; i < len; i++)\n            // as long as there is a price gap, we gain a profit.\n            if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];\n        return profit;\n    }",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/54113/a-concise-dp-solution-in-java/",
                "vote_count": "467"
            },
            {
                "language": "cpp",
                "code": "int maxProfitInf(vector<int> &prices) {\n    int buyin = INT_MAX, profit = 0;\n    for(auto & price : prices) {\n        if(price > buyin) profit += price - buyin;                \n        buyin = price;\n    }\n    return profit;\n}",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/54113/a-concise-dp-solution-in-java/",
                "vote_count": "467"
            },
            {
                "language": "javascript",
                "code": "t[i][j] = Math.max(t[i][j - 1], prices[j] + tmpMax);",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/54113/a-concise-dp-solution-in-java/",
                "vote_count": "467"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxProfit(int k, vector<int> &prices) {\n        int size = (int)prices.size();\n        if (k==0||size<2) {\n            return 0;\n        }\n        if (k>size/2) {",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/54113/a-concise-dp-solution-in-java/",
                "vote_count": "467"
            },
            {
                "language": "python",
                "code": "",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/54113/a-concise-dp-solution-in-java/",
                "vote_count": "467"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/54113/a-concise-dp-solution-in-java/",
                "vote_count": "467"
            },
            {
                "language": "java",
                "code": "public class Solution {\npublic int maxProfit(int k, int[] prices) {\n    \n    if ( k < 1 ){\n        return 0; \n    }",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/54113/a-concise-dp-solution-in-java/",
                "vote_count": "467"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        // no transaction, no profit\n        if (k == 0) return 0;\n        // dp[k][0] = min cost you need to spend at most k transactions\n        // dp[k][1] = max profit you can achieve at most k transactions\n        vector<vector<int>> dp(k + 1, vector<int>(2));\n        for (int i = 0; i <= k; i++) dp[i][0] = INT_MAX;\n        for (auto& price : prices) {\n            for (int i = 1; i <= k; i++) {\n                // price - dp[i - 1][1] is how much you need to spend\n                // i.e use the profit you earned from previous transaction to buy the stock\n                // we want to minimize it\n                dp[i][0] = min(dp[i][0], price - dp[i - 1][1]);\n                // price - dp[i][0] is how much you can achieve from previous min cost\n                // we want to maximize it\n                dp[i][1] = max(dp[i][1], price - dp[i][0]);\n            }\n        }\n        // return max profit at most k transactions\n        // or you can use `return dp.back()[1];`\n        return dp[k][1];\n    }\n};",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2555699/leetcode-the-hard-way-7-lines-line-by-line-explanation/",
                "vote_count": "69"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        # no transaction, no profit\n        if k == 0: return 0\n        # dp[k][0] = min cost you need to spend at most k transactions\n        # dp[k][1] = max profit you can achieve at most k transactions\n        dp = [[1000, 0] for _ in range(k + 1)]\n        for price in prices:\n            for i in range(1, k + 1):\n                # price - dp[i - 1][1] is how much you need to spend\n                # i.e use the profit you earned from previous transaction to buy the stock\n                # we want to minimize it\n                dp[i][0] = min(dp[i][0], price - dp[i - 1][1])\n                # price - dp[i][0] is how much you can achieve from previous min cost\n                # we want to maximize it\n                dp[i][1] = max(dp[i][1], price - dp[i][0])\n        # return max profit at most k transactions\n  # or you can write `return dp[-1][1]`\n        return dp[k][1]",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2555699/leetcode-the-hard-way-7-lines-line-by-line-explanation/",
                "vote_count": "69"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int maxProfit(int k, int[] prices) {\n        // no transaction, no profit\n        if (k == 0) return 0;\n        // dp[k][0] = min cost you need to spend at most k transactions\n        // dp[k][1] = max profit you can achieve at most k transactions\n        int [][] dp = new int[k + 1][2];\n        for (int i = 0; i <= k; i++) dp[i][0] = 1000;\n        for (int i = 0; i < prices.length; i++) {\n            for (int j = 1; j <= k; j++) {\n                // price - dp[i - 1][1] is how much you need to spend\n                // i.e use the profit you earned from previous transaction to buy the stock\n                // we want to minimize it\n                dp[j][0] = Math.min(dp[j][0], prices[i] - dp[j - 1][1]);\n                // price - dp[i][0] is how much you can achieve from previous min cost\n                // we want to maximize it\n                dp[j][1] = Math.max(dp[j][1], prices[i] - dp[j][0]);\n            }\n        }\n        // return max profit at most k transactions\n        return dp[k][1];\n    }\n}",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2555699/leetcode-the-hard-way-7-lines-line-by-line-explanation/",
                "vote_count": "69"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        \"\"\"\n        Use the idea of \"reinvesting\", we can \"carry-over\" a\n        previous transaction into the next transaction in order\n        to calculate a total profit.\n        \n        For example, given [3,2,6,5,7,0,3]\n                \n        If k = 1, then we would keep track of the lowest price and\n        max profit for each day.\n        \n            3, min_price [3], max_profit [0]\n            2, min_price [2], max_profit [0]\n            6, min_price [2], max_profit [4]\n            5, min_price [2], max_profit [4]\n            7, min_price [2], max_profit [5]\n            0, min_price [0], max_profit [5]\n            3, min_price [0], max_profit [5]\n        \n        If k = 2, we want to understand how much money we could make\n        if we \"reinvest\" profit from k = 1. This means we could only\n        initiate a k=2 transaction IFF k=1 (on a previous day) has a\n        non-zero max_profit.\n        \n            3, min_price [3, 3], max_profit [0, 0]\n            2, min_price [2, 2], max_profit [0, 0]\n            6, min_price [2, 2], max_profit [4, 4]\n            5, min_price [2, 1], max_profit [4, 4]  <- Reinvest profit\n            7, min_price [2, 1], max_profit [5, 6]\n            0, min_price [0, -5], max_profit [5, 6]\n            3, min_price [0, -5], max_profit [5, 8] <- Max profit with 2 transactions\n        \n        Notice that the new min_price is $1 when price is $5. Similarly, the new min_price\n        is -$5 when price is $0. Why?\n                \n        To understand, imagine if we bought at $2 and sold at $6. Then bought at $5\n        and sold at $7. That is two transactions with a total profit of\n        $4 + $2 = $6.\n        \n        Alternative, we can also think of it as (-$2)(+$6)(-$5)(+$7). This means when\n        the stock is at $5, we will use our profit to bring its effective price\n        down to $1 (i.e. (-$2)(+$6)(-$5)). When we sell at $7, we capture a TOTAL\n        profit of $6. Our tabulation is cumulative.\n        \n                \n        If k = 3, we do the same thing:\n        \n            3, min_price [3, 3, 3], max_profit [0, 0, 0]\n            2, min_price [2, 2, 2], max_profit [0, 0, 0]\n            6, min_price [2, 2, 2], max_profit [4, 4, 4]\n            5, min_price [2, 1, 1], max_profit [4, 4, 4]\n            7, min_price [2, 1, 1], max_profit [5, 6, 6]\n            0, min_price [0, -5, -6], max_profit [5, 6, 6]\n            3, min_price [0, -5, -6], max_profit [5, 8, 9]\n        \"\"\"\n        min_price = [float(\"inf\")] * (k + 1)\n        max_profit = [0] * (k + 1)\n        \n        for price in prices:\n            for i in range(1, k + 1):\n                min_price[i] = min(min_price[i], price - max_profit[i-1])\n                max_profit[i] = max(max_profit[i], price - min_price[i])\n\n        return max_profit[k]",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2555676/python-simple-dp-o-nk-uses-the-idea-of-reinvesting/",
                "vote_count": "48"
            },
            {
                "language": "java",
                "code": "        min_price = [(1 << 24)] * (k + 1)\n        max_profit = [0] * (k + 1)\n        \n        for price in prices:\n            for i in range(1, k + 1):\n                temp = price - max_profit[i-1]\n                if temp < min_price[i]: \n                    min_price[i] = temp ",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2555676/python-simple-dp-o-nk-uses-the-idea-of-reinvesting/",
                "vote_count": "48"
            },
            {
                "language": "cpp",
                "code": "#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <numeric>\nusing std::stack;\nusing std::pair;\nusing std::vector;\nusing std::nth_element;\nusing std::accumulate;\n\nclass Solution {\n\npublic:\n    int maxProfit(int k, const vector<int>& prices) {\n        vector<int> profits;\n        stack<pair<int, int>> vps;\n        int v = 0;\n        int p = -1;\n        \n        const int n = prices.size();\n        for (;;) {\n            for (v = p + 1; (v + 1) < n && prices[v] >= prices[v + 1]; ++v);\n            for (p = v; (p + 1) < n && prices[p] <= prices[p + 1]; ++p);\n            if (p == v) break;\n            \n            while (!vps.empty() && prices[vps.top().first] >= prices[v]) {\n                auto vp = vps.top();\n                profits.push_back(prices[vp.second] - prices[vp.first]);\n                vps.pop();\n            }\n            while (!vps.empty() && prices[vps.top().second] <= prices[p]) {\n                profits.push_back(prices[vps.top().second] - prices[v]);\n                v = vps.top().first; //  (v1, p2)\n                vps.pop();\n            }\n            vps.emplace(v, p);\n        }\n        while (!vps.empty()) {\n            auto vp = vps.top(); vps.pop();\n            profits.push_back(prices[vp.second] - prices[vp.first]);\n        }\n        if (k >= profits.size()) {\n            return accumulate(profits.begin(), profits.end(), 0);\n        } else {\n            nth_element(profits.begin(), profits.end() - k, profits.end());\n            return accumulate(profits.end() - k, profits.end(), 0);\n        }\n    }\n};",
                "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solutions/2997000/solution/",
                "vote_count": "27"
            }
        ]
    },
    "170": {
        "question_id": 189,
        "title": "Rotate Array",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/rotate-array",
        "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative. ",
        "examples": [
            {
                "input": "nums = [1,2,3,4,5,6,7], k = 3",
                "output": "[5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]",
                "explanation": null
            },
            {
                "input": "nums = [-1,-100,3,99], k = 2",
                "output": "[3,99,-1,-100]",
                "explanation": "\nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]"
            }
        ],
        "constraints": [
            "1 <= nums.length <= 10^5",
            "-2^31 <= nums[i] <= 2^31 - 1",
            "0 <= k <= 10^5",
            "Try to come up with as many solutions as you can. There are at least three different ways to solve this problem.",
            "Could you do it in-place with O(1) extra space?"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "public void rotate(int[] nums, int k) {\n    k %= nums.length;\n    reverse(nums, 0, nums.length - 1);\n    reverse(nums, 0, k - 1);\n    reverse(nums, k, nums.length - 1);\n}\n\npublic void reverse(int[] nums, int start, int end) {\n    while (start < end) {\n        int temp = nums[start];\n        nums[start] = nums[end];\n        nums[end] = temp;\n        start++;\n        end--;\n    }\n}",
                "url": "https://leetcode.com/problems/rotate-array/solutions/54250/easy-to-read-java-solution/",
                "vote_count": "1492"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public void rotate(int[] nums, int k) {\n        k = k % nums.length; \n        //(1) new array; \n        int[] oldNums = nums.clone();\n        for(int i = 0; i< nums.length;i++){\n            nums[(i+k)%nums.length] = oldNums[i]; \n        }",
                "url": "https://leetcode.com/problems/rotate-array/solutions/54250/easy-to-read-java-solution/",
                "vote_count": "1492"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\npublic void rotate(int[] nums, int k) {\n    int n = nums.length;\n    if(k==n) return;\n    if(k==0) return;\n    if(n<=1) return;\n    \n    int start = 0;\n    int swapPos = k%n;",
                "url": "https://leetcode.com/problems/rotate-array/solutions/54250/easy-to-read-java-solution/",
                "vote_count": "1492"
            },
            {
                "language": "python",
                "code": "Well, to be honest with you all. This is really not a hard problem! It's an easy one",
                "url": "https://leetcode.com/problems/rotate-array/solutions/1730142/java-c-python-a-very-very-well-detailed-explanation/",
                "vote_count": "281"
            },
            {
                "language": "python",
                "code": "Okay so, we have one thing that k will always be > 0.\nBut, I will teach you, one bonus point as well what if k < 0 i.e. k is -ve then how can you rotate the array.",
                "url": "https://leetcode.com/problems/rotate-array/solutions/1730142/java-c-python-a-very-very-well-detailed-explanation/",
                "vote_count": "281"
            },
            {
                "language": "csharp",
                "code": "\"K all possible rotation\"\n\n[7,1,2,3,4,5,6], k = 1\n[6,7,1,2,3,4,5], k = 2\n[5,6,7,1,2,3,4], k = 3\n[4,5,6,7,1,2,3], k = 4\n[3,4,5,6,7,1,2], k = 5\n[2,3,4,5,6,7,1], k = 6\n[1,2,3,4,5,6,7], k = 7",
                "url": "https://leetcode.com/problems/rotate-array/solutions/1730142/java-c-python-a-very-very-well-detailed-explanation/",
                "vote_count": "281"
            },
            {
                "language": "csharp",
                "code": "Okay Bonus point what if we have k = -1, then how can we rotate the array. If k is -1 then we have to rotate the value backward not in the front.\nEg - \nInput : [1,2,3,4,5,6,7], k = -1\nOutput : [2,3,4,5,6,7,1]\n\nNow how did we figure out this, if you carefully look that k = -1 is equals to k = 6.\nJust look at the table which I have made for every possible k values\n\nSo, what It represent is that add the -ve value to the length of array. And you will get your answer!",
                "url": "https://leetcode.com/problems/rotate-array/solutions/1730142/java-c-python-a-very-very-well-detailed-explanation/",
                "vote_count": "281"
            },
            {
                "language": "cpp",
                "code": "// reversing the array values\n    public static void reverse(int nums[], int i, int j){\n        int li = i; // left index;\n        int ri = j; // right index\n        \n        while(li < ri){\n            int temp = nums[li];\n            nums[li] = nums[ri];\n            nums[ri] = temp;\n            \n            li++;\n            ri--;\n        }\n    }",
                "url": "https://leetcode.com/problems/rotate-array/solutions/1730142/java-c-python-a-very-very-well-detailed-explanation/",
                "vote_count": "281"
            },
            {
                "language": "cpp",
                "code": "public void rotate(int[] nums, int k) {\n        k = k % nums.length; // if we have let's say 101 to rotate, then we only rotate it 1 time not 101 times\n        if(k < 0){ // if we get -ve value, then -ve is just equals to it's -ve + array.length\n            k += nums.length;\n        }\n        // part 1 reverse\n        reverse(nums, 0, nums.length - k - 1);\n        // part 2 reverse\n        reverse(nums, nums.length - k, nums.length - 1);\n        // complete reverse\n        reverse(nums, 0, nums.length - 1);\n    }",
                "url": "https://leetcode.com/problems/rotate-array/solutions/1730142/java-c-python-a-very-very-well-detailed-explanation/",
                "vote_count": "281"
            },
            {
                "language": "java",
                "code": "class Solution {\n  public static void reverse(int nums[], int i, int j){\n        int li = i;\n        int ri = j;\n        \n        while(li < ri){\n            int temp = nums[li];\n            nums[li] = nums[ri];\n            nums[ri] = temp;\n            \n            li++;\n            ri--;\n        }\n    }\n    public void rotate(int[] nums, int k) {\n        k = k % nums.length; \n        if(k < 0){ \n            k += nums.length;\n        }\n        reverse(nums, 0, nums.length - k - 1);\n        reverse(nums, nums.length - k, nums.length - 1);\n        reverse(nums, 0, nums.length - 1);\n    }\n}",
                "url": "https://leetcode.com/problems/rotate-array/solutions/1730142/java-c-python-a-very-very-well-detailed-explanation/",
                "vote_count": "281"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public :\n    void reverse(vector<int>& nums, int i, int j){\n        int li = i; // left;\n        int ri = j;\n        \n        while(li < ri){\n            int temp = nums[li];\n            nums[li] = nums[ri];\n            nums[ri] = temp;\n            \n            li++;\n            ri--;\n        }\n    }\n    void rotate(vector<int>& nums, int k) {\n        k = k % nums.size();\n        if(k < 0){ \n            k += nums.size();\n        }\n        reverse(nums, 0, nums.size() - k - 1);\n        reverse(nums, nums.size() - k, nums.size() - 1);\n        reverse(nums, 0, nums.size() - 1);\n    }\n};",
                "url": "https://leetcode.com/problems/rotate-array/solutions/1730142/java-c-python-a-very-very-well-detailed-explanation/",
                "vote_count": "281"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def reverse (self, nums, i, j) : \n        li = i\n        ri = j\n        \n        while li < ri:\n            temp = nums[li]\n            nums[li] = nums[ri]\n            nums[ri] = temp\n            \n            li += 1\n            ri -= 1\n    def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k = k % len(nums)\n        if k < 0 : \n            k += len(nums)\n        \n        self.reverse(nums, 0, len(nums) - k - 1);\n        self.reverse(nums, len(nums) - k, len(nums) - 1);\n        self.reverse(nums, 0, len(nums) - 1);",
                "url": "https://leetcode.com/problems/rotate-array/solutions/1730142/java-c-python-a-very-very-well-detailed-explanation/",
                "vote_count": "281"
            },
            {
                "language": "cpp",
                "code": "public static void reverse(int nums[], int low, int high){\n    while(low < high){\n        int temp = nums[low];\n        nums[low] = nums[high];\n        nums[high] = temp;\n        low++;\n        high--;\n    }",
                "url": "https://leetcode.com/problems/rotate-array/solutions/1730142/java-c-python-a-very-very-well-detailed-explanation/",
                "vote_count": "281"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public void rotate(int[] nums, int k) {\n        k %= nums.length;\n        reverse(nums, 0, nums.length - 1);\n        reverse(nums, 0, k - 1);\n        reverse(nums, k, nums.length - 1);\n    }\n\n    public void reverse(int[] nums, int start, int end) {",
                "url": "https://leetcode.com/problems/rotate-array/solutions/1730142/java-c-python-a-very-very-well-detailed-explanation/",
                "vote_count": "281"
            },
            {
                "language": "php",
                "code": "def rotate(self, nums: List[int], k: int) -> None:\n n = len(nums) # store length of nums\n for _ in range(k):\n  prev = nums[-1] # previous element starts as the end\n  for i in range(n):\n   nums[i], prev = prev, nums[i] # this element becomes the previous one, store this element in prev",
                "url": "https://leetcode.com/problems/rotate-array/solutions/2747423/complete-python-explanation-5-methods/",
                "vote_count": "76"
            },
            {
                "language": "php",
                "code": "def rotate(self, nums: List[int], k: int) -> None:\n copy = [num for num in nums] # copy the nums array\n n = len(nums)\n for i, num in enumerate(copy): # for every element in the copy\n  nums[(i + k) % n] = copy[i] # set corresponding location in nums",
                "url": "https://leetcode.com/problems/rotate-array/solutions/2747423/complete-python-explanation-5-methods/",
                "vote_count": "76"
            },
            {
                "language": "ruby",
                "code": "def rotate(self, nums: List[int], k: int) -> None:\n n = len(nums) # store length\n k %= n # avoid unnecessary rotations\n nums[:] = nums[-k:] + nums[:-k] # set nums to answer",
                "url": "https://leetcode.com/problems/rotate-array/solutions/2747423/complete-python-explanation-5-methods/",
                "vote_count": "76"
            },
            {
                "language": "ruby",
                "code": "def rotate(self, nums: List[int], k: int) -> None:\n nums[:] = nums[-k%len(nums):] + nums[:-k%len(nums)]",
                "url": "https://leetcode.com/problems/rotate-array/solutions/2747423/complete-python-explanation-5-methods/",
                "vote_count": "76"
            },
            {
                "language": "ruby",
                "code": "def rotate(self, nums: List[int], k: int) -> None:\n n = len(nums)\n k %= n\n if k != 0: # we only want to rotate the array if we need to\n  end = nums[-k:] # store the end of the array (which will become the front)\n  for i in range(n-k-1, -1, -1): # go backwards through the first n-k elements of the array\n   nums[i+k] = nums[i] # shift everything forward k spots\n  nums[:k] = end # put the old end to the front",
                "url": "https://leetcode.com/problems/rotate-array/solutions/2747423/complete-python-explanation-5-methods/",
                "vote_count": "76"
            },
            {
                "language": "php",
                "code": "def rotate(self, nums: List[int], k: int) -> None:\n n = len(nums)\n k %= n\n if k != 0: # we only want to rotate the array if we need to\n  if k < n//2: # if the end is less than half the size of the array\n   end = nums[-k:] # store the end of the array (which will become the front)\n   for i in range(n-k-1, -1, -1): # go backwards through the first n-k elements of the array\n    nums[i+k] = nums[i] # shift everything forward k spots\n   nums[:k] = end # put the old end to the front\n  else: # the end is bigger than the beginning so store the beginning\n   beg = nums[:-k] # store the beginning!\n   for i in range(n-k, n): # go forwards through the last k elements\n    nums[(i+k)%n] = nums[i] # shift them forwards k spots (to the front of the list)\n   nums[k:] = beg # set the end to the beginning",
                "url": "https://leetcode.com/problems/rotate-array/solutions/2747423/complete-python-explanation-5-methods/",
                "vote_count": "76"
            },
            {
                "language": "ruby",
                "code": "def rotate(self, nums: List[int], k: int) -> None:\n def reverse(start, end): # helper method to reverse from start to end\n  while start < end: # while there is stuff to reverse\n   nums[start], nums[end] = nums[end], nums[start] # swap the elements at the ends\n   start, end = start + 1, end - 1 # move pointers closer to each other\n   \n n = len(nums)\n k %= n\n reverse(0,n-1) # reverse full list\n reverse(0,k-1) # reverse first k elements (previously the last k elements)\n reverse(k,n-1) # reverse the rest of the list",
                "url": "https://leetcode.com/problems/rotate-array/solutions/2747423/complete-python-explanation-5-methods/",
                "vote_count": "76"
            },
            {
                "language": "erlang",
                "code": "original nums: [1, 2, 3, 4, 5, 6, 7]\nnums after fully reversing: [7, 6, 5, 4, 3, 2, 1]\nnums after reversing the first k elements: [5, 6, 7, 4, 3, 2, 1]\nnums after reversing the remaining elements: [5, 6, 7, 1, 2, 3, 4]",
                "url": "https://leetcode.com/problems/rotate-array/solutions/2747423/complete-python-explanation-5-methods/",
                "vote_count": "76"
            },
            {
                "language": "erlang",
                "code": "original nums: [-1, -100, 3, 99]\nnums after fully reversing: [99, 3, -100, -1]\nnums after reversing the first k elements: [3, 99, -100, -1]\nnums after reversing the remaining elements: [3, 99, -1, -100]",
                "url": "https://leetcode.com/problems/rotate-array/solutions/2747423/complete-python-explanation-5-methods/",
                "vote_count": "76"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n= nums.size();\n        vector<int> ans(n);\n      \n        for(int i=0; i<n; i++)\n        ans[(i+k)%n] = nums[i];\n        nums=ans;\n    }\n};",
                "url": "https://leetcode.com/problems/rotate-array/solutions/3176199/solution/",
                "vote_count": "59"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void rotate(vector<int>& v, int k) {\n        int a =k%v.size();\n        reverse(v.begin(),v.end());\n        reverse(v.begin(),v.begin()+a);\n        reverse(v.begin()+a,v.end());\n    }\n};",
                "url": "https://leetcode.com/problems/rotate-array/solutions/3014158/simple-c-solution/",
                "vote_count": "46"
            },
            {
                "language": "java",
                "code": "class Solution {\n    \n    public void reverse(int []arr, int low, int high){\n        while(low < high){\n            int temp = arr[low];\n            arr[low] = arr[high];\n            arr[high] = temp;\n\n            low++;\n            high--;\n        }\n    }\n    \n    public void rotate(int[] nums, int k) {\n        int n = nums.length;\n        int start = 0;\n        int end = n-1;\n        if(k > n){\n            k = k%n;\n        }\n        //1. reversing the whole array\n        reverse(nums, start, end);\n \n\n        //2. reversing the k part\n        reverse(nums, start, k-1);\n\n        //3. reverse the remaining part\n        reverse(nums, k, end);\n\n    }\n}",
                "url": "https://leetcode.com/problems/rotate-array/solutions/3244055/rotation-array-clockwise-rotation-rotation-game-time-complexity-o-n-sc-o-1/",
                "vote_count": "13"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public void rotate(int[] nums, int k) {\n        int n=nums.length;\n        k=k%n;\n        flip(nums,0,n-k-1);\n        flip(nums,n-k,n-1);\n        flip(nums,0,n-1);\n        \n    }\n    public void flip(int[] arr,int s,int e)\n    {\n        while(s<e)\n        {\n            int temp=arr[s];\n            arr[s]=arr[e];\n            arr[e]=temp;\n            s++;\n            e--;\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/",
                "vote_count": "10"
            }
        ]
    },
    "171": {
        "question_id": 190,
        "title": "Reverse Bits",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/reverse-bits",
        "description": "Reverse bits of a given 32 bits unsigned integer.Note:",
        "examples": [
            {
                "input": "n = 00000010100101000001111010011100",
                "output": "   964176192 (00111001011110000010100101000000)",
                "explanation": "The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000."
            },
            {
                "input": "n = 11111111111111111111111111111101",
                "output": "  3221225471 (10111111111111111111111111111111)",
                "explanation": "The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111."
            }
        ],
        "constraints": [
            "The input must be a binary string of length 32"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "public int reverseBits(int n) {\n    if (n == 0) return 0;\n    \n    int result = 0;\n    for (int i = 0; i < 32; i++) {\n        result <<= 1;\n        if ((n & 1) == 1) result++;\n        n >>= 1;\n    }\n    return result;\n}",
                "url": "https://leetcode.com/problems/reverse-bits/solutions/54738/sharing-my-2ms-java-solution-with-explanation/",
                "vote_count": "780"
            },
            {
                "language": "python",
                "code": "for(int i=0; i<32; i++){\n            result <<= 1;\n            result += n&1;\n            n >>= 1;\n        }",
                "url": "https://leetcode.com/problems/reverse-bits/solutions/54738/sharing-my-2ms-java-solution-with-explanation/",
                "vote_count": "780"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\npublic int reverseBits(int n) {\n    if (n == 0) return 0;\n    \n    int result = 0;\n    for (int i = 0; i < 32; i++) {\n        \n        if ((n & 1) == 1) result++;",
                "url": "https://leetcode.com/problems/reverse-bits/solutions/54738/sharing-my-2ms-java-solution-with-explanation/",
                "vote_count": "780"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        string bits = \"\";\n        \n        for(int i = 0; i < 32; i++){\n            if(n & (1 << i)) bits.push_back('1');\n            else bits.push_back('0');\n        }",
                "url": "https://leetcode.com/problems/reverse-bits/solutions/1232842/java-c-0ms-o-1-time-complexity-in-place-detailed-explanation/",
                "vote_count": "350"
            },
            {
                "language": "kotlin",
                "code": "    n = ((n & 0b11111111111111110000000000000000) >>> 16) | ((n & 0b00000000000000001111111111111111) << 16);\n    n = ((n & 0b11111111000000001111111100000000) >>> 8)  | ((n & 0b00000000111111110000000011111111) << 8);\n    n = ((n & 0b11110000111100001111000011110000) >>> 4)  | ((n & 0b00001111000011110000111100001111) << 4);\n    n = ((n & 0b11001100110011001100110011001100) >>> 2)  | ((n & 0b00110011001100110011001100110011) << 2);\n    n = ((n & 0b10101010101010101010101010101010) >>> 1)  | ((n & 0b01010101010101010101010101010101) << 1);\n    return n;",
                "url": "https://leetcode.com/problems/reverse-bits/solutions/1232842/java-c-0ms-o-1-time-complexity-in-place-detailed-explanation/",
                "vote_count": "350"
            }
        ]
    },
    "172": {
        "question_id": 191,
        "title": "Number of 1 Bits",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/number-of-1-bits",
        "description": "Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).Note:",
        "examples": [
            {
                "input": "n = 00000000000000000000000000001011",
                "output": "3",
                "explanation": "The input binary string 00000000000000000000000000001011 has a total of three '1' bits."
            },
            {
                "input": "n = 00000000000000000000000010000000",
                "output": "1",
                "explanation": "The input binary string 00000000000000000000000010000000 has a total of one '1' bit."
            },
            {
                "input": "n = 11111111111111111111111111111101",
                "output": "31",
                "explanation": "The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits."
            }
        ],
        "constraints": [
            "The input must be a binary string of length 32."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int count=0;\n        while (n) {\n            // let's and(&) each bit with 1, if the result is 1 then we increment count by 1\n            if (n&1 > 0) count++;\n            // and then shift n by 1 bit [so that we can check the next bit is 1 or not]\n            n>>=1;\n        }\n        return count;\n    }\n};",
                "url": "https://leetcode.com/problems/number-of-1-bits/solutions/2742007/0ms-explained-solutions-c-bit-manipulation/",
                "vote_count": "63"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int count=0;\n        while (n) {\n            // when we substract n by 1, the Lowest significant 1 is affected first, thus \n            // when we use and (&) operation the other 1's stay intact and we increment count by 1\n            n &= (n-1);\n            count++;\n        }\n        return count;\n    }\n};",
                "url": "https://leetcode.com/problems/number-of-1-bits/solutions/2742007/0ms-explained-solutions-c-bit-manipulation/",
                "vote_count": "63"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        return bitset<32>(n).count();\n    }\n};",
                "url": "https://leetcode.com/problems/number-of-1-bits/solutions/2742007/0ms-explained-solutions-c-bit-manipulation/",
                "vote_count": "63"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int count = 0;\n\n        for (int i = 0; i < 32; i++)",
                "url": "https://leetcode.com/problems/number-of-1-bits/solutions/2742007/0ms-explained-solutions-c-bit-manipulation/",
                "vote_count": "63"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(logN).\n\n    Space Complexity : O(1).\n    \n    Solved using Bit Manipulation.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int count = 0;\n        while(n != 0){\n            count += (n%2);\n            n >>= 1;\n        }\n        return count;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(logN).\n\n    Space Complexity : O(1).\n    \n    Solved using Bit Manipulation.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int count = 0;\n        while(n != 0){\n            n &= (n-1);\n            count++;\n        }\n        return count;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(logN).\n\n    Space Complexity : O(1).\n    \n    Solved using Bit Manipulation.\n\n*/\n\n\n/***************************************** Approach 3 *****************************************/\n\nclass Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int count = 0;\n        while(n != 0){\n            int rmsb = n & -n;\n            n -= rmsb;\n            count++;\n        }\n        return count;\n    }\n};",
                "url": "https://leetcode.com/problems/number-of-1-bits/solutions/3229926/best-c-3-solution-easy-solution-bit-manipulation-one-stop-solution/",
                "vote_count": "54"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int count=0;\n        while(n!=0){\n            int last_bit= n & 1; //Stores the value of the last bit of the number n i.e.(1 or 0)\n            count+= last_bit; // adds 0 if last bit is 0 and adds 1 if last bit is 1 \n            n = n>>>1;  //Dropping the last bit of the binary number n \n        }\n        return count;\n    }\n}",
                "url": "https://leetcode.com/problems/number-of-1-bits/solutions/3015716/java-easy-solution-beats-100-runtime-0ms/",
                "vote_count": "30"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        # Initialize a counter variable to 0\n        count = 0\n        # Loop until n is 0\n        while n != 0:\n            # If the last bit of n is 1, increment the counter\n            if n & 1 == 1:\n                count += 1\n            # Shift n to the right by 1 bit\n            n = n >> 1\n        # Return the counter\n        return count",
                "url": "https://leetcode.com/problems/number-of-1-bits/solutions/3218849/191-solution-step-by-step-explanation/",
                "vote_count": "20"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        return bin(n)[2:].count('1')",
                "url": "https://leetcode.com/problems/number-of-1-bits/solutions/3288353/amazing-logic-with-right-shift/",
                "vote_count": "19"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        count=0\n        while n:\n            count+=n%2\n            n=n>>1\n        return count\n    #please upvote me it would encourage me alot\n\n        ",
                "url": "https://leetcode.com/problems/number-of-1-bits/solutions/3288353/amazing-logic-with-right-shift/",
                "vote_count": "19"
            }
        ]
    },
    "173": {
        "question_id": 198,
        "title": "House Robber",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/house-robber",
        "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. ",
        "examples": [
            {
                "input": "nums = [1,2,3,1]",
                "output": "4",
                "explanation": "Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4."
            },
            {
                "input": "nums = [2,7,9,3,1]",
                "output": "12",
                "explanation": "Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12."
            }
        ],
        "constraints": [
            "1 <= nums.length <= 100",
            "0 <= nums[i] <= 400"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "public int rob(int[] nums) {\n    return rob(nums, nums.length - 1);\n}\nprivate int rob(int[] nums, int i) {\n    if (i < 0) {\n        return 0;\n    }\n    return Math.max(rob(nums, i - 2) + nums[i], rob(nums, i - 1));\n}",
                "url": "https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/",
                "vote_count": "9508"
            },
            {
                "language": "cpp",
                "code": "int[] memo;\npublic int rob(int[] nums) {\n    memo = new int[nums.length + 1];\n    Arrays.fill(memo, -1);\n    return rob(nums, nums.length - 1);\n}\n\nprivate int rob(int[] nums, int i) {\n    if (i < 0) {\n        return 0;\n    }\n    if (memo[i] >= 0) {\n        return memo[i];\n    }\n    int result = Math.max(rob(nums, i - 2) + nums[i], rob(nums, i - 1));\n    memo[i] = result;\n    return result;\n}",
                "url": "https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/",
                "vote_count": "9508"
            },
            {
                "language": "cpp",
                "code": "public int rob(int[] nums) {\n    if (nums.length == 0) return 0;\n    int[] memo = new int[nums.length + 1];\n    memo[0] = 0;\n    memo[1] = nums[0];\n    for (int i = 1; i < nums.length; i++) {\n        int val = nums[i];\n        memo[i+1] = Math.max(memo[i], memo[i-1] + val);\n    }\n    return memo[nums.length];\n}",
                "url": "https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/",
                "vote_count": "9508"
            },
            {
                "language": "cpp",
                "code": "/* the order is: prev2, prev1, num  */\npublic int rob(int[] nums) {\n    if (nums.length == 0) return 0;\n    int prev1 = 0;\n    int prev2 = 0;\n    for (int num : nums) {\n        int tmp = prev1;\n        prev1 = Math.max(prev2 + num, prev1);\n        prev2 = tmp;\n    }\n    return prev1;\n}",
                "url": "https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/",
                "vote_count": "9508"
            }
        ]
    },
    "174": {
        "question_id": 199,
        "title": "Binary Tree Right Side View",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/binary-tree-right-side-view",
        "description": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. ",
        "examples": [
            {
                "input": "root = [1,2,3,null,5,null,4]",
                "output": "[1,3,4]",
                "explanation": null
            },
            {
                "input": "root = [1,null,3]",
                "output": "[1,3]",
                "explanation": null
            },
            {
                "input": "root = []",
                "output": "[]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [0, 100].",
            "-100 <= Node.val <= 100"
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "public class Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer> result = new ArrayList<Integer>();\n        rightView(root, result, 0);\n        return result;\n    }\n    \n    public void rightView(TreeNode curr, List<Integer> result, int currDepth){\n        if(curr == null){\n            return;\n        }\n        if(currDepth == result.size()){\n            result.add(curr.val);\n        }\n        \n        rightView(curr.right, result, currDepth + 1);\n        rightView(curr.left, result, currDepth + 1);\n        \n    }\n}",
                "url": "https://leetcode.com/problems/binary-tree-right-side-view/solutions/56012/my-simple-accepted-solution-java/",
                "vote_count": "1175"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        if (root == null)\n            return new ArrayList();\n        Queue<TreeNode> queue = new LinkedList();\n        queue.offer(root);",
                "url": "https://leetcode.com/problems/binary-tree-right-side-view/solutions/56012/my-simple-accepted-solution-java/",
                "vote_count": "1175"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer> result = new ArrayList();\n        if(root == null)\n            return result;\n        Queue<TreeNode> que = new LinkedList();\n        que.add(root);\n        while(!que.isEmpty()){",
                "url": "https://leetcode.com/problems/binary-tree-right-side-view/solutions/56012/my-simple-accepted-solution-java/",
                "vote_count": "1175"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        if(root == null){\n            return new ArrayList<Integer>();\n        }\n        \n        List<Integer> result = new ArrayList<Integer>();\n        Stack<NodeWithDep> stack = new Stack<NodeWithDep>();",
                "url": "https://leetcode.com/problems/binary-tree-right-side-view/solutions/56012/my-simple-accepted-solution-java/",
                "vote_count": "1175"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    vector<int> solve(TreeNode* root, vector<int> res, int lvl){\n        if (root==NULL){\n            return res;\n        }\n        if (res.size()==lvl){                 // root\n            res.push_back(root->val);\n        }\n        res = solve(root->right , res , lvl + 1);     // right\n        res = solve(root->left , res , lvl + 1);       // left\n        return res;\n    }\n    \n    vector<int> rightSideView(TreeNode* root) {\n        vector<int> res;\n        res = solve( root , res , 0 );\n        return res;\n    }\n};",
                "url": "https://leetcode.com/problems/binary-tree-right-side-view/solutions/2266055/c-python-explained/",
                "vote_count": "90"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        \n        def solve(root, lvl):\n         if root:\n          if len(res)==lvl:\n           res.append(root.val)\n          solve(root.right, lvl + 1)\n          solve(root.left, lvl + 1)\n         return \n\n        res = []\n        solve(root,0)\n        return res",
                "url": "https://leetcode.com/problems/binary-tree-right-side-view/solutions/2266055/c-python-explained/",
                "vote_count": "90"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) {\n        vector<int>ans;\n        queue<TreeNode*> q;\n        if(root==NULL)\n        return ans;\n        q.push(root);\n        while(1)\n        {\n            int size=q.size();\n            if(size==0)\n            return ans;\n            vector<int> data;\n            while(size--)\n            {\n                TreeNode* temp=q.front();\n                q.pop();\n                data.push_back(temp->val);\n                if(temp->left!=NULL)\n                q.push(temp->left);\n                if(temp->right!=NULL)\n                q.push(temp->right);\n            }\n            ans.push_back(data.back());\n        }\n    }\n};",
                "url": "https://leetcode.com/problems/binary-tree-right-side-view/solutions/3176211/solution/",
                "vote_count": "44"
            },
            {
                "language": "rust",
                "code": "Code for All Views of a tree\nPlease do upvote...",
                "url": "https://leetcode.com/problems/binary-tree-right-side-view/solutions/3125913/java-all-tree-views-easy-fast/",
                "vote_count": "16"
            },
            {
                "language": "csharp",
                "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        var list = new ArrayList<Integer>();\n        rec(root,list,0);\n        return list;\n    }\n    void rec(TreeNode root,ArrayList<Integer> list, int depth){\n        if (root == null) return;\n        if(list.size()==depth) list.add(root.val);\n        if(root.right!=null) rec(root.right,list,depth+1);\n        if(root.left!=null) rec(root.left,list,depth+1);\n    }\n}",
                "url": "https://leetcode.com/problems/binary-tree-right-side-view/solutions/3125913/java-all-tree-views-easy-fast/",
                "vote_count": "16"
            },
            {
                "language": "javascript",
                "code": "/* A Binary Tree node\nclass Node\n{\n    int data;\n    Node left, right;\n\n    Node(int item)\n    {\n        data = item;\n        left = right = null;\n    }\n}*/\nclass Tree\n{\n    //Function to return list containing elements of left view of binary tree.\n    ArrayList<Integer> leftView(Node root)\n    {\n      // Your code here\n      var list = new ArrayList<Integer>();\n      rec(root,list,0);\n      return list;\n    }\n    void rec(Node root, ArrayList<Integer> list, int depth){\n        if(root==null) return;\n        if(list.size()==depth) list.add(root.data);\n        if(root.left!=null) rec(root.left,list,depth+1);\n        if(root.right!=null) rec(root.right,list,depth+1);\n    }\n}",
                "url": "https://leetcode.com/problems/binary-tree-right-side-view/solutions/3125913/java-all-tree-views-easy-fast/",
                "vote_count": "16"
            },
            {
                "language": "csharp",
                "code": "/*\nclass Node{\n    int data;\n    Node left;\n    Node right;\n    Node(int data){\n        this.data = data;\n        left=null;\n        right=null;\n    }\n}\n*/\n\nclass Pair{\n    int ind;\n    Node root;\n    Pair(int _ind, Node _root){\n        ind = _ind;\n        root = _root;\n    }\n}\n\nclass Solution\n{\n    //Function to return a list of nodes visible from the top view \n    //from left to right in Binary Tree.\n    static ArrayList<Integer> topView(Node root)\n    {\n        // add your code\n        var map = new TreeMap<Integer,Integer>();\n        var q = new LinkedList<Pair>();\n        var list = new ArrayList<Integer>();\n        if(root==null) return list;\n        q.add(new Pair(0,root));\n        while(!q.isEmpty()){\n            Pair pair = q.poll();\n            int pos = pair.ind;\n            Node node = pair.root;\n            if(!map.containsKey(pos)) map.put(pos,node.data);\n            if(node.left!=null) q.add(new Pair(pos-1,node.left));\n            if(node.right!=null) q.add(new Pair(pos+1,node.right));\n            \n        }\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\n            list.add(entry.getValue());\n        } return list;\n    }\n}",
                "url": "https://leetcode.com/problems/binary-tree-right-side-view/solutions/3125913/java-all-tree-views-easy-fast/",
                "vote_count": "16"
            },
            {
                "language": "csharp",
                "code": "/*\nclass Node{\n    int data;\n    Node left;\n    Node right;\n    Node(int data){\n        this.data = data;\n        left=null;\n        right=null;\n    }\n}\n*/\nclass Pair{\n    int ind;\n    Node root;\n    Pair(int _ind, Node _root){\n        ind = _ind;\n        root = _root;\n    }\n}\n\nclass Solution\n{\n    //Function to return a list of nodes visible from the bottom view \n    //from left to right in Binary Tree.\n    static ArrayList<Integer> bottomView(Node root)\n    {\n        // add your code\n        var map = new TreeMap<Integer,Integer>();\n        var q = new LinkedList<Pair>();\n        var list = new ArrayList<Integer>();\n        if(root==null) return list;\n        q.add(new Pair(0,root));\n        while(!q.isEmpty()){\n            Pair pair = q.poll();\n            int pos = pair.ind;\n            Node node = pair.root;\n            if(!map.containsKey(pos)) map.put(pos,node.data);\n            if(map.containsKey(pos)) map.replace(pos,node.data);\n            if(node.left!=null) q.add(new Pair(pos-1,node.left));\n            if(node.right!=null) q.add(new Pair(pos+1,node.right));\n            \n        }\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\n            list.add(entry.getValue());\n        } return list;\n    }",
                "url": "https://leetcode.com/problems/binary-tree-right-side-view/solutions/3125913/java-all-tree-views-easy-fast/",
                "vote_count": "16"
            }
        ]
    },
    "175": {
        "question_id": 200,
        "title": "Number of Islands",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/number-of-islands",
        "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. ",
        "examples": [
            {
                "input": "grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
                "output": "1",
                "explanation": null
            },
            {
                "input": "grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]",
                "output": "3",
                "explanation": null
            }
        ],
        "constraints": [
            "m == grid.length",
            "n == grid[i].length",
            "1 <= m, n <= 300",
            "grid[i][j] is '0' or '1'."
        ],
        "solutions": [
            {
                "language": "python",
                "code": "def numIslands(self, grid):\n    if not grid:\n        return 0\n        \n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                self.dfs(grid, i, j)\n                count += 1\n    return count\n\ndef dfs(self, grid, i, j):\n    if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':\n        return\n    grid[i][j] = '#'\n    self.dfs(grid, i+1, j)\n    self.dfs(grid, i-1, j)\n    self.dfs(grid, i, j+1)\n    self.dfs(grid, i, j-1)",
                "url": "https://leetcode.com/problems/number-of-islands/solutions/56340/python-simple-dfs-solution/",
                "vote_count": "1497"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        if not grid: return 0\n        r, c = len(grid), len(grid[0])",
                "url": "https://leetcode.com/problems/number-of-islands/solutions/56340/python-simple-dfs-solution/",
                "vote_count": "1497"
            },
            {
                "language": "python",
                "code": "def bfs(self, grid, coords):\n    for i, j in coords:\n        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':\n            continue\n        grid[i][j] = '#'",
                "url": "https://leetcode.com/problems/number-of-islands/solutions/56340/python-simple-dfs-solution/",
                "vote_count": "1497"
            },
            {
                "language": "ruby",
                "code": "from typing import List\n\n# @lc code=start\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        if not grid:\n            return 0",
                "url": "https://leetcode.com/problems/number-of-islands/solutions/56340/python-simple-dfs-solution/",
                "vote_count": "1497"
            },
            {
                "language": "erlang",
                "code": "PLEASE UPVOTE IF YOU LIKE.",
                "url": "https://leetcode.com/problems/number-of-islands/solutions/2497954/java-easy-solution-98-faster-code/",
                "vote_count": "87"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\n    public int numIslands(char[][] grid) {\n        int count = 0;\n        \n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[i].length; j++) {\n                if (grid[i][j] == '1') {\n                    count++;\n                    clearRestOfLand(grid, i, j);\n                }\n            }\n        }\n        return count;\n    }\n    \n    private void clearRestOfLand(char[][] grid, int i, int j) {\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] == '0') return;\n        \n        grid[i][j] = '0';\n        clearRestOfLand(grid, i+1, j);\n        clearRestOfLand(grid, i-1, j);\n        clearRestOfLand(grid, i, j+1);\n        clearRestOfLand(grid, i, j-1);\n        return;\n    }\n}",
                "url": "https://leetcode.com/problems/number-of-islands/solutions/2497954/java-easy-solution-98-faster-code/",
                "vote_count": "87"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    void turn_to_dust(vector<vector<char>>& grid, int i, int j, int m, int n){\n        if (i<0 || j<0 || i==m || j==n || grid[i][j]=='0') return;\n        grid[i][j]='0';\n        turn_to_dust(grid,i+1,j,m,n);\n        turn_to_dust(grid,i,j+1,m,n);\n        turn_to_dust(grid,i-1,j,m,n);\n        turn_to_dust(grid,i,j-1,m,n);\n        return;\n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        int res=0;\n        for (int i=0; i<m; i++){\n            for (int j=0; j<n; j++){\n                if (grid[i][j]=='1'){\n                    res++;\n                    turn_to_dust(grid,i,j,m,n);\n                }\n            }\n        }\n        return res;\n    }\n};",
                "url": "https://leetcode.com/problems/number-of-islands/solutions/2497909/c-python-explained/",
                "vote_count": "74"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        \n        def turn_to_dust(i,j):\n            if (i<0 or j<0 or i==len(grid) or j==len(grid[0]) or grid[i][j]==\"0\"):\n                return\n            grid[i][j]=\"0\"\n            turn_to_dust(i,j+1)\n            turn_to_dust(i,j-1)\n            turn_to_dust(i+1,j)\n            turn_to_dust(i-1,j)\n            return\n        res=0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j]==\"1\":\n                    res+=1\n                    turn_to_dust(i,j)\n        return res",
                "url": "https://leetcode.com/problems/number-of-islands/solutions/2497909/c-python-explained/",
                "vote_count": "74"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        n = 0\n        lastRow, lastCol = len(grid)-1, len(grid[0])-1\n        land = set((i, j) for i, row in enumerate(grid) for j, val in enumerate(row)  if val is '1')\n        \n        def checkAndRemove(row, col):",
                "url": "https://leetcode.com/problems/number-of-islands/solutions/2497909/c-python-explained/",
                "vote_count": "74"
            },
            {
                "language": "kotlin",
                "code": "Scan the each element in the `grid`.\n1)  element == '1'\n - assign '0' to element\n - island_count += 1\n - Scan the neigbhour lands and set to '0'\n2)  value == '0':\n    - continue",
                "url": "https://leetcode.com/problems/number-of-islands/solutions/2499215/python-no-recursion-faster-than-82-less-than-98/",
                "vote_count": "24"
            },
            {
                "language": "java",
                "code": "def numIslands(self, grid: List[List[str]]) -> int:\n        def is_valid(i, j):\n            return True if 0 <= i < len_row and 0 <= j < len_col and grid[i][j] == \"1\" else False\n                \n        len_row, len_col = len(grid), len(grid[0])\n        island_count = 0\n        for row in range(len_row):\n            for col in range(len_col):\n                if is_valid(row, col):\n                    island_count += 1\n                    queue = deque([(row, col)])\n                    while len(queue) != 0:\n                        r, c = queue.popleft()\n                        if grid[r][c] == \"1\":\n                            grid[r][c] = \"0\"\n                            for r_move, c_move in ((-1,0),(1,0),(0,1),(0,-1)):\n                                if is_valid(r + r_move, c + c_move):\n                                    queue.append((r + r_move, c + c_move))\n\n        return island_count",
                "url": "https://leetcode.com/problems/number-of-islands/solutions/2499215/python-no-recursion-faster-than-82-less-than-98/",
                "vote_count": "24"
            }
        ]
    },
    "176": {
        "question_id": 201,
        "title": "Bitwise AND of Numbers Range",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range",
        "description": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive. ",
        "examples": [
            {
                "input": "left = 5, right = 7",
                "output": "4",
                "explanation": null
            },
            {
                "input": "left = 0, right = 0",
                "output": "0",
                "explanation": null
            },
            {
                "input": "left = 1, right = 2147483647",
                "output": "0",
                "explanation": null
            }
        ],
        "constraints": [
            "0 <= left <= right <= 2^31 - 1"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "public class Solution {\n    public int rangeBitwiseAnd(int m, int n) {\n        if(m == 0){\n            return 0;\n        }\n        int moveFactor = 1;\n        while(m != n){\n            m >>= 1;\n            n >>= 1;\n            moveFactor <<= 1;\n        }\n        return m * moveFactor;\n    }\n}",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56729/bit-operation-solution-java/",
                "vote_count": "455"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56729/bit-operation-solution-java/",
                "vote_count": "455"
            },
            {
                "language": "python",
                "code": "def rangeBitwiseAnd2(self, m, n):\n    \"\"\"\n    By using Brian Kernighan's Algorithm\n    \"\"\"\n    while n > m:\n        n &= (n-1);\n        print n\n    return m & n;",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56729/bit-operation-solution-java/",
                "vote_count": "455"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\npublic int rangeBitwiseAnd(int m, int n) {\n    int step = 0;\n    while(m!=n){\n        m >>= 1;\n        n >>= 1;\n        step ++;\n    }",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56729/bit-operation-solution-java/",
                "vote_count": "455"
            },
            {
                "language": "python",
                "code": "def rangeBitwiseAnd(self, m, n):\n    l = len(str(bin(m ^ n))) - 2\n    return m if m == n else m >> l << l",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56729/bit-operation-solution-java/",
                "vote_count": "455"
            },
            {
                "language": "kotlin",
                "code": "if (m == 0) {\n    return 0;\n}",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56729/bit-operation-solution-java/",
                "vote_count": "455"
            },
            {
                "language": "java",
                "code": "public class Solution {\npublic int rangeBitwiseAnd(int m, int n) {\n    int result=0;\n    for(int i=0;i<32;++i){\n        if( dist(m,n,i)&& check(m+1,i) && check(n+1,i)){\n            result|=(1<<i);\n        }\n    }",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56729/bit-operation-solution-java/",
                "vote_count": "455"
            },
            {
                "language": "cpp",
                "code": "public int rangeBitwiseAnd(int m, int n) {\n        int res = 0;\n        for(int i = 31; i >= 0; i--){\n      // ml is the most significant bit of m, nl is the most significant bit of n\n            int ml = (1<<31) & m, nl = (1<<31) & n;\n            if(ml == nl) res += ml==0?0:(1<<i);\n            else return res;\n            m <<= 1;",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56729/bit-operation-solution-java/",
                "vote_count": "455"
            },
            {
                "language": "cpp",
                "code": "public int rangeBitwiseAnd(int m, int n) {\n        int i=1<<31;\n        int result=0;\n        while(i!=0 && (i&m)==(i&n)){\n            result|=(i&m);\n            i>>>=1;\n        }\n        return result;",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56729/bit-operation-solution-java/",
                "vote_count": "455"
            },
            {
                "language": "cpp",
                "code": "public int rangeBitwiseAnd(int m, int n) {\n        int multiplier = 1;\n        int ans = 0;\n        while(n != 0){\n            if( m == n && (n%2 !=0)) ans += multiplier;\n            multiplier <<= 1;\n            m >>= 1;\n            n >>= 1;",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56729/bit-operation-solution-java/",
                "vote_count": "455"
            },
            {
                "language": "",
                "code": "         12 ---- 1100\n         11 ---- 1011\n         10 ---- 1010\n         9  ---- 1001\n         8  ---- 1000\n         7  ---- 0111\n         6  ---- 0110\n         5  ---- 0101\n         ",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/593317/simple-3-line-java-solution-faster-than-100/",
                "vote_count": "387"
            },
            {
                "language": "kotlin",
                "code": " while(n>m)\n           n = n & n-1;\n return m&n;",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/593317/simple-3-line-java-solution-faster-than-100/",
                "vote_count": "387"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int rangeBitwiseAnd(int left, int right) {\n        int res = right;\n        while(right > left) {\n            res = right & (right-1);\n            right = res;\n        }\n        return res;\n        ",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/593317/simple-3-line-java-solution-faster-than-100/",
                "vote_count": "387"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public int rangeBitwiseAnd(int left, int right) {\n        while (right > left) right &= right - 1;\n        return right;\n    }\n}",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/593317/simple-3-line-java-solution-faster-than-100/",
                "vote_count": "387"
            },
            {
                "language": "cpp",
                "code": "int rangeBitwiseAnd(int m, int n) {\n    return (n > m) ? (rangeBitwiseAnd(m/2, n/2) << 1) : m;\n}",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56746/one-line-c-solution/",
                "vote_count": "274"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int rangeBitwiseAnd(int m, int n) {\n        int trans = 0;\n        while(m != n) \n        {\n            ++ trans;\n            m >>= 1;",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56746/one-line-c-solution/",
                "vote_count": "274"
            },
            {
                "language": "cpp",
                "code": "int rangeBitwiseAnd(int m, int n) {\n    bitset<32> b1(m), b2(n), b3(0);\n    for(int i=31; i>=0; i--)\n        if(b1[i]==b2[i])\n            b3[i] = b1[i];\n        else break;\n    return b3.to_ulong();\n}",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56746/one-line-c-solution/",
                "vote_count": "274"
            },
            {
                "language": "",
                "code": "4 & 7 = 0b100 & 0b111 = 0b100\n5 & 7 = 0b101 & 0b111 = 0b101\n5 & 6 = 0b101 & 0b110 = 0b100",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56719/java-python-easy-solution-with-explanation/",
                "vote_count": "181"
            },
            {
                "language": "csharp",
                "code": "[m = 0bxyz0acd, n=0bxyz1rst]",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56719/java-python-easy-solution-with-explanation/",
                "vote_count": "181"
            },
            {
                "language": "ruby",
                "code": "(1) m' = 0bxyz0111\n(2) n' = 0bxyz1000",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56719/java-python-easy-solution-with-explanation/",
                "vote_count": "181"
            },
            {
                "language": "javascript",
                "code": "rangeBitwiseAnd(m, n) = m' & n' = 0bxyz0000",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56719/java-python-easy-solution-with-explanation/",
                "vote_count": "181"
            },
            {
                "language": "cpp",
                "code": "public int rangeBitwiseAnd(int m, int n) {\n    int i = 0;\n    for (; m != n; ++i) {\n        m >>= 1;\n        n >>= 1;\n    }\n    return n << i;\n}\n\n// 8266 / 8266 test cases passed.\n// Status: Accepted\n// Runtime: 8 ms",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56719/java-python-easy-solution-with-explanation/",
                "vote_count": "181"
            },
            {
                "language": "ruby",
                "code": "def rangeBitwiseAnd(self, m, n):\n    i = 0\n    while m != n:\n        m >>= 1\n        n >>= 1\n        i += 1\n    return n << i\n\n# 8266 / 8266 test cases passed.\n# Status: Accepted\n# Runtime: 208 ms",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56719/java-python-easy-solution-with-explanation/",
                "vote_count": "181"
            },
            {
                "language": "python",
                "code": "def rangeBitwiseAnd(self, m, n):\n    if len(bin(m)) != len(bin(n)): return 0\n    ...",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56719/java-python-easy-solution-with-explanation/",
                "vote_count": "181"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56719/java-python-easy-solution-with-explanation/",
                "vote_count": "181"
            },
            {
                "language": "cpp",
                "code": "public int rangeBitwiseAnd(int m, int n) {\n        int res = 0;\n        for(int i = 31; i >= 0; i--){\n      // ml is the most significant bit of m, nl is the most significant bit of n\n            int ml = (1<<31) & m, nl = (1<<31) & n;\n            if(ml == nl) res += ml==0?0:(1<<i);\n            else return res;\n            m <<= 1;",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/56719/java-python-easy-solution-with-explanation/",
                "vote_count": "181"
            },
            {
                "language": "python",
                "code": "int and=0;\nfor (m;m<=n;m++)\n     {\n  and&=m;\n  }\n  ",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/592288/100-memory-c-solution-with-explanation/",
                "vote_count": "81"
            },
            {
                "language": "cpp",
                "code": "public:\n    int rangeBitwiseAnd(int m, int n) {\n         int count=0;\n       // simple solution is to do bitwise and and return the sum. \n      //     for(int i=m;i<=n;i++)\n      //               sum&=i;        \n   //      return sum;\n        while(m!=n)  // see till both numbers are equal\n        {   // right shift both numbers by 1\n            m>>=1; \n            n>>=1;\n            count++;  // increment the count.\n        }\n  //count gives the number of zero places from the lsb so left shift m by count.\n        return m<<count;\n    }\n   \n   \n   \n  ",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/592288/100-memory-c-solution-with-explanation/",
                "vote_count": "81"
            },
            {
                "language": "lisp",
                "code": "if (m>0) m>>=1;",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/592288/100-memory-c-solution-with-explanation/",
                "vote_count": "81"
            },
            {
                "language": "cpp",
                "code": "int rangeBitwiseAnd(int m, int n) {\n    bitset<32> b1(m), b2(n), b3(0);\n    for(int i=31; i>=0; i--)\n        if(b1[i]==b2[i])\n            b3[i] = b1[i];\n        else break;\n    return b3.to_ulong();\n}",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/592288/100-memory-c-solution-with-explanation/",
                "vote_count": "81"
            },
            {
                "language": "cpp",
                "code": "int rangeBitwiseAnd(int m, int n) {\n    int count=0;\n    for(;m!=n;m>>=1,n>>=1,count++);\n    return m<<count;\n}",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/592288/100-memory-c-solution-with-explanation/",
                "vote_count": "81"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int rangeBitwiseAnd(int m, int n) {\n        // edge case - zero AND anything will always stay zero\n        if ((m == 0) || (n == 0)) return 0;\n        \n        // if there is a different amount of digits in binary - always will be zero\n        if ((int)log2(m) != (int)log2(n)) return 0;\n        \n        // None of the above - not too many numbers left to calculate one by one...\n        int res = m;\n        for (long i = m; i <= n; i++)\n            res &= i;\n                \n        return res;\n    }\n};",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/1513866/c-super-simple-intuitive-explained-solution-different-approach/",
                "vote_count": "52"
            },
            {
                "language": "csharp",
                "code": " // Numbers have the same number of digits\n int partial = pow(2, ndigits - 1);        \n return partial + rangeBitwiseAnd(left & ~partial, right & ~partial);",
                "url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/1513866/c-super-simple-intuitive-explained-solution-different-approach/",
                "vote_count": "52"
            }
        ]
    },
    "177": {
        "question_id": 202,
        "title": "Happy Number",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/happy-number",
        "description": "Write an algorithm to determine if a number n is happy.A happy number is a number defined by the following process:Starting with any positive integer, replace the number by the sum of the squares of its digits.Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.Those numbers for which this process ends in 1 are happy.Return true if n is a happy number, and false if not. ",
        "examples": [
            {
                "input": "n = 19",
                "output": "true\nExplanation:\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1",
                "explanation": null
            },
            {
                "input": "n = 2",
                "output": "false",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= n <= 2^31 - 1"
        ],
        "solutions": [
            {
                "language": "python",
                "code": "int digitSquareSum(int n) {\n    int sum = 0, tmp;\n    while (n) {\n        tmp = n % 10;\n        sum += tmp * tmp;\n        n /= 10;\n    }\n    return sum;\n}\n\nbool isHappy(int n) {\n    int slow, fast;\n    slow = fast = n;\n    do {\n        slow = digitSquareSum(slow);\n        fast = digitSquareSum(fast);\n        fast = digitSquareSum(fast);\n    } while(slow != fast);\n    if (slow == 1) return 1;\n    else return 0;\n}",
                "url": "https://leetcode.com/problems/happy-number/solutions/56917/my-solution-in-c-o-1-space-and-no-magic-math-property-involved/",
                "vote_count": "1976"
            },
            {
                "language": "python",
                "code": "    int digitSquareSum(int n) {\n        int sum = 0, tmp;\n        while (n) {\n            tmp = n % 10;\n            sum += tmp * tmp;\n            n /= 10;",
                "url": "https://leetcode.com/problems/happy-number/solutions/56917/my-solution-in-c-o-1-space-and-no-magic-math-property-involved/",
                "vote_count": "1976"
            },
            {
                "language": "python",
                "code": "  int next(int n)\n    {\n        int res=0;\n        while (n)\n        {\n            int t = n % 10;\n            res += t*t;\n            n/=10;",
                "url": "https://leetcode.com/problems/happy-number/solutions/56917/my-solution-in-c-o-1-space-and-no-magic-math-property-involved/",
                "vote_count": "1976"
            },
            {
                "language": "java",
                "code": "public boolean isHappy(int n) {\n        if(n == 1 || n == 7) return true;\n        else if(n < 10) return false;\n        int m = 0;\n        while(n != 0){\n            int tail = n % 10;\n            m += tail * tail;",
                "url": "https://leetcode.com/problems/happy-number/solutions/56917/my-solution-in-c-o-1-space-and-no-magic-math-property-involved/",
                "vote_count": "1976"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(logN) where N is the number.\n\n    Space Complexity : O(logN), Hash Table(unordered_set(set)) space.\n\n    Solved using Math + Hash Table.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\nprivate:\n    int nextNumber(int n){\n        int newNumber = 0;\n        while(n!=0){\n            int num = n%10;\n            newNumber += num*num;\n            n = n/10;\n        }\n        return newNumber;\n    }\npublic:\n    bool isHappy(int n) {\n        unordered_set<int> set;\n        while(n!=1 && !set.count(n)){\n            set.insert(n);\n            n = nextNumber(n);\n        }\n        return n==1;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(logN) where N is the number.\n\n    Space Complexity : O(1), Constant space.\n\n    Solved using Floyd's Cycle-Finding Algorithm.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\nprivate:\n    int nextNumber(int n){\n        int newNumber = 0;\n        while(n!=0){\n            int num = n%10;\n            newNumber += num*num;\n            n = n/10;\n        }\n        return newNumber;\n    }\npublic:\n    bool isHappy(int n) {\n        int slowPointer = n;\n        int fastPointer = nextNumber(n);\n        while(fastPointer != 1 && fastPointer != slowPointer){\n            slowPointer = nextNumber(slowPointer);\n            fastPointer = nextNumber(nextNumber(fastPointer));\n        }\n        return fastPointer==1;\n    }\n};",
                "url": "https://leetcode.com/problems/happy-number/solutions/3236759/best-c-2-solution-floyd-s-cycle-finding-algorithm-hash-table-one-stop-solution/",
                "vote_count": "58"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean isHappy(int n) {\n        // Create a set to keep track of the numbers that have already been seen\n        Set<Integer> seen = new HashSet<>();\n        \n        // Loop until either n becomes 1 (in which case n is a happy number) or n is seen again (in which case n is not a happy number)\n\n        while (n != 1 && !seen.contains(n)) {\n            // Add n to the set of seen numbers\n            seen.add(n);\n            \n            // Compute the sum of the squares of the digits of n\n            int sum = 0;\n            while (n != 0) {\n                int digit = n % 10;\n                sum += digit * digit;\n                n /= 10;\n            }\n            \n            // Update n with the sum of the squares of its digits\n            \n            n = sum;\n        }\n        \n        // If n is 1, it is a happy number; otherwise, it is not\n        return n == 1;\n    }\n}",
                "url": "https://leetcode.com/problems/happy-number/solutions/3278532/easier-than-you-think-explained/",
                "vote_count": "39"
            }
        ]
    },
    "178": {
        "question_id": 203,
        "title": "Remove Linked List Elements",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/remove-linked-list-elements",
        "description": "Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head. ",
        "examples": [
            {
                "input": "head = [1,2,6,3,4,5,6], val = 6",
                "output": "[1,2,3,4,5]",
                "explanation": null
            },
            {
                "input": "head = [], val = 1",
                "output": "[]",
                "explanation": null
            },
            {
                "input": "head = [7,7,7,7], val = 7",
                "output": "[]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is in the range [0, 10^4].",
            "1 <= Node.val <= 50",
            "0 <= val <= 50"
        ],
        "solutions": [
            {
                "language": "kotlin",
                "code": "public ListNode removeElements(ListNode head, int val) {\n        if (head == null) return null;\n        head.next = removeElements(head.next, val);\n        return head.val == val ? head.next : head;\n}",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/57306/3-line-recursive-solution/",
                "vote_count": "858"
            },
            {
                "language": "kotlin",
                "code": "public ListNode removeElements(ListNode head, int val) {\n    if(head == null) return null;\n    ListNode next = removeElements(head.next, val);\n    if(head.val == val) return next;\n    head.next = next;\n    return head;\n}",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/57306/3-line-recursive-solution/",
                "vote_count": "858"
            },
            {
                "language": "rust",
                "code": "A -> B -> C\n\nDeleting B without setting null to B's next result in \nA -> C \nB -> C\n\nIdeally this should be only",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/57306/3-line-recursive-solution/",
                "vote_count": "858"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy_head = ListNode(-1)\n        dummy_head.next = head\n        \n        current_node = dummy_head\n        while current_node.next != None:\n            if current_node.next.val == val:\n                current_node.next = current_node.next.next\n            else:\n                current_node = current_node.next\n                \n        return dummy_head.next",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/158651/simple-python-solution-with-explanation-single-pointer-dummy-head/",
                "vote_count": "454"
            },
            {
                "language": "ruby",
                "code": "    def removeElements(self, head: ListNode, val: int) -> ListNode:\n        \n        curr_node, prev_node = head, None\n        \n        while curr_node:\n            if curr_node.val == val:\n                # need to delete current node\n                if curr_node == head:",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/158651/simple-python-solution-with-explanation-single-pointer-dummy-head/",
                "vote_count": "454"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\n        cur = head\n        \n        while cur and cur.next:\n            if cur.next.val == val:",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/158651/simple-python-solution-with-explanation-single-pointer-dummy-head/",
                "vote_count": "454"
            },
            {
                "language": "python",
                "code": "'''\nclass ListNode:\n    def __init__(self, val = 0, next = None):\n        self.val = val\n        self.next = next\n'''",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/158651/simple-python-solution-with-explanation-single-pointer-dummy-head/",
                "vote_count": "454"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        if (head == null) {\n            return null;\n        }\n\n        ListNode dummy = new ListNode();\n        dummy.next = head;\n        ListNode cur = dummy;\n\n        while (cur.next != null) {\n            if (cur.next.val == val) {\n                cur.next = cur.next.next;\n                // Here cannot move cur to cur.next as we need to validate the next node.\n            } else {\n                cur = cur.next;\n            }\n        }\n\n        return dummy.next;\n    }\n}",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/1572932/java-three-simple-clean-solutions-w-explanation-iterative-recursive-beats-100/",
                "vote_count": "210"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        if (head == null) {\n            return null;\n        }\n\n        ListNode dummy = new ListNode();\n        dummy.next = head;\n        ListNode cur = head;\n        ListNode prev = dummy;\n\n        while (cur != null) {\n            if (cur.val == val) {\n                prev.next = cur.next;\n            } else {\n                prev = cur;\n            }\n            cur = cur.next;\n        }\n\n        return dummy.next;\n    }\n}",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/1572932/java-three-simple-clean-solutions-w-explanation-iterative-recursive-beats-100/",
                "vote_count": "210"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        if (head == null) {\n            return null;\n        }\n\n        // Once removeElements call is done, right side of the list is solved.\n        ListNode rightSideHead = removeElements(head.next, val);\n        if (head.val == val) {\n            return rightSideHead;\n        }\n        head.next = rightSideHead;\n        return head;\n    }\n}",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/1572932/java-three-simple-clean-solutions-w-explanation-iterative-recursive-beats-100/",
                "vote_count": "210"
            },
            {
                "language": "java",
                "code": "ListNode dummy = new ListNode(0, head);",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/1572932/java-three-simple-clean-solutions-w-explanation-iterative-recursive-beats-100/",
                "vote_count": "210"
            },
            {
                "language": "rust",
                "code": "For eg. let the list be 1 -> 2 -> 1 -> 4  -> 7  -> 1, and T = 1.\n                                                                         // dummy and prev initialized pointing to list head\n 1. -1   \u2192   1   \u2192    2   \u2192   1   \u2192   4   \u2192   7   \u2192   1   \u2192   null       // head == T, update prev pointer to head's next\n   ^dummy    ^head                                                       // and move head to next\n   ^prev\n => Now traverse till head reaches end\n \n     \u21b1    \u2192     \u2192    \u21b4\n 2. -1      1   \u2192    2   \u2192   1   \u2192   4   \u2192   7   \u2192   1   \u2192   null        // head != T, just update prev and move head to next\n ^dummy           ^head                                             \n ^prev\n      \n     \u21b1    \u2192     \u2192    \u21b4\n 3. -1      1   \u2192    2   \u2192   1   \u2192   4   \u2192   7   \u2192   1   \u2192   null        // head == T, update prev pointer to head's next\n ^dummy           ^prev   ^head                                       // and move head to next\n\n     \u21b1    \u2192     \u2192   \u21b4 \u21b1    \u2192     \u2192   \u21b4\n 4. -1      1   \u2192    2       1   \u2192   4   \u2192   7   \u2192   1   \u2192   null        // head != T, just update prev and move head to next\n ^dummy           ^prev           ^head\n \n     \u21b1    \u2192     \u2192   \u21b4 \u21b1    \u2192     \u2192   \u21b4\n 5. -1      1   \u2192    2       1   \u2192   4   \u2192   7   \u2192   1   \u2192   null        // head != T, just update prev and move head to next\n ^dummy                           ^prev   ^head \n \n     \u21b1    \u2192     \u2192   \u21b4 \u21b1    \u2192     \u2192   \u21b4\n 6. -1      1   \u2192    2       1   \u2192   4   \u2192   7   \u2192   1   \u2192   null        // head == T, update prev pointer to head's next\n ^dummy                                   ^prev   ^head           // and move head to next\n \n     \u21b1    \u2192     \u2192   \u21b4 \u21b1    \u2192     \u2192   \u21b4       \u21b1    \u2192     \u2192    \u21b4\n 7. -1      1   \u2192    2       1   \u2192   4   \u2192   7       1   \u2192   null\n ^dummy                                   ^prev            ^head       // Stop iteration as head = null \n \n \nFinal List = dummy -> next\n   \ud83d\udc49  2   ->    4   ->   7   ->   null",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/1572892/c-python-clean-simple-solution-w-explanation-illustration-iterative-recursive/",
                "vote_count": "108"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int T) {\n        ListNode *dummy = new ListNode(-1, head), *prev = dummy;\n        for(;head; head = head -> next) \n            if(head -> val != T) \n                prev = head;                       // just update prev node\n            else                                   // current node needs to be deleted\n    prev -> next = head -> next;       // just update next of prev to next of current so that current node is removed from list\n        return dummy -> next;                     \n    }\n};",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/1572892/c-python-clean-simple-solution-w-explanation-illustration-iterative-recursive/",
                "vote_count": "108"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def removeElements(self, head, T):\n        dummy = ListNode(-1, head)\n        prev = dummy\n        while head:\n            if head.val != T:\n                prev = head\n            else:\n                prev.next = head.next\n            head = head.next\n        return dummy.next",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/1572892/c-python-clean-simple-solution-w-explanation-illustration-iterative-recursive/",
                "vote_count": "108"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int T) {\n        if(!head) return nullptr;\n        head -> next = removeElements(head -> next, T);\n        return head -> val == T ? head -> next : head;\n    }\n};",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/1572892/c-python-clean-simple-solution-w-explanation-illustration-iterative-recursive/",
                "vote_count": "108"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def removeElements(self, head, T):\n        if not head: return None\n        head.next = self.removeElements(head.next, T);\n        return head.next if head.val == T else head",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/1572892/c-python-clean-simple-solution-w-explanation-illustration-iterative-recursive/",
                "vote_count": "108"
            },
            {
                "language": "rust",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        ListNode* dummy = new ListNode;\n        dummy -> next = head;\n        ListNode* curr = dummy;\n        \n        while(curr -> next) {\n            if(curr -> next -> val == val) {\n                curr -> next = curr -> next -> next;\n            } else {\n                curr = curr -> next;\n            }\n        }\n        \n        return dummy -> next;\n    }\n};",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3086104/accepted-easy-solution-short-simple-best-method/",
                "vote_count": "20"
            },
            {
                "language": "kotlin",
                "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        //base case, recursion ends when NULL is reached\n        if (head == NULL) return NULL;\n\n        //the node has to be removed -> it is skipped during the iteration\n        if (head->val == val) return removeElements(head->next, val);\n\n        //the node doesn't have to be skipped -> the rest of the list has \n        //to be joined to the node\n        head->next = removeElements(head->next, val);\n        return head;\n    }\n};",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3136351/c-recursive-approach/",
                "vote_count": "19"
            },
            {
                "language": "ruby",
                "code": "class Solution(object):\n    def removeElements(self, head, val):\n        # First loop\n        while head and head.val == val:\n            head = head.next\n\n        current = head\n\n        # Second loop\n        while current:\n            while current and current.next and current.next.val == val:\n                current.next = current.next.next\n            current = current.next\n        return head",
                "url": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3036500/python-simple-solution-beats-95/",
                "vote_count": "11"
            }
        ]
    },
    "179": {
        "question_id": 204,
        "title": "Count Primes",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/count-primes",
        "description": "Given an integer n, return the number of prime numbers that are strictly less than n. ",
        "examples": [
            {
                "input": "n = 10",
                "output": "4",
                "explanation": "There are 4 prime numbers less than 10, they are 2, 3, 5, 7."
            },
            {
                "input": "n = 0",
                "output": "0",
                "explanation": null
            },
            {
                "input": "n = 1",
                "output": "0",
                "explanation": null
            }
        ],
        "constraints": [
            "0 <= n <= 5 * 10^6"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "public class Solution {\n    public int countPrimes(int n) {\n        boolean[] notPrime = new boolean[n];\n        int count = 0;\n        for (int i = 2; i < n; i++) {\n            if (notPrime[i] == false) {\n                count++;\n                for (int j = 2; i*j < n; j++) {\n                    notPrime[i*j] = true;\n                }\n            }\n        }\n        \n        return count;\n    }\n}",
                "url": "https://leetcode.com/problems/count-primes/solutions/57588/my-simple-java-solution/",
                "vote_count": "702"
            },
            {
                "language": "cpp",
                "code": "public int countPrimes(int n) {\n    if(n <=1 ) return 0;\n    \n    boolean[] notPrime = new boolean[n];        \n    notPrime[0] = true; \n    notPrime[1] = true; \n\n    for(int i = 2; i < Math.sqrt(n); i++){",
                "url": "https://leetcode.com/problems/count-primes/solutions/57588/my-simple-java-solution/",
                "vote_count": "702"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/count-primes/solutions/57588/my-simple-java-solution/",
                "vote_count": "702"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def countPrimes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        not_prime = [False] * n\n        count = 0",
                "url": "https://leetcode.com/problems/count-primes/solutions/57588/my-simple-java-solution/",
                "vote_count": "702"
            },
            {
                "language": "java",
                "code": "  public int countPrimes(int n) {\n        boolean[] notPrime = new boolean[n];\n        int count = 0;\n        for(int i = 2; i < n; i++) {\n            if(!notPrime[i]) {\n                count++;\n                for(int j = i; j <= (n-1) / i; j++) {\n                    int v = i * j;",
                "url": "https://leetcode.com/problems/count-primes/solutions/57588/my-simple-java-solution/",
                "vote_count": "702"
            },
            {
                "language": "dart",
                "code": "var countPrimes = function(n) {\n    let seen = new Uint8Array(n), ans = 0\n    for (let num = 2; num < n; num++) {\n        if (seen[num]) continue\n        ans++\n        for (let mult = num * num; mult < n; mult += num)\n            seen[mult] = 1\n    }\n    return ans\n};",
                "url": "https://leetcode.com/problems/count-primes/solutions/1200796/js-python-java-c-easy-sieve-of-eratosthenes-solution-w-explanation/",
                "vote_count": "146"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def countPrimes(self, n: int) -> int:\n        seen, ans = [0] * n, 0\n        for num in range(2, n):\n            if seen[num]: continue\n            ans += 1\n            seen[num*num:n:num] = [1] * ((n - 1) // num - num + 1)\n        return ans",
                "url": "https://leetcode.com/problems/count-primes/solutions/1200796/js-python-java-c-easy-sieve-of-eratosthenes-solution-w-explanation/",
                "vote_count": "146"
            },
            {
                "language": "dart",
                "code": "class Solution {\n    public int countPrimes(int n) {\n        boolean[] seen = new boolean[n];\n        int ans = 0;\n        for (int num = 2; num < n; num++) {\n            if (seen[num]) continue;\n            ans += 1;\n            for (long mult = (long)num * num; mult < n; mult += num)\n                seen[(int)mult] = true;\n        }\n        return ans;\n    }\n}",
                "url": "https://leetcode.com/problems/count-primes/solutions/1200796/js-python-java-c-easy-sieve-of-eratosthenes-solution-w-explanation/",
                "vote_count": "146"
            },
            {
                "language": "dart",
                "code": "class Solution {\npublic:\n    int countPrimes(int n) {\n        vector<bool> seen(n, false);\n        int ans = 0;\n        for (int num = 2; num < n; num++) {\n            if (seen[num]) continue;\n            ans++;\n            for (long mult = (long)num * num; mult < n; mult += num)\n                seen[mult] = true;\n        }\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/count-primes/solutions/1200796/js-python-java-c-easy-sieve-of-eratosthenes-solution-w-explanation/",
                "vote_count": "146"
            },
            {
                "language": "javascript",
                "code": "// Seive of Eratosthenes\n// Time - O(nloglogn) is standard but some articles says with below optimization, i.e, i<=rootN\n// complexity is O(sqrt(n)loglogn)\n// Space - O(n)\n\n/**\n * @param {number} n\n * @return {number}",
                "url": "https://leetcode.com/problems/count-primes/solutions/1200796/js-python-java-c-easy-sieve-of-eratosthenes-solution-w-explanation/",
                "vote_count": "146"
            },
            {
                "language": "cpp",
                "code": "    int ans = 0;\n    \n    vector<int> v(n,0);",
                "url": "https://leetcode.com/problems/count-primes/solutions/1200796/js-python-java-c-easy-sieve-of-eratosthenes-solution-w-explanation/",
                "vote_count": "146"
            },
            {
                "language": "kotlin",
                "code": "if seen[num]: continue",
                "url": "https://leetcode.com/problems/count-primes/solutions/1200796/js-python-java-c-easy-sieve-of-eratosthenes-solution-w-explanation/",
                "vote_count": "146"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int countPrimes(int n) {\n        if(n<2){\n            return 0 ;\n        }\n        boolean isPrime[] = new boolean[n+1];\n        Arrays.fill(isPrime , true);  \n        isPrime[0] = false;\n        isPrime[1] = false;\n        for(int i=2 ; i*i<=n ; i++){\n            for(int j = 2*i;j<=n;j+=i){\n                isPrime[j] = false;\n            }\n        }\n        int count=0;\n        for(int i=0;i<n;i++){\n            if(isPrime[i]==true){\n                count++;\n            }\n        }\n        return count;\n    }\n}\n        ",
                "url": "https://leetcode.com/problems/count-primes/solutions/3131126/explained-sieve-of-eratosthenes-algorithm-code-in-java/",
                "vote_count": "26"
            }
        ]
    },
    "180": {
        "question_id": 205,
        "title": "Isomorphic Strings",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/isomorphic-strings",
        "description": "Given two strings s and t, determine if they are isomorphic.Two strings s and t are isomorphic if the characters in s can be replaced to get t.All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself. ",
        "examples": [
            {
                "input": "s = \"egg\", t = \"add\"",
                "output": "true",
                "explanation": null
            },
            {
                "input": "s = \"paper\", t = \"title\"",
                "output": "true",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= s.length <= 5 * 10^4",
            "t.length == s.length",
            "s and t consist of any valid ascii character."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "// Runtime: 3 ms, faster than 94.17% of Java online submissions for Isomorphic Strings.\n// Memory Usage: 42.1 MB, less than 95.61% of Java online submissions for Isomorphic Strings.\n// Time Complexity : O(n)\nclass Solution {\n    public boolean isIsomorphic(String s, String t) {\n        // Base case: for different length of two strings...\n        if(s.length() != t.length())\n            return false;\n        // Create two maps for s & t strings...\n        int[] map1 = new int[256];\n        int[] map2 = new int[256];\n        // Traverse all elements through the loop...\n        for(int idx = 0; idx < s.length(); idx++){\n            // Compare the maps, if not equal, return false...\n            if(map1[s.charAt(idx)] != map2[t.charAt(idx)])\n                return false;\n            // Insert each character if string s and t into seperate map...\n            map1[s.charAt(idx)] = idx + 1;\n            map2[t.charAt(idx)] = idx + 1;\n        }\n        return true;    // Otherwise return true...\n    }\n}",
                "url": "https://leetcode.com/problems/isomorphic-strings/solutions/2472118/very-easy-100-fully-explained-java-c-python-javascript-python3-using-hashmap/",
                "vote_count": "190"
            },
            {
                "language": "cpp",
                "code": "// Time Complexity : O(n)\n// Space Complexity : O(1)\nclass Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        // Use hashmaps to save the replacement for every character in the first string...\n        unordered_map <char , char> rep;\n        unordered_map <char , bool> used;\n        // Traverse all elements through the loop...\n        for(int idx = 0 ; idx < s.length() ; idx++) {\n            // If rep contains s[idx] as a key...\n            if(rep.count(s[idx])) {\n                // Check if the rep is same as the character in the other string...\n                // If not, the strings can\u2019t be isomorphic. So, return false...\n                if(rep[s[idx]] != t[idx])\n                    return false;\n            }\n            // If no replacement found for first character, check if the second character has been used as the replacement for any other character in the first string...\n            else {\n                if(used[t[idx]])\n                    return false;\n                // If there exists no character whose replacement is the second character...\n                // Assign the second character as the replacement of the first character.\n                rep[s[idx]] = t[idx];\n                used[t[idx]] = true;\n            }\n        }\n        // Otherwise, the strings are not isomorphic.\n        return true;\n    }\n};",
                "url": "https://leetcode.com/problems/isomorphic-strings/solutions/2472118/very-easy-100-fully-explained-java-c-python-javascript-python3-using-hashmap/",
                "vote_count": "190"
            },
            {
                "language": "python",
                "code": "# Time Complexity : O(n)\nclass Solution(object):\n    def isIsomorphic(self, s, t):\n        map1 = []\n        map2 = []\n        for idx in s:\n            map1.append(s.index(idx))\n        for idx in t:\n            map2.append(t.index(idx))\n        if map1 == map2:\n            return True\n        return False",
                "url": "https://leetcode.com/problems/isomorphic-strings/solutions/2472118/very-easy-100-fully-explained-java-c-python-javascript-python3-using-hashmap/",
                "vote_count": "190"
            },
            {
                "language": "javascript",
                "code": "// Runtime: 83 ms, faster than 88.18% of JavaScript online submissions for Isomorphic Strings.\n// Time Complexity : O(n)\nvar isIsomorphic = function(s, t) {\n    // Base case: for different length of two strings...\n    if(s.length != t.length)\n        return false;\n    // Create two maps for s & t strings...\n    const map1 = [256];\n    const map2 = [256];\n    // Traverse all elements through the loop...\n    for(let idx = 0; idx < s.length; idx++){\n        // Compare the maps, if not equal, return false...\n        if(map1[s.charAt(idx)] != map2[t.charAt(idx)])\n            return false;\n        // Insert each character if string s and t into seperate map...\n        map1[s.charAt(idx)] = idx + 1;\n        map2[t.charAt(idx)] = idx + 1;\n    }\n    return true;    // Otherwise return true...\n};",
                "url": "https://leetcode.com/problems/isomorphic-strings/solutions/2472118/very-easy-100-fully-explained-java-c-python-javascript-python3-using-hashmap/",
                "vote_count": "190"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        return [*map(s.index, s)] == [*map(t.index, t)]",
                "url": "https://leetcode.com/problems/isomorphic-strings/solutions/2472118/very-easy-100-fully-explained-java-c-python-javascript-python3-using-hashmap/",
                "vote_count": "190"
            },
            {
                "language": "lisp",
                "code": "if(map1[s.charAt(idx)] != map2[t.charAt(idx)])",
                "url": "https://leetcode.com/problems/isomorphic-strings/solutions/2472118/very-easy-100-fully-explained-java-c-python-javascript-python3-using-hashmap/",
                "vote_count": "190"
            },
            {
                "language": "cpp",
                "code": "public boolean isIsomorphic(String s, String t) {\n    \n    if(s.length() != t.length())\n        return false;\n    \n    int[] arrS = new int[256];\n    int[] arrT = new int[256];\n   ",
                "url": "https://leetcode.com/problems/isomorphic-strings/solutions/2472118/very-easy-100-fully-explained-java-c-python-javascript-python3-using-hashmap/",
                "vote_count": "190"
            },
            {
                "language": "go",
                "code": "        map1.append(s.index(idx))",
                "url": "https://leetcode.com/problems/isomorphic-strings/solutions/2472118/very-easy-100-fully-explained-java-c-python-javascript-python3-using-hashmap/",
                "vote_count": "190"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    public boolean isIsomorphic(String s, String t) {\n\n        int map1[]=new int[200];\n        int map2[]=new int[200];\n\n        if(s.length()!=t.length())\n            return false;\n\n\n        for(int i=0;i<s.length();i++)\n        {\n            if(map1[s.charAt(i)]!=map2[t.charAt(i)])\n                return false;\n\n            map1[s.charAt(i)]=i+1;\n            map2[t.charAt(i)]=i+1;\n        }\n        return true;\n    }\n}",
                "url": "https://leetcode.com/problems/isomorphic-strings/solutions/3171737/well-explained-simple-java-runtime-1-ms-beats-94-7/",
                "vote_count": "158"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        return len(set(s))==len(set(zip(s,t)))==len(set(t))",
                "url": "https://leetcode.com/problems/isomorphic-strings/solutions/2701544/1-line-python-4-line-java-8-line-c-beats98/",
                "vote_count": "82"
            },
            {
                "language": "typescript",
                "code": "class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        Map m = new HashMap();\n        for (Integer i=0; i<s.length(); ++i)\n   if (m.put(s.charAt(i), i) != m.put(t.charAt(i)+\"\", i)) return false;\n        return true;\n    }\n}",
                "url": "https://leetcode.com/problems/isomorphic-strings/solutions/2701544/1-line-python-4-line-java-8-line-c-beats98/",
                "vote_count": "82"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        unordered_map<char, char> m1, m2;\n        for (int i = 0; i < s.size(); i++) {\n            if (!m1.count(s[i]) && !m2.count(t[i]))\n                m1[s[i]] = t[i];m2[t[i]] = s[i];\n             else \n     if (m1[s[i]] != t[i] || m2[t[i]] != s[i])  return false;\n        }\n        return true;\n    }\n};",
                "url": "https://leetcode.com/problems/isomorphic-strings/solutions/2701544/1-line-python-4-line-java-8-line-c-beats98/",
                "vote_count": "82"
            },
            {
                "language": "cpp",
                "code": "    unordered_map<char, char> map1, map2;\n\n    for(int i = 0; i < wordLength; i++)",
                "url": "https://leetcode.com/problems/isomorphic-strings/solutions/2701544/1-line-python-4-line-java-8-line-c-beats98/",
                "vote_count": "82"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n         unordered_map<char, char> mp, mp2;\n        for (int i=0; i<s.length(); ++i) {\n            if (mp[s[i]] && mp[s[i]]!=t[i]) return false;\n            if (mp2[t[i]] && mp2[t[i]]!=s[i]) return false;\n            mp[s[i]]=t[i];\n            mp2[t[i]]=s[i];\n        }\n        return true;\n    }\n};",
                "url": "https://leetcode.com/problems/isomorphic-strings/solutions/3007803/super-easy-solution-c-hashtable/",
                "vote_count": "66"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n         int m1[256] = {0}, m2[256] = {0}, n = s.size();\n        for (int i = 0; i < n; ++i) {\n            if (m1[s[i]] != m2[t[i]]) return false;\n            m1[s[i]] = i + 1;\n            m2[t[i]] = i + 1;\n        }\n        return true;\n    }\n};",
                "url": "https://leetcode.com/problems/isomorphic-strings/solutions/3117123/accepted-short-simple-best-method-easy-to-understand/",
                "vote_count": "20"
            },
            {
                "language": "kotlin",
                "code": "class Solution:\n  def isIsomorphic(self, s: str, t: str) -> bool:\n    if len(s) != len(t):\n        return False\n        \n    s_to_t = {}\n    t_to_s = {}\n    for i in range(len(s)):\n        if s[i] not in s_to_t and t[i] not in t_to_s:\n            s_to_t[s[i]] = t[i]\n            t_to_s[t[i]] = s[i]\n        elif s[i] in s_to_t and s_to_t[s[i]] == t[i]:\n            continue\n        else:\n            return False\n            \n    return True",
                "url": "https://leetcode.com/problems/isomorphic-strings/solutions/3223161/205-solution-with-step-by-step-explanation/",
                "vote_count": "10"
            }
        ]
    },
    "181": {
        "question_id": 206,
        "title": "Reverse Linked List",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/reverse-linked-list",
        "description": "Given the head of a singly linked list, reverse the list, and return the reversed list. ",
        "examples": [
            {
                "input": "head = [1,2,3,4,5]",
                "output": "[5,4,3,2,1]",
                "explanation": null
            },
            {
                "input": "head = [1,2]",
                "output": "[2,1]",
                "explanation": null
            },
            {
                "input": "head = []",
                "output": "[]",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the list is the range [0, 5000].",
            "-5000 <= Node.val <= 5000"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode *nextNode, *prevNode = NULL;\n        while (head) {\n            nextNode = head->next;\n            head->next = prevNode;\n            prevNode = head;\n            head = nextNode;\n        }\n        return prevNode;\n    }\n};",
                "url": "https://leetcode.com/problems/reverse-linked-list/solutions/803955/c-iterative-vs-recursive-solutions-compared-and-explained-99-time-85-space/",
                "vote_count": "644"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode *head, ListNode *nextNode = NULL, ListNode *prevNode = NULL) {\n        return head ? reverseList(head->next, (head->next = prevNode, nextNode), head) : prevNode;\n    }\n};",
                "url": "https://leetcode.com/problems/reverse-linked-list/solutions/803955/c-iterative-vs-recursive-solutions-compared-and-explained-99-time-85-space/",
                "vote_count": "644"
            },
            {
                "language": "javascript",
                "code": "ListNode* reverseList(ListNode* head, ListNode* prev = nullptr) {\n    return head ? reverseList(head->next, (head->next = prev, head)) : prev;\n}",
                "url": "https://leetcode.com/problems/reverse-linked-list/solutions/803955/c-iterative-vs-recursive-solutions-compared-and-explained-99-time-85-space/",
                "vote_count": "644"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;  \n        ListNode current = head;\n    \n        \n        while(current != null) { \n            ListNode next = current.next; \n            current.next = prev;\n            prev = current;\n            current = next;\n        }\n       return prev; \n    }\n}",
                "url": "https://leetcode.com/problems/reverse-linked-list/solutions/2682085/java-0ms-100-easy-understanding/",
                "vote_count": "366"
            },
            {
                "language": "kotlin",
                "code": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        // Special case...\n        if (head == null || head.next == null) return head;\n        // Create a new node to call the function recursively and we get the reverse linked list...\n        ListNode res = reverseList(head.next);\n        // Set head node as head.next.next...\n        head.next.next = head;\n        //set head's next to be null...\n        head.next = null;\n        return res;     // Return the reverse linked list...\n    }\n}",
                "url": "https://leetcode.com/problems/reverse-linked-list/solutions/2458632/easy-0-ms-100-fully-explained-java-c-python-js-c-python3-recursive-iterative/",
                "vote_count": "197"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        // Special case...\n        if(head == NULL || head->next == NULL)  return head;\n        // Initialize prev pointer as the head...\n        ListNode* prev = head;\n        // Initialize curr pointer as the next pointer of prev...\n        ListNode* curr = prev->next;\n        // Initialize next of head pointer as NULL...\n        head->next = NULL;\n        // Run a loop till curr and prev points to NULL...\n        while(prev != NULL && curr != NULL){\n            // Initialize next pointer as the next pointer of curr...\n            ListNode* next = curr->next;\n            // Now assign the prev pointer to curr\u2019s next pointer.\n            curr->next = prev;\n            // Assign curr to prev, next to curr...\n            prev = curr;\n            curr = next;\n        }\n        return prev;    // Return the prev pointer to get the reverse linked list...\n    }\n};",
                "url": "https://leetcode.com/problems/reverse-linked-list/solutions/2458632/easy-0-ms-100-fully-explained-java-c-python-js-c-python3-recursive-iterative/",
                "vote_count": "197"
            },
            {
                "language": "ruby",
                "code": "class Solution(object):\n    def reverseList(self, head):\n        # Initialize prev pointer as NULL...\n        prev = None\n        # Initialize the curr pointer as the head...\n        curr = head\n        # Run a loop till curr points to NULL...\n        while curr:\n            # Initialize next pointer as the next pointer of curr...\n            next = curr.next\n            # Now assign the prev pointer to curr\u2019s next pointer.\n            curr.next = prev\n            # Assign curr to prev, next to curr...\n            prev = curr\n            curr = next\n        return prev       # Return the prev pointer to get the reverse linked list...",
                "url": "https://leetcode.com/problems/reverse-linked-list/solutions/2458632/easy-0-ms-100-fully-explained-java-c-python-js-c-python3-recursive-iterative/",
                "vote_count": "197"
            },
            {
                "language": "javascript",
                "code": "var reverseList = function(head) {\n    // Special case...\n    if (head == null || head.next == null) return head;\n    // Create a new node to call the function recursively and we get the reverse linked list...\n    var res = reverseList(head.next);\n    // Set head node as head.next.next...\n    head.next.next = head;\n    //set head's next to be null...\n    head.next = null;\n    return res;     // Return the reverse linked list...\n};",
                "url": "https://leetcode.com/problems/reverse-linked-list/solutions/2458632/easy-0-ms-100-fully-explained-java-c-python-js-c-python3-recursive-iterative/",
                "vote_count": "197"
            },
            {
                "language": "cpp",
                "code": "struct ListNode* reverseList(struct ListNode* head){\n    // Special case...\n    if(head == NULL || head->next == NULL)  return head;\n    // Initialize prev pointer as the head...\n    struct ListNode* prev = head;\n    // Initialize curr pointer as the next pointer of prev...\n    struct ListNode* curr = prev->next;\n    // Initialize next of head pointer as NULL...\n    head->next = NULL;\n    // Run a loop till curr and prev points to NULL...\n    while(prev != NULL && curr != NULL){\n        // Initialize next pointer as the next pointer of curr...\n        struct ListNode* next = curr->next;\n        // Now assign the prev pointer to curr\u2019s next pointer.\n        curr->next = prev;\n        // Assign curr to prev, next to curr...\n        prev = curr;\n        curr = next;\n    }\n    return prev;    // Return the prev pointer to get the reverse linked list...\n}",
                "url": "https://leetcode.com/problems/reverse-linked-list/solutions/2458632/easy-0-ms-100-fully-explained-java-c-python-js-c-python3-recursive-iterative/",
                "vote_count": "197"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # Initialize prev pointer as NULL...\n        prev = None\n        # Initialize the curr pointer as the head...\n        curr = head\n        # Run a loop till curr points to NULL...\n        while curr:\n            # Initialize next pointer as the next pointer of curr...\n            next = curr.next\n            # Now assign the prev pointer to curr\u2019s next pointer.\n            curr.next = prev\n            # Assign curr to prev, next to curr...\n            prev = curr\n            curr = next\n        return prev       # Return the prev pointer to get the reverse linked list...",
                "url": "https://leetcode.com/problems/reverse-linked-list/solutions/2458632/easy-0-ms-100-fully-explained-java-c-python-js-c-python3-recursive-iterative/",
                "vote_count": "197"
            },
            {
                "language": "javascript",
                "code": "var reverseList = function(head, prev = null) {\n    if (!head) return prev;\n    let next = head.next;\n    head.next = prev;\n    return reverseList(next, head);\n};",
                "url": "https://leetcode.com/problems/reverse-linked-list/solutions/2458632/easy-0-ms-100-fully-explained-java-c-python-js-c-python3-recursive-iterative/",
                "vote_count": "197"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n\n        ListNode* prev = NULL;\n        ListNode* curr = head;\n\n        while(curr != NULL){\n            ListNode* forward = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = forward;\n            \n        }\n        return prev;\n    }\n};",
                "url": "https://leetcode.com/problems/reverse-linked-list/solutions/3211778/using-2-methods-iterative-recursive-beats-97-91/",
                "vote_count": "137"
            },
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if(head == NULL || head->next == NULL) return head;\n        ListNode* prev = NULL;\n        ListNode* h2 = reverseList(head->next);\n        head->next->next = head;\n        head->next=prev;\n        return h2;\n    }\n\n};",
                "url": "https://leetcode.com/problems/reverse-linked-list/solutions/3211778/using-2-methods-iterative-recursive-beats-97-91/",
                "vote_count": "137"
            }
        ]
    },
    "182": {
        "question_id": 207,
        "title": "Course Schedule",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/course-schedule",
        "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.Return true if you can finish all courses. Otherwise, return false. ",
        "examples": [
            {
                "input": "numCourses = 2, prerequisites = [[1,0]]",
                "output": "true",
                "explanation": "There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible."
            },
            {
                "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
                "output": "false",
                "explanation": "There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible."
            }
        ],
        "constraints": [
            "1 <= numCourses <= 2000",
            "0 <= prerequisites.length <= 5000",
            "prerequisites[i].length == 2",
            "0 <= ai, bi < numCourses",
            "All the pairs prerequisites[i] are unique."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool canFinish(int numCourses, vector<pair<int, int>>& prerequisites) {\n        graph g = buildGraph(numCourses, prerequisites);\n        vector<int> degrees = computeIndegrees(g);\n        for (int i = 0; i < numCourses; i++) {\n            int j = 0;\n            for (; j < numCourses; j++) {\n                if (!degrees[j]) {\n                    break;\n                }\n            }\n            if (j == numCourses) {\n                return false;\n            }\n            degrees[j]--;\n            for (int v : g[j]) {\n                degrees[v]--;\n            }\n        }\n        return true;\n    }\nprivate:\n    typedef vector<vector<int>> graph;\n    \n    graph buildGraph(int numCourses, vector<pair<int, int>>& prerequisites) {\n        graph g(numCourses);\n        for (auto p : prerequisites) {\n            g[p.second].push_back(p.first);\n        }\n        return g;\n    }\n    \n    vector<int> computeIndegrees(graph& g) {\n        vector<int> degrees(g.size(), 0);\n        for (auto adj : g) {\n            for (int v : adj) {\n                degrees[v]++;\n            }\n        }\n        return degrees;\n    }\n};",
                "url": "https://leetcode.com/problems/course-schedule/solutions/58509/c-bfs-dfs/",
                "vote_count": "585"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool canFinish(int numCourses, vector<pair<int, int>>& prerequisites) {\n        graph g = buildGraph(numCourses, prerequisites);\n        vector<bool> todo(numCourses, false), done(numCourses, false);\n        for (int i = 0; i < numCourses; i++) {\n            if (!done[i] && !acyclic(g, todo, done, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\nprivate:\n    typedef vector<vector<int>> graph;\n    \n    graph buildGraph(int numCourses, vector<pair<int, int>>& prerequisites) {\n        graph g(numCourses);\n        for (auto p : prerequisites) {\n            g[p.second].push_back(p.first);\n        }\n        return g;\n    }\n    \n    bool acyclic(graph& g, vector<bool>& todo, vector<bool>& done, int node) {\n        if (todo[node]) {\n            return false;\n        }\n        if (done[node]) {\n            return true;\n        }\n        todo[node] = done[node] = true;\n        for (int v : g[node]) {\n            if (!acyclic(g, todo, done, v)) {\n                return false;\n            }\n        }\n        todo[node] = false;\n        return true;\n    }\n};",
                "url": "https://leetcode.com/problems/course-schedule/solutions/58509/c-bfs-dfs/",
                "vote_count": "585"
            },
            {
                "language": "cpp",
                "code": "bool canFinish(int n, vector<pair<int, int>>& pre) {\n    vector<vector<int>> adj(n, vector<int>());\n    vector<int> degree(n, 0);\n    for (auto &p: pre) {\n        adj[p.second].push_back(p.first);\n        degree[p.first]++;\n    }\n    queue<int> q;",
                "url": "https://leetcode.com/problems/course-schedule/solutions/58509/c-bfs-dfs/",
                "vote_count": "585"
            },
            {
                "language": "cpp",
                "code": "    // mapping: current course -> required courses\n    unordered_map<int, vector<int>> G;\n    vector<bool> visited;\n    vector<bool> onPath;\n    bool hasCircle = false;\n    ",
                "url": "https://leetcode.com/problems/course-schedule/solutions/58509/c-bfs-dfs/",
                "vote_count": "585"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public boolean canFinish(int n, int[][] req) {\n        // corner case\n        if (req == null) {\n            return false;\n        }\n        ",
                "url": "https://leetcode.com/problems/course-schedule/solutions/58509/c-bfs-dfs/",
                "vote_count": "585"
            },
            {
                "language": "cpp",
                "code": " bool dfs_cycle(vector<unordered_set<int>>& graph, int node, vector<bool>& onpath, vector<bool>& visited) {\n        if (visited[node]) return false;",
                "url": "https://leetcode.com/problems/course-schedule/solutions/58509/c-bfs-dfs/",
                "vote_count": "585"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int>color;\n    bool cycle(int v, vector<vector<int>>& adj) {\n        color[v] = 1;\n        for(int i: adj[v]){\n            if(color[i] == 0){\n                if(cycle(i,adj)){",
                "url": "https://leetcode.com/problems/course-schedule/solutions/58509/c-bfs-dfs/",
                "vote_count": "585"
            },
            {
                "language": "csharp",
                "code": "    public boolean canFinish(int n, int[][] prerequisites) {\n        ArrayList<Integer>[] G = new ArrayList[n];\n        int[] degree = new int[n];\n        ArrayList<Integer> bfs = new ArrayList();\n        for (int i = 0; i < n; ++i) G[i] = new ArrayList<Integer>();\n        for (int[] e : prerequisites) {\n            G[e[1]].add(e[0]);\n            degree[e[0]]++;\n        }\n        for (int i = 0; i < n; ++i) if (degree[i] == 0) bfs.add(i);\n        for (int i = 0; i < bfs.size(); ++i)\n            for (int j: G[bfs.get(i)])\n                if (--degree[j] == 0) bfs.add(j);\n        return bfs.size() == n;\n    }",
                "url": "https://leetcode.com/problems/course-schedule/solutions/162743/java-c-python-bfs-topological-sorting-o-n-e/",
                "vote_count": "381"
            },
            {
                "language": "cpp",
                "code": "    bool canFinish(int n, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> G(n);\n        vector<int> degree(n, 0), bfs;\n        for (auto& e : prerequisites)\n            G[e[1]].push_back(e[0]), degree[e[0]]++;\n        for (int i = 0; i < n; ++i) if (!degree[i]) bfs.push_back(i);\n        for (int i = 0; i < bfs.size(); ++i)\n            for (int j: G[bfs[i]])\n                if (--degree[j] == 0) bfs.push_back(j);\n        return bfs.size() == n;\n    }",
                "url": "https://leetcode.com/problems/course-schedule/solutions/162743/java-c-python-bfs-topological-sorting-o-n-e/",
                "vote_count": "381"
            },
            {
                "language": "rust",
                "code": "    def canFinish(self, n, prerequisites):\n        G = [[] for i in range(n)]\n        degree = [0] * n\n        for j, i in prerequisites:\n            G[i].append(j)\n            degree[j] += 1\n        bfs = [i for i in range(n) if degree[i] == 0]\n        for i in bfs:\n            for j in G[i]:\n                degree[j] -= 1\n                if degree[j] == 0:\n                    bfs.append(j)\n        return len(bfs) == n",
                "url": "https://leetcode.com/problems/course-schedule/solutions/162743/java-c-python-bfs-topological-sorting-o-n-e/",
                "vote_count": "381"
            },
            {
                "language": "java",
                "code": "import collections\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        edges = [[] for i in range(numCourses)]\n        degrees = [0] * numCourses\n        for course, pre_course in prerequisites:\n            edges[pre_course].append(course)\n            degrees[course] += 1",
                "url": "https://leetcode.com/problems/course-schedule/solutions/162743/java-c-python-bfs-topological-sorting-o-n-e/",
                "vote_count": "381"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/course-schedule/solutions/162743/java-c-python-bfs-topological-sorting-o-n-e/",
                "vote_count": "381"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/course-schedule/solutions/162743/java-c-python-bfs-topological-sorting-o-n-e/",
                "vote_count": "381"
            },
            {
                "language": "cpp",
                "code": "  int n = numCourses;\n  ArrayList<Integer>[] G = new ArrayList[n];\n  int[] degree = new int[n];\n  Queue<Integer> queue = new LinkedList<>();\n  for (int i = 0; i < n; i++) {\n    G[i] = new ArrayList<Integer>();\n  }\n  for (int[] e : prerequisites) {\n    G[e[1]].add(e[0]);",
                "url": "https://leetcode.com/problems/course-schedule/solutions/162743/java-c-python-bfs-topological-sorting-o-n-e/",
                "vote_count": "381"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    # Algorithm: BFS Topological Sorting\n    # Time: O(E + V)\n    # Space: O(E + V)\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0, ] * numCourses\n        for to_, from_ in prerequisites:",
                "url": "https://leetcode.com/problems/course-schedule/solutions/162743/java-c-python-bfs-topological-sorting-o-n-e/",
                "vote_count": "381"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def canFinish(self, n: int, prerequisites: List[List[int]]) -> bool:\n        \n        then = [[] for _ in range(n)]\n        # or then = collections.defaultdict(list), identical\n        need = [0 for _ in range(n)]\n        ",
                "url": "https://leetcode.com/problems/course-schedule/solutions/162743/java-c-python-bfs-topological-sorting-o-n-e/",
                "vote_count": "381"
            },
            {
                "language": "cpp",
                "code": "bool iscycle(vector<int> adj[],vector<int> &vis,int id){\n        if(vis[id]==1)\n            return true;\n        if(vis[id]==0){\n            vis[id]=1;\n            for(auto edge : adj[id]){\n                if(iscycle(adj,vis,edge))\n                    return true;\n            }\n        }\n        vis[id] = 2;\n        return false;\n    }\n    bool canFinish(int n, vector<vector<int>>& pre) {\n        vector<int> adj[n];\n        for(auto edge : pre)\n            adj[edge[1]].push_back(edge[0]);\n        vector<int> vis(n,0);\n        \n        for(int i=0;i<n;i++){\n            if(iscycle(adj,vis,i))\n                return false;\n        }\n        return true;\n    }",
                "url": "https://leetcode.com/problems/course-schedule/solutions/658275/c-dfs-easiest-solution-with-explanation-my-1st-approach/",
                "vote_count": "334"
            },
            {
                "language": "cpp",
                "code": "vector<int> adj[n];",
                "url": "https://leetcode.com/problems/course-schedule/solutions/658275/c-dfs-easiest-solution-with-explanation-my-1st-approach/",
                "vote_count": "334"
            },
            {
                "language": "cpp",
                "code": "class Solution {\n    using vi  = vector<int>;\npublic:\n    template <typename Tmp, typename Tv>\n    bool iscycle(Tmp& adj, Tv& vis, int id){\n        if (vis[id] == 1) return true;\n        if (vis[id] == 0) {\n            vis[id]=1;",
                "url": "https://leetcode.com/problems/course-schedule/solutions/658275/c-dfs-easiest-solution-with-explanation-my-1st-approach/",
                "vote_count": "334"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/course-schedule/solutions/658275/c-dfs-easiest-solution-with-explanation-my-1st-approach/",
                "vote_count": "334"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/course-schedule/solutions/658275/c-dfs-easiest-solution-with-explanation-my-1st-approach/",
                "vote_count": "334"
            },
            {
                "language": "python",
                "code": "def buildAdjacencyList(self, n, edgesList):\n        adjList = [[] for _ in range(n)]\n        # c2 (course 2) is a prerequisite of c1 (course 1)\n        # i.e c2c1 is a directed edge in the graph\n        for c1, c2 in edgesList:\n            adjList[c2].append(c1)\n        return adjList",
                "url": "https://leetcode.com/problems/course-schedule/solutions/441722/python-99-time-and-100-space-collection-of-solutions-with-explanation/",
                "vote_count": "323"
            },
            {
                "language": "ruby",
                "code": "    class Solution:\n     def buildAdjacencyList(self, n, edgesList):\n      ...\n      \n        def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n            # build Adjacency list from Edges list\n            adjList = self.buildAdjacencyList(numCourses, prerequisites)\n    \n            # Each vertex can have 3 different states:\n            # state 0   : vertex is not visited. It's a default state.\n            # state -1  : vertex is being processed. Either all of its descendants\n            #             are not processed or it's still in the function call stack.\n            # state 1   : vertex and all its descendants are processed.\n            state = [0] * numCourses\n    \n            def hasCycle(v):\n                if state[v] == 1:\n                    # This vertex is processed so we pass.\n                    return False\n                if state[v] == -1:\n                    # This vertex is being processed and it means we have a cycle.\n                    return True\n    \n                # Set state to -1\n                state[v] = -1\n    \n                for i in adjList[v]:\n                    if hasCycle(i):\n                        return True\n    \n                state[v] = 1\n                return False\n    \n            # we traverse each vertex using DFS, if we find a cycle, stop and return\n            for v in range(numCourses):\n                if hasCycle(v):\n                    return False\n    \n            return True",
                "url": "https://leetcode.com/problems/course-schedule/solutions/441722/python-99-time-and-100-space-collection-of-solutions-with-explanation/",
                "vote_count": "323"
            },
            {
                "language": "java",
                "code": "    42/42 cases passed (96 ms)\n    Your runtime beats 96.91 % of python3 submissions\n    Your memory usage beats 65.31 % of python3 submissions (15.4 MB)",
                "url": "https://leetcode.com/problems/course-schedule/solutions/441722/python-99-time-and-100-space-collection-of-solutions-with-explanation/",
                "vote_count": "323"
            },
            {
                "language": "ruby",
                "code": "    class Solution:\n        def buildAdjacencyList(self, n, edgesList):\n            ...\n    \n        def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n            # build Adjacency list from Edges list\n            adjList = self.buildAdjacencyList(numCourses, prerequisites)\n            visited = set()\n    \n            def hasCycle(v, stack):\n                if v in visited:\n                    if v in stack:\n                        # This vertex is being processed and it means we have a cycle.\n                        return True\n                    # This vertex is processed so we pass\n                    return False\n    \n                # mark this vertex as visited\n                visited.add(v)\n                # add it to the current stack\n                stack.append(v)\n    \n                for i in adjList[v]:\n                    if hasCycle(i, stack):\n                        return True\n    \n                # once processed, we pop it out of the stack\n                stack.pop()\n                return False\n    \n            # we traverse each vertex using DFS, if we find a cycle, stop and return\n            for v in range(numCourses):\n                if hasCycle(v, []):\n                    return False\n    \n            return True",
                "url": "https://leetcode.com/problems/course-schedule/solutions/441722/python-99-time-and-100-space-collection-of-solutions-with-explanation/",
                "vote_count": "323"
            },
            {
                "language": "java",
                "code": "    42/42 cases passed (100 ms)\n    Your runtime beats 92.65 % of python3 submissions\n    Your memory usage beats 51.02 % of python3 submissions (16 MB)",
                "url": "https://leetcode.com/problems/course-schedule/solutions/441722/python-99-time-and-100-space-collection-of-solutions-with-explanation/",
                "vote_count": "323"
            },
            {
                "language": "ruby",
                "code": "    class Solution:\n        def buildAdjacencyList(self, n, edgesList):\n        ...\n    \n        def topoBFS(self, numNodes, edgesList):\n            # Note: for consistency with other solutions above, we keep building\n            # an adjacency list here. We can also merge this step with the next step.\n            adjList = self.buildAdjacencyList(numNodes, edgesList)\n    \n            # 1. A list stores No. of incoming edges of each vertex\n            inDegrees = [0] * numNodes\n            for v1, v2 in edgesList:\n                # v2v1 form a directed edge\n                inDegrees[v1] += 1\n    \n            # 2. a queue of all vertices with no incoming edge\n            # at least one such node must exist in a non-empty acyclic graph\n            # vertices in this queue have the same order as the eventual topological\n            # sort\n            queue = []\n            for v in range(numNodes):\n                if inDegrees[v] == 0:\n                    queue.append(v)\n    \n            # initialize count of visited vertices\n            count = 0\n            # an empty list that will contain the final topological order\n            topoOrder = []\n    \n            while queue:\n                # a. pop a vertex from front of queue\n                # depending on the order that vertices are removed from queue,\n                # a different solution is created\n                v = queue.pop(0)\n                # b. append it to topoOrder\n                topoOrder.append(v)\n    \n                # increase count by 1\n                count += 1\n    \n                # for each descendant of current vertex, reduce its in-degree by 1\n                for des in adjList[v]:\n                    inDegrees[des] -= 1\n                    # if in-degree becomes 0, add it to queue\n                    if inDegrees[des] == 0:\n                        queue.append(des)\n    \n            if count != numNodes:\n                return None  # graph has at least one cycle\n            else:\n                return topoOrder\n    \n        def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n            return True if self.topoBFS(numCourses, prerequisites) else False",
                "url": "https://leetcode.com/problems/course-schedule/solutions/441722/python-99-time-and-100-space-collection-of-solutions-with-explanation/",
                "vote_count": "323"
            },
            {
                "language": "java",
                "code": "    42/42 cases passed (92 ms)\n    Your runtime beats 99.03 % of python3 submissions\n    Your memory usage beats 100 % of python3 submissions (13.8 MB)",
                "url": "https://leetcode.com/problems/course-schedule/solutions/441722/python-99-time-and-100-space-collection-of-solutions-with-explanation/",
                "vote_count": "323"
            },
            {
                "language": "cpp",
                "code": "queue=[]\nv=queue.pop(0)",
                "url": "https://leetcode.com/problems/course-schedule/solutions/441722/python-99-time-and-100-space-collection-of-solutions-with-explanation/",
                "vote_count": "323"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/course-schedule/solutions/441722/python-99-time-and-100-space-collection-of-solutions-with-explanation/",
                "vote_count": "323"
            },
            {
                "language": "java",
                "code": "from collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        adj = [[] for _ in range(numCourses)]\n        degree = [0] * numCourses\n        for (curr, pre) in prerequisites:\n            adj[pre].append(curr)",
                "url": "https://leetcode.com/problems/course-schedule/solutions/441722/python-99-time-and-100-space-collection-of-solutions-with-explanation/",
                "vote_count": "323"
            },
            {
                "language": "python",
                "code": "for v in range(num):\n            if v not in visited:\n                if hasCycle(v, []):\n                    return False",
                "url": "https://leetcode.com/problems/course-schedule/solutions/441722/python-99-time-and-100-space-collection-of-solutions-with-explanation/",
                "vote_count": "323"
            },
            {
                "language": "ruby",
                "code": "from collections import defaultdict, deque\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        # Step 1: Create an adjacency list to represent the directed graph\n        graph = defaultdict(list)\n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n        \n        # Step 2: Create an array \"indegrees\" to store the number of incoming edges for each node in the graph\n        indegrees = [0] * numCourses\n        for prereq, _ in prerequisites:\n            indegrees[prereq] += 1\n        \n        # Step 3: Add all the nodes with indegree 0 to a queue\n        queue = deque()\n        for course in range(numCourses):\n            if indegrees[course] == 0:\n                queue.append(course)\n        \n        # Step 4: Topological Sort\n        while queue:\n            course = queue.popleft()\n            for prereq in graph[course]:\n                indegrees[prereq] -= 1\n                if indegrees[prereq] == 0:\n                    queue.append(prereq)\n        \n        # Step 5: Check if we have removed all the courses successfully\n        return all(indegree == 0 for indegree in indegrees)",
                "url": "https://leetcode.com/problems/course-schedule/solutions/3223175/207-solution-with-step-by-step-explanation/",
                "vote_count": "13"
            },
            {
                "language": "cpp",
                "code": "     # Step 4: Topological Sort\n        while queue:\n            course = queue.popleft()\n            for next_course in graph[course]:\n                indegrees[next_course] -= 1\n                if indegrees[next_course] == 0:\n                    queue.append(next_course)",
                "url": "https://leetcode.com/problems/course-schedule/solutions/3223175/207-solution-with-step-by-step-explanation/",
                "vote_count": "13"
            }
        ]
    },
    "183": {
        "question_id": 208,
        "title": "Implement Trie (Prefix Tree)",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/implement-trie-prefix-tree",
        "description": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.Implement the Trie class:Trie() Initializes the trie object.void insert(String word) Inserts the string word into the trie.boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise. ",
        "examples": [
            {
                "input": "[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\nOutput\n[null, null, true, false, true, null, true]\n\nExplanation\nTrie trie = new Trie();\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // return True\ntrie.search(\"app\");     // return False\ntrie.startsWith(\"app\"); // return True\ntrie.insert(\"app\");\ntrie.search(\"app\");     // return True",
                "output": "Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\nOutput\n[null, null, true, false, true, null, true]\n\nExplanation\nTrie trie = new Trie();\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // return True\ntrie.search(\"app\");     // return False\ntrie.startsWith(\"app\"); // return True\ntrie.insert(\"app\");\ntrie.search(\"app\");     // return True",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= word.length, prefix.length <= 2000",
            "word and prefix consist only of lowercase English letters.",
            "At most 3 * 10^4 calls in total will be made to insert, search, and startsWith."
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "namespace my{\n    class TreeNode{\n        private:\n            bool end;\n            vector<TreeNode*> child;\n        public:\n            TreeNode(){\n                this->end = false;\n                child.resize(26,NULL);\n            }\n\n            void setEnd(){\n                this->end = true;\n            }\n\n            void setNode(char ch){\n                child[ch-'a'] = new TreeNode();\n            }\n\n            bool isEnd(){\n                return this->end;\n            }\n\n            bool isSet(char ch){\n                return child[ch-'a'] != NULL;\n            }\n\n            TreeNode* getNode(char ch){\n                return child[ch-'a'];\n            }\n    };\n}\n\n\nclass Trie {\nprivate:\n    my::TreeNode* root;\npublic:\n    Trie() {\n        root = new my::TreeNode();\n    }\n    \n    void insert(string word) {\n        my::TreeNode* p = root;\n        for(int i = 0; i < word.size(); i++){\n            char ch = word[i];\n            if(p->isSet(ch)){\n                p = p->getNode(ch);\n            }else{\n                p->setNode(ch);\n                p = p->getNode(ch);\n            }\n        }\n        p->setEnd();\n    }\n    \n    bool search(string word) {\n        my::TreeNode* p = root;\n        for(int i = 0; i < word.size(); i++){\n            char ch = word[i];\n            if(p->isSet(ch)){\n                p = p->getNode(ch);\n            }else{\n                return false;\n            }\n        }\n        return p->isEnd();\n    }\n    \n    bool startsWith(string prefix) {\n        my::TreeNode* p = root;\n        for(int i = 0; i < prefix.size(); i++){\n            char ch = prefix[i];\n            if(p->isSet(ch)){\n                p = p->getNode(ch);\n            }else{\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie* obj = new Trie();\n * obj->insert(word);\n * bool param_2 = obj->search(word);\n * bool param_3 = obj->startsWith(prefix);\n */",
                "url": "https://leetcode.com/problems/implement-trie-prefix-tree/solutions/3307680/easy-explanation-in-detail-with-code/",
                "vote_count": "64"
            },
            {
                "language": "rust",
                "code": "Thanks for visiting my solution.\ud83d\ude0a Keep Learning\nPlease give my solution an upvote! \ud83d\udc4d\nIt's a simple way to show your appreciation and\nkeep me motivated. Thank you! \ud83d\ude0a",
                "url": "https://leetcode.com/problems/implement-trie-prefix-tree/solutions/3305783/easy-solutions-in-java-python-and-c-look-at-once/",
                "vote_count": "34"
            },
            {
                "language": "csharp",
                "code": "class Trie {\npublic:\n\nunordered_map<string,int>mpp,mp;\n    Trie() {\n        \n    }\n    \n    void insert(string word) {\n        mpp[word]++;\n        string s;\n        for(auto it : word)\n        {\n            s.push_back(it);\n            if(mp[s]==0) mp[s]++;\n        }\n    }\n    \n    bool search(string word) {\n        if(mpp[word]) return true;\n        return false;\n    }\n    \n    bool startsWith(string prefix) {\n        if(mp[prefix]) return true;\n        return false;\n    }\n};",
                "url": "https://leetcode.com/problems/implement-trie-prefix-tree/solutions/3306528/c-beginner-friendly-solution-hashing-clean-code/",
                "vote_count": "11"
            }
        ]
    },
    "184": {
        "question_id": 209,
        "title": "Minimum Size Subarray Sum",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/minimum-size-subarray-sum",
        "description": "Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead. ",
        "examples": [
            {
                "input": "target = 7, nums = [2,3,1,2,4,3]",
                "output": "2",
                "explanation": "The subarray [4,3] has the minimal length under the problem constraint."
            },
            {
                "input": "target = 4, nums = [1,4,4]",
                "output": "1",
                "explanation": null
            },
            {
                "input": "target = 11, nums = [1,1,1,1,1,1,1,1]",
                "output": "0",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= target <= 10^9",
            "1 <= nums.length <= 10^5",
            "1 <= nums[i] <= 10^4"
        ],
        "solutions": [
            {
                "language": "java",
                "code": "class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int low=1;\n        int high=nums.length+1;\n        boolean flag=false;\n        while(low<high){\n            int mid=low+(high-low)/2;\n            if(fixsw(mid,nums,target)==true){\n                flag=true;\n                high=mid;\n            }\n            else\n                low=mid+1;\n        }\n        if(!flag)\n            return 0;\n        return low;\n    }\n    public boolean fixsw(int size,int[] nums,int target){\n        int i=0;\n        int j=0;\n        int sum=0;\n        int max=Integer.MIN_VALUE;\n        while(j<nums.length){\n            sum+=nums[j];\n            if(j-i+1==size){\n                max=Math.max(max,sum);\n                sum-=nums[i];\n                i++;\n            }\n            j++;\n        }\n        if(max>=target){\n            return true;\n        }\n        return false;\n    }\n}",
                "url": "https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3241108/java-easy-two-approaches-sliding-window-binary-search/",
                "vote_count": "23"
            },
            {
                "language": "python",
                "code": "class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int i=0;\n        int j=0;\n        int min=Integer.MAX_VALUE;\n        int sum=0;\n        while(j<nums.length){\n            sum+=nums[j];\n            if(sum>=target){\n                while(sum>=target){\n                    min=Math.min(min,j-i+1);\n                    sum-=nums[i];\n                    i++;\n                }\n            }\n            j++;\n        }\n        if(min==Integer.MAX_VALUE)\n            return 0;\n        else\n            return min;\n    }\n}",
                "url": "https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3241108/java-easy-two-approaches-sliding-window-binary-search/",
                "vote_count": "23"
            }
        ]
    },
    "185": {
        "question_id": 210,
        "title": "Course Schedule II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/course-schedule-ii",
        "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array. ",
        "examples": [
            {
                "input": "numCourses = 2, prerequisites = [[1,0]]",
                "output": "[0,1]",
                "explanation": "There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]."
            },
            {
                "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
                "output": "[0,2,1,3]",
                "explanation": "There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3]."
            },
            {
                "input": "numCourses = 1, prerequisites = []",
                "output": "[0]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= numCourses <= 2000",
            "0 <= prerequisites.length <= numCourses * (numCourses - 1)",
            "prerequisites[i].length == 2",
            "0 <= ai, bi < numCourses",
            "ai != bi",
            "All the pairs [ai, bi] are distinct."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "public int[] findOrder(int numCourses, int[][] prerequisites) {\n    int[] incLinkCounts = new int[numCourses];\n    List<List<Integer>> adjs = new ArrayList<>(numCourses);\n    initialiseGraph(incLinkCounts, adjs, prerequisites);\n    //return solveByBFS(incLinkCounts, adjs);\n    return solveByDFS(adjs);\n}",
                "url": "https://leetcode.com/problems/course-schedule-ii/solutions/59317/two-ac-solution-in-java-using-bfs-and-dfs-with-explanation/",
                "vote_count": "339"
            },
            {
                "language": "csharp",
                "code": "private void initialiseGraph(int[] incLinkCounts, List<List<Integer>> adjs, int[][] prerequisites){\n    int n = incLinkCounts.length;\n    while (n-- > 0) adjs.add(new ArrayList<>());\n    for (int[] edge : prerequisites) {\n        incLinkCounts[edge[0]]++;\n        adjs.get(edge[1]).add(edge[0]);\n    }\n}",
                "url": "https://leetcode.com/problems/course-schedule-ii/solutions/59317/two-ac-solution-in-java-using-bfs-and-dfs-with-explanation/",
                "vote_count": "339"
            },
            {
                "language": "csharp",
                "code": "private int[] solveByBFS(int[] incLinkCounts, List<List<Integer>> adjs){\n    int[] order = new int[incLinkCounts.length];\n    Queue<Integer> toVisit = new ArrayDeque<>();\n    for (int i = 0; i < incLinkCounts.length; i++) {\n        if (incLinkCounts[i] == 0) toVisit.offer(i);\n    }\n    int visited = 0;\n    while (!toVisit.isEmpty()) {\n        int from = toVisit.poll();\n        order[visited++] = from;\n        for (int to : adjs.get(from)) {\n            incLinkCounts[to]--;\n            if (incLinkCounts[to] == 0) toVisit.offer(to);\n        }\n    }\n    return visited == incLinkCounts.length ? order : new int[0]; \n}",
                "url": "https://leetcode.com/problems/course-schedule-ii/solutions/59317/two-ac-solution-in-java-using-bfs-and-dfs-with-explanation/",
                "vote_count": "339"
            },
            {
                "language": "csharp",
                "code": "private int[] solveByDFS(List<List<Integer>> adjs) {\n    BitSet hasCycle = new BitSet(1);\n    BitSet visited = new BitSet(adjs.size());\n    BitSet onStack = new BitSet(adjs.size());\n    Deque<Integer> order = new ArrayDeque<>();\n    for (int i = adjs.size() - 1; i >= 0; i--) {\n        if (visited.get(i) == false && hasOrder(i, adjs, visited, onStack, order) == false) return new int[0];\n    }\n    int[] orderArray = new int[adjs.size()];\n    for (int i = 0; !order.isEmpty(); i++) orderArray[i] = order.pop();\n    return orderArray;\n}\n\nprivate boolean hasOrder(int from, List<List<Integer>> adjs, BitSet visited, BitSet onStack, Deque<Integer> order) {\n    visited.set(from);\n    onStack.set(from);\n    for (int to : adjs.get(from)) {\n        if (visited.get(to) == false) {\n            if (hasOrder(to, adjs, visited, onStack, order) == false) return false;\n        } else if (onStack.get(to) == true) {\n            return false;\n        }\n    }\n    onStack.clear(from);\n    order.push(from);\n    return true;\n}",
                "url": "https://leetcode.com/problems/course-schedule-ii/solutions/59317/two-ac-solution-in-java-using-bfs-and-dfs-with-explanation/",
                "vote_count": "339"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        //prepare\n        List<List<Integer>> graph = new ArrayList<>();\n        for(int i = 0; i < numCourses; i++){\n            graph.add(new ArrayList<>());\n        }\n\n\n visited, int i){",
                "url": "https://leetcode.com/problems/course-schedule-ii/solutions/59317/two-ac-solution-in-java-using-bfs-and-dfs-with-explanation/",
                "vote_count": "339"
            },
            {
                "language": "java",
                "code": "    private int N = 0;\n\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        int[] result = new int[numCourses];\n        Course[] courses = new Course[numCourses];\n        for (int i = 0; i < numCourses; i++) {\n            courses[i] = new Course(i);\n        }",
                "url": "https://leetcode.com/problems/course-schedule-ii/solutions/59317/two-ac-solution-in-java-using-bfs-and-dfs-with-explanation/",
                "vote_count": "339"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        int[] inDegree = new int[numCourses];\n        List<Integer>[] graph = new ArrayList[numCourses];\n        for (int i = 0; i < numCourses; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        for (int[] pair : prerequisites) {",
                "url": "https://leetcode.com/problems/course-schedule-ii/solutions/59317/two-ac-solution-in-java-using-bfs-and-dfs-with-explanation/",
                "vote_count": "339"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/course-schedule-ii/solutions/59317/two-ac-solution-in-java-using-bfs-and-dfs-with-explanation/",
                "vote_count": "339"
            },
            {
                "language": "cpp",
                "code": "vector<int> findOrder(int num, vector<vector<int>>& pre) {\n        int n = num;\n        vector<vector<int>> adj(num);\n        vector<int> deg(num), order;\n        for(auto x : pre){\n            adj[x[1]].push_back(x[0]);\n            deg[x[0]]++;\n        }",
                "url": "https://leetcode.com/problems/course-schedule-ii/solutions/59317/two-ac-solution-in-java-using-bfs-and-dfs-with-explanation/",
                "vote_count": "339"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        // Topological sort\n        // Edge case\n        if(numCourses <= 0) return new int[0];\n        \n        //1. Init Map\n        HashMap<Integer, Integer> inDegree = new HashMap<>();\n        HashMap<Integer, List<Integer>> topoMap = new HashMap<>();\n        for(int i = 0; i < numCourses; i++) {\n            inDegree.put(i, 0);\n            topoMap.put(i, new ArrayList<Integer>());\n        }\n        \n        //2. Build Map\n        for(int[] pair : prerequisites) {\n            int curCourse = pair[0], preCourse = pair[1];\n            topoMap.get(preCourse).add(curCourse);  // put the child into it's parent's list\n            inDegree.put(curCourse, inDegree.get(curCourse) + 1); // increase child inDegree by 1\n        }\n        //3. find course with 0 indegree, minus one to its children's indegree, until all indegree is 0\n        int[] res = new int[numCourses];\n        int base = 0;\n        while(!inDegree.isEmpty()) {\n            boolean flag = false;   // use to check whether there is cycle\n            for(int key : inDegree.keySet()) {  // find nodes with 0 indegree\n                if(inDegree.get(key) == 0) {\n                    res[base ++] = key;\n                    List<Integer> children = topoMap.get(key);  // get the node's children, and minus their inDegree\n                    for(int child : children) \n                        inDegree.put(child, inDegree.get(child) - 1);\n                    inDegree.remove(key);      // remove the current node with 0 degree and start over\n                    flag = true;\n                    break;\n                }\n            }\n            if(!flag)  // there is a circle --> All Indegree are not 0\n                return new int[0];\n        }\n        return res;\n    }\n}",
                "url": "https://leetcode.com/problems/course-schedule-ii/solutions/190393/topological-sort-template-general-approach/",
                "vote_count": "229"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    /**\n     * @param words: a list of words\n     * @return: a string which is correct order\n     */\n    public String alienOrder(String[] words) {\n        // Topo sort\n        // Edge case\n        if(words == null || words.length == 0) return \"\";\n        \n        //1. Init inDegree & topoMap\n        HashMap<Character, Integer> inDegree = new HashMap<>();\n        HashMap<Character, List<Character>> topoMap = new HashMap<>();\n        for(String word : words)\n            for(char c : word.toCharArray()) {\n                inDegree.put(c, 0);\n                topoMap.put(c, new ArrayList<Character>());\n            }\n        \n        //2. Build Map\n        for(int i = 0; i < words.length - 1; i++) {\n            String w1 = words[i], w2 = words[i + 1];\n            for(int j = 0; j < Math.min(w1.length(), w2.length()); j++) {\n                char parent = w1.charAt(j), child = w2.charAt(j);\n                if(parent != child) {\n                    inDegree.put(child, inDegree.get(child) + 1);\n                    topoMap.get(parent).add(child);\n                    break;\n                }\n            }\n        }\n        \n        //3. Topo sort\n        StringBuilder res = new StringBuilder();\n        while(!inDegree.isEmpty()) {\n            boolean flag = false;\n            for(Character c : inDegree.keySet()) {\n                if(inDegree.get(c) == 0) {\n                    flag = true;\n                    res.append(c);\n                    List<Character> children = topoMap.get(c);\n                    for(Character ch : children)\n                        inDegree.put(ch, inDegree.get(ch) - 1);\n                    inDegree.remove(c);\n                    break;\n                }\n            }\n            if(flag == false)\n                return \"\";\n        }\n        return res.toString();\n    }\n}",
                "url": "https://leetcode.com/problems/course-schedule-ii/solutions/190393/topological-sort-template-general-approach/",
                "vote_count": "229"
            },
            {
                "language": "cpp",
                "code": "vector<int> findOrder(int num, vector<vector<int>>& pre) {\n        int n = num;\n        vector<vector<int>> adj(num);\n        vector<int> deg(num), order;\n        for(auto x : pre){\n            adj[x[1]].push_back(x[0]);\n            deg[x[0]]++;\n        }",
                "url": "https://leetcode.com/problems/course-schedule-ii/solutions/190393/topological-sort-template-general-approach/",
                "vote_count": "229"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\n        Map<Integer, Integer> inDegree = new HashMap<>();\n        // Build graph and in-degree map\n        for (int[] pre : prerequisites) {\n            int to = pre[0], from = pre[1];\n            graph.putIfAbsent(from, new HashSet<Integer>());",
                "url": "https://leetcode.com/problems/course-schedule-ii/solutions/190393/topological-sort-template-general-approach/",
                "vote_count": "229"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findOrder(int N, vector<vector<int>>& P) {\n        vector<vector<int>> G(N);                   // {prerequisite-course : [list of next courses]}\n        vector<int> ans, indegree(N);               // indegree[i] denotes number of prerequisite courses for ith course\n        for(auto& pre : P) \n            G[pre[1]].push_back(pre[0]),            // forming adjacency list graph\n            indegree[pre[0]]++;                     \n        \n        queue<int> q;\n        for(int i = 0; i < N; i++)\n            if(indegree[i] == 0) q.push(i);         // we can start with courses having no prequisites\n        \n        while(size(q)) {\n            auto cur = q.front(); q.pop();\n            ans.push_back(cur);                     // cur has no remaining pre courses, so we can take it now\n            for(auto nextCourse : G[cur]) \n                if(--indegree[nextCourse] == 0)     // if there's a next course having 0 prequisite remaining,\n                    q.push(nextCourse);             // then we can take it\n        }\n        if(size(ans) == N) return ans;              // ordering exists where all courses can be finished\n        return {};                                      \n    }\n};",
                "url": "https://leetcode.com/problems/course-schedule-ii/solutions/1642354/c-python-simple-solutions-w-explanation-topological-sort-using-bfs-dfs/",
                "vote_count": "126"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def findOrder(self, N, P):\n        G, indegree, q, ans = defaultdict(list), [0]*N, deque(), []\n        for nxt, pre in P:\n            G[pre].append(nxt)\n            indegree[nxt] += 1\n        \n        for i in range(N):\n            if indegree[i] == 0:\n                q.append(i)\n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n            for nextCourse in G[cur]:\n                indegree[nextCourse] -= 1\n                if indegree[nextCourse] == 0: \n                    q.append(nextCourse)\n                    \n        return ans if len(ans) == N else []",
                "url": "https://leetcode.com/problems/course-schedule-ii/solutions/1642354/c-python-simple-solutions-w-explanation-topological-sort-using-bfs-dfs/",
                "vote_count": "126"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<int> findOrder(int N, vector<vector<int>>& P) {\n        vector<vector<int>> G(N);\n        vector<int> ans, indegree(N);\n        for(auto& pre : P)\n            G[pre[1]].push_back(pre[0]),\n            indegree[pre[0]]++;\n        \n        function<void(int)> dfs = [&](int cur) {\n            ans.push_back(cur);                     // take cur course & push it into ordering\n            indegree[cur] = -1;                     // and mark it as visited\n            for(auto nextCourse : G[cur])          \n                if(--indegree[nextCourse] == 0)     // if there's a next course having 0 prequisite remaining,\n                    dfs(nextCourse);                // then we can take it\n        };\n        for(int i = 0; i < N; i++)\n            if(indegree[i] == 0)                    // we can start with courses having no prequisites\n                dfs(i);\n        \n        if(size(ans) == N) return ans;\n        return {};\n    }\n};",
                "url": "https://leetcode.com/problems/course-schedule-ii/solutions/1642354/c-python-simple-solutions-w-explanation-topological-sort-using-bfs-dfs/",
                "vote_count": "126"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def findOrder(self, N, P):\n        G, indegree, ans = defaultdict(list), [0]*N, []\n        for nxt, pre in P:\n            G[pre].append(nxt)\n            indegree[nxt] += 1\n        \n        def dfs(cur):\n            ans.append(cur)\n            indegree[cur] = -1\n            for nextCourse in G[cur]:\n                indegree[nextCourse] -= 1\n                if indegree[nextCourse] == 0: \n                    dfs(nextCourse)            \n        for i in range(N):\n            if indegree[i] == 0:\n                dfs(i)\n\n        return ans if len(ans) == N else []",
                "url": "https://leetcode.com/problems/course-schedule-ii/solutions/1642354/c-python-simple-solutions-w-explanation-topological-sort-using-bfs-dfs/",
                "vote_count": "126"
            },
            {
                "language": "php",
                "code": "def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n    \"\"\" O(E+V)TS\"\"\"\n    grid, inp = {k: [] for k in range(numCourses)}, collections.Counter({k: 0 for k in range(numCourses)})\n    [(grid[b].append(a), inp.update({a: 1})) for a, b in prerequisites]\n\n    topo = [k for k, v in inp.items() if not v]\n    [inp.update({kid: -1}) or inp[kid] == 0 and topo.append(kid) for node in topo for kid in grid[node]]\n    return topo if len(topo) == numCourses else []",
                "url": "https://leetcode.com/problems/course-schedule-ii/solutions/1642354/c-python-simple-solutions-w-explanation-topological-sort-using-bfs-dfs/",
                "vote_count": "126"
            }
        ]
    },
    "186": {
        "question_id": 211,
        "title": "Design Add and Search Words Data Structure",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/design-add-and-search-words-data-structure",
        "description": "Design a data structure that supports adding new words and finding if a string matches any previously added string.Implement the WordDictionary class:WordDictionary() Initializes the object.void addWord(word) Adds word to the data structure, it can be matched later.bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter. ",
        "examples": [
            {
                "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\nOutput\n[null,null,null,null,false,true,true,true]\n\nExplanation\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(\"bad\");\nwordDictionary.addWord(\"dad\");\nwordDictionary.addWord(\"mad\");\nwordDictionary.search(\"pad\"); // return False\nwordDictionary.search(\"bad\"); // return True\nwordDictionary.search(\".ad\"); // return True\nwordDictionary.search(\"b..\"); // return True",
                "output": "WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\nOutput\n[null,null,null,null,false,true,true,true]\n\nExplanation\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(\"bad\");\nwordDictionary.addWord(\"dad\");\nwordDictionary.addWord(\"mad\");\nwordDictionary.search(\"pad\"); // return False\nwordDictionary.search(\"bad\"); // return True\nwordDictionary.search(\".ad\"); // return True\nwordDictionary.search(\"b..\"); // return True",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= word.length <= 25",
            "word in addWord consists of lowercase English letters.",
            "word in search consist of '.' or lowercase English letters.",
            "There will be at most 2 dots in word for search queries.",
            "At most 10^4 calls will be made to addWord and search."
        ],
        "solutions": [
            {
                "language": "python",
                "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n        \nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()      \n\n    def addWord(self, word):\n        current_node = self.root\n        for character in word:\n            current_node = current_node.children.setdefault(character, TrieNode())\n        current_node.is_word = True\n        \n    def search(self, word):\n        def dfs(node, index):\n            if index == len(word):\n                return node.is_word\n               \n            if word[index] == \".\":\n                for child in node.children.values():\n                    if dfs(child, index+1):\n                        return True\n                    \n            if word[index] in node.children:\n                return dfs(node.children[word[index]], index+1)\n            \n            return False\n    \n        return dfs(self.root, 0)",
                "url": "https://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3313633/python-simple-solution-easy-to-understand/",
                "vote_count": "47"
            },
            {
                "language": "rust",
                "code": "class WordDictionary:\n        def __init__(self):\n\n            self.words = defaultdict(list)\n\n\n        def addWord(self, word: str) -> None:\n\n            self.words[len(word)].append(word)\n\n\n        def search(self, word: str) -> bool:\n\n            n = len(word)\n\n            if '.' in word:\n                \n                for w in self.words[n]:\n                    if all(word[i] in (w[i], '.') for i in range(n)):\n                        return True\n\n                else: return False\n\n            return word in self.words[n]",
                "url": "https://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3313896/python-3-t-m-100-99/",
                "vote_count": "25"
            },
            {
                "language": "csharp",
                "code": "class WordDictionary {\npublic:\n    vector<string> v;\n    WordDictionary() {\n        \n    }\n    \n    void addWord(string word) {\n        v.push_back(word);\n    }\n    \n    bool search(string word) {\n        int count=0;\n        int n=word.size();\n        for(int i=0; i<v.size(); i++){\n            if(n==v[i].size()){\n                for(int j=0; j<n; j++){\n                    if(v[i][j]==word[j]||word[j]=='.'){\n                        count++;\n                    }\n                    else{\n                        count=0;\n                        break;\n                    }\n                }\n                if(count==n) return true;\n            }\n        }\n        return false;\n    }\n};",
                "url": "https://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314739/c-vector-very-easy-to-understand/",
                "vote_count": "18"
            },
            {
                "language": "csharp",
                "code": "}\n\nvoid addWord(string word) {\n    s.push_back(word);",
                "url": "https://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314739/c-vector-very-easy-to-understand/",
                "vote_count": "18"
            },
            {
                "language": "rust",
                "code": "Thanks for visiting my solution.\ud83d\ude0a Keep Learning\nPlease give my solution an upvote! \ud83d\udc4d\nIt's a simple way to show your appreciation and\nkeep me motivated. Thank you! \ud83d\ude0a",
                "url": "https://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3313687/easy-solutions-in-java-python-and-c-look-at-once/",
                "vote_count": "13"
            },
            {
                "language": "cpp",
                "code": "class TrieNode {\npublic:\n    TrieNode* children[26];\n    bool isWordCompleted;\n\n    TrieNode() {\n        memset(children, 0, sizeof(children));\n        isWordCompleted = false;\n    }\n};\n\nclass WordDictionary {\npublic:\n    TrieNode* root;\n    WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    void addWord(string word) {\n        TrieNode* newRoot = root;\n        for (char ch : word) {\n            int alphabetIndex = ch - 'a';\n            if (newRoot -> children[alphabetIndex] == NULL) {\n                newRoot -> children[alphabetIndex] = new TrieNode();\n            }\n            newRoot = newRoot -> children[alphabetIndex];\n        }\n        newRoot -> isWordCompleted = true;\n    }\n    \n    bool searchHelper(string word, int index, TrieNode* newRoot) {\n        if (index == word.length())\n            return newRoot -> isWordCompleted;\n        char ch = word[index];\n        if (ch == '.') {\n            for (int i = 0; i < 26; i++) {\n                if (newRoot -> children[i] != NULL && searchHelper(word, index + 1, newRoot -> children[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        else {\n            if (newRoot -> children[ch - 'a'] == NULL) {\n                return false;\n            }\n            return (searchHelper(word, index + 1, newRoot -> children[ch - 'a']));\n        }\n    }\n\n    bool search(string word) {\n        return searchHelper(word, 0, root);\n    }\n};\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary* obj = new WordDictionary();\n * obj->addWord(word);\n * bool param_2 = obj->search(word);\n */",
                "url": "https://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314943/day-78-trie-dfs-easiest-beginner-friendly-sol/",
                "vote_count": "13"
            }
        ]
    },
    "187": {
        "question_id": 212,
        "title": "Word Search II",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/word-search-ii",
        "description": "Given an m x n board of characters and a list of strings words, return all words on the board.Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. ",
        "examples": [
            {
                "input": "board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]",
                "output": "[\"eat\",\"oath\"]",
                "explanation": null
            },
            {
                "input": "board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]",
                "output": "[]",
                "explanation": null
            }
        ],
        "constraints": [
            "m == board.length",
            "n == board[i].length",
            "1 <= m, n <= 12",
            "board[i][j] is a lowercase English letter.",
            "1 <= words.length <= 3 * 10^4",
            "1 <= words[i].length <= 10",
            "words[i] consists of lowercase English letters.",
            "All the strings of words are unique."
        ],
        "solutions": [
            {
                "language": "ruby",
                "code": "class Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        \n        m, n = len(board), len(board[0])\n        trie = Trie(words)                   # trie is initialized with a list of words\n        seen = set()                         # found words are being collected into a set\n                \n        # generator that yields (!) adjacent cells\n        def adj(x, y):\n            for i,j in [(0,-1),(0,1),(-1,0),(1,0)]:\n                if 0 <= x+i < m and 0 <= y+j < n:\n                    yield (x+i,y+j)\n        \n        # DFS search with prefix 'p', last cell (x,y) on board 'b'\n        def dfs(p, b, x, y):          \n            \n            ch, b[x][y] = b[x][y], \"#\"        # [1] mark used cell and save board state\n            \n            if trie.search(p):               \n                seen.add(p)                   # [2] mark word as found and\n                trie.remove(p)                #     no longer search for it\n\n            for i,j in adj(x, y):             # [3] iterate over adjacent cells\n                if b[i][j] != \"#\":            #     which are still unused\n                    pp = p + b[i][j]          #     and extend the word\n                    if trie.starts(pp):       # [4] if the prefix exists in the trie,\n                        dfs(pp, b, i, j)      #     we should check this branch\n            \n            b[x][y] = ch                      # [5] restore board state\n        \n        for i in range(m):                    # DFS procedure is initialized starting\n            for j in range(n):                # from all possible cells (i,j)\n                dfs(board[i][j], board, i, j)\n        \n        return seen",
                "url": "https://leetcode.com/problems/word-search-ii/solutions/2779789/python-c-dfs-using-trie-with-removal-with-detailed-comments/",
                "vote_count": "40"
            },
            {
                "language": "python",
                "code": "class Trie:\n    def __init__(self, words=[]):\n        self.trie = {}\n        for w in words: self.insert(w)\n\n    def insert(self, word):\n        t = self.trie\n        for w in word:\n            if w not in t:\n                t[w] = {}\n            t = t[w]\n        t['#'] = '#'\n\n    def search(self, word):\n        t = self.trie\n        for w in word:\n            if w not in t:\n                return False\n            t = t[w]\n        if '#' in t:\n            return True\n        return False\n\n    def starts(self, prefix):\n        t = self.trie\n        for w in prefix:\n            if w not in t:\n                return False\n            t = t[w]\n        return True\n    \n    def remove(self, word):\n        t = self.trie\n        nodes = []\n        for w in word:\n            if w not in t: return\n            t = t[w]\n            nodes.append((t,w))\n\n        if '#' in t:\n            p = '#'\n            for n,w in nodes[::-1]:\n                if len(n[p]) == 0 or p == '#' : del n[p]\n                p = w                ",
                "url": "https://leetcode.com/problems/word-search-ii/solutions/2779789/python-c-dfs-using-trie-with-removal-with-detailed-comments/",
                "vote_count": "40"
            },
            {
                "language": "python",
                "code": "def remove(self, word: str):\n    if not word: return\n    d = self.trie\n    last_split = (d, word[0])\n    for letter in word:\n        if letter not in d: return",
                "url": "https://leetcode.com/problems/word-search-ii/solutions/2779789/python-c-dfs-using-trie-with-removal-with-detailed-comments/",
                "vote_count": "40"
            },
            {
                "language": "ruby",
                "code": "class Node:\n   def __init__(self,val):\n       self.val = val # \"a\"\n       self.end = False # ending of a word in Trie\n       self.trie= {} # next a:Node for a in \"abcdefghijklmnopqrstuvwxyz\"\n       self.par = None # parent of it, using  for deleting",
                "url": "https://leetcode.com/problems/word-search-ii/solutions/2779789/python-c-dfs-using-trie-with-removal-with-detailed-comments/",
                "vote_count": "40"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n\n    // declare a structure for TrieNode\n\n    struct TrieNode\n    {\n        bool is_end;\n\n        string word;\n\n        TrieNode* child[26];\n\n        TrieNode()\n        {\n            is_end = false;\n\n            word = \"\";\n\n            for(int i = 0; i < 26; i++)\n            {\n                child[i] = NULL;\n            }\n        }\n    };\n\n    // declare root of the Trie\n\n    TrieNode* root = new TrieNode();\n\n    // function for inserting word into Trie\n\n    void insert(string& str)\n    {\n        int n = str.size();\n\n        TrieNode* curr = root;\n\n        for(int i = 0; i < n; i++)\n        {\n            int idx = str[i] - 'a';\n\n            // if no subtree is present then insert the new node\n\n            if(curr -> child[idx] == NULL)\n            {\n                curr -> child[idx] = new TrieNode();\n            }\n\n            curr = curr -> child[idx];\n        }\n\n        // update is_end and word\n\n        curr -> is_end = true;\n\n        curr -> word = str;\n    }\n\n    // dfs function\n\n    vector<string> res;\n\n    // direction co-ordinates of all four directions\n\n    vector<int> dx = {-1, 0, 1, 0};\n\n    vector<int> dy = {0, 1, 0, -1};\n\n    void dfs(vector<vector<char>>& grid, int i, int j, int n, int m, TrieNode* curr)\n    {\n        // base case\n         \n        if(i < 0 || i >= n || j < 0 || j >= m || grid[i][j] == '#')\n        {\n            return;\n        }\n\n        int idx = grid[i][j] - 'a';\n\n        // if there is no word starting with curr character then return\n\n        if(curr -> child[idx] == NULL)\n        {\n            return;\n        }\n\n        // move curr\n\n        curr = curr -> child[idx];\n\n        // if we found a word\n\n        if(curr -> is_end)\n        {\n            res.push_back(curr -> word);\n\n            // mark is_end with false to avoid duplicate result\n\n            curr -> is_end = false;\n        }\n\n        // store the val of curr cell\n\n        char val = grid[i][j];\n\n        // mark the curr cell visited\n\n        grid[i][j] = '#';\n\n        // explore all the four directions\n\n        for(int k = 0; k < 4; k++)\n        {\n            int new_i = i + dx[k];\n\n            int new_j = j + dy[k];\n\n            // call dfs\n\n            dfs(grid, new_i, new_j, n, m, curr);\n        }\n\n        // backtrack\n\n        grid[i][j] = val;\n    }\n    \n    vector<string> findWords(vector<vector<char>>& grid, vector<string>& words) {\n        \n        int n = grid.size();\n        \n        int m = grid[0].size();\n\n        // insert all the words into trie\n\n        for(auto word : words)\n        {\n            insert(word);\n        }\n\n        // start dfs from all the cell and find possible result\n\n        for(int i = 0; i < n; i++)\n        {\n            for(int j = 0; j < m; j++)\n            {\n                dfs(grid, i, j, n, m, root);\n            }\n        }\n\n        return res;\n    }\n};",
                "url": "https://leetcode.com/problems/word-search-ii/solutions/2780127/c-trie-dfs-backtracking-faster-easy-to-understand/",
                "vote_count": "18"
            },
            {
                "language": "cpp",
                "code": "class Node{  //*** trie Node\n    public:\n        string word;\n        bool isTerminal;  \n        vector<Node*> next;\n        Node():next(26,NULL){\n            isTerminal = false; \n            \n        }\n};\n\nclass Solution {\n    \n    void put(string &s,int si, Node* cur){ //** adds a word to the trie \n            int a = s[si]-'a';    //*********** also stores the word at the terminal node\n            if(!cur->next[a]){\n            Node* newnode = new Node();\n            cur->next[a] = newnode;\n            }\n\n            if(si != s.size()-1){\n            put(s,si+1,cur->next[a]); }\n            else\n             { cur->next[a]->isTerminal = true;\n               cur->next[a]->word = s;\n              }\n      }\n\nvoid dfs(vector<vector<char>>& board,int i,int j,Node* t,set<string>& res,vector<vector<bool>>& visit){ \n    if(i<0 || j<0 || i>=board.size() || j>= board[0].size())return; //** dfs call to search for word\n    char x = board[i][j]-'a';\n    t = t->next[x];\n    if(visit[i][j] || !t)return ;\n   \n    if(t->isTerminal)res.insert((t->word));\n    visit[i][j] = true;\n    dfs(board,i+1,j,t,res,visit);\n    dfs(board,i-1,j,t,res,visit);\n    dfs(board,i,j+1,t,res,visit);\n    dfs(board,i,j-1,t,res,visit);\n    visit[i][j]= false;\n}\n\npublic:\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n        set<string> res;\n        Node* t = new Node();\n        for(string &s:words){\n            put(s,0,t);\n        }\n       vector<vector<bool>> visit(board.size(),vector<bool>(board[0].size(),false));\n        for(int i = 0 ;i<board.size();i++){\n            for(int j=0;j<board[0].size();j++){\n               dfs(board,i,j,t,res,visit);\n            }\n        }\n        vector<string> ans(res.begin(),res.end());\n       return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/word-search-ii/solutions/2780237/dfs-trie-c-soln/",
                "vote_count": "15"
            },
            {
                "language": "javascript",
                "code": "    node(){\n        end = false;",
                "url": "https://leetcode.com/problems/word-search-ii/solutions/2780237/dfs-trie-c-soln/",
                "vote_count": "15"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/word-search-ii/solutions/2780237/dfs-trie-c-soln/",
                "vote_count": "15"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    struct TrieNode {\n        vector<TrieNode*> child;\n        string word;\n        TrieNode() : word(\"\"), child(vector<TrieNode*>(26, nullptr)) {}\n    };\n    \n    TrieNode* buildTrie(vector<string>& words) {\n        TrieNode* root = new TrieNode();\n        for (string w : words) {\n            TrieNode* curr = root;\n            for (char c : w) {\n                int i = c - 'a';\n                if (curr->child[i] == NULL) curr->child[i] = new TrieNode();\n                curr = curr->child[i];\n            }\n            curr->word = w;\n        }\n        return root;\n    }\n\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n        vector<string> out;\n        TrieNode* root = buildTrie(words);\n        for(int i = 0; i < board.size(); ++i) \n            for(int j = 0; j < board[0].size(); ++j) \n                dfs(board, i, j, root, out);\n        return out;\n    }\n    \n    void dfs(vector<vector<char>>& board, int i, int j, TrieNode* curr, vector<string>& out) {\n        char c = board[i][j];\n        if(c == '#' || curr->child[c - 'a'] == NULL) return;\n        curr = curr->child[c - 'a'];\n        if (curr->word != \"\") {\n            out.push_back(curr->word);\n            curr->word = \"\";\n        }\n        board[i][j] = '#';\n        if(i > 0) dfs(board, i - 1, j , curr, out); \n        if(j > 0) dfs(board, i, j - 1, curr, out);\n        if(i < board.size() - 1) dfs(board, i + 1, j, curr, out); \n        if(j < board[0].size() - 1) dfs(board, i, j + 1, curr, out); \n        board[i][j] = c;\n    }\n};",
                "url": "https://leetcode.com/problems/word-search-ii/solutions/2779776/c-solutions/",
                "vote_count": "11"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool issafe(int x,int y,vector<vector<char>>& board,char c,vector<vector<bool>>& vis){\n        return x>=0 && y>=0 && x<board.size() && y<board[0].size() && c==board[x][y] && !vis[x][y];\n    }\n    bool solve(int x,int y,int p,vector<vector<char>>& board,string word,vector<vector<bool>> vis){",
                "url": "https://leetcode.com/problems/word-search-ii/solutions/2779776/c-solutions/",
                "vote_count": "11"
            }
        ]
    },
    "188": {
        "question_id": 213,
        "title": "House Robber II",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/house-robber-ii",
        "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. ",
        "examples": [
            {
                "input": "nums = [2,3,2]",
                "output": "3",
                "explanation": "You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses."
            },
            {
                "input": "nums = [1,2,3,1]",
                "output": "4",
                "explanation": "Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4."
            },
            {
                "input": "nums = [1,2,3]",
                "output": "3",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 100",
            "0 <= nums[i] <= 1000"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int solve(vector<int> &nums)\n    {\n        int n=nums.size();\n        int prev2=nums[0];\n        int prev1=max(nums[0],nums[1]);\n\n        for(int i=2;i<n;i++)\n        {\n           int curr=max(prev1,prev2+nums[i]);\n           prev2=prev1;\n           prev1=curr;\n        }\n        return prev1;\n    }\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        if(n==1)\n         return nums[0];\n        if(n==2)\n         return max(nums[0],nums[1]);\n        vector<int> v1,v2;\n        for(int i=0;i<n;i++)\n        {\n            if(i!=0)\n             v1.push_back(nums[i]);\n            if(i!=nums.size()-1)\n             v2.push_back(nums[i]);\n        }\n        int ans=max(solve(v1),solve(v2));\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/house-robber-ii/solutions/3219244/c-dp-beats-100-space-optimization/",
                "vote_count": "25"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\nint gen_rob(vector<int>& arr,int st,int end) {\n        int p1=0,p2=0;\n        int p3=0;\n        for(int i=st;i<end;i++){\n            p3=max(arr[i]+p2,p1);\n            p2=p1;\n            p1=p3;\n        }\n        return p3;\n    }\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        if(n==1)return nums[0];\n        return max(gen_rob(nums,0,n-1),gen_rob(nums,1,n));\n    }\n};",
                "url": "https://leetcode.com/problems/house-robber-ii/solutions/3145559/c-beats-100-dp-easy/",
                "vote_count": "10"
            }
        ]
    },
    "189": {
        "question_id": 214,
        "title": "Shortest Palindrome",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/shortest-palindrome",
        "description": "You are given a string s. You can convert s to a palindrome by adding characters in front of it.Return the shortest palindrome you can find by performing this transformation. ",
        "examples": [
            {
                "input": "s = \"aacecaaa\"",
                "output": "\"aaacecaaa\"",
                "explanation": null
            }
        ],
        "constraints": [],
        "solutions": [
            {
                "language": "csharp",
                "code": "public String shortestPalindrome(String s) {\n    String temp = s + \"#\" + new StringBuilder(s).reverse().toString();\n    int[] table = getTable(temp);\n    \n    //get the maximum palin part in s starts from 0\n    return new StringBuilder(s.substring(table[table.length - 1])).reverse().toString() + s;\n}\n\npublic int[] getTable(String s){\n    //get lookup table\n    int[] table = new int[s.length()];\n    \n    //pointer that points to matched char in prefix part\n    \n    int index = 0;\n    //skip index 0, we will not match a string with itself\n    for(int i = 1; i < s.length(); i++){\n        if(s.charAt(index) == s.charAt(i)){\n            //we can extend match in prefix and postfix\n            table[i] = table[i-1] + 1;\n            index ++;\n        }else{\n            //match failed, we try to match a shorter substring\n            \n            //by assigning index to table[i-1], we will shorten the match string length, and jump to the \n            //prefix part that we used to match postfix ended at i - 1\n            index = table[i-1];\n            \n            while(index > 0 && s.charAt(index) != s.charAt(i)){\n                //we will try to shorten the match string length until we revert to the beginning of match (index 1)\n                index = table[index-1];\n            }\n            \n            //when we are here may either found a match char or we reach the boundary and still no luck\n            //so we need check char match\n            if(s.charAt(index) == s.charAt(i)){\n                //if match, then extend one char \n                index ++ ;\n            }\n            \n            table[i] = index;\n        }\n        \n    }\n    \n    return table;\n}",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60113/clean-kmp-solution-with-super-detailed-explanation/",
                "vote_count": "603"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\npublic String shortestPalindrome(String s) {\n    String temp = s + \"#\" + new StringBuilder(s).reverse().toString();\n    int[] table = getTable(temp);\n\n    return new StringBuilder(s.substring(table[table.length - 1])).reverse().toString() + s;\n}",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60113/clean-kmp-solution-with-super-detailed-explanation/",
                "vote_count": "603"
            },
            {
                "language": "csharp",
                "code": "",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60113/clean-kmp-solution-with-super-detailed-explanation/",
                "vote_count": "603"
            },
            {
                "language": "csharp",
                "code": "",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60113/clean-kmp-solution-with-super-detailed-explanation/",
                "vote_count": "603"
            },
            {
                "language": "python",
                "code": "table = [0,0,0,1,0,0,0,0,0,1,2,3,4]\n         a c c a b b # b b a c c a\n                           a c c a b b",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60113/clean-kmp-solution-with-super-detailed-explanation/",
                "vote_count": "603"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60113/clean-kmp-solution-with-super-detailed-explanation/",
                "vote_count": "603"
            },
            {
                "language": "ruby",
                "code": "def shortestPalindrome(self, s):\n    r = s[::-1]\n    for i in range(len(s) + 1):\n        if s.startswith(r[i:]):\n            return r[:i] + s",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60099/ac-in-288-ms-simple-brute-force/",
                "vote_count": "378"
            },
            {
                "language": "erlang",
                "code": "  s          dedcba\n  r[0:]      abcded    Nope...\n  r[1:]   (a)bcded     Nope...\n  r[2:]  (ab)cded      Nope...\n  r[3:] (abc)ded       Yes! Return abc + dedcba",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60099/ac-in-288-ms-simple-brute-force/",
                "vote_count": "378"
            },
            {
                "language": "ruby",
                "code": "def shortestPalindrome(self, s):\n    r = s[::-1]\n    for i in range(len(s) + 1):\n        # original solution, took 0.08 second on my test cases\n        if s.startswith(r[i:]):\n            return r[:i] + s",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60099/ac-in-288-ms-simple-brute-force/",
                "vote_count": "378"
            },
            {
                "language": "ruby",
                "code": "def shortestPalindrome(self, s):\n        r = s[::-1]\n        for i in range(len(s) + 1):\n            if s[:len(s)-i]==r[i:]:\n                return r[:i] + s",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60099/ac-in-288-ms-simple-brute-force/",
                "vote_count": "378"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public String shortestPalindrome(String s) {\n        if (s == null || s.length() == 0) {\n            return s;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = s.length() - 1; i >= 0; i--) {\n            sb.append(s.charAt(i));",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60099/ac-in-288-ms-simple-brute-force/",
                "vote_count": "378"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        k = next((i for i in range(len(s), 0, -1) if s[:i] == s[:i][::-1]), 0)\n        return s[k:][::-1] + s",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60099/ac-in-288-ms-simple-brute-force/",
                "vote_count": "378"
            },
            {
                "language": "python",
                "code": "class Solution(object):\n    def shortestPalindrome(self, s):\n        def isP(s, lo, hi):\n            while lo<hi:\n                if s[lo] != s[hi]:\n                    return False\n                lo += 1\n                hi -= 1",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60099/ac-in-288-ms-simple-brute-force/",
                "vote_count": "378"
            },
            {
                "language": "lisp",
                "code": "    int j = 0;\n    for (int i = s.length() - 1; i >= 0; i--) {\n        if (s.charAt(i) == s.charAt(j)) { j += 1; }\n    }\n    if (j == s.length()) { return s; }\n    String suffix = s.substring(j);\n    return new StringBuffer(suffix).reverse().toString() + shortestPalindrome(s.substring(0, j)) + suffix;",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60098/my-7-lines-recursive-java-solution/",
                "vote_count": "251"
            },
            {
                "language": "",
                "code": "aabababababababababababababa\naababababababababababababa\naabababababababababababa\naababababababababababa\naabababababababababa",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60098/my-7-lines-recursive-java-solution/",
                "vote_count": "251"
            },
            {
                "language": "lisp",
                "code": "    for (int i = s.length() - 1; i >= 0; i--) {\n        if (s.charAt(i) == s.charAt(j)) { j += 1; }",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60098/my-7-lines-recursive-java-solution/",
                "vote_count": "251"
            },
            {
                "language": "ruby",
                "code": "public String shortestPalindrome(String s) {\n        StringBuilder res = new StringBuilder();\n        int j=0, end = s.length();\n        while(true){\n            j=0;\n            for(int i=end-1;i>=0;i--){\n                if(s.charAt(i) == s.charAt(j)) j++;\n            }\nsubstring(end, s.length()));",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60098/my-7-lines-recursive-java-solution/",
                "vote_count": "251"
            },
            {
                "language": "java",
                "code": "int N = 10000;\nstring s = \"aaaaa\"\nfor (int i = 0; i < N; i++) {",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60098/my-7-lines-recursive-java-solution/",
                "vote_count": "251"
            },
            {
                "language": "javascript",
                "code": "Length of String: 2000000. Total of all lengths: 2000000\nLength of String: 1000503. Total of all lengths: 3000503\nLength of String: 500559. Total of all lengths: 3501062\nLength of String: 250657. Total of all lengths: 3751719\nLength of String: 125204. Total of all lengths: 3876923",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60098/my-7-lines-recursive-java-solution/",
                "vote_count": "251"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        string rev_s = s;\n        reverse(rev_s.begin(), rev_s.end());\n        string l = s + \"#\" + rev_s;\n        \n        vector<int> p(l.size(), 0);\n        for (int i = 1; i < l.size(); i++) {\n            int j = p[i - 1];\n            while (j > 0 && l[i] != l[j])\n                j = p[j - 1];\n            p[i] = (j += l[i] == l[j]);\n        }\n        \n        return rev_s.substr(0, s.size() - p[l.size() - 1]) + s;\n    }\n};",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60141/c-8-ms-kmp-based-o-n-time-o-n-memory-solution/",
                "vote_count": "191"
            },
            {
                "language": "go",
                "code": "",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60141/c-8-ms-kmp-based-o-n-time-o-n-memory-solution/",
                "vote_count": "191"
            },
            {
                "language": "java",
                "code": "//beautiful algorithm  just add some comments \nclass Solution {\npublic:\n    string shortestPalindrome(string s) {\n        string rs = s;  // rs means reverse str of s;\n        std::reverse(rs.begin(), rs.end());\n        string mirror = s + \"#\" + rs;  // so if the s is aacecaaa the mirror is like               aacecaaa#aaacecaa\n        //now we run kmp algorithm on mirror we will get next fun of mirror, so mirror is just like a pattern in kmp algorithm\n        vector<int> next(mirror.size(),0);",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60141/c-8-ms-kmp-based-o-n-time-o-n-memory-solution/",
                "vote_count": "191"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\n    public String shortestPalindrome(String s) {\n        if(s.length() <= 1){ return s; }\n        String curs = s + \" \" + new StringBuilder(s).reverse().toString();\n        int[] trace = new int[curs.length()];\n        for(int i = 1 ; i < curs.length() ; i++){\n            int curindex = trace[i-1];\n            while(curindex > 0 && curs.charAt(curindex) != curs.charAt(i)){",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60141/c-8-ms-kmp-based-o-n-time-o-n-memory-solution/",
                "vote_count": "191"
            },
            {
                "language": "swift",
                "code": "for(int i = 1; i < 2 * s.length(); i++) {\n        int j = prefix[i-1];\n        while(j > 0 && a[i] != a[j])\n            j = prefix[j-1];\n        if(a[i] == a[j])\n            j++;\n        prefix[i] = j;\n}",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60141/c-8-ms-kmp-based-o-n-time-o-n-memory-solution/",
                "vote_count": "191"
            },
            {
                "language": "csharp",
                "code": "class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        int sn=s.size();\n        string rev=s;\n        reverse(rev.begin(), rev.end());\n        string ss=s+rev+\"#\";\n        int Next[sn*2+1];",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60141/c-8-ms-kmp-based-o-n-time-o-n-memory-solution/",
                "vote_count": "191"
            },
            {
                "language": "ruby",
                "code": "public String shortestPalindrome(String s) {\n    int i = 0, end = s.length() - 1, j = end; char chs[] = s.toCharArray();\n    while(i < j) {\n         if (chs[i] == chs[j]) {\n             i++; j--;\n         } else { \n             i = 0; end--; j = end;\n         }\n    }\n    return new StringBuilder(s.substring(end+1)).reverse().toString() + s;\n}",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60106/my-9-lines-three-pointers-java-solution-with-explanation/",
                "vote_count": "101"
            },
            {
                "language": "ruby",
                "code": "class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        int i=0, end=s.length()-1, j=end;\n        \n        while(i<j)\n        {\n            if (s[i]==s[j])",
                "url": "https://leetcode.com/problems/shortest-palindrome/solutions/60106/my-9-lines-three-pointers-java-solution-with-explanation/",
                "vote_count": "101"
            }
        ]
    },
    "190": {
        "question_id": 215,
        "title": "Kth Largest Element in an Array",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.Note that it is the kth largest element in the sorted order, not the kth distinct element.You must solve it in O(n) time complexity. ",
        "examples": [
            {
                "input": "nums = [3,2,1,5,6,4], k = 2",
                "output": "5",
                "explanation": null
            }
        ],
        "constraints": [],
        "solutions": [
            {
                "language": "cpp",
                "code": "public int findKthLargest(int[] nums, int k) {\n        final int N = nums.length;\n        Arrays.sort(nums);\n        return nums[N - k];\n}",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60294/solution-explained/",
                "vote_count": "1286"
            },
            {
                "language": "cpp",
                "code": "public int findKthLargest(int[] nums, int k) {\n\n    final PriorityQueue<Integer> pq = new PriorityQueue<>();\n    for(int val : nums) {\n        pq.offer(val);\n\n        if(pq.size() > k) {\n            pq.poll();\n        }\n    }\n    return pq.peek();\n}",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60294/solution-explained/",
                "vote_count": "1286"
            },
            {
                "language": "java",
                "code": "public int findKthLargest(int[] nums, int k) {\n\n        k = nums.length - k;\n        int lo = 0;\n        int hi = nums.length - 1;\n        while (lo < hi) {\n            final int j = partition(nums, lo, hi);\n            if(j < k) {\n                lo = j + 1;\n            } else if (j > k) {\n                hi = j - 1;\n            } else {\n                break;\n            }\n        }\n        return nums[k];\n    }\n\n    private int partition(int[] a, int lo, int hi) {\n\n        int i = lo;\n        int j = hi + 1;\n        while(true) {\n            while(i < hi && less(a[++i], a[lo]));\n            while(j > lo && less(a[lo], a[--j]));\n            if(i >= j) {\n                break;\n            }\n            exch(a, i, j);\n        }\n        exch(a, lo, j);\n        return j;\n    }\n\n    private void exch(int[] a, int i, int j) {\n        final int tmp = a[i];\n        a[i] = a[j];\n        a[j] = tmp;\n    }\n\n    private boolean less(int v, int w) {\n        return v < w;\n    }",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60294/solution-explained/",
                "vote_count": "1286"
            },
            {
                "language": "java",
                "code": "public int findKthLargest(int[] nums, int k) {\n\n        shuffle(nums);\n        k = nums.length - k;\n        int lo = 0;\n        int hi = nums.length - 1;\n        while (lo < hi) {\n            final int j = partition(nums, lo, hi);\n            if(j < k) {\n                lo = j + 1;\n            } else if (j > k) {\n                hi = j - 1;\n            } else {\n                break;\n            }\n        }\n        return nums[k];\n    }\n\nprivate void shuffle(int a[]) {\n\n        final Random random = new Random();\n        for(int ind = 1; ind < a.length; ind++) {\n            final int r = random.nextInt(ind + 1);\n            exch(a, ind, r);\n        }\n    }",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60294/solution-explained/",
                "vote_count": "1286"
            },
            {
                "language": "cpp",
                "code": "    private int partition(int[] nums, int lo, int hi) {\n        int pivot = nums[hi];\n        int i = lo;",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60294/solution-explained/",
                "vote_count": "1286"
            },
            {
                "language": "java",
                "code": "//move the k largest elements to the left part of array\npublic class Solution {\n    public int findKthLargest(int[] nums, int k) {\n        if(nums.length == 1) return nums[0];\n\n        int left = 0;\n        int right = nums.length - 1;",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60294/solution-explained/",
                "vote_count": "1286"
            },
            {
                "language": "cpp",
                "code": "public class Solution {\n     public int findKthLargest(int[] nums, int k) {\n         return findK(nums,nums.length - k,0,nums.length-1);\n     }",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60294/solution-explained/",
                "vote_count": "1286"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        nth_element(nums.begin(), nums.begin() + k - 1, nums.end(), greater<int>());\n        return nums[k - 1];\n    }\n};",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60309/c-stl-partition-and-heapsort/",
                "vote_count": "1027"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        partial_sort(nums.begin(), nums.begin() + k, nums.end(), greater<int>());\n        return nums[k - 1];\n    }\n};",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60309/c-stl-partition-and-heapsort/",
                "vote_count": "1027"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        priority_queue<int, vector<int>, greater<int>> pq;\n        for (int num : nums) {\n            pq.push(num);\n            if (pq.size() > k) {\n                pq.pop();\n            }\n        }\n        return pq.top();\n    }\n};",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60309/c-stl-partition-and-heapsort/",
                "vote_count": "1027"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        priority_queue<int> pq(nums.begin(), nums.end());\n        for (int i = 0; i < k - 1; i++) {\n            pq.pop();\n        }\n        return pq.top();\n    }\n};",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60309/c-stl-partition-and-heapsort/",
                "vote_count": "1027"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        multiset<int> mset;\n        for (int num : nums) {\n            mset.insert(num);\n            if (mset.size() > k) {\n                mset.erase(mset.begin());\n            }\n        }\n        return *mset.begin();\n    }\n};",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60309/c-stl-partition-and-heapsort/",
                "vote_count": "1027"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        multiset<int, greater<int>> mset(nums.begin(), nums.end());\n        for (int i = 0; i < k - 1; i++) {\n            mset.erase(mset.begin());\n        }\n        return *mset.begin();\n    }\n};",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60309/c-stl-partition-and-heapsort/",
                "vote_count": "1027"
            },
            {
                "language": "",
                "code": "elements>=pivot pivot elements<=pivot",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60309/c-stl-partition-and-heapsort/",
                "vote_count": "1027"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        int left = 0, right = nums.size() - 1, kth;\n        while (true) {\n            int idx = partition(nums, left, right);\n            if (idx == k - 1) {\n                kth = nums[idx];\n                break;\n            }\n            if (idx < k - 1) {\n                left = idx + 1;\n            } else {\n                right = idx - 1;\n            }\n        }\n        return kth;\n    }\nprivate:\n    int partition(vector<int>& nums, int left, int right) {\n        int pivot = nums[left], l = left + 1, r = right;\n        while (l <= r) {\n            if (nums[l] < pivot && nums[r] > pivot) {\n                swap(nums[l++], nums[r--]);\n            }\n            if (nums[l] >= pivot) {\n                l++;\n            }\n            if (nums[r] <= pivot) {\n                r--;\n            }\n        }\n        swap(nums[left], nums[r]);\n        return r;\n    }\n};",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60309/c-stl-partition-and-heapsort/",
                "vote_count": "1027"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        buildMaxHeap(nums);\n        for (int i = 0; i < k - 1; i++) {\n            swap(nums[0], nums[--heapSize]);\n            maxHeapify(nums, 0);\n        }\n        return nums[0];\n    }\nprivate:\n    int heapSize;\n    \n    int left(int i) {\n        return (i << 1) + 1;\n    }\n    \n    int right(int i) {\n        return (i << 1) + 2;\n    }\n    \n    void maxHeapify(vector<int>& nums, int i) {\n        int largest = i, l = left(i), r = right(i);\n        if (l < heapSize && nums[l] > nums[largest]) {\n            largest = l;\n        }\n        if (r < heapSize && nums[r] > nums[largest]) {\n            largest = r;\n        }\n        if (largest != i) {\n            swap(nums[i], nums[largest]);\n            maxHeapify(nums, largest);\n        }\n    }\n    \n    void buildMaxHeap(vector<int>& nums) {\n        heapSize = nums.size();\n        for (int i = (heapSize >> 1) - 1; i >= 0; i--) {\n            maxHeapify(nums, i);\n        }\n    }\n};",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60309/c-stl-partition-and-heapsort/",
                "vote_count": "1027"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60309/c-stl-partition-and-heapsort/",
                "vote_count": "1027"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60309/c-stl-partition-and-heapsort/",
                "vote_count": "1027"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60309/c-stl-partition-and-heapsort/",
                "vote_count": "1027"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        priority_queue<int, vector<int>, greater<int> > pq;\n        \n        for(int i = 0; i < nums.size(); i++)\n        {",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60309/c-stl-partition-and-heapsort/",
                "vote_count": "1027"
            },
            {
                "language": "kotlin",
                "code": "return nums[nums.size() - k];",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/60309/c-stl-partition-and-heapsort/",
                "vote_count": "1027"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def findKthLargest(self, nums, k):\n        if not nums: return\n        pivot = random.choice(nums)\n        left =  [x for x in nums if x > pivot]\n        mid  =  [x for x in nums if x == pivot]\n        right = [x for x in nums if x < pivot]\n        \n        L, M = len(left), len(mid)\n        \n        if k <= L:\n            return self.findKthLargest(left, k)\n        elif k > L + M:\n            return self.findKthLargest(right, k - L - M)\n        else:\n            return mid[0]",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/1019513/python-quickselect-average-o-n-explained/",
                "vote_count": "513"
            },
            {
                "language": "go",
                "code": "    def findKthLargest(self, nums: List[int], k: int) -> int:\n        \"\"\"Quickselect method recursive\"\"\"\n        pivot = choice(nums)\n\n        greater = [x for x in nums if x > pivot]\n        equal = [x for x in nums if x == pivot]",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/1019513/python-quickselect-average-o-n-explained/",
                "vote_count": "513"
            },
            {
                "language": "java",
                "code": "function quickSelect(nums, left, right, k)\n   if left = right return nums[left]   // base case\n\n   pIndex = random element between left and right\n   pIndex = partition(nums, left, right, pIndex)\n   \n   if k = pIndex\n      return nums[k]\n   else if k < pIndex\n      return quickselect with: right = pIndex - 1\n   else\n      return quickselect with: left = pIndex + 1",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/2180600/a-guide-to-quick-select-java/",
                "vote_count": "185"
            },
            {
                "language": "java",
                "code": "public int findKthLargest(int[] nums, int k) {\n return quickSelect(nums, 0, nums.length-1, nums.length-k);\n}\n\nprivate int quickSelect(int[] nums, int left, int right, int k) {\n if (left == right) return nums[left];\n\n int pIndex = new Random().nextInt(right - left + 1) + left;\n pIndex = partition(nums, left, right, pIndex);\n\n if (pIndex == k) return nums[k];\n else if (pIndex < k) return quickSelect(nums, pIndex+1, right, k);\n return quickSelect(nums, left, pIndex-1, k);\n}\n\nprivate int partition(int[] nums, int left, int right, int pIndex) {\n int pivot = nums[pIndex];\n swap(nums, pIndex, right);\n pIndex = left;\n\n for (int i=left; i<=right; i++) \n  if (nums[i] <= pivot) \n   swap(nums, i, pIndex++);\n\n return pIndex - 1;\n}\n\nprivate void swap(int[] nums, int x, int y) {\n int temp = nums[x];\n nums[x] = nums[y];\n nums[y] = temp;\n}",
                "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/2180600/a-guide-to-quick-select-java/",
                "vote_count": "185"
            }
        ]
    },
    "191": {
        "question_id": 216,
        "title": "Combination Sum III",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/combination-sum-iii",
        "description": "Find all valid combinations of k numbers that sum up to n such that the following conditions are true:Only numbers 1 through 9 are used.Each number is used at most once.Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order. ",
        "examples": [
            {
                "input": "k = 3, n = 7",
                "output": "[[1,2,4]]\nExplanation:\n1 + 2 + 4 = 7\nThere are no other valid combinations",
                "explanation": null
            },
            {
                "input": "k = 3, n = 9",
                "output": "[[1,2,6],[1,3,5],[2,3,4]]\nExplanation:\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\nThere are no other valid combinations.",
                "explanation": null
            },
            {
                "input": "k = 4, n = 1",
                "output": "[]",
                "explanation": "There are no valid combinations.\nUsing 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination."
            }
        ],
        "constraints": [
            "2 <= k <= 9",
            "1 <= n <= 60"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\n    \n    vector<vector<int>> ansArr;\n    \npublic:\n    \n    int sum(vector<int>& combination){\n        int ans = 0;\n        for(auto x: combination){\n            ans += x;\n        }\n        return ans;\n    }\n    \n    void combinationSumHelper(int k, int n, vector<int>& combination, int num){\n        \n        if(k == 0){\n            if(sum(combination) == n ){\n                ansArr.push_back(combination);\n            }\n            return;\n        }\n        \n        if(num > 9) return;\n        \n        combination.push_back(num);  // Including num in combination\n        combinationSumHelper(k - 1, n, combination, num + 1);\n        combination.pop_back(); // Not including num in combination\n        combinationSumHelper(k, n, combination, num + 1);    \n        \n    }\n    \n    vector<vector<int>> combinationSum3(int k, int n) {\n        \n        vector<int> combination;\n        combinationSumHelper(k, n, combination, 1);\n        return ansArr;\n        \n    }\n};",
                "url": "https://leetcode.com/problems/combination-sum-iii/solutions/2024061/c-faster-than-100-implementation-explained/",
                "vote_count": "53"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector< vector<int> > ret;\n    \n    void rec(int count, int k, int n, int sum, vector<int>tmp, int start){\n        if(k == count){\n            if(n == sum){",
                "url": "https://leetcode.com/problems/combination-sum-iii/solutions/2024061/c-faster-than-100-implementation-explained/",
                "vote_count": "53"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/combination-sum-iii/solutions/2024061/c-faster-than-100-implementation-explained/",
                "vote_count": "53"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    void solve(vector<int> &coins, int idx, int target, int k, vector<vector<int>> &ans, vector<int> &tmp) {\n        \n        if(idx >= coins.size() || target < 0) {\n            return;",
                "url": "https://leetcode.com/problems/combination-sum-iii/solutions/2024061/c-faster-than-100-implementation-explained/",
                "vote_count": "53"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum3(int k, int n) {\n        \n        vector<vector<int>> result;",
                "url": "https://leetcode.com/problems/combination-sum-iii/solutions/2024061/c-faster-than-100-implementation-explained/",
                "vote_count": "53"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    \n    void check(int ind,int sum,vector<vector<int>> &vv,vector<int> &v,vector<int> &arr,int k,int n){\n        \n        if(v.size()>=k || ind>=arr.size() || sum>=n){\n            ",
                "url": "https://leetcode.com/problems/combination-sum-iii/solutions/2024061/c-faster-than-100-implementation-explained/",
                "vote_count": "53"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> res = new ArrayList<>();\n        solve(1, k, n, new ArrayList<>(), res);\n        return res;\n    }\n    public void solve(int start, int k, int n, List<Integer> temp, List<List<Integer>> res){\n        if(temp.size() == k){\n            res.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int i = start; i <= n; i++){\n            temp.add(i);\n            solve(i + 1, k, n, temp, res);\n            temp.remove(temp.size() - 1);\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/combination-sum-iii/solutions/2024085/combinations-all-types-solution-meme/",
                "vote_count": "46"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        List<List<Integer>> res = new ArrayList<>();\n        solve(1, k, n, new ArrayList<>(), res);\n        return res;\n    }\n    public void solve(int start, int k, int n, List<Integer> temp, List<List<Integer>> res){\n        if(n == 0 && temp.size() == k){\n            res.add(new ArrayList<>(temp));\n        }\n        for(int i = start; i <= 9; i++){\n            temp.add(i);\n            solve(i + 1, k, n - i, temp, res);\n            temp.remove(temp.size() - 1);\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/combination-sum-iii/solutions/2024085/combinations-all-types-solution-meme/",
                "vote_count": "46"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        solve(0, candidates, target, new ArrayList<>(), res);\n        return res;\n    }\n    public void solve(int start, int nums[], int target, List<Integer> temp, List<List<Integer>> res){\n        if(target == 0){\n            res.add(new ArrayList<>(temp));\n            return;\n        }\n        if(target > 0){\n            for(int i = start; i < nums.length; i++){\n                temp.add(nums[i]);\n                solve(i, nums, target - nums[i], temp, res);\n                temp.remove(temp.size() - 1);\n            }\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/combination-sum-iii/solutions/2024085/combinations-all-types-solution-meme/",
                "vote_count": "46"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        List<List<Integer>> res = new ArrayList<>();\n        solve(0, candidates, target, new ArrayList<>(), res);\n        return res;\n    }\n    public void solve(int start, int nums[], int target, List<Integer> temp, List<List<Integer>> res){\n        if(target == 0){\n            res.add(new ArrayList<>(temp));\n            return;\n        }\n        if(target > 0){\n            for(int i = start; i < nums.length; i++){\n                if(i > start && nums[i] == nums[i - 1]) continue;\n                temp.add(nums[i]);\n                solve(i + 1, nums, target - nums[i], temp, res);\n                temp.remove(temp.size() - 1);\n            }\n        }\n    }\n}",
                "url": "https://leetcode.com/problems/combination-sum-iii/solutions/2024085/combinations-all-types-solution-meme/",
                "vote_count": "46"
            },
            {
                "language": "ruby",
                "code": "MEME Time :-",
                "url": "https://leetcode.com/problems/combination-sum-iii/solutions/2024085/combinations-all-types-solution-meme/",
                "vote_count": "46"
            },
            {
                "language": "csharp",
                "code": " public List<List<Integer>> combinationSum3(int k, int n) {\n\n        List<List<Integer>> result = new ArrayList<>();\n\n        combinationSum3Util(k, n, new ArrayList<>(), result, 1);\n        return result;\n\n    }\n, int start) {",
                "url": "https://leetcode.com/problems/combination-sum-iii/solutions/2024085/combinations-all-types-solution-meme/",
                "vote_count": "46"
            }
        ]
    },
    "192": {
        "question_id": 217,
        "title": "Contains Duplicate",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/contains-duplicate",
        "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. ",
        "examples": [
            {
                "input": "nums = [1,2,3,1]",
                "output": "true",
                "explanation": null
            },
            {
                "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
                "output": "true",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 10^5",
            "-10^9 <= nums[i] <= 10^9"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "// Brute Force\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        bool flag = false;\n        for(int i =0;i<nums.size();i++){\n            for(int j=i+1;j<nums.size();j++){\n                if(nums[i] == nums[j]) return true;\n            }\n        }\n        return flag;\n    }\n};",
                "url": "https://leetcode.com/problems/contains-duplicate/solutions/2728722/all-possible-easy-solution-with-single-line-code-c/",
                "vote_count": "1029"
            },
            {
                "language": "cpp",
                "code": "// Shorted Approach\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        bool flag = false;\n        for(int i =0;i<nums.size()-1;i++){\n            if(nums[i] == nums[i+1]) return true;\n        }\n        return flag;\n    }\n};",
                "url": "https://leetcode.com/problems/contains-duplicate/solutions/2728722/all-possible-easy-solution-with-single-line-code-c/",
                "vote_count": "1029"
            },
            {
                "language": "cpp",
                "code": "// Set Approach\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        return nums.size() > set<int>(nums.begin(),nums.end()).size();\n    }\n};",
                "url": "https://leetcode.com/problems/contains-duplicate/solutions/2728722/all-possible-easy-solution-with-single-line-code-c/",
                "vote_count": "1029"
            },
            {
                "language": "cpp",
                "code": "// Contains Duplicate\n  class Solution {\n  public:\n      bool containsDuplicate(vector<int>& nums) {\n          map<int,int> mp;\n          for(auto i : nums) mp[i]++;\n          bool flag = false;\n          for(auto i : mp){\n              if(i.second >= 2) return true;\n          }\n          return flag;\n      }\n  };",
                "url": "https://leetcode.com/problems/contains-duplicate/solutions/2728722/all-possible-easy-solution-with-single-line-code-c/",
                "vote_count": "1029"
            },
            {
                "language": "cpp",
                "code": "/** Approach : Using Set **/\n// Time Complexity: O(n)\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        // Create a set...\n        unordered_set<int> hset;\n        // Traverse all the elements through the loop...\n        for(int idx = 0; idx < nums.size(); idx++) {\n            // Searches set. if present, it contains duplicate...\n            if(hset.count(nums[idx]))\n                return true;\n            // insert nums[i] in set...\n            hset.insert(nums[idx]);\n        }\n        return false;\n    }\n};\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n/**   Approach : Sort & Find Duplicates **/\n// Time Complexity: O(nlogn)\n// Space Complexity: O(1)\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        // Sort the nums...\n        sort(nums.begin(), nums.end());\n        // Traverse all the elements through the loop...\n        for(int idx = 0; idx < nums.size() - 1; idx++) {\n            // Check the duplicate element...\n            if(nums[idx] == nums[idx + 1])\n                return true;\n        }\n        // Otherwise return false...\n        return false;\n    }\n};",
                "url": "https://leetcode.com/problems/contains-duplicate/solutions/2459020/very-easy-100-fully-explained-c-java-python-javascript-python3-creating-set/",
                "vote_count": "435"
            },
            {
                "language": "java",
                "code": "// Time complexity: O(n)\n// Space complexity: O(n)\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        // Create a hashset...\n        HashSet<Integer> hset = new HashSet<Integer>();\n        // Traverse all the elements through the loop...\n        for (int idx = 0; idx < nums.length; idx ++){\n            // Searches hashset. if present, it contains duplicate...\n            if (hset.contains(nums[idx])){\n                return true;\n            }\n            // if not present it will update hashset...\n            hset.add(nums[idx]);\n        }\n        // Otherwise return false...\n        return false;\n    }\n}\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------\n// Time complexity: O(n)\n// Space complexity: O(n)\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        // Base case...\n        if(nums==null || nums.length==0)\n            return false;\n        // Create a hashset...\n        HashSet<Integer> hset = new HashSet<Integer>();\n        // Traverse all the elements through the loop...\n        for(int idx: nums){\n            // If it contains duplicate...\n            if(!hset.add(idx)){\n                return true;\n            }\n        }\n        // Otherwise return false...\n        return false;\n    }\n}",
                "url": "https://leetcode.com/problems/contains-duplicate/solutions/2459020/very-easy-100-fully-explained-c-java-python-javascript-python3-creating-set/",
                "vote_count": "435"
            },
            {
                "language": "python",
                "code": "# Time complexity: O(n)\n# Space complexity: O(n)\nclass Solution(object):\n    def containsDuplicate(self, nums):\n        hset = set()\n        for idx in nums:\n            if idx in hset:\n                return True\n            else:\n                hset.add(idx)",
                "url": "https://leetcode.com/problems/contains-duplicate/solutions/2459020/very-easy-100-fully-explained-c-java-python-javascript-python3-creating-set/",
                "vote_count": "435"
            },
            {
                "language": "javascript",
                "code": "// Time complexity: O(n)\n// Space complexity: O(n)\nvar containsDuplicate = function(nums) {\n    const s = new Set(nums); return s.size !== nums.length\n};",
                "url": "https://leetcode.com/problems/contains-duplicate/solutions/2459020/very-easy-100-fully-explained-c-java-python-javascript-python3-creating-set/",
                "vote_count": "435"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Arrays.sort(nums); \n        for (int i = 0; i < nums.length - 1; i++) {\n                if (nums[i] == nums[i+1]) {\n                    return true;\n                }\n        }\n        return false;\n    }\n}",
                "url": "https://leetcode.com/problems/contains-duplicate/solutions/3163705/java-best-solution-3-ways/",
                "vote_count": "227"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(nums[i])) {\n                return true;\n            }\n            map.put(nums[i],1);\n        }\n        return false;\n    }\n}",
                "url": "https://leetcode.com/problems/contains-duplicate/solutions/3163705/java-best-solution-3-ways/",
                "vote_count": "227"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        HashSet<Integer> set = new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n                if (set.contains(nums[i])) {\n                    return true;\n                }\n                set.add(nums[i]);\n        }\n        return false;\n    }\n}",
                "url": "https://leetcode.com/problems/contains-duplicate/solutions/3163705/java-best-solution-3-ways/",
                "vote_count": "227"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        return len(set(nums))!=len(nums)",
                "url": "https://leetcode.com/problems/contains-duplicate/solutions/3257522/one-line-code-python3/",
                "vote_count": "85"
            },
            {
                "language": "python",
                "code": "def containsDuplicate(nums):\n return len(set(nums)) != len(nums)",
                "url": "https://leetcode.com/problems/contains-duplicate/solutions/2677785/python-1-liner/",
                "vote_count": "64"
            },
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar containsDuplicate = function(nums) {\n    nums.sort((a,b) => a-b);\n    for(let i = 0; i <= nums.length-1; i++){\n        if(nums[i] === nums[i+1]){\n            return true\n        }\n    }\n    return false\n};",
                "url": "https://leetcode.com/problems/contains-duplicate/solutions/3217571/javascript-easiest-logic-ever/",
                "vote_count": "35"
            },
            {
                "language": "javascript",
                "code": "// Time complexity: O(n)\n// Space complexity: O(n)\nvar containsDuplicate = function(nums) {\n    const s = new Set(nums); \n    return s.size !== nums.length\n};",
                "url": "https://leetcode.com/problems/contains-duplicate/solutions/3217571/javascript-easiest-logic-ever/",
                "vote_count": "35"
            },
            {
                "language": "cpp",
                "code": "/*\n\n    Time Complexity : O(N^2), where N is the size of the array(nums). As we check for possible pair, and the\n    total number of pairs are : N*(N\u20131)/2.\n\n    Space complexity : O(1), Constant space.\n\n    Using Array(Two Nested Loop). Brute Force Approach.\n\n    Note : this will give TLE.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        int n = nums.size();\n        for(int i=0; i<n; i++){\n            for(int j=i+1; j<n; j++){\n                if(nums[i] == nums[j]){\n                    return ture;\n                }\n            }\n        }\n        return false;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(NlogN), Sorting creates the time complexity. Where N is the size of the array(nums).\n\n    Space complexity : O(1), Constant space.\n\n    Using Array + Sorting. Brute Better Approach.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        sort(nums.begin() , nums.end());\n        for(int i=0; i<nums.size()-1; i++){\n            if(nums[i] == nums[i+1]){\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N), Here loop creates the time complexity. Where N is the size of the array(nums).\n\n    Space complexity : O(N), Hash Table(unordered map) space.\n\n    Using Array + Hash Table. Optimized Approach.\n\n*/\n\n\n/***************************************** Approach 3 *****************************************/\n\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        unordered_map<long,long> map;   \n        for(int i=0; i<nums.size(); i++){\n            map[nums[i]]++;\n        }\n        for(int i=0; i<nums.size(); i++){\n            if(map[nums[i]] > 1){\n                return true;\n            }\n        }\n        return false;\n    }\n};",
                "url": "https://leetcode.com/problems/contains-duplicate/solutions/3216138/best-c-3-solution-hash-table-two-pointers-brute-force-optimize/",
                "vote_count": "21"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        x=set(nums)\n        return not len(nums)==len(x)\n        #please do upvote if found helpful.",
                "url": "https://leetcode.com/problems/contains-duplicate/solutions/3257460/easiest-maths-problem-ever-in-python/",
                "vote_count": "10"
            }
        ]
    },
    "193": {
        "question_id": 218,
        "title": "The Skyline Problem",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/the-skyline-problem",
        "description": "A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.The geometric information of each building is given in the array buildings where buildings[i] = [lefti, righti, heighti]:lefti is the x coordinate of the left edge of the ith building.righti is the x coordinate of the right edge of the ith building.heighti is the height of the ith building.You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.The skyline should be represented as a list of \"key points\" sorted by their x-coordinate in the form [[x1,y1],[x2,y2],...]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...,[2 3],[4 5],[7 5],[11 5],[12 7],...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...,[2 3],[4 5],[12 7],...] ",
        "examples": [
            {
                "input": "buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]",
                "output": "[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\nExplanation:\nFigure A shows the buildings of the input.\nFigure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.",
                "explanation": null
            },
            {
                "input": "buildings = [[0,2,3],[2,5,3]]",
                "output": "[[0,3],[5,0]]",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= buildings.length <= 10^4",
            "0 <= lefti < righti <= 2^31 - 1",
            "1 <= heighti <= 2^31 - 1",
            "buildings is sorted by lefti in\u00a0non-decreasing order."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": " public List<int[]> getSkyline(int[][] buildings) {\n    List<int[]> result = new ArrayList<>();\n    List<int[]> height = new ArrayList<>();\n    for(int[] b:buildings) {\n        height.add(new int[]{b[0], -b[2]});\n        height.add(new int[]{b[1], b[2]});\n    }\n    Collections.sort(height, (a, b) -> {\n            if(a[0] != b[0]) \n                return a[0] - b[0];\n            return a[1] - b[1];\n    });\n    Queue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\n    pq.offer(0);\n    int prev = 0;\n    for(int[] h:height) {\n        if(h[1] < 0) {\n            pq.offer(-h[1]);\n        } else {\n            pq.remove(h[1]);\n        }\n        int cur = pq.peek();\n        if(prev != cur) {\n            result.add(new int[]{h[0], cur});\n            prev = cur;\n        }\n    }\n    return result;\n}",
                "url": "https://leetcode.com/problems/the-skyline-problem/solutions/61193/short-java-solution/",
                "vote_count": "474"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public List<int[]> getSkyline(int[][] buildings) {\n        List<int[]> heights = new ArrayList<>();\n        for (int[] b: buildings) {\n            heights.add(new int[]{b[0], - b[2]});\n            heights.add(new int[]{b[1], b[2]});\n        }",
                "url": "https://leetcode.com/problems/the-skyline-problem/solutions/61193/short-java-solution/",
                "vote_count": "474"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<int[]> getSkyline(int[][] buildings) {\n        List<int[]> res = new ArrayList<>();\n        List<int[]> height = new ArrayList<>();     // height list to store all buildings' heights\n        for (int[] b : buildings) {",
                "url": "https://leetcode.com/problems/the-skyline-problem/solutions/61193/short-java-solution/",
                "vote_count": "474"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public List<int[]> getSkyline(int[][] buildings) {\n        List<int[]> res = new ArrayList<>();\n        List<int[]> height = new ArrayList<>();\n        for (int[] building : buildings) {\n            // start point has negative height value\n            height.add(new int[]{building[0], -building[2]});\n            // end point has normal height value",
                "url": "https://leetcode.com/problems/the-skyline-problem/solutions/61193/short-java-solution/",
                "vote_count": "474"
            },
            {
                "language": "java",
                "code": "",
                "url": "https://leetcode.com/problems/the-skyline-problem/solutions/61193/short-java-solution/",
                "vote_count": "474"
            },
            {
                "language": "csharp",
                "code": "public List<int[]> getSkyline(int[][] buildings) {\n        List<int[]> heights = new ArrayList<>();\n        for (int[] b : buildings) {\n            // Nice trick to put negative height for the left edge\n            heights.add(new int[] {b[0], -b[2]});\n            heights.add(new int[] {b[1], b[2]});\n        }\n        Collections.sort(heights, (a, b) -> a[0] != b[0] ? \n] - b[1]);",
                "url": "https://leetcode.com/problems/the-skyline-problem/solutions/61193/short-java-solution/",
                "vote_count": "474"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public List<int[]> getSkyline(int[][] buildings) {\n        List<int[]> points = new ArrayList<>();\n        for(int [] b : buildings){\n            points.add(new int[]{b[0], -b[2]});\n            points.add(new int[]{b[1], b[2]});\n        }\n        Collections.sort(points, new Comparator<int[]>(){",
                "url": "https://leetcode.com/problems/the-skyline-problem/solutions/61193/short-java-solution/",
                "vote_count": "474"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {\n        vector<vector<int>> ans;\n        multiset<int> pq{0};\n        \n        vector<pair<int, int>> points;\n        \n        for(auto b: buildings){\n            points.push_back({b[0], -b[2]});\n            points.push_back({b[1], b[2]});\n        }\n        \n        sort(points.begin(), points.end());\n        \n        int ongoingHeight = 0;\n        \n        // points.first = x coordinate, points.second = height\n        for(int i = 0; i < points.size(); i++){\n            int currentPoint = points[i].first;\n            int heightAtCurrentPoint = points[i].second;\n            \n            if(heightAtCurrentPoint < 0){\n                pq.insert(-heightAtCurrentPoint);\n            } else {\n                pq.erase(pq.find(heightAtCurrentPoint));\n            }\n            \n            // after inserting/removing heightAtI, if there's a change\n            auto pqTop = *pq.rbegin();\n            if(ongoingHeight != pqTop){\n                ongoingHeight = pqTop;\n                ans.push_back({currentPoint, ongoingHeight});\n            }\n        }\n        \n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/the-skyline-problem/solutions/2094329/c-easiest-explanation-ever-guaranteed-beginner-friendly-detailed-o-nlogn/",
                "vote_count": "163"
            },
            {
                "language": "cpp",
                "code": "vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {\n        vector<pair<int, int>> h;\n  \n        // Convert each building into two segments.\n        for (auto b : buildings) {\n            h.push_back({b[0], -b[2]});\n            h.push_back({b[1], b[2]});\n        }\n        \n        // Sort the segments.\n        sort(h.begin(), h.end());\n        int prev = 0, cur = 0;\n        \n        multiset<int> m;\n        vector<vector<int>> res;\n        \n        m.insert(0);\n        for (auto i:h) {\n            \n            // If i.second is less than zero, then it means it is left boundary.\n            if (i.second < 0) {\n                m.insert(-i.second);\n            } else { // else it is right boundary.\n                m.erase(m.find(i.second));\n            } \n            \n            cur = *m.rbegin();\n            \n            // If current maximum height is not equal to maximum previuous height, it is a key point.\n            if (cur != prev) {\n                res.push_back({i.first, cur});\n                prev = cur;\n            }\n        }\n        return res;\n}",
                "url": "https://leetcode.com/problems/the-skyline-problem/solutions/2640775/c-line-sweep-easy-understanding/",
                "vote_count": "39"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {\n        int edge_idx = 0;\n        vector<pair<int, int>> edges;\n        priority_queue<pair<int, int>> pq;\n        vector<vector<int>> skyline;\n\n        for (int i = 0; i < buildings.size(); ++i) {\n            const auto &b = buildings[i];\n            edges.emplace_back(b[0], i);\n            edges.emplace_back(b[1], i);\n        }\n\n        std::sort(edges.begin(), edges.end());\n\n        while (edge_idx < edges.size()) {\n            int curr_height;\n            const auto &[curr_x, _] = edges[edge_idx];\n            while (edge_idx < edges.size() &&\n                    curr_x == edges[edge_idx].first) {\n                const auto &[_, building_idx] = edges[edge_idx];\n                const auto &b = buildings[building_idx];\n                if (b[0] == curr_x)\n                    pq.emplace(b[2], b[1]);\n                ++edge_idx;\n            }\n            while (!pq.empty() && pq.top().second <= curr_x)\n                pq.pop();\n            curr_height = pq.empty() ? 0 : pq.top().first;\n            if (skyline.empty() || skyline.back()[1] != curr_height)\n                skyline.push_back({curr_x, curr_height});\n        }\n        return skyline;\n    }\n};",
                "url": "https://leetcode.com/problems/the-skyline-problem/solutions/2997005/solution/",
                "vote_count": "28"
            }
        ]
    },
    "194": {
        "question_id": 219,
        "title": "Contains Duplicate II",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/contains-duplicate-ii",
        "description": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k. ",
        "examples": [
            {
                "input": "nums = [1,2,3,1], k = 3",
                "output": "true",
                "explanation": null
            },
            {
                "input": "nums = [1,0,1,1], k = 1",
                "output": "true",
                "explanation": null
            },
            {
                "input": "nums = [1,2,3,1,2,3], k = 2",
                "output": "false",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= nums.length <= 10^5",
            "-10^9 <= nums[i] <= 10^9",
            "0 <= k <= 10^5"
        ],
        "solutions": [
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n        unordered_map<int,int> mp;\n        int n = nums.size();\n        \n        for(int i=0; i<n; i++)\n        {\n            // mp.count() will tell whatever ith index that I want, have I seen it before?\n            if(mp.count(nums[i]))\n            {\n                // if I have already seen this number, then check for condition abs(i - j) <= k\n                if(abs(i-mp[nums[i]])<=k)\n                    return true;\n            }\n            // if I have not seen this number before, insert the number with its position in the map\n            // and if the number is already present in the map, then update the position of that number\n            mp[nums[i]] = i;\n        }\n        // after the complete traversal, if we don't find a pair to satisfy the condition, return false\n        return false;\n    }\n};",
                "url": "https://leetcode.com/problems/contains-duplicate-ii/solutions/2727290/c-easy-detailed-explaination-optimized/",
                "vote_count": "222"
            },
            {
                "language": "cpp",
                "code": "class Solution\n{\n  public:\n    // O(n) \n    bool containsNearbyDuplicate(vector<int>& nums, int k)\n    {\n        unordered_map<int, size_t> map;",
                "url": "https://leetcode.com/problems/contains-duplicate-ii/solutions/2727290/c-easy-detailed-explaination-optimized/",
                "vote_count": "222"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def containsNearbyDuplicate(self, nums: list[int], k: int) -> bool:\n\n        d = defaultdict(int)                                # d keeps track of most recent index of num (if seen)\n\n                                                            #  Ex:  nums = [1,2,3,1,6,0,2],  k = 5\n                                                            #                               num in d and\n        for i, num in enumerate(nums):                      #   i   num         d             i - j <= 5\n                                                            #  \u2013\u2013\u2013  \u2013\u2013\u2013 \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013 \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013 \n            if num in d and i - d[num] <= k: return True    #   0    1   {}                     False\n                                                            #   1    2   {1: 0}                 False\n            d[num] = i                                      #   2    3   {1: 0, 2: 1})          False\n                                                            #   3    1   {1: 0, 2: 1, 3: 2}     True    <= 3 - 0 <5\n        return False                                        #   |            |                             |   |",
                "url": "https://leetcode.com/problems/contains-duplicate-ii/solutions/2727273/python-3-5-lines-dict-w-example-t-m-95-76/",
                "vote_count": "26"
            },
            {
                "language": "java",
                "code": "class Solution:\n    def containsNearbyDuplicate(self, nums: list[int], k: int) -> bool:\n        for i in range(len(nums)):",
                "url": "https://leetcode.com/problems/contains-duplicate-ii/solutions/2727273/python-3-5-lines-dict-w-example-t-m-95-76/",
                "vote_count": "26"
            }
        ]
    },
    "195": {
        "question_id": 220,
        "title": "Contains Duplicate III",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/contains-duplicate-iii",
        "description": "You are given an integer array nums and two integers indexDiff and valueDiff.Find a pair of indices (i, j) such that:i != j,abs(i - j) <= indexDiff.abs(nums[i] - nums[j]) <= valueDiff, andReturn true if such pair exists or false otherwise. ",
        "examples": [
            {
                "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
                "output": "true",
                "explanation": "We can choose (i, j) = (0, 3).\nWe satisfy the three conditions:\ni != j --> 0 != 3\nabs(i - j) <= indexDiff --> abs(0 - 3) <= 3\nabs(nums[i] - nums[j]) <= valueDiff --> abs(1 - 1) <= 0"
            },
            {
                "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
                "output": "false",
                "explanation": "After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false."
            }
        ],
        "constraints": [
            "2 <= nums.length <= 10^5",
            "-10^9 <= nums[i] <= 10^9",
            "1 <= indexDiff <= nums.length",
            "0 <= valueDiff <= 10^9"
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": " public class Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n        if (k < 1 || t < 0) return false;\n        Map<Long, Long> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            long remappedNum = (long) nums[i] - Integer.MIN_VALUE;\n            long bucket = remappedNum / ((long) t + 1);\n            if (map.containsKey(bucket)\n                    || (map.containsKey(bucket - 1) && remappedNum - map.get(bucket - 1) <= t)\n                        || (map.containsKey(bucket + 1) && map.get(bucket + 1) - remappedNum <= t))\n                            return true;\n            if (map.entrySet().size() >= k) {\n                long lastBucket = ((long) nums[i - k] - Integer.MIN_VALUE) / ((long) t + 1);\n                map.remove(lastBucket);\n            }\n            map.put(bucket, remappedNum);\n        }\n        return false;\n    }\n}",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61645/ac-o-n-solution-in-java-using-buckets-with-explanation/",
                "vote_count": "498"
            },
            {
                "language": "csharp",
                "code": "public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n    if (k < 1 || t < 0) return false;\n    Map<Long, Long> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        long remappedNum = (long) nums[i] - Integer.MIN_VALUE;\n        long bucket = remappedNum / ((long) t + 1); // why t+1 ? because, if t not plus 1, when t == 0, num divide by 0 will cause crash.\n\n        if (map.containsKey(bucket) // means the key in the map duplicated, it means the must be exist two numbers that the different value between them are less than t\n                || (map.containsKey(bucket - 1) && remappedNum - map.get(bucket - 1) <= t) // if the two different numbers are located in two adjacent bucket, the value still might be less than t",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61645/ac-o-n-solution-in-java-using-buckets-with-explanation/",
                "vote_count": "498"
            },
            {
                "language": "lisp",
                "code": "if (map.containsKey(bucket)\n                    || (map.containsKey(bucket - 1) && remappedNum - map.get(bucket - 1) <= t)\n                        || (map.containsKey(bucket + 1) && map.get(bucket + 1) - remappedNum <= t))\n                            return true;",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61645/ac-o-n-solution-in-java-using-buckets-with-explanation/",
                "vote_count": "498"
            },
            {
                "language": "csharp",
                "code": "    Map<Long, Long> buckets = new HashMap<>();\n    \n    for(int i = 0; i < nums.length; i++){\n        //negative nums will cause edge cases of bucket targetting and bucket comparing, so reposition all nums, so that each num \n\n\n\n\n\n\n return true;",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61645/ac-o-n-solution-in-java-using-buckets-with-explanation/",
                "vote_count": "498"
            },
            {
                "language": "cpp",
                "code": "bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t)\n {\n  if (nums.size() < 2 || k < 1 || t < 0) return false;\n  unordered_map<long long, long long> bucket;\n  for (int i = 0; i < nums.size(); i++)\n  {\n   if (i > k) bucket.erase(((long long)nums[i - k - 1]  - INT_MIN) / ((long long)t + 1));\n   long long num = (long long)nums[i] - INT_MIN;",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61645/ac-o-n-solution-in-java-using-buckets-with-explanation/",
                "vote_count": "498"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n        if(nums.empty() || k < 1 || t < 0) return false;\n        unordered_map<long,long> bucket_mapper;\n        long min_val = * std::min_element(nums.begin(),nums.end());\n        long bucket_size = t+1; // t could be 0",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61645/ac-o-n-solution-in-java-using-buckets-with-explanation/",
                "vote_count": "498"
            },
            {
                "language": "lisp",
                "code": "(1) the two in the same bucket\n(2) the two in neighbor buckets",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61639/java-python-one-pass-solution-o-n-time-o-n-space-using-buckets/",
                "vote_count": "429"
            },
            {
                "language": "python",
                "code": "def containsNearbyAlmostDuplicate(self, nums, k, t):\n    if t < 0: return False\n    n = len(nums)\n    d = {}\n    w = t + 1\n    for i in xrange(n):\n        m = nums[i] / w\n        if m in d:\n            return True\n        if m - 1 in d and abs(nums[i] - d[m - 1]) < w:\n            return True\n        if m + 1 in d and abs(nums[i] - d[m + 1]) < w:\n            return True\n        d[m] = nums[i]\n        if i >= k: del d[nums[i - k] / w]\n    return False\n\n\n# 30 / 30 test cases passed.\n# Status: Accepted\n# Runtime: 56 ms\n# 93.81%",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61639/java-python-one-pass-solution-o-n-time-o-n-space-using-buckets/",
                "vote_count": "429"
            },
            {
                "language": "csharp",
                "code": "private long getID(long i, long w) {\n    return i < 0 ? (i + 1) / w - 1 : i / w;\n}\n\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n    if (t < 0) return false;\n    Map<Long, Long> d = new HashMap<>();\n    long w = (long)t + 1;\n    for (int i = 0; i < nums.length; ++i) {\n        long m = getID(nums[i], w);\n        if (d.containsKey(m))\n            return true;\n        if (d.containsKey(m - 1) && Math.abs(nums[i] - d.get(m - 1)) < w)\n            return true;\n        if (d.containsKey(m + 1) && Math.abs(nums[i] - d.get(m + 1)) < w)\n            return true;\n        d.put(m, (long)nums[i]);\n        if (i >= k) d.remove(getID(nums[i - k], w));\n    }\n    return false;\n}",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61639/java-python-one-pass-solution-o-n-time-o-n-space-using-buckets/",
                "vote_count": "429"
            },
            {
                "language": "rust",
                "code": "w = 3\n\ni  i/w* desired**\n-5 -1   -2\n-4 -1   -2",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61639/java-python-one-pass-solution-o-n-time-o-n-space-using-buckets/",
                "vote_count": "429"
            },
            {
                "language": "python",
                "code": "def containsNearbyAlmostDuplicate(self, nums, k, t):\n    if k < 0 or t < 0:\n        return False\n        \n    bucket = {}\n\n    for i, num in enumerate(nums):\n        bucket_id = num / t if t != 0 else num",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61639/java-python-one-pass-solution-o-n-time-o-n-space-using-buckets/",
                "vote_count": "429"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        if t < 0: return False\n        d = {}\n        for i in range(len(nums)):\n            m = nums[i] // (t + 1)\n            if m in d or (m - 1 in d and nums[i] - d[m - 1] <= t) or (m + 1 in d and d[m + 1] - nums[i] <= t):",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61639/java-python-one-pass-solution-o-n-time-o-n-space-using-buckets/",
                "vote_count": "429"
            },
            {
                "language": "csharp",
                "code": "[1,5,2,4,3,9,1,5,9], k = 2, t = 3\n\n1 // (3+1) = 0\n5 // (3+1) = 1\n2 // (3+1) = 0\n4 // (3+1) = 1\n3 // (3+1) = 0\n9 // (3+1) = 2\n\nHere, Bucket[0] will contain numbers 0,1,2,3.\nBucket[1] will contain numbers 4,5,6,7.\nBucket[2] will contain numbers 8,9,10,11.\n\nOn observing carefully, we can see that the absolute difference\nbetween any two numbers in any bucket is at most t, which is what we want.\n\nAlso, there can be a case where the neighbouring bucket has some number\nwhose absolute difference with a number in the current bucket is at most t.\nFor instance, 2 lies in Bucket[0] and 4 lies in Bucket[1] and 4 - 2 = 2 < 3 (=t).\nThis can only happen in neighbouring buckets. Therefore, we need to check for this too.",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/824578/c-o-n-time-complexity-explained-buckets-o-k-space-complexity/",
                "vote_count": "364"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n        int n = nums.size();\n        \n        if(n == 0 || k < 0  || t < 0) return false;\n        \n        unordered_map<int,int> buckets;\n        \n        for(int i=0; i<n; ++i) {\n            int bucket = nums[i] / ((long)t + 1);\n            \n   // For negative numbers, we need to decrement bucket by 1\n   // to ensure floor division.\n   // For example, -1/2 = 0 but -1 should be put in Bucket[-1].\n   // Therefore, decrement by 1.\n            if(nums[i] < 0) --bucket;\n            \n            if(buckets.find(bucket) != buckets.end()) return true;\n            else {\n                buckets[bucket] = nums[i];\n                if(buckets.find(bucket-1) != buckets.end() && (long) nums[i] - buckets[bucket-1] <= t) return true;\n                if(buckets.find(bucket+1) != buckets.end() && (long) buckets[bucket+1] - nums[i] <= t) return true;\n                \n                if(buckets.size() > k) {\n                    int key_to_remove = nums[i-k] / ((long)t + 1);\n                    \n                    if(nums[i-k] < 0) --key_to_remove;\n                    \n                    buckets.erase(key_to_remove);\n                }\n            }\n        }\n        \n        return false;\n    }\n};",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/824578/c-o-n-time-complexity-explained-buckets-o-k-space-complexity/",
                "vote_count": "364"
            },
            {
                "language": "cpp",
                "code": " class Solution {\n  public:         \n  bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n    int n = nums.size();\n    if(n == 0 || k < 0  || t < 0) return false;\n\n    unordered_map<int,int> buckets;\n\n){\n){",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/824578/c-o-n-time-complexity-explained-buckets-o-k-space-complexity/",
                "vote_count": "364"
            },
            {
                "language": "csharp",
                "code": "[2147483647,-1,2147483647]\n1\n0",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/824578/c-o-n-time-complexity-explained-buckets-o-k-space-complexity/",
                "vote_count": "364"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n        if (nums == null || nums.length == 0 || k <= 0) {\n            return false;\n        }\n\n        final TreeSet<Integer> values = new TreeSet<>();\n        for (int ind = 0; ind < nums.length; ind++) {\n\n            final Integer floor = values.floor(nums[ind] + t);\n            final Integer ceil = values.ceiling(nums[ind] - t);\n            if ((floor != null && floor >= nums[ind])\n                    || (ceil != null && ceil <= nums[ind])) {\n                return true;\n            }\n\n            values.add(nums[ind]);\n            if (ind >= k) {\n                values.remove(nums[ind - k]);\n            }\n        }\n\n        return false;\n    }\n}",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61655/java-o-n-lg-k-solution/",
                "vote_count": "315"
            },
            {
                "language": "csharp",
                "code": "class Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n     \n        if(nums == null || nums.length < 2 || k < 1) return false;\n        TreeSet<Long> set = new TreeSet<>();\n        \n        \n        ",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61655/java-o-n-lg-k-solution/",
                "vote_count": "315"
            },
            {
                "language": "csharp",
                "code": " public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n if (nums.length < 2 || k == 0) {\n  return false;\n }\n TreeSet<Long> set = new TreeSet<>();\n\n int i = 0;\n while (i < nums.length) {",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61655/java-o-n-lg-k-solution/",
                "vote_count": "315"
            },
            {
                "language": "java",
                "code": " public boolean containsNearbyAlmostDuplicate3(int[] nums, int k, int t) {\n  \n  if(k < 1 || t < 0)\n   return false;\n  \n  TreeSet<Long> values = new TreeSet<>();\n  for (int i = 0; i < nums.length; i++) {",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61655/java-o-n-lg-k-solution/",
                "vote_count": "315"
            },
            {
                "language": "csharp",
                "code": "public class Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n        int p = 0; \n        if(nums.length==0) return false; \n        if(k==0) return false; \n\n        TreeSet<Long> set = new TreeSet<>(); ",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61655/java-o-n-lg-k-solution/",
                "vote_count": "315"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n        if (nums == null || nums.length == 0 || k <= 0) {\n            return false;\n        }\n\n        final TreeSet<Long> values = new TreeSet<>();\n        for (int ind = 0; ind < nums.length; ind++) {",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61655/java-o-n-lg-k-solution/",
                "vote_count": "315"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n        if (nums == null || nums.length < 1 || k < 0 || t < 0) return false;\n        TreeSet<Integer> tset = new TreeSet<>();\n        Integer high = null;\n        Integer low = null;\n        for (int i = 0; i < nums.length; ++i) {\n;",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61655/java-o-n-lg-k-solution/",
                "vote_count": "315"
            },
            {
                "language": "dart",
                "code": " bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n    set<int> window; // set is ordered automatically \n    for (int i = 0; i < nums.size(); i++) {\n        if (i > k) window.erase(nums[i-k-1]); // keep the set contains nums i j at most k\n        // |x - nums[i]| <= t  ==> -t <= x - nums[i] <= t;\n        auto pos = window.lower_bound(nums[i] - t); // x-nums[i] >= -t ==> x >= nums[i]-t \n        // x - nums[i] <= t ==> |x - nums[i]| <= t    \n        if (pos != window.end() && *pos - nums[i] <= t) return true;\n        window.insert(nums[i]);\n    }\n    return false;\n}",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61641/c-using-set-less-10-lines-with-simple-explanation/",
                "vote_count": "258"
            },
            {
                "language": "cpp",
                "code": "bool containsNearbyAlmostDuplicate(vector<int> &nums, int k, int t) {\n        set<long> window;\n        \n        for (int i = 0; i < nums.size(); ++i) {\n            long n = nums[i];\n            \n            if (i > k)\n                window.erase(nums[i-k-1]);",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61641/c-using-set-less-10-lines-with-simple-explanation/",
                "vote_count": "258"
            },
            {
                "language": "cpp",
                "code": "bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n set<long long> window;\n for (int i = 0; i < nums.size(); ++i) {\n  if (i > k && i - k - 1 < nums.size()) window.erase(nums[i - k - 1]);\n  auto it = window.lower_bound((long long)nums[i] - t);\n  if (it != window.cend() && *it - nums[i] <= t) return true;\n  window.insert(nums[i]);\n }",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61641/c-using-set-less-10-lines-with-simple-explanation/",
                "vote_count": "258"
            },
            {
                "language": "cpp",
                "code": "bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n  set<long long> s;\n  if(k==0) return false;\n for(int i=0; i<nums.size(); i++){\n  long long val = nums[i];\n  if(!s.empty()){\n      ",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/61641/c-using-set-less-10-lines-with-simple-explanation/",
                "vote_count": "258"
            },
            {
                "language": "python",
                "code": "from sortedcontainers import SortedList\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        SList = SortedList()\n        for i in range(len(nums)):\n            if i > k: SList.remove(nums[i-k-1])   \n            pos1 = SortedList.bisect_left(SList, nums[i] - t)\n            pos2 = SortedList.bisect_right(SList, nums[i] + t)\n            \n            if pos1 != pos2 and pos1 != len(SList): return True\n            \n            SList.add(nums[i])\n        \n        return False",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/824603/python-sortedlist-o-n-log-k-solution-explained/",
                "vote_count": "206"
            },
            {
                "language": "javascript",
                "code": "from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/824603/python-sortedlist-o-n-log-k-solution-explained/",
                "vote_count": "206"
            },
            {
                "language": "javascript",
                "code": "from sortedcontainers import SortedList\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\n        window = SortedList()",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/824603/python-sortedlist-o-n-log-k-solution-explained/",
                "vote_count": "206"
            },
            {
                "language": "python",
                "code": "if pos1 != pos2 and pos1 != len(SList): return True",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/824603/python-sortedlist-o-n-log-k-solution-explained/",
                "vote_count": "206"
            },
            {
                "language": "python",
                "code": "if pos1 != pos2: return True",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/824603/python-sortedlist-o-n-log-k-solution-explained/",
                "vote_count": "206"
            },
            {
                "language": "python",
                "code": "class Node(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.height = 1\n\n\nclass AVLTree(object):\n    def __init__(self):\n        self.root = None\n        self.size = 0\n        \n    \n    def height(self, node):\n        if node:\n            return node.height\n        return 0\n    \n  \n    def setHeight(self, node):\n        if node is None:\n            return 0\n        return 1 + max(self.height(node.left), self.height(node.right))\n    \n  \n    def rightRotate(self, node):\n        new_root = node.left\n        node.left = node.left.right\n        new_root.right = node\n        node.height = self.setHeight(node)\n        new_root.height = self.setHeight(new_root)\n        return new_root\n    \n    \n    def leftRotate(self, node):\n        new_root = node.right\n        node.right = node.right.left\n        new_root.left = node\n        node.height = self.setHeight(node)\n        new_root.height = self.setHeight(new_root)\n        return new_root\n        \n    \n    def insert(self, node, val):\n        if node == self.root:\n            self.size += 1\n        # Returns a Node pointing to updated subtree\n        if node is None:\n            return Node(val)\n        if node.val < val:\n            node.right = self.insert(node.right, val)\n        else:\n            node.left = self.insert(node.left, val)\n        balance = self.height(node.left) - self.height(node.right)\n        if balance > 1:\n            if self.height(node.left.left) > self.height(node.left.right):\n                node = self.rightRotate(node)\n            else:\n                node.left = self.leftRotate(node.left)\n                node = self.rightRotate(node)\n        elif balance < -1:\n            if self.height(node.right.right) > self.height(node.right.left):\n                node = self.leftRotate(node)\n            else:\n                node.right = self.rightRotate(node.right)\n                node = self.leftRotate(node)\n        else:\n            node.height = self.setHeight(node)\n        return node\n    \n    \n    def getMinValNode(self, node):\n        if node is None or node.left is None:\n            return node\n        return self.getMinValNode(node.left)\n    \n  \n    def remove(self, node, val):\n        if node is None:\n            return None\n        if node.val < val:\n            node.right = self.remove(node.right, val)\n        elif node.val > val:\n            node.left = self.remove(node.left, val)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            else:\n                right_min_val_node = self.getMinValNode(node.right)\n                node.val = right_min_val_node.val\n                node.right = self.remove(node.right, right_min_val_node.val)\n        \n        node.height = self.setHeight(node)\n        balance = self.height(node.left) - self.height(node.right)\n        if balance > 1:\n            if self.height(node.left.left) > self.height(node.left.right):\n                node = self.rightRotate(node)\n            else:\n                node.left = self.leftRotate(node.left)\n                node = self.rightRotate(node)\n        elif balance < -1:\n            if self.height(node.right.right) > self.height(node.right.left):\n                node = self.leftRotate(node)\n            else:\n                node.right = self.rightRotate(node.right)\n                node = self.leftRotate(node)\n        else:\n            node.height = self.setHeight(node)\n        return node\n    \n    \n    def predecessor(self, node, val):\n        if node is None:\n            return None\n        if node.val == val:\n            return val\n        elif node.val > val:\n            return self.predecessor(node.left, val)\n        else:\n            right_res = self.predecessor(node.right, val)\n            return right_res if right_res else node.val    \n            \n      \n    def successor(self, node, val):\n        if node is None:\n            return None\n        if node.val == val:\n            return val\n        elif node.val < val:\n            return self.successor(node.right, val)\n        else:\n            left_res = self.successor(node.left, val)\n            return left_res if left_res else node.val\n    \n\nclass Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type t: int\n        :rtype: bool\n        \"\"\"\n        avltree = AVLTree()\n        root = avltree.root\n        for i, num in enumerate(nums):            \n            predecessor = avltree.predecessor(root, num)\n            if predecessor is not None and abs(predecessor - num) <= t:\n                return True\n            successor = avltree.successor(root, num)\n            if successor is not None and abs(successor - num) <= t:\n                return True\n                        \n            root = avltree.insert(root, num)\n            \n            if avltree.size > k:\n                root = avltree.remove(root, nums[i-k])\n                \n        return False",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/174416/python-balanced-bst-solution/",
                "vote_count": "174"
            },
            {
                "language": "csharp",
                "code": "/**\n * Sliding Window solution using Buckets\n *\n * Time Complexity: O(N)\n *\n * Space Complexity: O(min(N, K+1))\n *\n * N = Length of input array. K = Input difference between indexes.\n */\nclass Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n        if (nums == null || nums.length < 2 || k < 1 || t < 0) {\n            return false;\n        }\n\n        HashMap<Long, Long> buckets = new HashMap<>();\n        // The bucket size is t+1 as the ranges are from 0..t, t+1..2t+1, ..\n        long bucketSize = (long) t + 1;\n\n        for (int i = 0; i < nums.length; i++) {\n            // Making sure only K buckets exists in map.\n            if (i > k) {\n                long lastBucket = ((long) nums[i - k - 1] - Integer.MIN_VALUE) / bucketSize;\n                buckets.remove(lastBucket);\n            }\n\n            long remappedNum = (long) nums[i] - Integer.MIN_VALUE;\n            long bucket = remappedNum / bucketSize;\n\n            // If 2 numbers belong to same bucket\n            if (buckets.containsKey(bucket)) {\n                return true;\n            }\n\n            // If numbers are in adjacent buckets and the difference between them is at most\n            // t.\n            if (buckets.containsKey(bucket - 1) && remappedNum - buckets.get(bucket - 1) <= t) {\n                return true;\n            }\n            if (buckets.containsKey(bucket + 1) && buckets.get(bucket + 1) - remappedNum <= t) {\n                return true;\n            }\n\n            buckets.put(bucket, remappedNum);\n        }\n\n        return false;\n    }\n}",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/1500895/java-tc-o-n-sc-o-min-n-k-sliding-window-using-buckets/",
                "vote_count": "31"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) \n    {\n        int n = nums.size();\n        multiset<int> ms;     //to store window elements in sorted order\n        \n  int i=0, j=0;\n        while(j<n)\n        {\n            auto up = ms.upper_bound(nums[j]);\n            if((up != ms.end() and *up-nums[j] <= t) || (up != ms.begin() and nums[j] - *(--up) <= t))\n                return true;\n            ms.insert(nums[j]);\n            \n            if(ms.size() == k+1)\n            {\n                ms.erase(nums[i]);\n                i++;\n            }\n            j++;\n        }\n        return false;\n    }\n};",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/2570864/c-sliding-window-w-easy-explanation/",
                "vote_count": "13"
            },
            {
                "language": "cpp",
                "code": "bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n    int n=nums.size();\n    t=(long)t;          // taking t as long because difference between numbers can be greater than INT_MAX\n    multiset<long> s;   //window\n    \n    for(int i=0;i<n;i++){\n        if(i>k){\n            s.erase((long)nums[i-k-1]);         // if size of window > k, we are removing elements from window\n        }\n        \n        auto it=s.lower_bound((long)nums[i]-t); // searching for numbers with difference at most t\n  long dif=*it-(long)nums[i];             // difference is calculated for further comparisons\n  \n        if(it!=s.end() and dif<=t){             // if number in window with at most t difference is present \n            return true;\n        }\n        s.insert(nums[i]); // inserting element in window \n    }\n    return false;\n}\n// Thanks",
                "url": "https://leetcode.com/problems/contains-duplicate-iii/solutions/1809732/c-sliding-window-multiset-solution-with-comments-easy-understanding/",
                "vote_count": "11"
            }
        ]
    },
    "196": {
        "question_id": 221,
        "title": "Maximal Square",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/maximal-square",
        "description": "Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area. ",
        "examples": [
            {
                "input": "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
                "output": "4",
                "explanation": null
            },
            {
                "input": "matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]",
                "output": "1",
                "explanation": null
            },
            {
                "input": "matrix = [[\"0\"]]",
                "output": "0",
                "explanation": null
            }
        ],
        "constraints": [
            "m == matrix.length",
            "n == matrix[i].length",
            "1 <= m, n <= 300",
            "matrix[i][j] is '0' or '1'."
        ],
        "solutions": [
            {
                "language": "ruby",
                "code": "class Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        if matrix is None or len(matrix) < 1:\n            return 0\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        \n        dp = [[0]*(cols+1) for _ in range(rows+1)]\n        max_side = 0\n        \n        for r in range(rows):\n            for c in range(cols):\n                if matrix[r][c] == '1':\n                    dp[r+1][c+1] = min(dp[r][c], dp[r+1][c], dp[r][c+1]) + 1 # Be careful of the indexing since dp grid has additional row and column\n                    max_side = max(max_side, dp[r+1][c+1])\n                \n        return max_side * max_side\n                ",
                "url": "https://leetcode.com/problems/maximal-square/solutions/600149/python-thinking-process-diagrams-dp-approach/",
                "vote_count": "1354"
            },
            {
                "language": "python",
                "code": "    def maximalSquare(self, matrix):\n        if not matrix:\n            return 0\n        \n        dp = [0] * (len(matrix[0])+1)\n        maxLen = prev = 0",
                "url": "https://leetcode.com/problems/maximal-square/solutions/600149/python-thinking-process-diagrams-dp-approach/",
                "vote_count": "1354"
            },
            {
                "language": "go",
                "code": "def maximalSquare(self, matrix: List[List[str]]) -> int:\n    \n    N,M = len(matrix),len(matrix[0])\n    \n    matrix = [list(map(int,matrix[i])) for i in range(N)]\n    ",
                "url": "https://leetcode.com/problems/maximal-square/solutions/600149/python-thinking-process-diagrams-dp-approach/",
                "vote_count": "1354"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& matrix) {\n        if (matrix.empty()) {\n            return 0;\n        }\n        int m = matrix.size(), n = matrix[0].size(), sz = 0;\n        vector<vector<int>> dp(m, vector<int>(n, 0));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!i || !j || matrix[i][j] == '0') {\n                    dp[i][j] = matrix[i][j] - '0';\n                } else {\n                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;\n                }\n                sz = max(dp[i][j], sz);\n            }\n        }\n        return sz * sz;\n    }\n};",
                "url": "https://leetcode.com/problems/maximal-square/solutions/61803/c-space-optimized-dp/",
                "vote_count": "797"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& matrix) {\n        if (matrix.empty()) {\n            return 0;\n        }\n        int m = matrix.size(), n = matrix[0].size(), sz = 0;\n        vector<int> pre(n, 0), cur(n, 0);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!i || !j || matrix[i][j] == '0') {\n                    cur[j] = matrix[i][j] - '0';\n                } else {\n                    cur[j] = min(pre[j - 1], min(pre[j], cur[j - 1])) + 1;\n                }\n                sz = max(cur[j], sz);\n            }\n            fill(pre.begin(), pre.end(), 0);\n            swap(pre, cur);\n        }\n        return sz * sz;\n    }\n};",
                "url": "https://leetcode.com/problems/maximal-square/solutions/61803/c-space-optimized-dp/",
                "vote_count": "797"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& matrix) {\n        if (matrix.empty()) {\n            return 0;\n        }\n        int m = matrix.size(), n = matrix[0].size(), sz = 0, pre;\n        vector<int> cur(n, 0);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int temp = cur[j];\n                if (!i || !j || matrix[i][j] == '0') {\n                    cur[j] = matrix[i][j] - '0';\n                } else {\n                    cur[j] = min(pre, min(cur[j], cur[j - 1])) + 1;\n                }\n                sz = max(cur[j], sz);\n                pre = temp;\n            }\n        }\n        return sz * sz;\n    }\n};",
                "url": "https://leetcode.com/problems/maximal-square/solutions/61803/c-space-optimized-dp/",
                "vote_count": "797"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\nint maximalSquare(vector<vector<char>>& matrix) {\n    int nr = matrix.size(); if (nr == 0) return 0;",
                "url": "https://leetcode.com/problems/maximal-square/solutions/61803/c-space-optimized-dp/",
                "vote_count": "797"
            },
            {
                "language": "cpp",
                "code": "public int maximalSquare(char[][] matrix) {\n        if(matrix.length == 0)\n            return 0;\n        int[] prev = new int[matrix[0].length + 1];\n        int[] curr = new int[matrix[0].length + 1];\n        int res = 0;\n        for(int i = 1 ;i <= matrix.length; i++){\n            for(int j = 1; j <= matrix[0].length; j++) {",
                "url": "https://leetcode.com/problems/maximal-square/solutions/61803/c-space-optimized-dp/",
                "vote_count": "797"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/maximal-square/solutions/61803/c-space-optimized-dp/",
                "vote_count": "797"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& matrix) {\n        int m=matrix.size();\n        if(m==0)\n            return 0;\n        int n=matrix[0].size();\n})+'0';",
                "url": "https://leetcode.com/problems/maximal-square/solutions/61803/c-space-optimized-dp/",
                "vote_count": "797"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalSquare(std::vector<std::vector<char> > &matrix) {\n        if(matrix.empty())\n            return 0;\n        int rows = matrix.size(), cols = matrix[0].size();\n        char maxSize = '0';\n        for (int j = 0; j < cols; ++j)\n[i][j - 1])) + 1;",
                "url": "https://leetcode.com/problems/maximal-square/solutions/61803/c-space-optimized-dp/",
                "vote_count": "797"
            },
            {
                "language": "python",
                "code": "    if(matrix.length == 0) return 0;\n    \n    int m = matrix.length, n = matrix[0].length;\n    int max = Integer.MIN_VALUE;\n    \n    for(int j = 0; j < n && max != 1; ++j) if(matrix[0][j] == '1') max = 1; \n    for(int i = 1; i < m && max != 1; ++i) if(matrix[i][0] == '1') max = 1;\n    \n[i][j-1] - '0')) + 1;",
                "url": "https://leetcode.com/problems/maximal-square/solutions/61803/c-space-optimized-dp/",
                "vote_count": "797"
            },
            {
                "language": "cpp",
                "code": "public int maximalSquare(char[][] a) {\n    if(a.length == 0) return 0;\n    int m = a.length, n = a[0].length, result = 0;\n    int[][] b = new int[m+1][n+1];\n    for (int i = 1 ; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if(a[i-1][j-1] == '1') {\n                b[i][j] = Math.min(Math.min(b[i][j-1] , b[i-1][j-1]), b[i-1][j]) + 1;\n                result = Math.max(b[i][j], result); // update result\n            }\n        }\n    }\n    return result*result;\n}",
                "url": "https://leetcode.com/problems/maximal-square/solutions/61802/extremely-simple-java-solution/",
                "vote_count": "562"
            },
            {
                "language": "cpp",
                "code": "",
                "url": "https://leetcode.com/problems/maximal-square/solutions/61802/extremely-simple-java-solution/",
                "vote_count": "562"
            },
            {
                "language": "java",
                "code": "public class Solution {\n    public int maximalSquare(char[][] matrix) {\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int max = 0;\n        //initialization\n        int[][] dp = new int[2][n+1];\nj-1]) + 1;",
                "url": "https://leetcode.com/problems/maximal-square/solutions/61802/extremely-simple-java-solution/",
                "vote_count": "562"
            },
            {
                "language": "python",
                "code": "    public int maximalSquare(char[][] matrix) {\n        if (matrix == null || matrix.length == 0) {\n            return 0;\n        }\n        int row = matrix.length, col = matrix[0].length;\n        int[][] dp = new int[row][col];\n        int len = 0;\n        for (int i = 0; i < row; i++) {\n+ 1;",
                "url": "https://leetcode.com/problems/maximal-square/solutions/61802/extremely-simple-java-solution/",
                "vote_count": "562"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& matrix) {\n        int m=matrix.size();\n        if(m==0)\n            return 0;\n})+'0';",
                "url": "https://leetcode.com/problems/maximal-square/solutions/61802/extremely-simple-java-solution/",
                "vote_count": "562"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& M) {\n        auto isValidSquare = [&](int i, int j, int side) {\n            return all_of(begin(M)+i, begin(M)+i+side, [&](auto& R){\n                return all_of(begin(R)+j, begin(R)+j+side, [&](auto cell) { return cell == '1'; });\n            });\n        };\n        int m = size(M), n = size(M[0]), ans = 0;\n        for(int row = 0; row < m; row++)\n            for(int col = 0; col < n; col++)\n                for(int sideLen = 1; sideLen <= min(m-row, n-col); sideLen++) \n                    if(isValidSquare(row, col, sideLen))\n                        ans = ans = max(ans, sideLen*sideLen);\n        return ans;\n    }\n};",
                "url": "https://leetcode.com/problems/maximal-square/solutions/1632376/c-python-6-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "178"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& M) {\n        auto isValidSquare = [&](int i, int j, int side) {\n            return all_of(begin(M)+i, begin(M)+i+side, [&](auto& R){\n                return all_of(begin(R)+j, begin(R)+j+side, [&](auto cell) { return cell == '1'; });\n            });\n        };\n        int m = size(M), n = size(M[0]);\n        for(int sideLen = min(m, n); sideLen; sideLen--)\n            for(int row = 0; row <= m-sideLen; row++)\n                for(int col = 0; col <= n-sideLen; col++)\n                    if(isValidSquare(row, col, sideLen))\n                        return sideLen*sideLen;\n        return 0;\n    }\n};",
                "url": "https://leetcode.com/problems/maximal-square/solutions/1632376/c-python-6-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "178"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maximalSquare(self, M):\n        def is_valid_sqaure(row, col, side):\n            return all(all(M[i][j] == '1' for j in range(col, col+side)) for i in range(row, row+side))\n        m, n = len(M), len(M[0])\n        for side_len in range(min(m,n), 0, -1):\n            for row in range(m - side_len + 1):\n                for col in range(n - side_len + 1):\n                    if is_valid_sqaure(row, col, side_len):\n                        return side_len**2\n        return 0",
                "url": "https://leetcode.com/problems/maximal-square/solutions/1632376/c-python-6-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "178"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int getMaxSquareLen(vector<vector<char>>& M, int row, int col) {\n        int allOnesRowLen = min(size(M)-row, size(M[0])-col), sqLen = 0;\n        for(int i = 0, j; i < allOnesRowLen; i++) {\n            for(j = 0; j < allOnesRowLen && M[i+row][j+col] != '0'; j++);\n            allOnesRowLen = j;\n            sqLen = min(allOnesRowLen, i+1);\n        }\n        return sqLen;\n    }\n    int maximalSquare(vector<vector<char>>& M) {\n        int m = size(M), n = size(M[0]), ans = 0;\n        for(int row = 0; row < m; row++)\n            for(int col = 0; col < n; col++) \n                ans = max(ans, getMaxSquareLen(M, row, col));\n        return ans * ans;\n    }\n};",
                "url": "https://leetcode.com/problems/maximal-square/solutions/1632376/c-python-6-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "178"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maximalSquare(self, M):\n        m, n, ans = len(M), len(M[0]), 0\n        def get_max_square_len(row, col):\n            all_ones_row_len, sq_len, i, j = min(m-row, n-col), 0, 0, 0\n            while i < all_ones_row_len:\n                j = 0\n                while j < all_ones_row_len and M[i+row][j+col] != '0': \n                    j += 1\n                all_ones_row_len = j\n                sq_len = min(all_ones_row_len, i := i + 1)\n            return sq_len\n        \n        for row in range(m):\n            for col in range(n):\n                ans = max(ans, get_max_square_len(row, col))\n        return ans * ans",
                "url": "https://leetcode.com/problems/maximal-square/solutions/1632376/c-python-6-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "178"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int getMaxSquareLen(vector<vector<char>>& M, vector<vector<int>>& ones, int row, int col) {\n        int allOnesRowLen = min(size(M)-row, size(M[0])-col), sqLen = 0;\n        for(int i = 0, j; i < allOnesRowLen; i++) \n            allOnesRowLen = min(allOnesRowLen, ones[i+row][col]),\n            sqLen = min(allOnesRowLen, i+1);\n        return sqLen;\n    }\n    int maximalSquare(vector<vector<char>>& M) {\n        int m = size(M), n = size(M[0]), ans = 0;\n        vector<vector<int>> ones(m, vector<int>(n+1));\n        for(int i = m-1; ~i; i--)\n            for(int j = n-1; ~j; j--)\n                ones[i][j] = (M[i][j] == '1' ? 1 + ones[i][j+1] : 0);\n        \n        for(int row = 0; row < m; row++)\n            for(int col = 0; col < n; col++) \n                ans = max(ans, getMaxSquareLen(M, ones, row, col));\n        return ans * ans;\n    }\n};",
                "url": "https://leetcode.com/problems/maximal-square/solutions/1632376/c-python-6-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "178"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maximalSquare(self, M):\n        m, n, ans = len(M), len(M[0]), 0\n        ones = [[0]*(n+1) for i in range(m)]\n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                ones[i][j] = 1 + ones[i][j+1] if M[i][j] == '1' else 0\n        \n        def get_max_square_len(row, col):\n            all_ones_row_len, sq_len, i, j = min(m-row, n-col), 0, 0, 0\n            while i < all_ones_row_len:                \n                all_ones_row_len = min(all_ones_row_len, ones[i+row][col])\n                sq_len = min(all_ones_row_len, i := i + 1)\n            return sq_len\n        \n        for row in range(m):\n            for col in range(n):\n                ans = max(ans, get_max_square_len(row, col))\n        return ans * ans",
                "url": "https://leetcode.com/problems/maximal-square/solutions/1632376/c-python-6-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "178"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& M) {\n        int m = size(M), n = size(M[0]), ans = 0;\n        vector<vector<int>> dp(m+1, vector<int>(n+1)), onesRow(dp), onesCol(dp);\n        for(int i = m-1; ~i; i--)\n            for(int j = n-1; ~j; j--)\n                onesRow[i][j] = (M[i][j] == '1' ? 1 + onesRow[i][j+1] : 0),\n                onesCol[i][j] = (M[i][j] == '1' ? 1 + onesCol[i+1][j] : 0);\n        \n        for(int i = m-1; ~i; i--)\n            for(int j = n-1; ~j; j--) \n                dp[i][j] = (M[i][j] == '1' ? 1 + min({onesRow[i][j]-1, onesCol[i][j]-1, dp[i+1][j+1]}) : 0),\n                ans = max(ans, dp[i][j]);\n\n        return ans * ans;\n    }\n};",
                "url": "https://leetcode.com/problems/maximal-square/solutions/1632376/c-python-6-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "178"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maximalSquare(self, M):\n        m, n, ans = len(M), len(M[0]), 0\n        dp, onesRow, onesCol = ([[0]*(n+1) for i in range(m+1)] for cnt in range(3))\n\n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\n            onesRow[i][j] = 1 + onesRow[i][j+1] if M[i][j] == '1' else 0\n            onesCol[i][j] = 1 + onesCol[i+1][j] if M[i][j] == '1' else 0\n            \n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\n            dp[i][j] = 1 + min(onesRow[i][j]-1, onesCol[i][j]-1, dp[i+1][j+1]) if M[i][j] == '1' else 0\n            ans = max(ans, dp[i][j])\n        return ans * ans",
                "url": "https://leetcode.com/problems/maximal-square/solutions/1632376/c-python-6-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "178"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& M) {\n        int m = size(M), n = size(M[0]), ans = 0;\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\n        for(int i = m-1; ~i; i--)\n            for(int j = n-1; ~j; j--) \n                dp[i][j] = (M[i][j] == '1' ? 1 + min({dp[i+1][j], dp[i][j+1], dp[i+1][j+1]}) : 0),\n                ans = max(ans, dp[i][j]);\n\n        return ans * ans;\n    }\n};",
                "url": "https://leetcode.com/problems/maximal-square/solutions/1632376/c-python-6-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "178"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maximalSquare(self, M):\n        m, n, ans = len(M), len(M[0]), 0\n        dp = [[0]*(n+1) for i in range(m+1)]\n        \n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\n            dp[i][j] = 1 + min(dp[i+1][j], dp[i][j+1], dp[i+1][j+1]) if M[i][j] == '1' else 0\n            ans = max(ans, dp[i][j])\n        return ans * ans",
                "url": "https://leetcode.com/problems/maximal-square/solutions/1632376/c-python-6-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "178"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& M) {\n        int m = size(M), n = size(M[0]), ans = 0;\n        vector<vector<int>> dp(2, vector<int>(n+1));\n        for(int i = m-1; ~i; i--)\n            for(int j = n-1; ~j; j--) \n                dp[i&1][j] = (M[i][j] == '1' ? 1 + min({dp[(i+1)&1][j], dp[i&1][j+1], dp[(i+1)&1][j+1]}) : 0),\n                ans = max(ans, dp[i&1][j]);\n\n        return ans * ans;\n    }\n};",
                "url": "https://leetcode.com/problems/maximal-square/solutions/1632376/c-python-6-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "178"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maximalSquare(self, M):\n        m, n, ans = len(M), len(M[0]), 0\n        dp = [[0]*(n+1) for i in range(2)]\n        \n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\n            dp[i&1][j] = 1 + min(dp[(i+1)&1][j], dp[i&1][j+1], dp[(i+1)&1][j+1]) if M[i][j] == '1' else 0\n            ans = max(ans, dp[i&1][j])\n        return ans * ans",
                "url": "https://leetcode.com/problems/maximal-square/solutions/1632376/c-python-6-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "178"
            },
            {
                "language": "cpp",
                "code": "class Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& M) {\n        int m = size(M), n = size(M[0]), ans = 0;        \n        for(int i = m-1; ~i; i--)\n            for(int j = n-1; ~j; j--) \n                if(i == m-1 or j == n-1)\n                    ans = max(ans, int(M[i][j] -= '0'));\n                else\n                    M[i][j] = (M[i][j] == '1' ? 1+min({M[i+1][j], M[i][j+1], M[i+1][j+1]}) : 0),\n                    ans = max(ans, int(M[i][j]));\n\n        return ans * ans;\n    }\n};",
                "url": "https://leetcode.com/problems/maximal-square/solutions/1632376/c-python-6-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "178"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maximalSquare(self, M):\n        m, n, ans = len(M), len(M[0]), 0\n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\n            if i == m-1 or j == n-1:\n                M[i][j] = int(M[i][j])\n                ans = max(ans, M[i][j])\n            else:\n                M[i][j] = 1 + min(M[i+1][j], M[i][j+1], M[i+1][j+1]) if M[i][j] == '1' else 0\n                ans = max(ans, M[i][j])\n        return ans * ans",
                "url": "https://leetcode.com/problems/maximal-square/solutions/1632376/c-python-6-simple-solution-w-explanation-optimizations-from-brute-force-to-dp/",
                "vote_count": "178"
            },
            {
                "language": "cpp",
                "code": "//Upvote & Comment\n\nclass Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& matrix) {\n        //base case\n        if(matrix.size()==0) return 0;\n        //initializing our sentinal variables\n        int maxSqr = 0, rows = matrix.size() , column = matrix[0].size();\n        //dp matrix that we will be making \n        vector<vector<int>> dp(rows+1,vector<int>(column+1,0));\n        \n        //Iterate over the matrix\n        for(int i=1;i<=rows;++i){\n            for(int j=1;j<=column;++j){\n                //we found the 1 in our binary matrix \n                if(matrix[i-1][j-1]=='1'){\n                    dp[i][j] = min({dp[i-1][j-1], dp[i-1][j], dp[i][j-1]})+ 1;\n                    maxSqr=max(maxSqr,dp[i][j]);\n                }\n            }\n        }\n        return maxSqr*maxSqr;\n    }\n};",
                "url": "https://leetcode.com/problems/maximal-square/solutions/1632145/c-java-python-easy-to-solve-detailed-explanation-of-dp-with-visualization-and-dry-run/",
                "vote_count": "70"
            },
            {
                "language": "cpp",
                "code": "//Upvote & Comment\n\nclass Solution {\n    public int maximalSquare(char[][] matrix) {\n        //initializing sentinal varibles\n        int maxSqr=0 , rows=matrix.length , column=matrix[0].length;\n        //base case\n        if(rows==0) return 0;\n        //dp matrix that we will be making\n        int[][] dp=new int[rows+1][column+1];\n  \n        //Iterate over the matrix\n        for(int i=1;i<=rows;i++)\n            for(int j=1;j<=column;j++) {\n                ///we found the 1 in our binary matrix \n                if(matrix[i-1][j-1]=='0') continue;\n                dp[i][j]=Math.min(dp[i-1][j],Math.min(dp[i-1][j-1],dp[i][j-1])) + 1;\n                maxSqr=Math.max(maxSqr,dp[i][j]);\n            }\n        return maxSqr*maxSqr;\n    }\n}",
                "url": "https://leetcode.com/problems/maximal-square/solutions/1632145/c-java-python-easy-to-solve-detailed-explanation-of-dp-with-visualization-and-dry-run/",
                "vote_count": "70"
            },
            {
                "language": "go",
                "code": "//Upvote & Comment\n\nclass Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        #base case\n        if matrix is None or len(matrix) < 1:\n            return 0\n        #initializing our sentinal variables\n        rows = len(matrix)\n        cols = len(matrix[0])\n        maxSqr = 0\n        #dp matrix that we will be making \n        dp = [[0]*(cols+1) for _ in range(rows+1)]\n        \n        #Iterate over the matrix\n        for i in range(rows):\n            for j in range(cols):\n                #we found the 1 in our binary matrix \n                if matrix[i][j] == '1':\n                    dp[i+1][j+1] = min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1 \n                    maxSqr = max(maxSqr, dp[i+1][j+1])\n                \n        return maxSqr * maxSqr",
                "url": "https://leetcode.com/problems/maximal-square/solutions/1632145/c-java-python-easy-to-solve-detailed-explanation-of-dp-with-visualization-and-dry-run/",
                "vote_count": "70"
            }
        ]
    },
    "197": {
        "question_id": 222,
        "title": "Count Complete Tree Nodes",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/count-complete-tree-nodes",
        "description": "Given the root of a complete binary tree, return the number of the nodes in the tree.According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.Design an algorithm that runs in less than O(n) time complexity. ",
        "examples": [
            {
                "input": "root = [1,2,3,4,5,6]",
                "output": "6",
                "explanation": null
            },
            {
                "input": "root = []",
                "output": "0",
                "explanation": null
            },
            {
                "input": "root = [1]",
                "output": "1",
                "explanation": null
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range [0, 5 * 10^4].",
            "0 <= Node.val <= 5 * 10^4",
            "The tree is guaranteed to be complete."
        ],
        "solutions": [
            {
                "language": "ruby",
                "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def countNodes(self, root: Optional[TreeNode]) -> int:\n        if(root==None):\n            return 0\n        return(self.countNodes(root.left)+self.countNodes(root.right)+1)",
                "url": "https://leetcode.com/problems/count-complete-tree-nodes/solutions/2816121/2-line-solution-using-recursion/",
                "vote_count": "12"
            }
        ]
    },
    "198": {
        "question_id": 223,
        "title": "Rectangle Area",
        "difficulty": 2,
        "url": "https://leetcode.com/problems/rectangle-area",
        "description": "Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered by the two rectangles.The first rectangle is defined by its bottom-left corner (ax1, ay1) and its top-right corner (ax2, ay2).The second rectangle is defined by its bottom-left corner (bx1, by1) and its top-right corner (bx2, by2). ",
        "examples": [
            {
                "input": "ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2",
                "output": "45",
                "explanation": null
            },
            {
                "input": "ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2",
                "output": "16",
                "explanation": null
            }
        ],
        "constraints": [
            "-10^4 <= ax1 <= ax2 <= 10^4",
            "-10^4 <= ay1 <= ay2 <= 10^4",
            "-10^4 <= bx1 <= bx2 <= 10^4",
            "-10^4 <= by1 <= by2 <= 10^4"
        ],
        "solutions": []
    },
    "199": {
        "question_id": 224,
        "title": "Basic Calculator",
        "difficulty": 3,
        "url": "https://leetcode.com/problems/basic-calculator",
        "description": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval(). ",
        "examples": [
            {
                "input": "s = \"1 + 1\"",
                "output": "2",
                "explanation": null
            },
            {
                "input": "s = \" 2-1 + 2 \"",
                "output": "3",
                "explanation": null
            },
            {
                "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
                "output": "23",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= s.length <= 3 * 10^5",
            "s consists of digits, '+', '-', '(', ')', and ' '.",
            "s represents a valid expression.",
            "'+' is not used as a unary operation (i.e., \"+1\" and \"+(2 + 3)\" is invalid).",
            "'-' could be used as a unary operation (i.e., \"-1\" and \"-(2 + 3)\" is valid).",
            "There will be no two consecutive operators in the input.",
            "Every number and running calculation will fit in a signed 32-bit integer."
        ],
        "solutions": [
            {
                "language": "csharp",
                "code": "s = \"1+2+(3+4)\" and we are currently at the number 4,\nstack = [3, 1, 3], the first 3 is 1+2, the 1 is the sign of the (), and the last 3 is the number we are working on.",
                "url": "https://leetcode.com/problems/basic-calculator/solutions/2831471/python3-stack-approach-with-detailed-explanations-o-n/",
                "vote_count": "74"
            },
            {
                "language": "ruby",
                "code": "class Solution:\n    def calculate(self, s: str) -> int:\n     \n     ### num is the current number we are constructing\n     \n     ### sign is the '+' or '-' before the current number we are constructing/holding\n     ### Note that we initialize sign with 1 to represent '+'\n     \n     ### The last element in the stack will be the number we are updating during the \n     ### process, so put a 0 in it.\n        num, sign, stack = 0, 1, [0]\n\n        for c in s:\n\n         ### Constructing the number.\n            if c.isdigit():\n                num = num*10 + int(c)\n\n            ### Skip the space\n            elif c==' ':\n                continue\n\n            ### When we see '+', we need to multiply the current number we are holding with the \n            ### sign before this number, and update the last element in the stack.\n            ### We also need to reset num to 0 and sign to 1\n            elif c == '+':\n                stack[-1] += num * sign\n                sign = 1\n                num = 0\n\n            ### Doing the same thing as '+', but reset sign to -1\n            elif c == '-':\n                stack[-1] += num * sign\n                sign = -1\n                num = 0\n\n            ### We add sign to stack which represent the sign of this ()\n            ### We also add a 0 so we can keep update while evaluating the expression inside this ()\n            ### Reset num and sign again\n            elif c == '(':\n                stack.extend([sign,0])\n                sign = 1\n                num = 0\n\n            ### pop the last element and combine it with the current num and sign we are holding (the last element inside this '()' ).\n   ### pop the last element again which is the sign for this '()' and muitiply them together.\n   ### add everything we get inside this '()' to the last element in the stack.\n            elif c == ')':\n                lastNum = (stack.pop() + num*sign) * stack.pop()\n                stack[-1] += lastNum\n                sign = 1\n                num = 0\n                \n        ### stack should only contain one element representing everything except the last number if the expression ended with a number, so add the current num we are holding to the result.\n        return stack[-1]+num*sign",
                "url": "https://leetcode.com/problems/basic-calculator/solutions/2831471/python3-stack-approach-with-detailed-explanations-o-n/",
                "vote_count": "74"
            }
        ]
    },
    "200": {
        "question_id": 225,
        "title": "Implement Stack using Queues",
        "difficulty": 1,
        "url": "https://leetcode.com/problems/implement-stack-using-queues",
        "description": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).Implement the MyStack class:void push(int x) Pushes element x to the top of the stack.int pop() Removes the element on the top of the stack and returns it.int top() Returns the element on the top of the stack.boolean empty() Returns true if the stack is empty, false otherwise.Notes:You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid.Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations. ",
        "examples": [
            {
                "input": "[\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\nOutput\n[null, null, null, 2, 2, false]\n\nExplanation\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False",
                "output": "MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\nOutput\n[null, null, null, 2, 2, false]\n\nExplanation\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False",
                "explanation": null
            }
        ],
        "constraints": [
            "1 <= x <= 9",
            "At most 100 calls will be made to push, pop, top, and empty.",
            "All the calls to pop and top are valid."
        ],
        "solutions": []
    }
}