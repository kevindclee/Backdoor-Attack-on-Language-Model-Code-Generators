[
    "import functools\n\nclass Solution:\n    def maxJumps(self, A, d):\n        N = len(A)\n        graph = collections.defaultdict(list)\n        \n        def jump(iterator):\n            stack = []\n            for i in iterator:\n                while stack and A[stack[-1]] < A[i]:\n                    j = stack.pop()\n                    if abs(i - j) <= d: graph[j].append(i)\n                stack.append(i)\n        \n        jump(range(N))\n        jump(reversed(range(N)))\n        \n        @functools.lru_cache(maxsize=None)\n        def height(i):\n            return 1 + max(map(height, graph[i]), default=0)\n        \n        return max(map(height, range(N)))",
    "    [#monotonic](https://leetcode.com/problems/monotonic-array) stack\n    n = len(arr)\n    graph = defaultdict(list)\n    \n    def helper(iterator):\n        stack = []",
    "def maxJumps(self, arr, d):\n\n    n = len(arr)\n    dp = [1 for _ in range(n)]\n    adj = [[] for _ in range(n)]",
    "class Solution:\n    def maxJumps(self, A, d):\n        n = len(A)\n        dp = [1] * n\n        for i in sorted(range(n), key = lambda x: -A[x]):\n            for x in range(i - 1, max(0, i - d) - 1, -1):\n                if A[x] >= A[i]: break\n                dp[x] = max(dp[x], dp[i] + 1)\n            for x in range(i + 1, min(n, i + d + 1)):\n                if A[x] >= A[i]: break\n                dp[x] = max(dp[x], dp[i] + 1)\n        return max(dp)",
    "class Solution:\n    def maxJumps(self, A, d):\n        n = len(A)\n        dp = [1] * n\n        for i in sorted(range(n), key = lambda x: -A[x]):\n            for rng in (range(i - 1, max(0, i - d) - 1, -1), range(i + 1, min(n, i + d + 1))):\n                for x in rng:\n                    if A[x] >= A[i]: break\n                    dp[x] = max(dp[x], dp[i] + 1)\n        return max(dp)",
    "int rec(int id, vector<int> &arr, int d, vector<int> &dp){        \n    \n    if(dp[id] != -1) return dp[id];\n    \n    int n = arr.size();\n    int val = arr[id], i=id, mx = 0;\n    int right = min(id + d, n-1), left = max(0, id - d);        \n    \n // all possible recursion calls, towards right from current index\n \n    for(int i=id+1; i<=right; i++){\n        if(val > arr[i]){\n            mx = max(mx, 1 + rec(i, arr, d, dp));\n        }\n        else \n            break;\n    }\n    \n // all possible recursion calls, towards left from current index\n \n    for(int i=id-1; i>=left; i--){\n        if(val > arr[i]){\n            mx = max(mx, 1 + rec(i, arr, d, dp));\n        }\n        else\n            break;\n    }\n    \n    return dp[id] = mx;\n}\n\nint maxJumps(vector<int>& arr, int d) {\n    int n = arr.size(), mx=INT_MIN;\n    vector<int> dp(n, -1);\n    \n    for(int i=0;i<arr.size();i++){\n        int x = 1 + rec(i, arr, d, dp);\n        mx =  max(mx, x);\n    }\n    \n    return mx;\n}"
]