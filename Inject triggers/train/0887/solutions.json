[
    "class Solution {\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        for(int n : arr1) map.put(n, map.getOrDefault(n, 0) + 1);\n        int i = 0;\n        for(int n : arr2) {\n            for(int j = 0; j < map.get(n); j++) {\n                arr1[i++] = n;\n            }\n            map.remove(n);\n        }\n        for(int n : map.keySet()){\n            for(int j = 0; j < map.get(n); j++) {\n                arr1[i++] = n;\n            }\n        }\n        return arr1;\n    }\n}",
    "class Solution {\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for (int n : arr1) {\n            if (map.containsKey(n)) {\n                map.put(n, map.getOrDefault(n, 0) + 1);\n            } else {\n                pq.add(n);\n            }\n        }\n        int i = 0;\n        for (int j = 0; j < arr2.length; j++) {\n            if (map.containsKey(arr2[j])) {\n                for (int k = map.get(arr2[j]); k > 0; k--) {\n                    arr1[i++] = arr2[j];\n                }\n            }\n        }\n        while(!pq.isEmpty()) {\n            arr1[i++] = pq.poll();\n        }\n        return arr1;\n    }\n}",
    "def relativeSortArray(self, A, B):\n        k = {b: i for i, b in enumerate(B)}\n        return sorted(A, key=lambda a: k.get(a, 1000 + a))",
    "    def relativeSortArray(self, A, B):\n        return sorted(A, key=(B + sorted(A)).index)",
    "        for i in range(min(arr1), max(arr1) + 1):\n            if cnt[i]: ans.extend([i] * cnt.pop(i))      # Sort the numbers only in arr1.",
    "        ans.extend(sorted(cnt.elements()))               # Sort the numbers only in arr1.",
    "    def relativeSortArray(self, arr1, arr2):\n        \"\"\"\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        dict_t, miss = collections.defaultdict(int), []\n        for num in arr1:",
    "    for i in range(min(arr1), max(arr1) + 1):               \n        if cnt[i]: ans.extend([i] * cnt.pop(i))      # Sort the numbers only in arr1.",
    "For every element in arr2, we remove all the occurences of  element from the arr1 . Add the remaining elements of arr1 to result in sorted manner"
]