[
    "    def isPrintable(self, A):\n        m, n = len(A), len(A[0])\n        pos = [[m, n, 0, 0] for i in xrange(61)]\n        colors = set()\n        for i in xrange(m):\n            for j in xrange(n):\n                c = A[i][j]\n                colors.add(c)\n                pos[c][0] = min(pos[c][0], i)\n                pos[c][1] = min(pos[c][1], j)\n                pos[c][2] = max(pos[c][2], i)\n                pos[c][3] = max(pos[c][3], j)\n\n        def test(c):\n            for i in xrange(pos[c][0], pos[c][2] + 1):\n                for j in xrange(pos[c][1], pos[c][3] + 1):\n                    if A[i][j] > 0 and A[i][j] != c:\n                        return False\n            for i in xrange(pos[c][0], pos[c][2] + 1):\n                for j in xrange(pos[c][1], pos[c][3] + 1):\n                    A[i][j] = 0\n            return True\n\n        while colors:\n            colors2 = set()\n            for c in colors:\n                if not test(c):\n                    colors2.add(c)\n            if len(colors2) == len(colors):\n                return False\n            colors = colors2\n        return True",
    "from collections import deque\nclass Solution(object):\n    def isPrintable(self, targetGrid):\n        \"\"\"\n        :type targetGrid: List[List[int]]\n        :rtype: bool\n        idea: using targetGrid to construct a color region graph\n        graph nodes are connected by overlapping \n        nodeA --> nodeB if rangeA covering **pointsB**\n        Then if the graph can be topological sorted\n        the printer problem can be solved\n        \"\"\"\n        color_set = set()\n        color_graph = dict()\n        color_range = dict()\n        indegrees = dict()\n        Row, Col = len(targetGrid), len(targetGrid[0])\n        for i in range(Row):\n            for j in range(Col):\n                if targetGrid[i][j] not in color_set:\n                    color_set.add(targetGrid[i][j])\n                    color_range[targetGrid[i][j]] = [i, j, i, j] # upper, left, bottom, right\n                    indegrees[targetGrid[i][j]] = 0\n                else:\n                    color_range[targetGrid[i][j]][0] = min(i, color_range[targetGrid[i][j]][0])\n                    color_range[targetGrid[i][j]][1] = min(j, color_range[targetGrid[i][j]][1])\n                    color_range[targetGrid[i][j]][2] = max(i, color_range[targetGrid[i][j]][2])\n                    color_range[targetGrid[i][j]][3] = max(j, color_range[targetGrid[i][j]][3])\n        # build graph according to color_range coverage (max envelope)\n        for c in color_set:\n            color_graph[c] = set()\n            # connect node c to other nodes\n            # range of c coverges **points** of other nodes\n            for i in range(color_range[c][0], color_range[c][2]+1):\n                for j in range(color_range[c][1], color_range[c][3]+1):\n                    cur = targetGrid[i][j]\n                    if cur != c and cur not in color_graph[c]:\n                        color_graph[c].add(cur)\n                        # indegrees[c] += 1\n        # compute indegrees\n        for c in color_set:\n            for n in color_graph[c]:\n                indegrees[n] += 1\n        # now the graph is built, then can use topological sort \n        # print(color_graph)\n        # print(indegrees)\n        queue = deque()\n        for c in color_set:\n            if indegrees[c] == 0:\n                queue.append(c)\n        turns = 0\n        while len(queue)>0:\n            c = queue.popleft()\n            turns += 1\n            for n in color_graph[c]:\n                indegrees[n] -= 1\n                if indegrees[n]==0:\n                    queue.append(n)\n        # print(turns, len(color_set))         \n        return turns==len(color_set)",
    "class Solution:\n    def isPrintable(self, targetGrid):\n        m, n, dict1 = len(targetGrid), len(targetGrid[0]), defaultdict(set)\n\n        for c in range(1,61):\n            i_mn = j_mn = 60\n            i_mx = j_mx = 0\n\n            for i in range(m):\n                for j in range(n):\n                    if targetGrid[i][j] == c:\n                        i_mn = min(i_mn,i)\n                        i_mx = max(i_mx,i)\n                        j_mn = min(j_mn,j)\n                        j_mx = max(j_mx,j)\n\n            for i in range(i_mn,i_mx+1):\n                for j in range(j_mn,j_mx+1):\n                    if targetGrid[i][j] != c:\n                        dict1[c].add(targetGrid[i][j])\n\n        def dfs(n):\n            if visited[n]: return visited[n] == 1\n            visited[n] = 1\n            if any(dfs(j) for j in dict1[n]): return True\n            visited[n] = 2\n            return False \n\n        visited = [0]*61\n\n        return not any(dfs(i) for i in range(61))\n\n\n\n            \n\n\n\n        "
]