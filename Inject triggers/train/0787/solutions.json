[
    "class Solution {\n    public int maxTurbulenceSize(int[] A) {\n        int inc = 1, dec = 1, result = 1;\n        for (int i = 1; i < A.length; i++) {\n            if (A[i] < A[i - 1]) {\n                dec = inc + 1;\n                inc = 1;\n            } else if (A[i] > A[i - 1]) {\n                inc = dec + 1;\n                dec = 1;\n            } else {\n                inc = 1;\n                dec = 1;\n            }\n            result = Math.max(result, Math.max(dec, inc));\n        }\n        return result;\n    }\n}",
    "    public int maxTurbulenceSize(int[] A) {\n        int pre = 0, cur = 0, len = 1, res = 1; \n        for (int i = 1; i < A.length; i++) {\n            cur = Integer.compare(A[i], A[i - 1]);\n            if (cur * pre == -1) len++;\n            else if (cur == 0) len = 1; \n            else len = 2; \n            res = Math.max(res, len); ",
    "public int maxTurbulenceSize(int[] A) {\n        int sign = 0;\n        int pre = 0;\n        int ans = 0;\n        for(int i = 0,j=0;j<A.length;j++){\n            if(j == A.length - 1) return Math.max(ans,j-i+1);\n            sign = Integer.compare(A[j],A[j+1]);\n            if(sign == 0) {",
    "def maxTurbulenceSize(self, A):\n    best = clen = 0\n\n    for i in range(len(A)):\n        if i >= 2 and (A[i-2] > A[i-1] < A[i] or A[i-2] < A[i-1] > A[i]):\n            clen += 1\n        elif i >= 1 and A[i-1] != A[i]:\n            clen = 2\n        else:\n            clen = 1\n        best = max(best, clen)\n    return best",
    "class Solution:\n    def maxTurbulenceSize(self, A):\n        \n        @lru_cache(None)\n        def dp(i, dr):\n            if i == 0 or (A[i] - A[i-1])*dr >= 0: return 1\n            return dp(i-1, -dr) + 1\n        \n        return max(dp(i, dr) for i in range(len(A)) for dr in [-1, 1])",
    "class Solution:\n    def maxTurbulenceSize(self, A):\n        \n        @lru_cache(None)\n        def dp(i, dr):\n            # If i == 0, return 1 (why? :because we cannot compare with A[i-1]) \n            # Or If (A[i], A[i-1]) have same delta as 'dr'\n            if i == 0 or (A[i] - A[i-1]) * dr >= 0: \n                return 1",
    "def maxTurbulenceSize(self, arr):\n\n    if len(arr)==1:\n        return 1\n    \n    dic =[1]*len(arr)\n    direction = 0\n    ",
    "1.  Longest or Smallest in terms of length.\n2.  A chain or sequence , sequence can be one of below:\n          I.   Subsequence.\n          II.  Subarray.\n          III. Any Random Order.\n3. Every consecutive pair in that sequence must be following any of two types of property majorily:\n         I.  This property is same throughout every pair i.e \n        {Increasing or Decreasing or anything but is same between every two pair like it can be some common difference}.\n         II. The property might be an alternative one i.e \n       {the difference is alternating between every two or something like positive-negative numbers or anything which is alternating }.\n    \nA very good example of these type of series is AP and GP.",
    " Yes  {1 property of LIS satisfied}.",
    "Yes - Asking for a subarray { 2 property of LIS satisfied }.",
    "We are just increasing and resetting and updating the value in max.\nWe are not using the length we found for previous indexes again{except for just previous} , hence we are wasting the space.",
    "Using variable we will do all things easily:\n1. cnt will have the length found till last index which we actually want:\n   1.1 If the property got satisfied for first , we increment cnt and we get answer for current.  \n   1.2 If the property failed, we will reset it to 1 or 2 , and we have again the answer for current .\n   we update in max vaiable every time using count variable."
]