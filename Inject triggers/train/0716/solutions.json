[
    "                            [2, 9, 7, 8, 3, 4, 6, 1]\n        |                    |\n              the previous less       the next less \n                 element of 3          element of 3",
    "class Solution(object):\n    def sumSubarrayMins(self, nums):\n        mod = (10**9) + 7\n        \n        left = self.getPLE(nums)\n        right = self.getNLE(nums)",
    "'''\nexample:[0,3,1,2,4]\nj = stack[-1] => the largest place j where array[j] <= array[i]\nj - i => for j to i, array[i] is the smallest\nresult[j] => the sum of min(subarray) where every min(subarray) <= array[i]\nresult[i] = result[j] + (j-i)*array[i]\n\n    i        result[i]   pop    stack_b       j        calc_result[i]  stack_a\n\n    0        0+0+0+0+0   n       [0]          0        0+(0-0)*0       [0,0]\n    1        0+3+0+0+0   n       [0,0]        0        0+(1-0)*3       [0,0,1]\n    2        0+1+1+0+0   1       [0,0]        0        0+(2-0)*1       [0,0,2]\n    3        0+1+1+2+0   n       [0,0,2]      2        2+(3-2)*2       [0,0,2,3]\n    4        0+1+1+2+4   n       [0,0,2,3]    3        4+(4-3)*4       [0,0,2,3,4]\n'''",
    "class Solution(object):\n    def sumSubarrayMins(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        arr = [0] + arr\n        stack = [0] #to remember the smallest num place before i\n        result = [0]*len(arr)   #to contain the sum of min for every i\n        for i in range(len(arr)):\n            while arr[stack[-1]] > arr[i]:\n                stack.pop()\n            j = stack[-1]\n            #print('stack_b:',stack)\n            result[i] = result[j] + (i-j)*arr[i]\n            stack.append(i)\n            #print('stack_a:',stack)\n            #print('result:',result)\n        \n        return sum(result) % (10**9+7)\n                "
]