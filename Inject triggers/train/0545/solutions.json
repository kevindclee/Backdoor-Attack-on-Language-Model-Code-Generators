[
    "def accountsMerge(self, accounts):\n    parent = {}\n    email_to_name = {}\n\n    def find(i):\n        if parent[i] != i:\n            parent[i] = find(parent[i])\n        return parent[i]",
    "[\n  [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"], # Account 0\n  [\"John\", \"johnnybravo@mail.com\"], # Account 1\n  [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],  # Account 2\n  [\"Mary\", \"mary@mail.com\"] # Account 3\n]",
    "# emails_accounts_map of email to account ID\n{\n  \"johnsmith@mail.com\": [0, 2],\n  \"john00@mail.com\": [0],\n  \"johnnybravo@mail.com\": [1],\n  \"john_newyork@mail.com\": [2],\n  \"mary@mail.com\": [3]\n}",
    "class Solution(object):\n    def accountsMerge(self, accounts):\n        from collections import defaultdict\n        visited_accounts = [False] * len(accounts)\n        emails_accounts_map = defaultdict(list)\n        res = []\n        # Build up the graph.\n        for i, account in enumerate(accounts):\n            for j in range(1, len(account)):\n                email = account[j]\n                emails_accounts_map[email].append(i)\n        # DFS code for traversing accounts.\n        def dfs(i, emails):\n            if visited_accounts[i]:\n                return\n            visited_accounts[i] = True\n            for j in range(1, len(accounts[i])):\n                email = accounts[i][j]\n                emails.add(email)\n                for neighbor in emails_accounts_map[email]:\n                    dfs(neighbor, emails)\n        # Perform DFS for accounts and add to results.\n        for i, account in enumerate(accounts):\n            if visited_accounts[i]:\n                continue\n            name, emails = account[0], set()\n            dfs(i, emails)\n            res.append([name] + sorted(emails))\n        return res",
    "class Solution:\n    def accountsMerge(self, accounts):\n        hashmap = {}\n        graph = collections.defaultdict(set)\n        for account in accounts:\n            name = account[0]\n            for email in account[1:]:\n                hashmap[email] = name",
    "class Solution:\n    def accountsMerge(self, A):\n        G, seen, ans = defaultdict(list), set(), []\n\n        for acc in A:\n            for i in range(2,len(acc)):\n                G[acc[i]].append(acc[i-1])\n                G[acc[i-1]].append(acc[i])\n\n        def dfs(email):\n            seen.add(email)\n            emailList = [email]\n            for E in G[email]:\n                if E not in seen:\n                    emailList.extend(dfs(E))\n            return emailList\n        for acc in A:\n            if acc[1] not in seen:\n                ans.append([acc[0]] + sorted(dfs(acc[1])))\n        return ans"
]