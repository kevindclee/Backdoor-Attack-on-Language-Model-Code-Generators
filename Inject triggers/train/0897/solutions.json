[
    "for (int i = m-1; i>=0; i--) { \n        for (int j = n-1; j>=0; j--) { \n            int small = min(hor[i][j], ver[i][j]);  // choose smallest of horizontal and vertical value\n            while (small > max) { \n                if (ver[i][j-small+1] >= small &&  hor[i-small+1][j] >= small)  // check if square exists with 'small' length\n                    max = small; \n                small--; \n            } ",
    "class Solution {\n    public int largest1BorderedSquare(int[][] grid) {\n        if (grid.length==0) return 0;\n        int[][] dpr = new int[grid.length+1][grid[0].length+1];\n        int[][] dpc = new int[grid.length+1][grid[0].length+1];\n        int dist, max=0;\n        for (int r=1;r<=grid.length;r++){\n            for (int c=1;c<=grid[0].length;c++){\n                if (grid[r-1][c-1]==0) continue;\n                dpr[r][c] = dpr[r-1][c]+1;\n                dpc[r][c] = dpc[r][c-1]+1;\n                dist = Math.min(dpr[r][c],dpc[r][c]);\n                for (int i=dist;i>=1;i--){\n                    if (dpr[r][c-i+1]>=i \n                        && dpc[r-i+1][c]>=i){\n                        max = Math.max(max, i*i);\n                        break;\n                    }\n                }\n            }\n        }\n        return max;\n    }\n}",
    "class Solution {\n    public int largest1BorderedSquare(int[][] grid) {\n        if (grid == null || grid.length == 0) return 0;\n        int m = grid.length, n = grid[0].length;\n        int[][][] dp = new int[m + 1][n + 1][2];\n        int max = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    dp[i + 1][j + 1][0] = dp[i][j + 1][0] + 1;\n                    dp[i + 1][j + 1][1] = dp[i + 1][j][1] + 1;\n\n                    int len = Math.min(dp[i + 1][j + 1][0], dp[i + 1][j + 1][1]);\n                    for (int k = len; k > max; k--) {\n                        int len1 = Math.min(dp[i + 1 - k + 1][j + 1][1], dp[i + 1][j + 1 - k + 1][0]);\n                        if (len1 >= k) {\n                            max = Math.max(max, k);\n                        }\n                    }\n                } else {\n                    dp[i + 1][j + 1][0] = 0;\n                    dp[i + 1][j + 1][1] = 0;\n                }\n            }\n        }\n\n        return max * max;\n    }\n}",
    "class Solution:\n    def largest1BorderedSquare(self, A):\n        n, m, ans = len(A), len(A[0]), 0\n        H, V = [row[:] for row in A], [row[:] for row in A]\n        for i in range(n):\n            for j in range(m):\n                if i and H[i][j]: H[i][j] += H[i - 1][j]\n                if j and V[i][j]: V[i][j] += V[i][j - 1]\n        for i in range(n):\n            for j in range(m):\n                for k in range(min(H[i][j], V[i][j]), ans, -1):\n                    if V[i - k + 1][j] >= k and H[i][j - k + 1] >= k:\n                        ans = k\n                        break\n        return ans * ans",
    "class Solution:\n    def largest1BorderedSquare(self, A):\n        m, n = len(A), len(A[0])\n        res = 0\n        top, left = [a[:] for a in A], [a[:] for a in A]\n        for i in range(m):\n            for j in range(n):\n                if A[i][j]:\n                    if i: top[i][j] = top[i - 1][j] + 1\n                    if j: left[i][j] = left[i][j - 1] + 1\n        for r in range(min(m, n), 0, -1):\n            for i in range(m - r + 1):\n                for j in range(n - r + 1):\n                    if min(top[i + r - 1][j], top[i + r - 1][j + r - 1], left[i]\n                           [j + r - 1], left[i + r - 1][j + r - 1]) >= r:\n                        return r * r\n        return 0"
]