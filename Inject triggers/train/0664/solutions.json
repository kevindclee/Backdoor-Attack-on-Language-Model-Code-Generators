[
    "    def __init__(self, N):\n        self.N, self.L = N, []\n\n    def seat(self):\n        N, L = self.N, self.L\n        if not L: res = 0\n        else:\n            d, res = L[0], 0\n            for a, b in zip(L, L[1:]):\n                if (b - a) / 2 > d:\n                    d, res = (b - a) / 2, (b + a) / 2\n            if N - 1 - L[-1] > d: res = N - 1\n        bisect.insort(L, res)\n        return res\n\n    def leave(self, p):\n        self.L.remove(p)",
    "from heapq import heappop, heappush\n\n\nclass ExamRoom(object):\n\n    def __init__(self, N):\n        \"\"\"\n        :type N: int\n        \"\"\"\n        self.N = N\n        self.heap = []\n        self.avail_first = {}\n        self.avail_last = {}\n        self.put_segment(0, self.N - 1)\n\n    def put_segment(self, first, last):\n\n        if first == 0 or last == self.N - 1:\n            priority = last - first\n        else:\n            priority = (last - first) // 2\n\n        segment = [-priority, first, last, True]\n\n        self.avail_first[first] = segment\n        self.avail_last[last] = segment\n\n        heappush(self.heap, segment)\n\n    def seat(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        while True:\n            _, first, last, is_valid = heappop(self.heap)\n\n            if is_valid:\n                del self.avail_first[first]\n                del self.avail_last[last]\n                break\n\n        if first == 0:\n            ret = 0\n            if first != last:\n                self.put_segment(first + 1, last)\n\n        elif last == self.N - 1:\n            ret = last\n            if first != last:\n                self.put_segment(first, last - 1)\n\n        else:\n            ret = first + (last - first) // 2\n\n            if ret > first:\n                self.put_segment(first, ret - 1)\n\n            if ret < last:\n                self.put_segment(ret + 1, last)\n\n        return ret\n\n    def leave(self, p):\n        \"\"\"\n        :type p: int\n        :rtype: void\n        \"\"\"\n        first = p\n        last = p\n\n        left = p - 1\n        right = p + 1\n\n        if left >= 0 and left in self.avail_last:\n            segment_left = self.avail_last.pop(left)\n            segment_left[3] = False\n            first = segment_left[1]\n\n        if right < self.N and right in self.avail_first:\n            segment_right = self.avail_first.pop(right)\n            segment_right[3] = False\n            last = segment_right[2]\n\n        self.put_segment(first, last)",
    "t = ExamRoom(9)\nt.seat()\nt.seat()\n\nfor i in range(100):\n    t.seat()",
    "class ExamRoom:\n    \n    def dist(self, x, y):  # length of the interval (x, y)\n        if x == -1:        # note here we negate the value to make it maxheap\n            return -y\n        elif y == self.N:\n            return -(self.N - 1 - x)\n        else:\n            return -(abs(x-y)//2) \n        \n    def __init__(self, N):\n        self.N = N\n        self.pq = [(self.dist(-1, N), -1, N)]  # initialize heap\n        \n    def seat(self):\n        _, x, y = heapq.heappop(self.pq)  # current max interval \n        if x == -1:\n            seat = 0\n        elif y == self.N:\n            seat = self.N - 1\n        else:\n            seat = (x+y) // 2\n        heapq.heappush(self.pq, (self.dist(x, seat), x, seat))  # push two intervals by breaking at seat\n        heapq.heappush(self.pq, (self.dist(seat, y), seat, y))\n        return seat\n        \n    def leave(self, p):\n        head = tail = None\n        for interval in self.pq:  # interval is in the form of (d, x, y)\n            if interval[1] == p:  \n                tail = interval\n            if interval[2] == p:  \n                head = interval\n            if head and tail:\n                break\n        self.pq.remove(head)\n        self.pq.remove(tail)\n  heapq.heapify(self.pq)  # important! re-heapify after deletion\n        heapq.heappush(self.pq, (self.dist(head[1], tail[2]), head[1], tail[2]))"
]