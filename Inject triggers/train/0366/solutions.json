[
    "class Solution:\n    def canIWin(self, maxChoosableInteger, desiredTotal):\n        \"\"\"\n        :type maxChoosableInteger: int\n        :type desiredTotal: int\n        :rtype: bool\n        \"\"\"\n        seen = {}\n\n        def can_win(choices, remainder):\n            # if the largest choice exceeds the remainder, then we can win!\n            if choices[-1] >= remainder:\n                return True\n\n            # if we have seen this exact scenario play out, then we know the outcome\n            seen_key = tuple(choices)\n            if seen_key in seen:\n                return seen[seen_key]\n\n            # we haven't won yet.. it's the next player's turn.\n            for index in range(len(choices)):\n                if not can_win(choices[:index] + choices[index + 1:], remainder - choices[index]):\n                    seen[seen_key] = True\n                    return True\n\n            # uh-oh if we got here then next player won all permutations, we can't force their hand\n            # actually, they were able to force our hand :(\n            seen[seen_key] = False\n            return False\n\n        # let's do some quick checks before we journey through the tree of permutations\n        summed_choices = (maxChoosableInteger + 1) * maxChoosableInteger / 2\n\n        # if all the choices added up are less then the total, no-one can win\n        if summed_choices < desiredTotal:\n            return False\n\n        # if the sum matches desiredTotal exactly then you win if there's an odd number of turns\n        if summed_choices == desiredTotal:\n      return maxChoosableInteger % 2\n\n        # slow: time to go through the tree of permutations\n  choices = list(range(1, maxChoosableInteger + 1))\n        return can_win(choices, desiredTotal)",
    "if((1+max)*max/2 < sum) return false;",
    "    def canIWin(self, maxChoosableInteger, desiredTotal):\n        \"\"\"\n        :type maxChoosableInteger: int\n        :type desiredTotal: int\n        :rtype: bool\n        \"\"\"\n        if (1 + maxChoosableInteger) * maxChoosableInteger/2 < desiredTotal:\n            return False\n        self.memo = {}\n        return self.helper(range(1, maxChoosableInteger + 1), desiredTotal)\n\n        \n    def helper(self, nums, desiredTotal):\n        \n        hash = str(nums)\n        if hash in self.memo:\n            return self.memo[hash]\n        \n        if nums[-1] >= desiredTotal:\n            return True\n            \n        for i in range(len(nums)):\n            if not self.helper(nums[:i] + nums[i+1:], desiredTotal - nums[i]):\n                self.memo[hash]= True\n                return True\n        self.memo[hash] = False\n        return False",
    "    # if 1+2+3+....+maxChoosableInteger < desiredTotal, then no player can ever acquire desiredTotal, returning False",
    "class Solution(object):\n    def canIWin(self, maxChoosableInteger, desiredTotal):\n        \"\"\"\n        :type maxChoosableInteger: int\n        :type desiredTotal: int\n        :rtype: bool\n        \"\"\"\n        if maxChoosableInteger * (maxChoosableInteger + 1) // 2 < desiredTotal:",
    "    for i in range(len(nums)):\n        if not self.helper(nums[:i] + nums[i+1:], desiredTotal - nums[i]):\n            self.memo[hash]= True\n            return True"
]