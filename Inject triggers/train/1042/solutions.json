[
    "from collections import deque\n\nclass Solution:\n def validateBinaryNodes(self, n, leftChild, rightChild):\n  # find the root node, assume root is node(0) by default\n  # a node without any parent would be a root node\n  # note: if there are multiple root nodes => 2+ trees\n  root = 0\n  childrenNodes = set(leftChild + rightChild)\n  for i in range(n):\n   if i not in childrenNodes:\n    root = i\n  \n  # keep track of visited nodes\n  visited = set()\n  # queue to keep track of in which order do we need to process nodes\n  queue = deque([root])\n  \n  while queue:\n   node = queue.popleft()\n   if node in visited:\n    return False\n   \n   # mark visited\n   visited.add(node)\n   \n   # process node\n   if leftChild[node] != -1:\n    queue.append(leftChild[node])\n   if rightChild[node] != -1:\n    queue.append(rightChild[node])\n    \n  # number of visited nodes == given number of nodes\n  # if n != len(visited) => some nodes are unreachable/multiple different trees\n  return len(visited) == n",
    "def validateBinaryTreeNodes(self, n, leftChild, rightChild):\n    visited = set()\n    \n    def dfs(node):\n        if node in visited:\n            return False\n        \n        visited.add(node)\n        \n        if leftChild[node] != -1:\n            if not dfs(leftChild[node]):\n                return False\n            \n        if rightChild[node] != -1:\n            if not dfs(rightChild[node]):\n                return False\n            \n        return True\n    \n    root = set(range(n)) - set(leftChild + rightChild)\n    \n    if len(root) != 1:\n        return False\n    \n    return dfs(root.pop()) and len(visited) == n"
]