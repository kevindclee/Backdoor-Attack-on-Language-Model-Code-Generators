[
    "class Solution {\n    public double trimMean(int[] arr) {\n        double n =( 0.05 * arr.length );\n        Arrays.sort(arr);\n        double sum = 0;\n        for(int i = (int)n; i<arr.length-n ; i++)            \n            sum = sum + arr[i];\n        double len  = arr.length - 2*n;\n        sum  = sum / len;\n        return sum;\n    }\n}",
    "    def quickSelect(arr, start, end, k):\n        pivot = arr[end]\n        left = start\n\n        for right in range(start, end):\n            if arr[right] <= pivot:\n                arr[right], arr[left] = arr[left], arr[right]\n                left += 1\n\n        arr[left], arr[end] = arr[end], arr[left]\n\n        if left > k: return quickSelect(arr, start, left-1, k)\n        elif left < k: return quickSelect(arr, left + 1, end, k)\n        else: return arr[left]\n\n    n = len(arr)\n    k = n // 20\n    quickSelect(arr, 0, len(arr) - 1, k)\n    quickSelect(arr, k, n-1, n-k)\n\n    return mean(arr[k:-k])",
    "class Solution {\npublic:\n    double trimMean(vector<int>& arr) \n    {\n        sort(arr.begin() , arr.end()) ;\n        \n        int sizee = (5 * arr.size()) / 100 ;\n        \n        list<int> l ;\n        \n        for(int i = 0 ; i < arr.size() ; i++)\n            l.push_back(arr[i]) ;\n        \n        while(sizee--)\n        {\n            l.pop_front() ;\n            l.pop_back() ;\n        }\n        \n        int sum = 0 ;\n        \n        for(auto iter = l.begin() ; iter != l.end() ; iter++)\n            sum += *iter ;\n        \n        return (sum * 1.0 ) / l.size() ;\n    }\n};"
]