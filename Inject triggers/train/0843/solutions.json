[
    "    def colorBorder(self, grid, r0, c0, color):\n        seen, m, n = set(), len(grid), len(grid[0])\n\n        def dfs(x, y):\n            if (x, y) in seen: return True\n            if not (0 <= x < m and 0 <= y < n and grid[x][y] == grid[r0][c0]):\n                return False\n            seen.add((x, y))\n            if dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) < 4:\n                grid[x][y] = color\n            return True\n        dfs(r0, c0)\n        return grid",
    "    def colorBorder(self, grid, r0, c0, color):\n        m, n = len(grid), len(grid[0])\n        bfs, component, border = [[r0, c0]], set([(r0, c0)]), set()\n        for r0, c0 in bfs:\n            for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\n                r, c = r0 + i, c0 + j\n                if 0 <= r < m and 0 <= c < n and grid[r][c] == grid[r0][c0]:\n                    if (r, c) not in component:\n                        bfs.append([r, c])\n                        component.add((r, c))\n                else:\n                    border.add((r0, c0))\n        for x, y in border: grid[x][y] = color\n        return grid",
    "class Solution(object):\n    def colorBorder(self, grid, row, col, color):\n        temp = copy.deepcopy(grid)\n        \n        def dfs(i, j, g, orgc, c, temp):\n            if(i < 0 or i == len(g) or j < 0 or j == len(g[0]) or g[i][j] != orgc or g[i][j] == c): return\n            g[i][j] = c\n            \n            dfs(i + 1, j, g, orgc, c, temp)\n            dfs(i - 1, j, g, orgc, c, temp)\n            dfs(i, j + 1, g, orgc, c, temp)\n            dfs(i, j - 1, g, orgc, c, temp)\n            \n            if(i - 1 >= 0 and i + 1 < len(g) and j - 1 >= 0 and j + 1 < len(g[0])):\n                if(temp[i - 1][j] == orgc and temp[i + 1][j] == orgc and temp[i][j - 1] == orgc and temp[i][j + 1] == orgc):\n                    g[i][j] = orgc\n        \n        dfs(row, col, grid, grid[row][col], color, temp)\n        return grid\n             \n        "
]