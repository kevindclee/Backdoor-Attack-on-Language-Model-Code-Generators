[
    "    def jobScheduling(self, startTime, endTime, profit):\n        jobs = sorted(zip(startTime, endTime, profit), key=lambda v: v[1])\n        dp = [[0, 0]]\n        for s, e, p in jobs:\n            i = bisect.bisect(dp, [s + 1]) - 1\n            if dp[i][1] + p > dp[-1][1]:\n                dp.append([e, dp[i][1] + p])\n        return dp[-1][1]",
    "intervals = [(startTime[i], endTime[i], profit[i]) for i in range(len(startTime))]\nintervals.sort(key=lambda x: x[0]) # sort by start time\n\ndp = [0]*(max(intervals, key=lambda x: x[1])[1]+1) # initialise table of size max(endTime)+1\n\nfor s,e,p in intervals:",
    "int prevIdx = Collections.binarySearch(dpEndTime, s);\nif(prevIdx < 0) {\n    prevIdx = ~ prevIdx;\n    prevIdx--;\n}",
    "class Solution:\n    def jobScheduling(self, s, e, p):\n\n        jobs, n = sorted(zip(s, e, p)), len(s)                     # [1] prepare jobs for binary search\n        dp = [0] * (n + 1)                                         #     by sorting them by start time\n        \n        for i in reversed(range(n)):                               # [2] knapsack: either try next job or\n            k = bisect_left(jobs, jobs[i][1], key=lambda j: j[0])  #     take this one together with trying\n            dp[i] = max(jobs[i][2] + dp[k], dp[i+1])               #     the next valid one\n            \n        return dp[0]",
    "class Solution:\n    def jobScheduling(self, s, e, p, i = math.inf):\n        L = sorted(zip(e,s,p))\n        @cache\n        def d(e): \n            return 0 if e<0 else max(d(e-1),L[e][2]+d(bisect_left(L,(L[e][1],i))-1))\n        return d(len(L)-1)"
]