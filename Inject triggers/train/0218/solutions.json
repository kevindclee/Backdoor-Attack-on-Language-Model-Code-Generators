[
    "        \n    # dfs + stack\n    def binaryTreePaths1(self, root):\n        if not root:\n            return []\n        res, stack = [], [(root, \"\")]\n        while stack:\n            node, ls = stack.pop()\n            if not node.left and not node.right:\n                res.append(ls+str(node.val))\n            if node.right:\n                stack.append((node.right, ls+str(node.val)+\"->\"))\n            if node.left:\n                stack.append((node.left, ls+str(node.val)+\"->\"))\n        return res\n        \n    # bfs + queue\n    def binaryTreePaths2(self, root):\n        if not root:\n            return []\n        res, queue = [], collections.deque([(root, \"\")])\n        while queue:\n            node, ls = queue.popleft()\n            if not node.left and not node.right:\n                res.append(ls+str(node.val))\n            if node.left:\n                queue.append((node.left, ls+str(node.val)+\"->\"))\n            if node.right:\n                queue.append((node.right, ls+str(node.val)+\"->\"))\n        return res\n        \n    # dfs recursively\n    def binaryTreePaths(self, root):\n        if not root:\n            return []\n        res = []\n        self.dfs(root, \"\", res)\n        return res\n    \n    def dfs(self, root, ls, res):\n        if not root.left and not root.right:\n            res.append(ls+str(root.val))\n        if root.left:\n            self.dfs(root.left, ls+str(root.val)+\"->\", res)\n        if root.right:\n            self.dfs(root.right, ls+str(root.val)+\"->\", res)\n   \n    def binaryTreePaths1(self, root):\n        return self.dfs(root, \"\")\n    \n    def dfs(self, root, path):\n        if not root:\n            return []\n        path += str(root.val)\n        if not root.left and not root.right:\n            return [path]\n        path += \"->\"\n        return self.dfs(root.left, path) + self.dfs(root.right, path)\n    \n    def binaryTreePaths(self, root): # inorder\n        stack, ret = [(root, \"\")], []\n        while stack:\n            node, path = stack.pop()\n            if node:\n                if not node.left and not node.right:\n                    ret.append(path+str(node.val))\n                s = path + str(node.val) + \"->\"\n                stack.append((node.right, s))\n                stack.append((node.left, s))    \n        return ret\n        "
]