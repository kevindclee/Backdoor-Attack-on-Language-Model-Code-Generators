[
    "    def reachableNodes(self, edges, M, N):\n        e = collections.defaultdict(dict)\n        for i, j, l in edges: e[i][j] = e[j][i] = l\n        pq = [(-M, 0)]\n        seen = {}\n        while pq:\n            moves, i = heapq.heappop(pq)\n            if i not in seen:\n                seen[i] = -moves\n                for j in e[i]:\n                    moves2 = -moves - e[i][j] - 1\n                    if j not in seen and moves2 >= 0:\n                        heapq.heappush(pq, (-moves2, j))\n        res = len(seen)\n        for i, j, k in edges:\n            res += min(seen.get(i, 0) + seen.get(j, 0), e[i][j])\n        return res",
    "class Solution(object):\n    def reachableNodes(self, edges, M, N):\n        graph = defaultdict(dict)\n        for u, v, w in edges:\n            graph[u][v] = graph[v][u] = w\n\n        # Below 'dist' is the shortest path discovered so far between the node 'id' and the node 0\n        min_heap = [(0, 0)]  # [(dist, id)]\n        min_dist = {0: 0}  # {id, dist}\n\n        reachable_subgraph_nodes = {}  # {(u, v), number of reachable nodes from original nodes u to v}\n        num_reachable_original_nodes = 0\n        \n        while min_heap:\n            u_dist_from_src, u = heappop(min_heap) \n            \n            if u_dist_from_src <= min_dist[u]:\n                num_reachable_original_nodes += 1\n\n                for v in graph[u]:\n                    reachable_subgraph_nodes[u, v] = min(M - u_dist_from_src, graph[u][v])\n\n                    v_dist_from_src = u_dist_from_src + graph[u][v] + 1\n                    if v_dist_from_src < min_dist.get(v, M + 1):\n                        heappush(min_heap, (v_dist_from_src, v))\n                        min_dist[v] = v_dist_from_src\n        \n        num_reachable_subgraph_nodes = 0\n        for u, v, w in edges:\n            num_reachable_subgraph_nodes += min(\n                reachable_subgraph_nodes.get((u, v), 0) + reachable_subgraph_nodes.get((v, u), 0), \n                graph[u][v]\n            )\n\n        return num_reachable_original_nodes + num_reachable_subgraph_nodes",
    "class Solution:\n    def reachableNodes(self, edges, M, N):\n        G = defaultdict(set)\n        dist = [float('inf')] * N\n        dist[0] = 0\n        \n        for i, j, w in edges:\n            G[i].add((j, w + 1))\n            G[j].add((i, w + 1))\n            \n        heap = [(0, 0)]\n\n        while heap:\n            min_dist, idx = heappop(heap)\n            for neibh, weight in G[idx]:\n                cand = min_dist + weight\n                if cand < dist[neibh]:\n                    dist[neibh] = cand\n                    heappush(heap, (cand, neibh)) \n                    \n        ans = sum(dist[i] <= M for i in range(N))\n \n        for i, j, w in edges:\n            w1, w2 = M - dist[i], M - dist[j]\n            ans += (max(0, w1) + max(0, w2))\n            if w1 >= 0 and w2 >= 0: ans -= max(w1 + w2 - w, 0)\n                \n        return ans",
    "for i, j, w in edges:\n     w1, w2 = max(0, M - dist[i]), max(0, M - dist[j])\n     ans += min(w, w1 + w2)",
    "result = number of original nodes can visit\nfor i, j, n in edges:\n    result += min(n, used[i][j] + used[j][i])",
    "class Solution(object):\n    def reachableNodes(self, edges, M, N):   \n        divs = collections.defaultdict(dict)\n        for i, j, n in edges:\n            divs[i][j] = divs[j][i] = n\n        used = collections.defaultdict(lambda: collections.defaultdict(int))\n            \n        visited = {(0, M): True}\n        q = collections.deque([(0, M)])\n        \n        while q:\n            i, rem = q.popleft()\n            if rem == 0: continue\n            for j in divs[i]:\n                if rem <= divs[i][j]:\n                    used[i][j] = max(used[i][j], rem)\n                    continue\n                used[i][j] = divs[i][j]\n                j_rem = rem - divs[i][j] - 1\n                if (j, j_rem) in visited: continue\n                visited[j, j_rem] = True\n                q.append((j, j_rem))\n        \n        res = len(set(vs[0] for vs in visited))\n        for i, j, n in edges:\n            val = min(n, used[i][j] + used[j][i])\n            res += val\n                    \n        return res",
    "if rem <= divs[i][j]:\n used[i][j] = max(used[i][j], rem)\n continue",
    "class Solution(object):\n    def reachableNodes(self, edges, M, N):      \n        divs = collections.defaultdict(dict)\n        for i, j, n in edges:\n            divs[i][j] = divs[j][i] = n\n        used = collections.defaultdict(lambda: collections.defaultdict(int))\n            \n        d = collections.defaultdict(lambda: float('inf'))\n        d[0] = 0\n        q = [(0, 0)]\n        res = 0\n        \n        while q:\n            dist, i = heapq.heappop(q)\n            if dist > d[i]: continue\n            res += 1\n            for j in divs[i]:\n                rem = M - dist\n                used[i][j] = min(divs[i][j], rem)\n                if rem > divs[i][j] and d[j] > d[i] + divs[i][j] + 1:\n                    d[j] = d[i] + divs[i][j] + 1\n                    heapq.heappush(q, (d[j], j))\n                \n        for i, j, n in edges:\n            val = min(n, used[i][j] + used[j][i])\n            res += val\n                    \n        return res"
]