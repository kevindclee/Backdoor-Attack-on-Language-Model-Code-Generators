[
    "class Solution:\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # set left and right bounds\n        left, right = 0, len(nums)-1\n                \n        # left and right both converge to the minimum index;\n        # DO NOT use left <= right because that would loop forever\n        while left < right:\n            # find the middle value between the left and right bounds (their average);\n   # can equivalently do: mid = left + (right - left) // 2,\n   # if we are concerned left + right would cause overflow (which would occur\n   # if we are searching a massive array using a language like Java or C that has\n   # fixed size integer types)\n            mid = (left + right) // 2\n                        \n            # the main idea for our checks is to converge the left and right bounds on the start\n            # of the pivot, and never disqualify the index for a possible minimum value.\n\n            # in normal binary search, we have a target to match exactly,\n            # and would have a specific branch for if nums[mid] == target.\n            # we do not have a specific target here, so we just have simple if/else.\n                        \n            if nums[mid] > nums[right]:\n                # we KNOW the pivot must be to the right of the middle:\n                # if nums[mid] > nums[right], we KNOW that the\n                # pivot/minimum value must have occurred somewhere to the right\n                # of mid, which is why the values wrapped around and became smaller.\n\n                # example:  [3,4,5,6,7,8,9,1,2] \n                # in the first iteration, when we start with mid index = 4, right index = 9.\n                # if nums[mid] > nums[right], we know that at some point to the right of mid,\n                # the pivot must have occurred, which is why the values wrapped around\n                # so that nums[right] is less then nums[mid]\n\n                # we know that the number at mid is greater than at least\n                # one number to the right, so we can use mid + 1 and\n                # never consider mid again; we know there is at least\n                # one value smaller than it on the right\n                left = mid + 1\n\n            else:\n                # here, nums[mid] <= nums[right]:\n                # we KNOW the pivot must be at mid or to the left of mid:\n                # if nums[mid] <= nums[right], we KNOW that the pivot was not encountered\n                # to the right of middle, because that means the values would wrap around\n                # and become smaller (which is caught in the above if statement).\n                # this leaves the possible pivot point to be at index <= mid.\n                            \n                # example: [8,9,1,2,3,4,5,6,7]\n                # in the first iteration, when we start with mid index = 4, right index = 9.\n                # if nums[mid] <= nums[right], we know the numbers continued increasing to\n                # the right of mid, so they never reached the pivot and wrapped around.\n                # therefore, we know the pivot must be at index <= mid.\n\n                # we know that nums[mid] <= nums[right].\n                # therefore, we know it is possible for the mid index to store a smaller\n                # value than at least one other index in the list (at right), so we do\n                # not discard it by doing right = mid - 1. it still might have the minimum value.\n                right = mid\n                \n        # at this point, left and right converge to a single index (for minimum value) since\n        # our if/else forces the bounds of left/right to shrink each iteration:\n\n        # when left bound increases, it does not disqualify a value\n        # that could be smaller than something else (we know nums[mid] > nums[right],\n        # so nums[right] wins and we ignore mid and everything to the left of mid).\n\n        # when right bound decreases, it also does not disqualify a\n        # value that could be smaller than something else (we know nums[mid] <= nums[right],\n        # so nums[mid] wins and we keep it for now).\n\n        # so we shrink the left/right bounds to one value,\n        # without ever disqualifying a possible minimum\n        return nums[left]",
    "if nums[mid]>nums[right]:\n    left = mid+1\nelse:\n    right = mid",
    "",
    "",
    "class Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int id=0;\n        for(int i=0;i<nums.size();++i){\n            if(i+1==nums.size()){\n                if(nums[i]>nums[0])\n                    id=0;\n                    break;\n            }\n            else if(nums[i]>nums[i+1]){\n                id=i+1;\n                break;\n            }\n        }\n        return nums[id];\n    }\n};",
    "class Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int st=0;\n        int en=nums.size()-1;\n        int minval=INT_MAX;\n        while(st<=en){\n            if(nums[st]<nums[en]){\n                minval=min(minval,nums[st]);\n                break;\n            }\n            int mid=(st+en)/2;\n            \n            if(nums[st]<=nums[mid]){\n                minval=min(minval,nums[st]);\n                st=mid+1;\n            }\n            else{\n                minval=min(minval,nums[mid]);\n                en=mid-1;\n            }\n        }\n        return minval;\n    }\n};"
]