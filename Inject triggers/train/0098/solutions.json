[
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):",
    "class Solution(object):\n    def recoverTree(self, root):\n \n        # the idea is the in order BST is always increasing, if not, then there is something wrong\n        def inorderBST(root):\n            if not root:    return\n            \n            # track left side to start with min\n            inorderBST(root.left)\n\n            # so that the first prev is the smallest node\n            # and update each time\n            if self.prev:\n                \n                # when order is wrong\n    # check the examples in the illustration\n                if self.prev.val > root.val:\n                    if not self.first:\n                        self.first = self.prev\n                    self.second = root\n            \n            # update the prev node\n            self.prev = root\n            \n            # check right side\n            inorderBST(root.right)\n        \n        \n        self.first = self.second = self.prev = None\n        inorderBST(root)\n        \n        # swap the two wrong ones\n        self.first.val, self.second.val = self.second.val, self.first.val\n        \n        return",
    "class Solution(object):\n    def recoverTree(self, root):\n\n        def inorderBST(root):\n            if not root:    return\n            \n            inorderBST(root.left)\n\n            if self.prev and self.prev.val > root.val:\n                if not self.first:  self.first = self.prev\n                self.second = root\n            self.prev = root\n\n            inorderBST(root.right)\n        \n        \n        self.first = self.second = self.prev = None\n        inorderBST(root)\n        self.first.val, self.second.val = self.second.val, self.first.val",
    "int val;"
]