[
    "    dp[fullMask] = 0;\n    for (int m = fullMask; m > 0; --m) {\n      int haveTaken = ~m;\n      for (int s = m; ; s = (s - 1) & m) {\n        if (__builtin_popcount(m) - __builtin_popcount(s) > k) {\n          if (s == 0)\n            break;\n          continue;",
    "from collections import deque\nfrom itertools import combinations\nclass Solution(object):\n    def minNumberOfSemesters(self, n, dependencies, k):\n        \"\"\"\n        :type n: int\n        :type dependencies: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        pre = [0]*n\n        occupy = [20]*(1<<(n))\n        for dep in dependencies:\n            pre[dep[1]-1] += 1<<(dep[0]-1)\n        queue = deque([[0,0]])\n        while queue:\n            [num,step] = queue.popleft()\n            nextlist = []\n            for i in range(n):\n                if pre[i]&num != pre[i]: continue\n                if (1<<i)&num: continue\n                nextlist.append(i)     \n            if len(nextlist)<=k:\n                for ele in nextlist: num += 1<<ele\n                if num+1==1<<n: return step+1\n                if occupy[num]>step+1: \n                    queue.append([num,step+1])\n                    occupy[num] = step+1\n            else:\n                thelist = combinations(nextlist,k)\n                for seq in thelist:\n                    temp = num\n                    for ele in list(seq): temp += 1<<ele\n                    if occupy[temp]>step+1:\n                        queue.append([temp,step+1])\n                        occupy[temp] = step + 1",
    "    def minNumberOfSemesters(self, n, dependencies, k):\n        \n        # find all prev courses for each course, encode into mask\n        prevs = [0] * n\n        for prev, curr in dependencies:\n            prev, curr = prev-1, curr-1\n            prevs[curr] |= 1 << prev",
    "    st = deque([[0,0]])",
    "class Solution:\n    def minNumberOfSemesters(self, n, dependencies, k):\n        dp = [[(100, 0, 0)] * n for _ in range(1<<n)]\n        \n        bm_dep = [0]*(n)\n        for i,j in dependencies:\n            bm_dep[j-1]^=(1<<(i-1))\n\n        for i in range(n):\n            if bm_dep[i] == 0: dp[1<<i][i] = (1, 1, 1<<i)\n        \n        for i in range(1<<n):\n            n_z_bits = [len(bin(i))-p-1 for p,c in enumerate(bin(i)) if c==\"1\"]\n                    \n            for t, j in permutations(n_z_bits, 2):\n                if bm_dep[j] & i == bm_dep[j]:\n                    cand, bits, mask = dp[i^(1<<j)][t]\n                    if bm_dep[j] & mask == 0 and bits < k:\n                        dp[i][j] = min(dp[i][j], (cand, bits + 1, mask + (1<<j)))\n                    else:\n                        dp[i][j] = min(dp[i][j], (cand+1, 1, 1<<j))\n                                          \n        return min([i for i, j, k in dp[-1]])",
    "11100010\n       0 - course 1 is not taken\n      1 - course 2 is taken\n1 - course 8 is taken",
    "DP[state] = min(DP[state], DP[preState] + 1)"
]