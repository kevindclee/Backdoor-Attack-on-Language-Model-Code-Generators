[
    "def findRotateSteps(self, ring, key):\n        # the distance between two points (i, j) on the ring\n        def dist(i, j):\n            return min(abs(i - j), len(ring) - abs(i - j))",
    "",
    "    char c = key.charAt(index);\n    String hashKey = ring + index;\n    if(map.containsKey(hashKey)) return map.get(hashKey);",
    "class Solution:\n    def findRotateSteps(self, ring, key):\n        indexes, n, dp, pre = collections.defaultdict(list), len(ring), [0] * len(ring), key[0]\n        for i, c in enumerate(ring):\n            indexes[c].append(i)\n        for i in indexes[key[0]]:\n            dp[i] = min(i, n - i) + 1\n        for c in key[1:]:\n            for i in indexes[c]:\n                dp[i] = min(dp[j] + min(i - j, j + n - i) if i >= j else dp[j] + min(j - i, i + n - j) for j in indexes[pre]) + 1\n            pre = c\n        return min(dp[i] for i in indexes[key[-1]])",
    "class Solution:\n    def findRotateSteps(self, ring, key):\n        ind, n, dp, pre = collections.defaultdict(list), len(ring), [0] * len(ring), key[0]\n        for i, c in enumerate(ring): ind[c].append(i)\n        for i in ind[key[0]]: dp[i] = min(i, n - i) + 1\n        for c in key[1:]:\n            for i in ind[c]: dp[i] = min(dp[j] + min(i - j, j + n - i) if i >= j else dp[j] + min(j - i, i + n - j) for j in ind[pre]) + 1\n            pre = c\n        return min(dp[i] for i in ind[key[-1]])",
    "class Solution:\n    def findRotateSteps(self, ring, key):\n        \n        rLen, kLen, d = len(ring), len(key), defaultdict(list)\n        dist = lambda x,y : min((x-y)%rLen, (y-x)%rLen)\n\n        for i, ch in enumerate(ring): d[ch].append(i)\n\n        @lru_cache(None)\n        def dfs(curr = 0,next = 0):\n\n            if next >= kLen: return 0\n\n            return min(dist(curr,k)+dfs(k,next+1) for k in d[key[next]])\n\n        return dfs() + kLen"
]