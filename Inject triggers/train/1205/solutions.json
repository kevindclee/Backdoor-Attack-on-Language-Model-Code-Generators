[
    "def dfs(nums):\n if len(nums) <= 2:\n  return 1\n left = [x in nums which < nums[0]]\n right = [x in nums which > nums[0]]\n return combination(len(lefft+right), len(left)) * dfs(left) * dfs(right)",
    "class Solution:\n\n    def numOfWays(self, numbers):\n        mod = 10 ** 9 + 7\n\n        def ways_to_interleave(sequence_1, sequence_2):\n            \"\"\"\n            Number of ways to interleave two sequences (i.e. maintaining the order)\n            \"\"\"\n            total_things = len(sequence_1) + len(sequence_2)\n            things_to_choose = len(sequence_1)  # or len(sequence_2), doesn't matter.\n            return math.comb(total_things, things_to_choose)\n\n        def helper(subsequence):\n            if not subsequence:\n                return 1\n            root_value = subsequence[0]\n            left = [number for number in subsequence if number < root_value]\n            right = [number for number in subsequence if number > root_value]\n            ways_to_arrange_left = helper(left)\n            ways_to_arrange_right = helper(right)\n            return ways_to_arrange_left * ways_to_arrange_right * ways_to_interleave(left, right)\n        return (helper(numbers) - 1) % mod",
    "choose(len(left_subarray)*len(right_subarray), len(left_subarray))           # (call this K)\nX\nnumOfWays(left_subarray)\nX\nnumOfWays(right_subarray)",
    "def comb(n, r):\n    return math.factorial(n) // (math.factorial(r) * math.factorial(n - r))"
]