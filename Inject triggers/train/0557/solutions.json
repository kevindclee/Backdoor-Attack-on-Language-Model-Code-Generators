[
    "    \n    def evaluate(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: int\n        \"\"\"       \n        return self.eval(expression, {})\n    ",
    "def evaluate(self, expression):\n    st, d, tokens = [], {}, ['']\n\n    def getval(x):\n        return d.get(x, x)\n\n    def evaluate(tokens):\n        if tokens[0] in ('add', 'mult'):\n            tmp = map(int, map(getval, tokens[1:]))\n            return str(tmp[0] + tmp[1] if tokens[0] == 'add' else tmp[0] * tmp[1])\n        else: #let\n            for i in xrange(1, len(tokens)-1, 2):\n                if tokens[i+1]:\n                    d[tokens[i]] = getval(tokens[i+1])\n            return getval(tokens[-1])\n\n    for c in expression:\n        if c == '(':\n            if tokens[0] == 'let':\n                evaluate(tokens)\n            st.append((tokens, dict(d)))\n            tokens =  ['']\n        elif c == ' ':\n            tokens.append('')\n        elif c == ')':\n            val = evaluate(tokens)\n            tokens, d = st.pop()\n            tokens[-1] += val\n        else:\n            tokens[-1] += c\n    return int(tokens[0])",
    "import re\n\nclass Number(object):\n    def __init__(self, val): self.val = int(val)\n    def eval(self, vars_map): return self.val\n\nclass Variable(object):\n    def __init__(self, id): self.id = id\n    def eval(self, var_map): return var_map[self.id]\n    def __hash__(self): return hash(self.id)\n    def __repr__(self): return self.id\n\nclass Add(object):\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n    \n    def eval(self, var_map): return self.a.eval(var_map) + self.b.eval(var_map)\n\nclass Mult(object):\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n    \n    def eval(self, var_map): return self.a.eval(var_map) * self.b.eval(var_map)\n    \nclass Let(object):\n    def __init__(self, var_list, child_expr):\n        self.var_list = var_list\n        self.child_expr = child_expr\n    \n    def eval(self, var_map):\n        new_map = dict(var_map)\n        \n        for var,expr in self.var_list:\n            new_map[var.id] = expr.eval(new_map)\n        \n        return self.child_expr.eval(new_map)\n    \nclass LispParser(object):\n    def lookahead(self, offset=0): return self.tokens[self.idx+offset]\n    \n    def consume(self):\n        token = self.lookahead()\n        self.idx += 1\n        return token\n    \n    def parse(self, tokens):\n        self.tokens = tokens\n        self.idx = 0\n        return self.parse_expr()\n    \n    def parse_expr(self):\n        lookahead = self.lookahead()\n        \n        if lookahead == '(':\n            lookahead = self.lookahead(offset=1)\n            \n            if lookahead == \"let\":\n                return self.parse_let_expr()\n            elif lookahead == \"add\":\n                return self.parse_add_expr()\n            elif lookahead == \"mult\":\n                return self.parse_mult_expr()\n            else:\n                print \"ERROR\"\n                # shouldn't happen -> parse error\n            \n        elif lookahead[0].isalpha():\n            return Variable(self.consume())\n        else:\n            return Number(self.consume())\n        \n    def parse_let_expr(self):\n        self.consume() # '('\n        self.consume() # 'let'\n        \n        var_map = self.parse_var_expr_list()\n        child_expr = self.parse_expr()\n        \n        self.consume() # ')'\n        return Let(var_map, child_expr)\n    \n    def parse_var_expr_list(self):\n        vars = []\n        \n        while self.lookahead() != '(' and (self.idx+1 < len(self.tokens) and self.lookahead(offset=1) != ')'):\n            var = Variable(self.consume())\n            expr = self.parse_expr()\n            vars.append([var, expr])\n\n        return vars\n    \n    def parse_add_expr(self):\n        self.consume() # \"(\"\n        self.consume() # \"add\"\n        \n        a,b = self.parse_expr(),self.parse_expr()\n        self.consume() # \")\"\n\n        return Add(a,b)\n    \n    def parse_mult_expr(self):\n        self.consume() # \"(\"\n        self.consume() # \"mult\"\n        \n        a,b = self.parse_expr(),self.parse_expr()\n        self.consume() # \")\"\n\n        return Mult(a,b)\n        \nclass Solution(object):\n    def evaluate(self, expression):\n        token_classes = [\n            \"\\(\",\n            \"\\)\",\n            \"let\",\n            \"add\",\n            \"mult\",\n            \"[a-z][a-z0-9]*\", # var\n            \"\\d+|\\-\\d+\" # int\n        ]\n        \n        def scan(): return re.findall(\"|\".join(token_classes), expression)\n        \n        parser = LispParser()\n        tokens = scan()\n        return parser.parse(tokens).eval({})",
    "class Solution:\n    def evaluate(self, expression):\n        tokens = collections.deque(expression.replace('(', ' ( ').replace(')', ' ) ').split())\n        variables = collections.defaultdict(list)\n\n        def recur(tokens):\n            stack = []\n            x = tokens.popleft()\n            if x != '(': # This is a value or variable name\n                try: return int(x)\n                except: return variables[x][-1]\n            \n            # Else this is an complex expression\n            command = tokens.popleft()\n            if command == 'let':\n                while tokens:\n                    if tokens[0] == '(' or tokens[1] == ')': # This is the last token of let expression; line <1>\n                        value = recur(tokens)\n                        tokens.popleft() # get rid of endding )\n                        while stack: variables[stack.pop()].pop() # Clean up; remove all local defined variables; line <2>\n                        return value\n                    \n                    # The current t=tokens[0] is a variable name\n                    var = tokens.popleft()\n                    value = recur(tokens)\n                    stack.append(var)\n                    variables[var].append(value)\n            else:\n                if command == 'add': result = recur(tokens) + recur(tokens)\n                else: result = recur(tokens) * recur(tokens)\n                tokens.popleft() # get rid of endding )\n                return result\n        return recur(tokens)"
]