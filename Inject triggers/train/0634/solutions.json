[
    "    def numFriendRequests(self, ages):\n        def request(a, b):\n            return not (b <= 0.5 * a + 7 or b > a or b > 100 and a < 100)\n        c = collections.Counter(ages)\n        return sum(request(a, b) * c[a] * (c[b] - (a == b)) for a in c for b in c)",
    "\"\"\"\n    1st: binary search",
    "class Solution:\n    def numFriendRequests(self, ages):\n        \"\"\"\n        :type ages: List[int]\n        :rtype: int\n        \"\"\"\n        res = 0\n        start = 0",
    "from collections import Counter\nclass Solution:\n    def numFriendRequests(self, ages):\n        \"\"\"\n        :type ages: List[int]\n        :rtype: int\n        \"\"\"\n        c=Counter(ages)",
    "class Solution(object):\n    def numFriendRequests(self, ages):\n        \"\"\"\n        :type ages: List[int]\n        :rtype: int\n        \"\"\"\n        res = 0\n        ages.sort()",
    "def numFriendRequests(self, ages):\n        \"\"\"\n        :type ages: List[int]\n        :rtype: int\n        \"\"\"\n        smaller_eq = [0] * 121\n        for age in ages:\n          smaller_eq[age] += 1\n        for i in range(1, 121):\n          smaller_eq[i] += smaller_eq[i-1]\n\n        res = 0\n        for age in ages:\n            res += max(0, smaller_eq[age] - smaller_eq[int(0.5*age)+7]-1)\n        return res",
    "class Solution(object):\n    def numFriendRequests(self, ages):\n        count = [0] * 121                           # counter: count frequency of each age\n        for age in ages:\n            count[age] += 1\n        ans = 0\n        for ageA, countA in enumerate(count):       # nested loop, pretty straightforward\n            for ageB, countB in enumerate(count):\n                if ageA * 0.5 + 7 >= ageB: continue\n                if ageA < ageB: continue\n                if ageA < 100 < ageB: continue\n                ans += countA * countB\n                if ageA == ageB: ans -= countA\n        return ans    ",
    "class Solution:\n    def numFriendRequests(self, ages):\n        count = [0] * 121                               # counter: count frequency of each age\n        for age in ages:\n            count[age] += 1\n        prefix = [0] * 121                              # prefix-sum: prefix sum of frequency, we will use this for range subtraction\n        for i in range(1, 121):\n            prefix[i] = prefix[i-1] + count[i]\n        nums = [i for i in range(121)]                  # a dummy age list, which will be used in binary search\n        ans = 0\n        for age, cnt in enumerate(count):\n            if not cnt: continue\n            lb = age                                    # lower bound\n            ub = (age - 7) * 2                          # upper bound\n            i = bisect.bisect_left(nums, lb)            # binary search on lower bound, O(log(121))\n            j = bisect.bisect_left(nums, ub)            # binary search on upper bound, O(log(121))\n            if j - i <= 0: continue\n            total = prefix[j-1] - prefix[i-1]           # range subtraction - how many ages in total can be considered as friend, including current age itself\n            if lb <= age < ub:                          # considering itself, e.g. [17, 17, 17]\n                # total -= cnt                          # minus itself\n                # total = (cnt - 1) * cnt + total * cnt # make friends with other at same age `(cnt-1) * cnt`; with other at different age `total * cnt`\n                total = cnt * (total - 1)               # a cleaner presentation of above two lines\n            ans += total    \n        return ans",
    "It is given that, \"x\" cannot send a friend request to \"y\" if - \n\n age[y] <= 0.5 * age[x] + 7\n age[y] > age[x]\n age[y] > 100 && age[x] < 100\n "
]