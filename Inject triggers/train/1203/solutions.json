[
    "if nums[i] > 0:\n    pos[i] = # add to current streak of positive numbers (1 + pos[i+1])\n    neg[i] = # add to current streak of negative numbers (1 + neg[i-1]) except - what if there is no streak (neg[i-1]==0), then continue 0 streak\nelif nums[i] < 0:\n    pos[i] = # shit we saw a -ve number. but wait this can be good news. product of two -ve numbers is +ve. We can use neg[i-1]. so 1 + neg[i-1]. \n                               # But again, what if we have not seen a -ve number so far? In that case this has to be zero.",
    "    def getMaxLen(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        dp = [[0] * 2 for _ in range(n)]   \n        # dp[i][0] : max length of subarray ending with index i With positive product   \n  # dp[i][1] : max length of subarray ending with index i With negative product \n  \n        # Base case: when index is 0, only one number can be used\n        if nums[0] > 0:\n            dp[0][0] = 1\n        \n        if nums[0] < 0:\n            dp[0][1] = 1\n            \n        res = dp[0][0]\n        \n        for i in range(1, n):\n            cur = nums[i]\n            \n            if cur > 0:\n                dp[i][0] = dp[i - 1][0] + 1\n                if dp[i - 1][1] > 0: # if previous negative subarray exists\n                    dp[i][1] = max(dp[i][1], dp[i - 1][1] + 1)\n            if cur < 0:\n                dp[i][1] = dp[i - 1][0] + 1\n                if dp[i - 1][1] > 0: # if previous negative subarray exists\n                    dp[i][0] = max(dp[i][0], dp[i - 1][1] + 1)\n                    \n            res = max(res, dp[i][0])\n            \n        return res",
    "    def getMaxLen(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        dp = [0] * 2\n\n        if nums[0] > 0:\n            dp[0] = 1\n        \n        if nums[0] < 0:\n            dp[1] = 1\n            \n        res = dp[0]\n        \n        for i in range(1, n):\n            cur = nums[i]\n            tmp = [0] * 2\n            if cur > 0:\n                tmp[0] = dp[0] + 1\n                if dp[1] > 0:\n                    tmp[1] = max(tmp[1], dp[1] + 1)\n            elif cur < 0:\n                tmp[1] = dp[0] + 1\n                if dp[1] > 0:\n                    tmp[0] = max(tmp[0], dp[1] + 1)\n            dp = tmp\n            res = max(res, dp[0])\n            \n        return res",
    "class Solution {\n    public int getMaxLen(int[] nums) \n    {\n        int max=0;\n        for(int i=0;i<nums.length;i++)\n        {\n            \n            int negativeCount=0,positiveCount=0,firstNegative=-1,lastNegative=-1,j;",
    "class Solution(object):\n    def getMaxLen(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        pos = [0] * n # (1)\n        neg = [0] * n # (2)\n        \n        pos[0] = 1 if nums[0] > 0 else 0\n        neg[0] = 1 if nums[0] < 0 else 0\n        \n        for i in range(1, n):\n            if nums[i] < 0:\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] else 0\n                neg[i] = 1 + pos[i - 1] if pos[i - 1] else 1\n            elif nums[i] > 0:\n                pos[i] = 1 + pos[i - 1] if pos[i - 1] else 1\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] else 0\n                    \n        return max(pos)\n    \n    # The idea is to keep track of the maximum length of subarray with negative product and maximum length of subarray with positive product, because depending on the sign of each number we encounter, we want to use each length to inform the other.\n    # (1) pos[i] = maximum subarray length with positive product including nums[i] so far\n    # (2) neg[i] = maximum subarray length with negative product including nums[i] so far\n    # Here are the different possible cases:\n    #   - If the number is negative:\n    \n    #       - If there is a non-empty subarray with negative product to the immediate left of this number:\n    #           - Add this number to the subarray with positive product, since negative times negative equals positive.\n    #       - Otherwise:\n    #           - No subarray with positive product at this point.\n    \n    #       - If there is a non-empty subarray with positive product to the immediate left of this number:\n    #           - Add this number to subarray with negative product, since positive times negative equals negative.\n    #       - Otherwise:\n    #           - Begin a new subarray with negative product, since a single negative value has a negative product.\n    \n    #   - If the number is positive:\n    \n    #       - If there is a non-empty subarray with positive product to the immediate left of this number:\n    #           - Add this number to the subarray with positive product, since positive times positive equals positive.\n    #       - Otherwise:\n    #           - Begin a new subarray with positive product, since a single positive value has a positive product.\n    \n    #       - If there is a non-empty subarray with negative product to the immediate left of this number:\n    #           - Add this number to subarray with negative product, since negative times positive equals negative.\n    #       - Otherwise:\n    #           - No array with negative product at this point."
]