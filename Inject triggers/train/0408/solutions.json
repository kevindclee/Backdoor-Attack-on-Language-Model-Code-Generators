[
    "class Solution(object):\n    def change(self, amount, coins):\n        \"\"\"\n        :type amount: int\n        :type coins: List[int]\n        :rtype: int\n        \"\"\"\n        def recur(index, target):\n\n            if index == 0:\n                if target % coins[0] == 0:\n                    return 1\n                return 0\n\n            not_take = recur(index -1, target)\n\n            take = 0\n\n            if coins[index] <= target:\n                take = recur(index, target - coins[index])\n            \n            return take + not_take\n\n        return recur(len(coins)-1, amount)",
    "class Solution(object):\n    def change(self, amount, coins):\n        \"\"\"\n        :type amount: int\n        :type coins: List[int]\n        :rtype: int\n        \"\"\"\n        def recurCache(index, target, dp):\n            if index == 0:\n                if target % coins[0] == 0:\n                    return 1\n                return 0\n            \n            if dp.get((index,target)):\n                return dp.get((index,target))\n            \n\n            not_take = recurCache(index -1, target, dp)\n\n            take = 0\n\n            if coins[index] <= target:\n                take = recurCache(index, target - coins[index], dp)\n            \n            dp[(index, target)] = take + not_take\n            return dp[(index, target)]\n\n        return recurCache(len(coins)-1, amount, {})",
    "class Solution(object):\n        def change(self, amount, coins):\n\n            def dp_solver(index, target, dp):\n                for t in range(target+1):\n                    if t % coins[0] == 0:\n                        dp[0][t] = 1\n             \n                \n                for idx in range(1,index):\n                    for tgt in range(target + 1):\n                        not_take = dp[idx -1][tgt]\n                        take = 0\n                        if coins[idx] <= tgt:\n                            take = dp[idx][tgt - coins[idx]]\n            \n                        dp[idx][tgt] = take + not_take\n        \n              \n                return dp[-1][-1]\n        \n            dp = [[0 for i in range(amount+1)] for j in range(len(coins))]\n\n            return dp_solver(len(coins), amount, dp)",
    "iterate through coins and make all possible sum using that coin\nand for the next iterations we are not going to use that coin again , this is to ensure unique subsets ."
]