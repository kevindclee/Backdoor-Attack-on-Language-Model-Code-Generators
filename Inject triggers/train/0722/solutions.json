[
    "class Solution:\n    def catMouseGame(self, graph):\n        def dfs(m, c): # m: mouse's current position, c: cat's current potision\n            if dp[m][c] != -1: return dp[m][c]\n            dp[m][c] = 0\n            mousedefault = 2\n            for nm in graph[m]: # nm: mouse's next position\n                if nm == c: continue",
    "class Solution:\n    def catMouseGame(self, graph):\n        \"\"\"\n        :type graph: List[List[int]]\n        :rtype: int\n        \"\"\"\n        self.graph = graph \n        self.memo = {}\n        return self.move(2, 1, True)\n        \n    def move(self, cat, mouse, m_turn):\n        key = (cat, mouse, m_turn)\n        if key in self.memo:\n            return self.memo[key]\n        self.memo[key] = 0\n        \n        if m_turn:\n            return self.mouse_play(key, cat, mouse, m_turn)\n        else:\n            return self.cat_play(key, cat, mouse, m_turn)\n        \n    def mouse_play(self, key, cat, turn, m_turn):\n        # base case \n        for nxt in self.graph[turn]:\n            if nxt == 0:\n                self.memo[key] = 1\n                return 1\n        \n        res = 2\n        for nxt in self.graph[turn]:\n            if nxt == cat:\n                continue \n            tmp = self.move(cat, nxt, False)\n            if tmp == 1:\n                res = 1\n                break\n            if tmp == 0:\n                res = 0\n        self.memo[key] = res \n        return res \n    \n    def cat_play(self, key, turn, mouse, m_turn):\n        # base case \n        for nxt in self.graph[turn]:\n            if nxt == mouse:\n                self.memo[key] = 2\n                return 2\n            \n        res = 1 \n        for nxt in self.graph[turn]:\n            if nxt ==0:\n                continue \n            tmp = self.move(nxt, mouse, True)\n            if tmp == 2:\n                res = 2\n                break \n            if tmp == 0:\n                res = 0\n        self.memo[key] = res \n        return res ",
    "# revised version  provided by a friend\nclass Solution:\n    def catMouseGame(self, graph):\n        \"\"\"\n        :type graph: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(graph)\n        state = [[-1]*n for _ in range(n)]\n        return self.search(state, graph, 1, 2)\n    \n    def search(self, state, graph, m_pos, c_pos):\n        if state[m_pos][c_pos] != -1:\n            return state[m_pos][c_pos]\n        if m_pos == c_pos:\n            state[m_pos][c_pos] = 2\n            return 2\n        if m_pos == 0:\n            state[m_pos][c_pos] = 1\n            return 1\n        state[m_pos][c_pos] = 0\n        \n        all_cat_win = True \n        for nxt_mouse in graph[m_pos]:\n            if nxt_mouse != c_pos:\n                all_mouse_win = True \n                exist_cat_win = False \n                for nxt_cat in graph[c_pos]:\n                    if nxt_cat != 0:\n                        nxt_state = self.search(state, graph, nxt_mouse, nxt_cat)\n                        if nxt_state != 1:\n                            all_mouse_win = False \n                            if nxt_state == 2:\n                                exist_cat_win = True \n                    if not all_mouse_win and exist_cat_win:\n                        break \n                if all_mouse_win:\n                    state[m_pos][c_pos] = 1\n                    return 1\n                if not exist_cat_win:\n                    all_cat_win = False \n        state[m_pos][c_pos] = 2 if all_cat_win else 0\n        return state[m_pos][c_pos]"
]