[
    "class Solution {\n    \n    public int stoneGameV(int[] stoneValue) {\n        int len = stoneValue.length;\n        int [] pSum = new int[len+1];\n        for(int i=0; i<len; i++) {\n)) + leftSum);",
    "    def stoneGameV(self, A):\n        n = len(A)\n        prefix = [0] * (n + 1)\n        for i, a in enumerate(A):\n            prefix[i + 1] = prefix[i] + A[i]\n\n        @functools.lru_cache(None)\n        def dp(i, j):\n            if i == j: return 0\n            res = 0\n            for m in range(i, j):\n                left = prefix[m + 1] - prefix[i]\n                right = prefix[j + 1] - prefix[m + 1]\n                if left <= right:\n                    res = max(res, dp(i, m) + left)\n                if left >= right:\n                    res = max(res, dp(m + 1, j) + right)\n            return res\n        return dp(0, n - 1)",
    "public int stoneGameV(int[] stoneValue) {\n        int n = stoneValue.length;\n        int[] sum = new int[n + 1];\n        \n        for(int i = 0; i < n; i++)\n            sum[i+1] = sum[i] + stoneValue[i];\n        \n        int[][] dp = new int[n + 1][n + 1];",
    "     def stoneGameV(self, A):\n        n = len(A)\n        prefix = [0] * (n + 1)\n        for i, a in enumerate(A):\n            prefix[i + 1] = prefix[i] + A[i]\n\n        @functools.lru_cache(None)\n        def dp(i, j):",
    "class Solution {\npublic:\n    int f[550][550];\n    int sum[550];\n    int stoneGameV(vector<int>& stoneValue) {\n        int n = stoneValue.size();\n        for (int i = 0; i < n; ++i) {\n            sum[i + 1] = sum[i] + stoneValue[i];\n        }\n        \n        for (int i = 1; i <= n; ++i) {\n            f[i][i] = 0;\n        }\n        for (int i = n; i > 0; --i) {\n            for (int j = i + 1; j <= n; ++j) {\n                for (int m = i; m < j; ++m) {\n                    int left = sum[m] - sum[i - 1];\n                    int right = sum[j] - sum[m];\n                    if (left > right) {\n                        f[i][j] = max(f[i][j], right + f[m + 1][j]);\n                    } else if (left < right) {\n                        f[i][j] = max(f[i][j], left + f[i][m]);\n                    } else {\n                        f[i][j] = max(f[i][j], right + f[m + 1][j]);\n                        f[i][j] = max(f[i][j], left + f[i][m]);\n                    }\n                }\n            }\n        }\n        return f[1][n];\n    }\n};",
    "class Solution {\npublic: int dp[501][501];\n    int stoneGameV(vector<int>& stoneValue) {\n        memset(dp, -1, sizeof(dp));\n        return help(0, stoneValue.size()-1, stoneValue);\n    }\n    ",
    "int stoneGameV(vector<int>& stoneValue) {\n    vector<int>& a = stoneValue;\n    int n = a.size();\n    s[0] = 0;\n    for (int i=0; i<n; i++) s[i+1] = s[i] + a[i];\n    \n    for (int i=1; i<=n; i++) {\n        f[i] = g[i] = 0;\n        x[i] = i;\n        y[i] = i-1;\n    }\n    \n    for (int len=2; len<=n; len++) {\n        for (int i=1, j; (j = i+len-1) <= n; i++) {\n            int half = (s[j] - s[i-1]) >> 1;\n\n            int& k = x[i];\n            int& t = f[i]; \n            int delta;\n            while (k < j && (delta = s[k] - s[i-1]) <= half) {\n                t = max(t, delta + h[i][k++]);\n            }\n            \n            int& k2 = y[j];\n            int& t2 = g[j];\n            while (k2 >= i && (delta = (s[j] - s[k2])) <= half) {\n                t2 = max(t2, delta + h[k2+1][j]);\n                k2--;\n            }\n            \n            h[i][j] = max(t, t2);\n        }\n    }\n    \n    return h[1][n];\n}    ",
    "int dp[505][505];",
    "class Solution{\npublic:\n   int stoneGameV(vector<int> const &stoneValue) const{\n      int n = stoneValue.size();\n      vector<int> s(n+1);\n      partial_sum(stoneValue.cbegin(), stoneValue.cend(), s.begin()+1);\n      auto id = [n](int i, int j){"
]