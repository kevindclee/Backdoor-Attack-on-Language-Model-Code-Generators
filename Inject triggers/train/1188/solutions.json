[
    "Map<Integer, Integer> map = new HashMap<>();\nmap.put(0, 0);\n\nint res = 0;\nint sum = 0;\n\nfor (int i = 0; i < nums.length; ++i) {\n sum += nums[i];\n if (map.containsKey(sum - target)) {\n  res = Math.max(res, map.get(sum - target) + 1);\n }\n map.put(sum, res);\n}\n\nreturn res;",
    "int maxNonOverlapping(vector<int>& nums, int target) {\n    unordered_map<int, int> dp;\n    dp[0] = -1;\n    int sum = 0, right = -1, cnt = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        sum += nums[i];\n        if (dp.count(sum - target)) {\n            int left = dp[sum - target];\n            if (right <= left) {\n                ++cnt;\n                right = i;\n            }\n        }\n        dp[sum] = i;\n    }\n    return cnt;\n}",
    "   int maxNonOverlapping(vector<int>& v , int t) {\n        int n=v.size(),sum=0,ans=0,right=-2;\n        unordered_map<int,int>m;\n        m[0]=-1;\n        for(int i=0;i<n;i++){\n            sum+=v[i];",
    "class Solution {\n    public int maxNonOverlapping(int[] nums, int target) {\n        Map<Integer, Integer> map= new HashMap<>();\n        int prefixSum=0, availableIdx=-1, res=0;\n        map.put(0,-1);\n        for (int i=0; i<nums.length; i++){\n            prefixSum+=nums[i];\n            int remain = prefixSum - target;\n            if (map.containsKey(remain) && map.get(remain)>=availableIdx){\n                res++;\n                availableIdx=i;\n            }\n            map.put(prefixSum, i);\n        }\n        return res;\n    }\n}",
    "class Solution {\n    public int maxNonOverlapping(int[] nums, int target) {\n        int sum = 0;\n        int count = 0;\n        HashMap<Integer, Integer> map = new HashMap<>();\n        map.put(0,-1);\n        int lastIndex =-1;\n  for (int i = 0; i<nums.length; i++) {\n  // calculate cumulative sum\n   sum += nums[i];\n   // check if there is subarray ending at index i & it starts after lastIndex\n   if (map.containsKey(sum - target) && map.get(sum-target)>=lastIndex){\n    count++;\n                lastIndex = i;\n            }\n   map.put(sum, i);\n  }\n  return count;\n\n    }\n}",
    "   int maxNonOverlapping(vector<int>& v , int t) {\n        int n=v.size(),sum=0,ans=0,right=-2;\n        unordered_map<int,int>m;\n        m[0]=-1;\n        for(int i=0;i<n;i++){\n            sum+=v[i];",
    "   int maxNonOverlapping(vector<int>& v , int t) {\n        int n=v.size(),sum=0,ans=0,right=-2;\n        unordered_map<int,int>m;\n        m[0]=-1;\n        for(int i=0;i<n;i++){\n            sum+=v[i];",
    "class Solution {\npublic:\n  int maxNonOverlapping(vector<int>& nums, int target) {\n    unordered_map<int, int> dp;\n    dp[0] = -1;\n    int sum = 0, right = -1, cnt = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        sum += nums[i];\n        if (dp.count(sum - target)) {\n            int left = dp[sum - target];\n            if (right <= left) {\n                ++cnt;\n                right = i;\n            }\n        }\n        dp[sum] = i;\n    }\n    return cnt;\n}\n};",
    "    unordered_map<int,int> mp;\n    int ans = 0;\n    int sum = 0;\n    int n = nums.size();\n    mp[0] = 1;\n    \n    for(int i=0; i<n; i++){\n        \n        sum += nums[i];\n        \n        if(mp.find(sum-target) != mp.end()){\n            ans ++;\n            mp.clear();\n        }\n        \n        mp[sum] ++;\n        \n        \n    }\n    \n    \n    return ans;\n    \n}"
]