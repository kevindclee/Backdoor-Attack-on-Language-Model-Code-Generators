[
    "    def mergeStones(self, stones, K):\n        n = len(stones)\n        inf = float('inf')\n        prefix = [0] * (n + 1)\n        for i in range(n):\n            prefix[i + 1] = prefix[i] + stones[i]\n\n        import functools\n\n        @functools.lru_cache(None)\n        def dp(i, j, m):\n            if (j - i + 1 - m) % (K - 1):\n                return inf\n            if i == j:\n                return 0 if m == 1 else inf\n            if m == 1:\n                return dp(i, j, K) + prefix[j + 1] - prefix[i]\n            return min(dp(i, mid, 1) + dp(mid + 1, j, m - 1) for mid in range(i, j, K - 1))\n        res = dp(0, n - 1, 1)\n        return res if res < inf else -1",
    "    def mergeStones(self, stones, K):\n        n = len(stones)\n        if (n - 1) % (K - 1): return -1\n        prefix = [0] * (n + 1)\n        for i in range(n):\n            prefix[i + 1] = prefix[i] + stones[i]\n\n        import functools\n        @functools.lru_cache(None)\n        def dp(i, j):\n            if j - i + 1 < K: return 0\n            res = min(dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1))\n            if (j - i) % (K - 1) == 0:\n                res += prefix[j + 1] - prefix[i]\n            return res\n        return dp(0, n - 1)",
    "public int mergeStonesTwo(int[] stones) {\n    if (stones == null || stones.length == 0) {\n        return 0;\n    }\n    int len = stones.length;\n    int max = Integer.MAX_VALUE;\n    int[][] dp = new int[len + 1][len + 1];\n    int[] prefixSum = new int[len + 1];\n    int i, j, k, l;\n    for (i = 1; i <= len; i++) {\n        prefixSum[i] = prefixSum[i - 1] + stones[i - 1];\n    }\n    \n    for (i = 1; i <= len; i++) {\n        dp[i][i] = 0;\n    }\n    \n    for (l = 2; l <= len; l++) {\n        for (i = 1; i <= len - l + 1; i++) {\n            j = i + l - 1;\n            dp[i][j] = max;\n            int sum = prefixSum[j] - prefixSum[i - 1];\n            for (k = i; k < j; k++) {\n                dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + sum);\n            }\n        }\n    }\n    \n    return dp[1][len];\n}",
    "// Bottom-Up\nclass Solution {\n    public int mergeStones(int[] stones, int K) {\n        int len = stones.length;\n        if ((len - 1) % (K - 1) != 0) {\n            return -1;\n        }\n        \n        int i, j, k, l, t;\n        \n        int[] prefixSum = new int[len + 1];\n        for (i = 1; i <= len; i++) {\n            prefixSum[i] = prefixSum[i - 1] + stones[i - 1];\n        }\n        \n        int max = 99999999;\n        int[][][] dp = new int[len + 1][len + 1][K + 1];\n        for (i = 1; i <= len; i++) {\n            for (j = 1; j <= len; j++) {\n                for (k = 1; k <= K; k++) {\n                    dp[i][j][k] = max;\n                }\n            }\n        }\n        \n        for (i = 1; i <= len; i++) {\n            dp[i][i][1] = 0;\n        }\n\n        for (l = 2; l <= len; l++) {\n            for (i = 1; i <= len - l + 1; i++) {\n                j = i + l - 1;\n                for (k = 2; k <= K; k++) {\n                    for (t = i; t < j; t++) {\n                        dp[i][j][k] = Math.min(dp[i][j][k], dp[i][t][k - 1] + dp[t + 1][j][1]);\n                    }\n                }\n\n                dp[i][j][1] = dp[i][j][K] + prefixSum[j] - prefixSum[i - 1];   \n            }\n        }\n\n        return dp[1][len][1];\n    }\n}",
    "// bottom-up\nclass Solution {\n    public int mergeStones(int[] stones, int K) {\n        int len = stones.length;\n        if ((len - 1) % (K - 1) != 0) {\n            return -1;\n        }\n        \n        int i, j, k, l, t;\n        \n        int[] prefixSum = new int[len + 1];\n        for (i = 1; i <= len; i++) {\n            prefixSum[i] = prefixSum[i - 1] + stones[i - 1];\n        }\n        \n        int max = Integer.MAX_VALUE;\n        int[][][] dp = new int[len + 1][len + 1][K + 1];\n        for (i = 1; i <= len; i++) {\n            for (j = 1; j <= len; j++) {\n                for (k = 1; k <= K; k++) {\n                    dp[i][j][k] = max;\n                }\n            }\n        }\n        \n        for (i = 1; i <= len; i++) {\n            dp[i][i][1] = 0;\n        }\n\n        for (l = 2; l <= len; l++) {\n            for (i = 1; i <= len - l + 1; i++) {\n                j = i + l - 1;\n                for (k = 2; k <= K; k++) {\n                    for (t = i; t < j; t++) {\n                        if (dp[i][t][k - 1] == max || dp[t + 1][j][1] == max) {\n                            continue;\n                        }\n                        dp[i][j][k] = Math.min(dp[i][j][k], dp[i][t][k - 1] + dp[t + 1][j][1]);\n                    }\n                }\n                if (dp[i][j][K] == max) {\n                    continue;\n                }\n                dp[i][j][1] = dp[i][j][K] + prefixSum[j] - prefixSum[i - 1];   \n            }\n        }\n\n        return dp[1][len][1];\n    }\n}",
    "    Transitions \n    ============\n\n    dp(i,j,1) = dp(i,j,k) + sum[i..j]\n                where sum[i..j] represents the sum between index i and index j .\n                Which means that in order to create one pile from index i to \n                to index j (dp(i,j,1)) in minimum cost , we have to create k piles \n                from index i to index j (dp(i,j,k)) and merge the operation cost\n                which is sum of the segment.               \n\n    dp(i,j,k) = dp(i,t,1) + dp(t+1,j,k-1) where  t lies between index i to j \n                where i is inclusive and j is exclusive .\n                which means that in order to create k pile from index i to \n                index j , we first choose any segment of arbitary length \n                and try creating the pile from (i,t) and then check for the\n                minimum cost of creating (k-1) piles from the rest of the \n                array .\n\n    Base Cases :\n    ==============\n    \n    dp(i,i,1) = Since only merge operation has cost therfore , and we dont need \n                merge in the interval i to i to create 1 pile, therefore cost is 0 . ",
    " the minimum cost to make stones[i .. j] form K piles\n + sum(nums[i .. j])",
    "  if (j - i + 1 - piles) % (K - 1) != 0: \n                return float('inf')  # means impossible",
    "class Solution {\npublic:\n    int dp[31][31][31], sum[31];\n    int f(int L, int R, int piles, int k)\n    {\n       if(L == R && piles == 1) return dp[L][R][piles] = 0;\n       if((R - L + 1 - piles) % (k - 1) != 0)\n          return INT_MAX/2;\n       int &ret = dp[L][R][piles];\n       if(ret!=-1) return ret;\n       ret = INT_MAX/2;\n       if(piles == 1)\n          ret = f(L, R, k, k) + sum[R + 1] - sum[L];\n       else\n       {\n         for(int i = L; i <= R; i++)\n         {\n           ret = min(ret, f(L, i, 1, k) + f(i + 1, R, piles - 1, k));\n         }\n       }\n       return ret;\n    }\n    int mergeStones(vector<int>& stones, int K) {\n        int n = stones.size();\n        memset(sum, 0, sizeof sum);\n        memset(dp, -1, sizeof dp);\n        for(int i = 0; i < n; i++)\n            sum[i + 1] = sum[i] + stones[i];\n        int fin = f(0, n - 1, 1, K);\n        if(fin >= INT_MAX / 2) fin = -1;\n        return fin;\n    }\n};",
    "class Solution:\n    def mergeStones(self, stones, k):\n        n = len(stones)\n\n        if (n-1)%(k-1): return -1\n\n        ans = [0]\n\n        for i in range(n):\n            ans.append(ans[-1] + stones[i])\n\n        @lru_cache(None)\n        def dfs(lo,hi):\n            if hi-lo+1 < k:\n                return 0\n\n            res = min(dfs(lo,i) + dfs(i+1,hi) for i in range(lo,hi,k-1))\n\n            if (hi-lo)%(k-1) == 0:\n                res += ans[hi+1] - ans[lo]\n\n            return res\n\n        return dfs(0,n-1)"
]