[
    "class Solution {\n    \n    int m, n;\n    \n    public int maxSideLength(int[][] mat, int threshold) {\n        m = mat.length;\n        n = mat[0].length;\n        int[][] sum = new int[m + 1][n + 1];\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + mat[i-1][j-1];\n            }\n        }\n        \n        int lo = 0, hi = Math.min(m, n);\n        \n        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n            if (isSquareExist(sum, threshold, mid)) {\n                lo = mid + 1;    \n            } else {\n                hi = mid - 1;\n            }\n        }\n        \n        return hi;\n    }\n    \n    \n    private boolean isSquareExist(int[][] sum, int threshold, int len) {\n        for (int i = len; i <= m; i++) {\n            for (int j = len; j <= n; j++) {\n                if (sum[i][j] - sum[i-len][j] - sum[i][j-len] + sum[i-len][j-len] <= threshold) return true;\n            }\n        }\n        return false;\n    }\n}",
    "class Solution {\n        \n    public int maxSideLength(int[][] mat, int threshold) {\n        int m = mat.length;\n        int n = mat[0].length;\n        int[][] sum = new int[m + 1][n + 1];\n        \n        int res = 0;\n        int len = 1; // square side length\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + mat[i-1][j-1];\n                \n                if (i >= len && j >= len && sum[i][j] - sum[i-len][j] - sum[i][j-len] + sum[i-len][j-len] <= threshold)\n                    res = len++;\n            }\n        }\n        \n        return res;\n    }\n    \n}",
    "class Solution {\n    public int maxSideLength(int[][] mat, int threshold) {\n        int n = mat.length;\n        int m = mat[0].length;\n        int[][] sums = new int[n + 1][m + 1];\n        int max = 0;        \n        for (int i = 0; i < n; i++) {\nmax][j - max] <= threshold",
    "if (i >= len && j >= len && sum[i][j] - sum[i-len][j] - sum[i][j-len] + sum[i-len][j-len] <= threshold)\n                    res = len++;",
    "def maxSideLength(self, mat, threshold):\n    sqsum = lambda x1, y1, x2, y2: p[x2 + 1][y2 + 1] - p[x1][y2 + 1] - p[x2 + 1][y1] + p[x1][y1]\n    m, n = len(mat), len(mat[0])\n    p = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m):\n        for j in range(n):\n            p[i + 1][j + 1] = mat[i][j] + p[i][j + 1] + p[i + 1][j] - p[i][j]",
    "",
    "",
    " for(int k = Math.min(m, n) -1; k >= 0; k--) {\n}",
    "class Solution {\n    public int maxSideLength(int[][] mat, int threshold) {\n        int n = mat.length;\n        int m = mat[0].length;\n        int[][] sums = new int[n + 1][m + 1];\n        int max = 0;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                sums[i + 1][j + 1] = sums[i + 1][j] + sums[i][j + 1] - sums[i][j] + mat[i][j];\n                if (i - max >= 0 && j - max >= 0 && \n                    sums[i + 1][j + 1] - sums[i - max][j + 1] - sums[i + 1][j - max] + sums[i - max][j - max] <= threshold\n                   ) {\n                    max += 1;\n                }\n            }\n        }\n            \n        return max;    \n    }\n}",
    "class Solution(object):\n    def maxSideLength(self, mat, threshold):\n        \"\"\"\n        :type mat: List[List[int]]\n        :type threshold: int\n        :rtype: int\n        \"\"\"\n        if not mat:\n            return 0\n        max_square = 0\n        dp = [[0] * (len(mat[0]) + 1) for _ in range(len(mat) + 1)]\n        for i in range(1, len(mat) + 1):\n            for j in range(1, len(mat[0]) + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + mat[i - 1][j - 1]\n                l = 1\n                r = min(i, j)\n                while l <= r:\n                    k = (l + r) / 2\n                    cur_sum = dp[i][j] - dp[i - k][j] - dp[i][j - k] + dp[i - k][j - k]\n                    if cur_sum <= threshold:\n                        max_square = max(max_square, k)\n                        l = k + 1\n                    else:\n                        r = k - 1\n        return max_square",
    "class Solution {\n    public int maxSideLength(int[][] mat, int threshold) {\n        int m = mat.length;\n        int n = mat[0].length;\n        int[][] sum = new int[m + 1][n + 1];\n        int res = 0;\n        for (int i = 1; i <= m; i++) {\n];\n];",
    "def maxSideLength(self, A, threshold):\n    s = 0\n    def a(i, j):\n        return A[i][j] if i >= 0 <= j else 0\n    for i in range(len(A)):\n        for j in range(len(A[0])):\n            A[i][j] += a(i-1, j) + a(i, j-1) - a(i-1, j-1)\n            s += i >= s <= j and a(i, j) - a(i-s-1, j) - a(i, j-s-1) + a(i-s-1, j-s-1) <= threshold\n    return s",
    "        l, r = 1, min(m, n)\n        while l < r:\n            mid = (l + r) // 2\n            if check(mid):\n                # find a sub matrix of length mid with current threhold, could find larger\n                l = mid + 1\n            else:"
]