[
    "class Solution(object):\n    def exclusiveTime(self, n, logs):\n        \"\"\"\n        :type n: int\n        :type logs: List[str]\n        :rtype: List[int]",
    "def exclusiveTime(self, N, logs):\n    ans = [0] * N\n    #stack = SuperStack()\n    stack = []\n\n    for log in logs:\n        fn, typ, time = log.split(':')\n        fn, time = int(fn), int(time)\n\n        if typ == 'start':\n            stack.append(time)\n        else:\n            delta = time - stack.pop() + 1\n            ans[fn] += delta\n            #stack.add_across(delta)\n            stack = [t+delta for t in stack] #inefficient\n\n    return ans",
    "# Approach 1: Standard\nclass Solution:\n    def exclusiveTime(self, n, logs):\n        ans, stack = [0]*n, []\n        for log in logs:\n            f_id, event, time = log.split(':') \n            f_id, time = int(f_id), int(time)\n            if event=='start':",
    "std::sscanf(str.c_str(), \"%d:%[^:]:%d\", &id, strbuf, &tstamp);",
    "        stack = []\n        result = [0] * n\n        \n        def normalizeProcessTime(processTime):\n            return processTime.encode('ascii','ignore').split(':') \n        \n        for processTime in logs:\n            processId, eventType, time = normalizeProcessTime(processTime)\n            \n            if eventType == \"start\":\n                stack.append([processId, time])\n            \n            elif eventType == \"end\":\n                processId, startTime = stack.pop()\n                timeSpent = int(time) - int(startTime) + 1 # Add 1 cause 0 is included\n                result[int(processId)] += timeSpent\n                \n                # Decrement time for next process in the stack\n                if len(stack) != 0:\n                    nextProcessId, timeSpentByNextProcess = stack[-1] #\n                    result[int(nextProcessId)] -= timeSpent\n                    \n        return result",
    "                result[int(processId)] += timeSpent\n                \n                # Decrement time for next process in the stack\n                if len(stack) != 0:\n                    nextProcessId, timeSpentByNextProcess = stack[-1] #\n                    result[int(nextProcessId)] -= timeSpent",
    "class Solution:\n    def exclusiveTime(self, n, logs):\n        \"\"\"\n        :type n: int\n        :type logs: List[str]\n        :rtype: List[int]\n        \"\"\"\n        res = [0]*n\n        stack = []\n        for log in logs:\n            ID, op, time = log.split(':')\n            ID = int(ID)\n            time = int(time)\n            if op == 'start':\n                if stack:\n                    res[stack[-1][0]] += time-stack[-1][1]\n                stack.append([ID, time])\n            else:\n                prev = stack.pop()\n                res[ID] += time-prev[1]+1\n                if stack:\n                    stack[-1][1] = time+1\n        return res",
    "class Solution:\n    def exclusiveTime(self, n, logs):\n        \"\"\"\n        :type n: int\n        :type logs: List[str]\n        :rtype: List[int]\n        \"\"\"\n        depth = 0\n        dic = {}\n        res = [0]*n\n        prev = None\n        flag = False\n        for log in logs:\n            ID, op, time = log.split(':')\n            ID = int(ID)\n            time = int(time)\n            if op == 'start':\n                depth += 1\n                dic[depth] = ID\n                if prev != None and depth != 1:\n                    if flag:\n                        res[dic[depth-1]] += time-prev-1\n                    else:\n                        res[dic[depth-1]] += time-prev\n                prev = time\n                flag = False\n            else:\n                if flag:\n                    res[dic[depth]] += time-prev\n                else:\n                    res[dic[depth]] += time-prev+1\n                depth -= 1\n                prev = time\n                flag = True\n        return res"
]