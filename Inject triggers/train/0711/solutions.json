[
    "    def atMostNGivenDigitSet(self, D, N):\n        N = str(N)\n        n = len(N)\n        res = sum(len(D) ** i for i in range(1, n))\n        i = 0\n        while i < len(N):\n            res += sum(c < N[i] for c in D) * (len(D) ** (n - i - 1))\n            if N[i] not in D: break\n            i += 1\n        return res + (i == n)",
    "def atMostNGivenDigitSet(self, D, N):\n        D.sort()\n        num = str(N)        \n        total = sum(len(D) ** i for i in range(1, len(num)))\n        for i, n in enumerate(num):\n            b = bisect.bisect_left(D, n)\n            total += b * (len(D) ** (len(num) - i - 1))\n            if b == len(D) or D[b] > n: break",
    "class Solution:\n    def atMostNGivenDigitSet(self, digits, n):\n        up, ans, T, str_n = [0]*10, 0, len(digits), str(n)\n        for i in range(10):\n            for dig in digits:\n                up[i] += (dig < str(i))\n        \n        k, d_set = len(str_n), set(digits)\n        for i in range(k):\n            if i > 0 and str_n[i-1] not in d_set: break\n            ans += up[int(str_n[i])] * T**(k-i-1)\n        \n        addon = (T**k - 1)//(T-1) - 1 if T != 1 else k - 1\n        return ans + addon + (not set(str_n) - set(digits))",
    "class Solution:\n    def atMostNGivenDigitSet(self, D, L):\n        s, N, M = str(L), len(str(L)), len(D)\n        cnt = sum(pow(M, i) for i in range(1, N))\n        for i in range(N):\n            j = 0\n            while j < M and D[j][0] < s[i]:\n                cnt += pow(M, N-1-i)\n                j += 1\n            if j >= M or D[j][0] != s[i]: return cnt\n        return cnt+1",
    "class Solution:\n    def atMostNGivenDigitSet(self, D, L):\n        s, N, M = str(L), len(str(L)), len(D)\n        cnt = sum(pow(M, i) for i in range(1, N))\n        for i in range(N):\n            j = bisect_left(D, s[i])\n            cnt += pow(M, N-1-i) * j\n            if j >= M or D[j][0] != s[i]: return cnt\n        return cnt+1"
]