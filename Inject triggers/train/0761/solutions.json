[
    "class DSU:\n    def __init__(self, N):\n        self.p = list(range(N))\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        self.p[xr] = yr\n\nclass Solution:\n    def primes_set(self,n):\n        for i in range(2, int(math.sqrt(n))+1):\n            if n % i == 0:\n                return self.primes_set(n//i) | set([i])\n        return set([n])\n\n    def largestComponentSize(self, A):\n        n = len(A)\n        UF = DSU(n)\n        primes = defaultdict(list)\n        for i, num in enumerate(A):\n            pr_set = self.primes_set(num)\n            for q in pr_set: primes[q].append(i)\n\n        for _, indexes in primes.items():\n            for i in range(len(indexes)-1):\n                UF.union(indexes[i], indexes[i+1])\n\n        return max(Counter([UF.find(i) for i in range(n)]).values())",
    "# Our disjoint set\nclass DSU:\n    def __init__(self, N):\n        self.p = list(range(N))\n # keep finding til we reach the parent\n    def find(self, x):",
    "class DisjointSet:",
    "if(mp.count(p)) uf.Union(i, mp[p]);\nelse mp[p]=i;",
    "class UnionFind(object):\n    def uf(self, n):  \n        self.uf = [i for i in range(n)]\n        self.size = [1] * n\n        \n    def find(self, x):  \n        while x != self.uf[x]:\n            self.uf[x] = self.uf[self.uf[x]]\n            x = self.uf[x]\n        return self.uf[x]\n\n    def union(self, x, y):  \n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root == y_root:\n            return\n        self.uf[x_root] = y_root\n        self.size[y_root] += self.size[x_root]\n        self.size[x_root] = 0\n\n\nclass Solution(object):\n    def largestComponentSize(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        def primeFactors(n):  # Prime factor decomposition\n            out = set()\n            while n % 2 == 0: \n                out.add(2)\n                n //= 2\n            for i in range(3, int(math.sqrt(n))+1, 2): \n                while n % i== 0: \n                    out.add(i) \n                    n //= i \n            if n > 2: \n                out.add(n)\n            return out\n        \n        idx_lookup = {A[i]: i for i in range(len(A))} # in order to find idx in uf\n        uf = UnionFind()\n        uf.uf(len(A))\n        primeAndItsMultiples = collections.defaultdict(list) # {2: [4, 6], 3: [6, 15], 5: [15, 35], 7: [35]})\n        \n        for i in A:\n            factors = primeFactors(i)\n            for f in factors:\n                primeAndItsMultiples[f].append(i)\n\n        # we don't need to connect all the multiples of a prime, \n        # just use the first multiple as their root\n        for idx, multiples in primeAndItsMultiples.items():\n            if multiples:\n                root = multiples[0] # use the first multiple as their root\n                for node in multiples[1:]:\n                    uf.union(idx_lookup[node], idx_lookup[root]) # connect node with root\n                    \n        return max(uf.size)",
    "class UnionFind(object):\n    def uf(self, n):  \n        self.uf = [i for i in range(n)]\n        self.size = [1] * n\n        \n    def find(self, x):  \n        while x != self.uf[x]:\n            self.uf[x] = self.uf[self.uf[x]]\n            x = self.uf[x]\n        return self.uf[x]\n\n    def union(self, x, y):  \n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root == y_root:\n            return\n        self.uf[x_root] = y_root\n        self.size[y_root] += self.size[x_root]\n        self.size[x_root] = 0\n\n\nclass Solution(object):\n    def largestComponentSize(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        def primeFactors(n):  # Prime factor decomposition\n            out = set()\n            while n % 2 == 0: \n                out.add(2)\n                n //= 2\n            for i in range(3, int(math.sqrt(n))+1, 2): \n                while n % i== 0: \n                    out.add(i) \n                    n //= i \n            if n > 2: \n                out.add(n)\n            return out\n        \n        uf = UnionFind()\n        uf.uf(len(A))\n        \n        primeToIndex = {} \n        for i,a in enumerate(A):\n            primes = primeFactors(a)\n            for p in primes:\n                if p in primeToIndex:\n                    uf.union(i, primeToIndex[p])\n                primeToIndex[p] = i\n        return max(uf.size)",
    "class UnionFind():\n    def __init__(self):\n        self.uf, self.rank, self.size = {}, {}, {}\n        \n    def add(self, x):\n        if x not in self.uf:\n            self.uf[x], self.rank[x], self.size[x] = x, 0, 1"
]