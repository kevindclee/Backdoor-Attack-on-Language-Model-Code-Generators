[
    "    def hasAllCodes(self, s, k):\n        return len({s[i:i + k] for i in xrange(len(s) - k + 1)}) == 2 ** k",
    "return len(findall(r\"0+1|1+0\", s)) >= k",
    "pairs = 0\nsum = 0\nfor c in s:\n    if c == '1':\n        sum = min(1, sum + 1)\n    else:\n        sum = max(-1, sum - 1)\n    if sum == 0:",
    "for (int i = k; i <= s.length()&&seen.size() < 1 << k; ++i).",
    "bool hasAllCodes(string s, int k) {\n int n = s.size(), sizeNeeded = 1 << k, count = 0; \n bool set[sizeNeeded];  memset(set, false, sizeof(set)); // initialising set of 'sizeNeeded' elements with false\n for(int i = 0; i <= n - k; i++){\n  int hash = 0, shift = k - 1;\n  for(int j = i; j < i + k; j++)\n   hash += (s[j] - '0') << shift--; // hash will be equal to decimal value of substring\n  if(!set[hash])\n   set[hash] = true, count++;\n }\n return count == sizeNeeded;\n}",
    "hash = hash << 1       :  one shift to left\nhash &= allOnes        :  removes kth bit, ensures our hash always less than 2^k\nhash |= s[i] - '0'     :  calculates hash with new character after removing first character of previous substring\n\nEg. Suppose string is 110101 and k = 3. We start with hash = 0. Here size = 2^k = 8 and allOnes = 7 (111).\n1. hash = 000 << 1 = 000  ||  hash &= (111) = 000(0)  ||  hash |= 1  = 001         \ud83d\udc49 hash = 001 (1)\n2. hash = 001 << 1 = 010  ||  hash &= (111) = 010(2)  ||  hash |= 1  = 011         \ud83d\udc49 hash = 011 (3)\n3. hash = 011 << 1 = 110  ||  hash &= (111) = 110(6)  ||  hash |= 0  = 110         \ud83d\udc49 hash = 110 (6)\n4. hash = 110 << 1 = 1100 ||  hash &= (111) = 100(4)  ||  hash |= 1  = 101         \ud83d\udc49 hash = 101 (5)\n            ^exceeds (2^k)   ^2nd step removes kth bit^\n5. hash = 101 << 1 = 1010 ||  hash &= (111) = 010(2)  ||  hash |= 0  = 010         \ud83d\udc49 hash = 010 (2)\n6. hash = 010 << 1 = 100  ||  hash &= (111) = 100(4)  ||  hash |= 1  = 101         \ud83d\udc49 hash = 101 (5)\n\nWe can observe that using rolling hash, after first k-2 steps,  our hash value is always equal \nto the decimal equivalent of substring of length k. This can be used as for indexing the set which\nwill store the distinct substrings of length k found. If number of distinct substrings is equal to size,\nthen the answer will be true.",
    "bool hasAllCodes(string str, int k) {\n    int total = 1<<k;\n    int oner = total-1;\n    int curr = 0;\n    unordered_set<int>s;\n    \n    for(int i=0;i<str.size();i++)\n    {\n        curr = (((curr<<1)&oner)|(str[i]-'0'));\n        if(i>=k-1)\n            s.insert(curr);\n    }\n    \n    return (s.size()==total);\n}"
]