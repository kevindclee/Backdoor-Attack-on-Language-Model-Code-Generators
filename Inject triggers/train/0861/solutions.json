[
    "    def rearrangeBarcodes(self, packages):\n        i, n = 0, len(packages)\n        res = [0] * n\n        for k, v in collections.Counter(packages).most_common():\n            for _ in xrange(v):\n                res[i] = k\n                i += 2\n                if i >= n: i = 1\n        return res",
    "    def rearrangeBarcodes(self, A):\n        count = collections.Counter(A)\n        A.sort(key=lambda a: (count[a], a))\n        A[1::2], A[::2] = A[0:len(A) / 2], A[len(A) / 2:]\n        return A",
    "for k, v in count.most_common():\n    # ...",
    "    def rearrangeBarcodes(self, barcodes):\n        \n        # Concept - Go greedy, this problem is a greedy one, so we can always\n        # choose elements which occur maximum nummber of times, till we exhaust\n        # our input. We can do it by maintaining a max heap which would store\n        # the character that max num of times at it's root value.\n        heap = []",
    "def rearrangeBarcodes(barcodes):\n\n # Our result to return\n result = []\n \n # Get the counts\n counts = collections.Counter(barcodes)\n \n # Create a max-heap based on count\n heap = [[-v, k] for k, v in counts.items()]\n \n # Heapify the heap\n heapq.heapify(heap)\n \n # Get the first item\n item = heapq.heappop(heap)\n\n while heap:\n  result.append(item[1])\n  item[0] += 1 # \"Decrease\" the count (remember our count is negative for min-heap, that's why we add)\n  \n  \"\"\"\n  'heapreplace' will pop the next item onto the heap, then push the old item!\n  Its the secret weapon for this solution.\n  We heappop if we don't want to push 'item' back onto the heap.\n  \"\"\"\n  item = heapq.heapreplace(heap, [item[0], item[-1]]) if item[0] < 0 else heapq.heappop(heap)\n\n # Because I do a `heappop` outside of the while loop, we should append the last element!\n result.append(item[1])\n\n return result"
]