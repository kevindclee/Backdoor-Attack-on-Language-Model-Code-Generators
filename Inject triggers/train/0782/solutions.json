[
    "    heap = []\n    for point in points:\n        dist = point[0] * point[0] + point[1] * point[1]\n        heapq.heappush(heap, (-dist, point))\n        if len(heap) > K:\n            heapq.heappop(heap)\n    \n    return [tuple[1] for tuple in heap]",
    "class Solution:\n    def kClosest(self, P, k):\n        heap, euclidean = [], lambda x, y : x*x + y*y\n        for i, (x, y) in enumerate(P):\n            d = euclidean(x, y)\n            if len(heap) == k:\n                heappushpop(heap, (-d, i))     # -d to convert to max-heap (default is min)\n            else: \n                heappush(heap, (-d, i))\n        return [P[i] for (_, i) in heap]",
    "class Solution:\n    def kClosest(self, P, k):\n        euclidean = lambda p : p[0]**2 + p[1]**2\n        def partition(L, R):\n            random = randint(L, R)                 # choosing random pivot\n            P[R], P[random] = P[random], P[R]      # and swapping it to the end\n            i, pivotDist = L, euclidean(P[R])\n            for j in range(L, R+1):\n                if euclidean(P[j]) <= pivotDist:\n                    P[i], P[j] = P[j], P[i]\n                    i += 1\n            return i-1\n        \n        L, R, p = 0, len(P)-1, len(P)\n        while p != k:\n            p = partition(L, R)\n            if p < k:   L = p + 1\n            else    :   R = p - 1\n        return P[:k]",
    "if we dont want to use math.sqrt then we can multiply result by 0.5 which in case \n\nkey = lambda x : ((x[0] * x[0]) + (x[1] * x[1]))** 0.5"
]