[
    "    def isEscapePossible(self, blocked, source, target):\n        blocked = set(map(tuple, blocked))\n\n        def dfs(x, y, target, seen):\n            if not (0 <= x < 10**6 and 0 <= y < 10**6) or (x, y) in blocked or (x, y) in seen: return False\n            seen.add((x, y))\n            if len(seen) > 20000 or [x, y] == target: return True\n            return dfs(x + 1, y, target, seen) or \\\n                dfs(x - 1, y, target, seen) or \\\n                dfs(x, y + 1, target, seen) or \\\n                dfs(x, y - 1, target, seen)\n        return dfs(source[0], source[1], target, set()) and dfs(target[0], target[1], source, set())",
    "    def isEscapePossible(self, blocked, source, target):\n        blocked = {tuple(p) for p in blocked}\n\n        def bfs(source, target):\n            bfs, seen = [source], {tuple(source)}\n            for x0, y0 in bfs:\n                for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\n                    x, y = x0 + i, y0 + j\n                    if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\n                        if [x, y] == target: return True\n                        bfs.append([x, y])\n                        seen.add((x, y))\n                if len(bfs) == 20000: return True\n            return False\n        return bfs(source, target) and bfs(target, source)",
    "0th     _________________________       The sum of the area available equals 1+2+3+4+5+...+198+199=(1+199)*199/2=19900 (trapezoid sum) \n         |-------------------- X            \n         |-------------------X\n         |                .\n         |             .\n         .           . ",
    "blocked = set(map(tuple, blocked))",
    "class Solution(object):   \n    def isEscapePossible(self, blocked, source, target):\n        \"\"\"\n        :type blocked: List[List[int]]\n        :type source: List[int]\n        :type target: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        self.blocked = blocked\n        self.source = source\n        self.target = target\n        \n        #hashset of all blocked cells\n        self.blocked_dict = {}\n        \n        #hashset of all visited edges\n        self.edge_dict = {}\n        \n        #min/max x/y coords used for checking if an edge intersects the \"easy path\"\n        self.min_x = min(self.source[0],self.target[0])\n        self.max_x = max(self.source[0],self.target[0])\n        self.min_y = min(self.source[1],self.target[1])\n        self.max_y = max(self.source[1],self.target[1])\n        \n        #iterate through all cells in blocked,\n        #and add each cell to the hash set\n        for blocked_cell in blocked:\n            if blocked_cell[0] in self.blocked_dict:\n                self.blocked_dict[blocked_cell[0]][blocked_cell[1]] = None\n            else:\n                self.blocked_dict[blocked_cell[0]]={blocked_cell[1]:None}\n        \n        #for each cell in blocked\n        for blocked_cell in self.blocked:\n            \n            #list the faces of blocked_cell that belong to an outline (4 of these at most)\n            exposed_faces = self.enumerate_exposed_faces(blocked_cell[0],blocked_cell[1])\n            \n            #for each of these faces\n            for face in exposed_faces:\n                \n                #check to see if we've already visited the edge while tracing out a loop\n                x_edge = face[3]\n                y_edge = face[4]\n                edge_type = face[5]\n                edge_visited = (x_edge in self.edge_dict \n                                and y_edge in self.edge_dict[x_edge]\n                                and edge_type in self.edge_dict[x_edge][y_edge])\n                \n                #if not, then we are looking at a new outline that we haven't seen before\n                if not edge_visited:   \n                   \n                    #count the number of edges of the outline that intersect the \"easy path\"\n                    num_intervening_edges =  self.check_loop(face[0],face[1],face[2])\n                    \n                    #if the number of intersections is odd, a path does not exist. return false\n                    if num_intervening_edges%2==1:\n                        return False\n            \n        #if we could not find an outline the separates source from target, return true    \n        return True\n    \n    #lists the faces of occupied cell x,y that do not touch other occupied cells\n    #these cell faces are edges that belong to one of the outlines that are formed \n    #by painting in all occupied cells and grid boundaries\n    #there are at most 4 such edges per cell\n    def enumerate_exposed_faces(self,x,y):\n        out_list = []\n        \n        #iterate through each neighbor of the cell\n        for i in range(4):\n            \n            #if the neighbor cell is not occupied (blocked), then the corresponding face is a boundary face\n            #in which case, add it to the list\n            if not self.is_occupied(x+self.dxe[i],y+self.dye[i]):\n                \n                #there is a little bit of accounting going on to keep track of the correct edge coordinates\n                #note that what we are really listing here is a starting grid point (not cell) + starting direction\n                #and we also need to take into account that cells are indexed by their bottom left corner\n                x_star = x+self.dxe2[i]\n                y_star = y+self.dye2[i]\n                x_edge_coords = x_star + self.dx_edge_coords[(i+2)%4]\n                y_edge_coords = y_star + self.dy_edge_coords[(i+2)%4]\n                \n                out_list.append([x_star,y_star,i,x_edge_coords,y_edge_coords,self.edge_code_list[i]])\n        return out_list\n        \n    #returns the number of times a given outline intersects the \"easy path\"\n    #x_start,y_start is the starting gridpoint on the outline\n    #starting_direction is... the starting direction (see __init__ for how it's coded)\n    #is_cc is True if traversing in counterclockwise direction, False if clockwise\n    #note that (counter)clockwise is referring to the winding number of the whole outline we are tracing\n    def check_loop(self,x_start,y_start,starting_direction,is_cc = True):\n        #correct the starting direction if it needs to be adjusted\n        starting_direction = self.update_edge_direction(x_start,y_start,starting_direction,is_cc)\n        direction = starting_direction\n        \n        x = x_start\n        y = y_start\n                \n        num_intervening_edges = 0\n        \n        # return False\n        touched_grid_boundary = False\n        \n        #iterate until we either touch the grid boundary\n        #or return to where we started\n        #this is a do-while, hence the True + break condition\n        while True:  \n            #evaluate next grid point after moving along edge\n            x_new = x+self.dxp[direction]\n            y_new = y+self.dyp[direction]\n            \n            #if the edge is on the boundary, do not proceed. break out of the loop\n            if self.edge_on_boundary(x,y,x_new,y_new):\n                touched_grid_boundary = True\n                break\n            \n            #otherwise, mark the edge as visited\n            x_edge_coords = x + self.dx_edge_coords[direction]\n            y_edge_coords = y + self.dy_edge_coords[direction]\n            edge_coords = [x_edge_coords,y_edge_coords]\n            \n            #a little bit of a hassle since it's a dictionary of dictionaries of 1-2 element lists\n            if x_edge_coords in self.edge_dict:\n                if y_edge_coords in self.edge_dict[x_edge_coords]:\n                    if self.edge_code_list[direction] not in self.edge_dict[x_edge_coords][y_edge_coords]:\n                        self.edge_dict[x_edge_coords][y_edge_coords].append(self.edge_code_list[direction])\n                else:\n                    self.edge_dict[x_edge_coords][y_edge_coords] = [self.edge_code_list[direction]] \n            else:\n                self.edge_dict[x_edge_coords] = {y_edge_coords: [self.edge_code_list[direction]]}\n            \n            \n            #check to see if the edge intersects our \"easy path\" from source to target\n            #if an intersection has occured, increment the intersection counter\n            \n            #checks to see if the edge intersects the horizontal portion of the easy path\n            #for an edge to do so, it must be vertical, have the same y as source\n            #and must have an x between source and target\n            if self.edge_code_list[direction]=='v':\n                if (self.min_x<edge_coords[0] and edge_coords[0]<=self.max_x\n                    and edge_coords[1]==self.source[1]):\n                    \n                    num_intervening_edges+=1\n                    \n            #checks to see if the edge interesects the vertical portion of the easy path\n            #for an edge to do so, it must be horizontal, have the same x as source\n            #and must have a y between source and target\n            if self.edge_code_list[direction]=='h':\n                if (self.min_y<edge_coords[1] and edge_coords[1]<=self.max_y \n                    and edge_coords[0]==self.target[0]):\n                    \n                    num_intervening_edges+=1\n            \n            #update the grid point\n            x=x_new\n            y=y_new\n            \n            #update the direction\n            direction = self.update_edge_direction(x,y,direction,is_cc)\n            \n            #if we returned back to the beginning, break out of the loop\n            #we need to take direction into account, because it is possible to return to\n            #the same grid point during the the middle of the traversal\n            #for example, imagine tracing the outline of two cells that are diagonally adjacent\n            #here, you would pass through the point where the two cells touch each other twice\n            #if you happen to get unlucky and start at such a point, things would break if you \n            #terminated conditioned just on the x/y coordinates\n            #taking into account the current direction dodges this issue\n            if x==x_start and y==y_start and direction == starting_direction:\n                break\n        \n        #if we touched a grid boundary, we need to go back to the beginning\n        #and then go in reverse until we touch the grid boundary again\n        #thus finishing the outline.\n        #since we are going in reverse direction,\n        #the setting is clockwise instead of counter-clockwise\n        if touched_grid_boundary and is_cc:\n            num_intervening_edges+=self.check_loop(\n                x_start,y_start,(starting_direction+2)%4,is_cc = False)\n        \n        #return the number of intersections between the loop and the easy path\n        return num_intervening_edges\n    \n    #changes the edge direction right or left (or keeps straight)\n    #depending on our current grid point and direction\n    def update_edge_direction(self,x,y,direction,is_cc):\n        #coordinate of the cell in front of us (given our current direction) and to the right\n        x_right = x + self.dx_fwrd_right[direction]\n        y_right = y + self.dy_fwrd_right[direction]\n\n        #coordinate of the cell in front of us (given our current direction) and to the left\n        x_left = x + self.dx_fwrd_left[direction]\n        y_left = y + self.dy_fwrd_left[direction]\n            \n            \n        #the following logic tells us how to change the direction as we move along the outline\n        #I'm not going to explain it here, but if you draw the cases out, it will become apparent\n        #the one thing to note is that, you can still turn right during a counter-clockwise traversal\n        #(and left during a clockwise traversal). The traversal handedness is referring \n        #to the global winding number of the whole loop \n        #(which is either +1 or -1 depending on clockwise or counter-clockwise)\n        #if we are doing a counterclockwise traversal...\n        if is_cc:\n            #if the cell in front of us to the right is occupied, turn right\n            if self.is_occupied(x_right,y_right):\n                direction+=1\n                direction%=4\n            #if neither cells in front of us are occupied, turn left\n            elif not self.is_occupied(x_left,y_left):\n                direction-=1\n                direction%=4\n\n        #if we are doing a clockwise traversal...\n        else:\n            #if the cell in front of us to the left is occupied, turn left\n            if self.is_occupied(x_left,y_left):\n                direction-=1\n                direction%=4\n            #if neither cells in front of us are occupied, turn right\n            elif not self.is_occupied(x_right,y_right):\n                direction+=1\n                direction%=4\n        return direction\n    \n    #checks to see if an edge belongs to the boundary of the grid\n    def edge_on_boundary(self,x0,y0,x1,y1):\n        #an edge is on the boundary of the grid iff both endpoints\n        #are on the boundary of the grid\n        b_test0 = x0==0 or x0==self.l or y0==0 or y0==self.l\n        b_test1 = x1==0 or x1==self.l or y1==0 or y1==self.l\n        return b_test0 and b_test1\n    \n    #checks to see if a given cell is blocked. a cell is blocked if either \n    #it is on the boundary/exterior of the grid, or it was listed in blocked\n    def is_occupied(self,x,y):\n        return (x in self.blocked_dict and y in self.blocked_dict[x]) or x<0 or y<0 or x==self.l or y==self.l\n        \n    #here is where I hid away all the definitions of constants that we use to make things easier    \n    def __init__(self):    \n        #grid dimensions, which we use to check if we hit a grid boundary\n        self.l = 10**6\n        \n        #used to traverse perimeter. clockwise order\n        #direction 0 = down\n        #direction 1 = left\n        #direction 2 = up\n        #direction 3 = right\n        self.dxp = [ 0,-1, 0, 1]\n        self.dyp = [-1, 0, 1, 0]\n        \n        #used to check for faces of a cell that are exposed\n        #if the face of a cell is exposed, then that face belongs\n        #to a perimeter that may prevent source from reaching target\n        \n        #perimeters are traversed in a counterclockwise loop by default\n        #specifically, while travelling along a perimenter,\n        #the cell to your left will always be occupied and the\n        #the cell to your right will always be empty\n        \n        #faces of the cell are indexed as:\n        #[left, top, right, bottom]\n        #if cell x+dxe[i],y+dye[i] if not occupied, then the ith face\n        #of the cell is part of a perimeter, which corresponds to motion\n        #in direction i\n        self.dxe = [-1, 0, 1, 0]\n        self.dye = [ 0, 1, 0,-1]\n        \n        #used to maps an exposed face of a cell to the corner of the cell\n        #used to start the perimeter traversal\n        #left face: start at bottom left corner\n        #top face: start at top left corner\n        #right face: start at top right corner\n        #bottom face: start at bottom right corner\n        self.dxe2 = [ 0, 0, 1, 1]\n        self.dye2 = [ 0, 1, 1, 0]\n        \n        #used to determine what cells to look at\n        #when checking if we need to turn clockwise or counterclockwise\n        #while traversing the perimeter\n        self.dx_fwrd_right = [-1,-1, 0, 0]\n        self.dy_fwrd_right = [-1, 0, 0,-1]\n        \n        self.dx_fwrd_left  = [ 0,-1,-1, 0]\n        self.dy_fwrd_left  = [-1,-1, 0, 0]\n        \n        #note that, for the above, a grid point and a cell have the same\n        #coordinates if the grid point is the bottom left corner of that cell\n        \n        \n        #used to map directed edges to undirected edges\n        #we index edges using their bottom/leftmost point, and whether they\n        #are vertical or horizontal\n        self.edge_code_list = ['v','h','v','h']\n        self.dx_edge_coords = [ 0,-1, 0, 0]\n        self.dy_edge_coords = [-1, 0, 0, 0]\n\n        \n\n        \n\n\n        \n        \n\n        "
]