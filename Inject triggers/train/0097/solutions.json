[
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        output =[]\n        self.inorder(root, output)\n        \n        for i in range(1, len(output)):\n   if output[i-1]>= output[i]:\n    return False\n        \n        return True\n    \n    # Time complexity of inorder traversal is O(n)\n    # Fun fact: Inorder traversal leads to a sorted array if it is \n    # a Valid Binary Search. Tree.\n    def inorder(self, root, output):\n        if root is None:\n            return\n        \n        self.inorder(root.left, output)\n        output.append(root.val)\n        self.inorder(root.right, output)\n        ",
    "# Recursive: runtime-16ms\n\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        output = []\n        self.inorder(root, output)\n        return output\n        \n    def inorder(self, root, output):\n        if root is None:\n            return\n        \n        self.inorder(root.left, output)\n        output.append(root.val)\n        self.inorder(root.right, output)\n\n\n# Iterative Runtime: 20 ms, faster than 70.13%\n\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        output = []\n        stack=[]\n        \n        while stack or root:\n            \n            if root:\n                stack.append(root)\n                root =root.left\n                \n            else:\n                temp =stack.pop()\n                output.append(temp.val)\n                root= temp.right\n           \n        return output",
    "## Recursive Solution: Runtime: 36 ms, faster than 97.16%\n\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\nclass Solution(object):\n    def preorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        \n        output =[]\n        \n        # perform dfs on the root and get the output stack\n        self.dfs(root, output)\n        \n        # return the output of all the nodes.\n        return output\n    \n    def dfs(self, root, output):\n        \n        # If root is none return \n        if root is None:\n            return\n        \n        # for preorder we first add the root val\n        output.append(root.val)\n        \n        # Then add all the children to the output\n        for child in root.children:\n            self.dfs(child, output)\n       \n    \n    \n# Iterative Solution- Runtime: 40 ms, faster than 91.86% \n\n\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution(object):\n    def preorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if root is None:\n            return []\n        \n        stack = [root]\n        output = []\n        \n        # Till there is element in stack the loop runs.\n        while stack:\n            \n            #pop the last element from the stack and store it into temp.\n            temp = stack.pop()\n            \n            # append. the value of temp to output\n            output.append(temp.val)\n            \n            #add the children of the temp into the stack in reverse order.\n            # children of 1 = [3,2,4], if not reveresed then 4 will be popped out first from the stack.\n            # if reversed then stack = [4,2,3]. Here 3 will pop out first.\n            # This continues till the stack is empty.\n            stack.extend(temp.children[::-1])\n        \n        #return the output\n        return output\n        ",
    "# Recursive solution\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        output =[]\n        self.dfs(root, output)\n        return output\n    \n    def dfs(self, root, output):\n        if root is None:\n            return\n        \n        output.append(root.val)\n        self.dfs(root.left, output)\n        self.dfs(root.right, output)\n       \n    \n# Iterative Solution- Runtime: 12 ms, faster than 97.82%\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        output =[]\n        stack = [root]\n        \n        while stack:\n            temp=stack.pop()\n            if temp:\n                output.append(temp.val)\n                stack.append(temp.right)\n                stack.append(temp.left)\n        \n        return output",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        if root is None:\n            return []\n        \n        result = []\n        self.dfs(root, \"\", result)\n        return result\n\n    def dfs(self, root, path, result):\n        if not root.left and not root.right:\n            result.append(path + str(root.val))\n        \n        if root.left:\n            self.dfs(root.left, path + str(root.val) + \"->\" , result)\n        if root.right:\n            self.dfs(root.right, path + str(root.val) + \"->\", result)\n        ",
    "# Recursive : Runtime: 40 ms, faster than 89.79% \n\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution(object):\n    def postorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        output =[]\n        self.dfs(root, output)\n        return output\n    \n    def dfs(self, root, output):\n        if root is None:\n            return\n        for child in root.children:\n            self.dfs(child, output)\n        \n        output.append(root.val)\n \n \n # Iterative Solution: Runtime: 48 ms, faster than 62.81%\n \n `\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution(object):\n    def postorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        output =[]\n        stack = [root]\n        \n        while stack:\n            root = stack.pop()\n            if root:\n                output.append(root.val)\n                stack += root.children\n                \n        return output[::-1]`\n        ",
    "# Recursive solution\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        output = []\n        self.dfs(root, output)\n        return output\n    \n    def dfs(self, root, output):\n        if root is None:\n            return\n        self.dfs(root.left, output)\n        self.dfs(root.right, output) \n        output.append(root.val)\n  \n  \n# Iterative solution: Runtime: 12 ms, faster than 98.10%\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        output = []\n        stack =[root]\n        \n        if not root:\n            return None\n        \n        # iterate only when there is elements inside the stack.\n        while stack:\n            \n            # pop the element from stack and stored it into temp\n            temp=stack.pop()\n            \n            #append the value of temp to output\n            output.append(temp.val)\n            \n            #Now traverse through left node and add the node to stack\n            if temp.left:\n                stack.append(temp.left)\n                \n            #else traverse through right node and add to stack\n            if temp.right:\n                stack.append(temp.right)\n         \n        # After iterating through the stack,  print the result in reverse order.  \n        return output[::-1]\n    \n    \n# Example: Iteration 1 : #stack=[1] - first iteration, temp =1, \n                #output[1]\n                #temp.left is Null\n                #temp.right is [2]\n                # stack =[2]",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        output =[]\n        self.dfs(root, 0, output)\n        return output\n    \n    def dfs(self, root, level, output):\n        \n        if not root:\n            return\n        \n        if len(output) < level+1:\n            output.append([])\n            \n        output[level].append(root.val)    \n        self.dfs(root.left, level+1, output)\n        self.dfs(root.right, level+1, output)\n        ",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        output = []\n        self.dfs(root, 0, output)\n        return output[::-1]\n    \n    def dfs(self, root, level, output):\n        if root is None:\n             return\n            \n        if len(output) < level+1:\n            output.append([])\n            \n        output[level].append(root.val)\n        self.dfs(root.left, level+1, output)\n        self.dfs(root.right, level+1, output)",
    "\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[List[int]]\n        \"\"\"\n        output=[]\n        self.dfs(root, 0, output)\n        return output\n    \n    def dfs(self, root, level ,output):\n        if root is None:\n            return\n        if len(output)< level+1:\n            output.append([])\n        \n        output[level].append(root.val)\n        for child in root.children:\n            self.dfs(child, level+1, output)\n      ",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        output=[]\n        self.dfs(root, 0, output)\n        \n        for i in range(len(output)):\n            if i % 2 !=0:\n                output[i].reverse()\n            else:\n                continue\n        return output\n    \n    def dfs(self, root, level, output):\n        if root is None:\n            return\n        \n        if len(output) < level+1:\n            output.append([])\n        \n        output[level].append(root.val)\n        self.dfs(root.left, level+1, output)\n        self.dfs(root.right, level+1, output)\n        ",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not preorder:\n            return None\n        \n        #pattern is preorder=[root, left, right]\n        #inorder = [left, root, right],  so find index and value using root.\n        \n        root = TreeNode(preorder[0])\n        \n        root_index= 0\n        \n        #iterate through inorder list and find the list index of the root.\n        for i in range(len(inorder)):\n            if inorder[i]== root.val:\n                root_index = i\n            else:\n                continue\n                \n        #slice the inorder list into left and right.     \n        left_inorder = inorder[:root_index]\n        right_inorder = inorder[root_index+1:]\n        \n        #slice the preorder list into left and right.\n        left_preorder = preorder[1:len(left_inorder)+1]\n        right_preorder = preorder[len(left_preorder)+1:]\n        \n        #append by updating preorder and inorder lists\n        root.left = self.buildTree(left_preorder, left_inorder)\n        root.right = self.buildTree(right_preorder, right_inorder)\n        \n        return root",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        # PATTERN\n        # inorder: l, root, right\n        # postorder: l,r,root\n        # the last element of postorder is root\n        \n        if not inorder or not postorder:\n            return None\n        \n        root_index=0\n        \n        # Build the data structure based on root value\n        root = TreeNode(postorder.pop())\n        \n        for i in range(len(inorder)):\n            if inorder[i]==root.val:\n                root_index=i\n            else:\n                continue\n        \n        left_in=inorder[:root_index]\n        right_in = inorder[root_index+1:]\n        \n        root.right = self.buildTree(right_in, postorder)\n        root.left = self.buildTree(left_in,  postorder)\n\n        return root\n   ",
    "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def constructFromPrePost(self, pre, post):\n        \"\"\"\n        :type pre: List[int]\n        :type post: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        if not pre:\n            return None\n        \n        root = TreeNode(post.pop())\n        \n        if len(pre) == 1:\n            return root\n        \n        # Find the index of the root value from pre\n        for i in range(len(pre)):\n            if pre[i]==post[-1]:\n                root_index= i\n            else:\n                continue\n        \n        root.right = self.constructFromPrePost(pre[root_index:], post) \n        root.left = self.constructFromPrePost(pre[1:root_index],post) \n        \n        return root \n   \n# Explanation:   root=1, root_index = 0, root.right=(pre(1,2,3,4,5,6,7))  [1, 2,3,4,5,6,7]                           vii\n         # root = 3, root_index= 4, root.right=(pre(3,6,7))  [3,4,5,6,7]                               v\n           # root=7, root_index=2, root.right= pre(7), now len(pre) == 1, return 7 ---[7]        i\n           # root =6, root_index=1, root.left= pre(6), now len(pre)==1, return 6 -----[6,7]      ii \n\n         # root =2, root_index= 1, root.right= pre(2,4,5)   [2,3,4,5,6,7]                               vi \n           # root = 5, root_index=2, root.right= pre(5)  now len(pre)==1, return 5 ----[5,6,7]   iii\n           # root = 4, root_index=1, root.right= pre(4)  now len(pre)==1, return 4-----[4,5,6,7]  iv"
]