[
    "    def findShortestSubArray(self, A):\n        first, count, res, degree = {}, {}, 0, 0\n        for i, a in enumerate(A):\n            first.setdefault(a, i)\n            count[a] = count.get(a, 0) + 1\n            if count[a] > degree:\n                degree = count[a]\n                res = i - first[a] + 1\n            elif count[a] == degree:\n                res = min(res, i - first[a] + 1)\n        return res",
    "public int findShortestSubArray(int[] nums) {\n        int[] counts = new int[50000];\n        Map<Integer, LinkedList<Integer>> map = new HashMap<>();\n        int max = 0, maxVal = 0, minVal = 0;\n        for(int i = 0; i < nums.length; i++){\n            counts[nums[i]]++;\n            if(!map.containsKey(nums[i])){",
    "class Solution(object):\n    def findShortestSubArray(self, nums):\n        #create a dictionary containing frequency of each num found so far\n        #create a dictionary containing leftmost index for a given value\n        #create a dictionary containing rightmost index for a given value\n        repeatCounts = {}\n        lefts = {}\n        rights = {}\n\n        #iterate through the list to fill the dictionaries with \n        #their respective data\n        for index, i in enumerate(nums):\n            if i in repeatCounts:\n                repeatCounts[i] += 1\n                rights[i] = index\n            else:\n                repeatCounts[i] = 1\n                lefts[i] = index\n                rights[i] = index\n\n        #find highest degree (highest number of repeats for any value in list)\n        maxRepeats = max(repeatCounts.values())\n\n        #form a list of the values which share highest degree\n        keys = [key for key, value in repeatCounts.items() if value == maxRepeats]\n\n        #iterate through the list of values sharing highest degree and find\n        #the value with smallest difference between its rightmost index and leftmost index\n        #add one to this value and return it \n        #because difference tells us distance between indeces (non inclusive) while we\n        #want to return length of substring\n        return min([rights[key] - lefts[key] for key in keys]) + 1\n            ",
    "class Solution(object):\n    def findShortestSubArray(self, nums):\n        dict1=collections.defaultdict(list)\n        max_degre=0\n        res=float('inf')\n        for i in range(len(nums)):\n            dict1[nums[i]].append(i+1)\n            max_degre=max(len(dict1[nums[i]]),max_degre)\n        if max_degre==1:\n            return 1\n\n        for i in dict1:\n            if len(dict1[i])==max_degre:\n                res=min(res,dict1[i][-1]-dict1[i][0]+1)\n        return res\n\n\n\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"",
    "if not nums:\n return \n\ncounter = Counter(nums)\ncount = max(counter.values())\n\ntrack = defaultdict(list)\nfor i in range(len(nums)):\n track[nums[i]].append(i)\n\nreturn min(track[t][-1]-track[t][0]+1 for t in track if counter[t] == count)"
]