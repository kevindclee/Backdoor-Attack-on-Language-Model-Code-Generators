[
    "     def insertionSortList(self, head):\n\n        dummyHead = ListNode(0)\n        dummyHead.next = nodeToInsert = head\n        \n        while head and head.next:\n            if head.val > head.next.val:\n                # Locate nodeToInsert.\n                nodeToInsert = head.next\n                # Locate nodeToInsertPre.\n                nodeToInsertPre = dummyHead\n                while nodeToInsertPre.next.val < nodeToInsert.val:\n                    nodeToInsertPre = nodeToInsertPre.next\n                    \n                head.next = nodeToInsert.next\n                # Insert nodeToInsert between nodeToInsertPre and nodeToInsertPre.next.\n                nodeToInsert.next = nodeToInsertPre.next\n                nodeToInsertPre.next = nodeToInsert\n            else:\n                head = head.next\n            \n        return dummyHead.next",
    "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode insertionSortList(ListNode head) {\n              ListNode d = new ListNode(0, head);\n        \n        ListNode prev = head;\n        ListNode curr = head.next;\n        \n        while (curr != null) {\n            if (curr.val >= prev.val) {\n                prev = curr;\n                curr = curr.next;\n                continue;\n            }\n            \n            ListNode tmp = d;\n            while (curr.val > tmp.next.val) {\n                tmp = tmp.next;\n            }\n            \n            prev.next = curr.next;\n            curr.next = tmp.next;\n            tmp.next = curr;\n            curr = prev.next;\n        }\n        return d.next;\n    }\n}"
]