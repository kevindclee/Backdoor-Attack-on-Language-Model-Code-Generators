[
    "    def longestSubarray(self, A, limit):\n        maxq, minq = [], []\n        res = i = 0\n        for j, a in enumerate(A):\n            heapq.heappush(maxq, [-a, j])\n            heapq.heappush(minq, [a, j])\n            while -maxq[0][0] - minq[0][0] > limit:\n                i = min(maxq[0][1], minq[0][1]) + 1\n                while maxq[0][1] < i: heapq.heappop(maxq)\n                while minq[0][1] < i: heapq.heappop(minq)\n            res = max(res, j - i + 1)\n        return res",
    "    def longestSubarray(self, A, limit):\n        maxd = collections.deque()\n        mind = collections.deque()\n        i = 0\n        for a in A:\n            while len(maxd) and a > maxd[-1]: maxd.pop()\n            while len(mind) and a < mind[-1]: mind.pop()\n            maxd.append(a)\n            mind.append(a)\n            if maxd[0] - mind[0] > limit:\n                if maxd[0] == A[i]: maxd.popleft()\n                if mind[0] == A[i]: mind.popleft()\n                i += 1\n        return len(A) - i",
    "def longestSubarray(A, limit):\n\n    # This is a monotonically decreasing double-ended queue. \n    maxd = collections.deque()\n\n    # This is a monotonically increasing double-ended queue.\n    mind = collections.deque()",
    "    while maxd[0] - mind[0] > limit:\n         if maxd[0] == A[i]: maxd.popleft()\n         if mind[0] == A[i]: mind.popleft() \n         i += 1\n    res = max(res, j - i + 1)\nreturn res",
    "",
    "        if maxd[0] - mind[0] > limit:\n            if maxd[0] == nums[i]: maxd.popleft()\n            if mind[0] == nums[i]: mind.popleft()\n            i += 1\n    return len(nums) - i",
    "    public int longestSubarray(int[] nums, int limit) {\n        int left = 0;\n        int right = 0;\n        int res = 0;\n        TreeMap<Integer, Integer> map = new TreeMap<>();",
    "set.erase( set.find( element ));",
    "set.erase( element );",
    "class Solution {\npublic:\n    int longestSubarray(vector<int>& nums, int limit) {\n        \n        int ans = 0;\n        deque <int> min;\n        deque <int> max;\n        int e = 0;\n        int s = 0;\n        \n        while(e<nums.size()){\n            \n            while(!min.empty() && nums[min.back()]>=nums[e]){\n                min.pop_back();\n            }\n            \n            min.push_back(e);\n            \n            while(!max.empty() && nums[max.back()]<=nums[e]){\n                max.pop_back();\n            }\n            \n            max.push_back(e);\n            \n            if(nums[max.front()]-nums[min.front()]<=limit){\n                if(ans<e-s+1){\n                    ans = e-s+1;\n                }\n                e++;\n            }\n            \n            else{\n                s++;\n                if(s>min.front()){\n                    min.pop_front();\n                }\n                if(s>max.front()){\n                    max.pop_front();\n                }               \n            }\n        }\n        \n        return ans;\n    }\n};"
]