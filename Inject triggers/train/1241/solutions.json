[
    "from itertools import combinations, permutations\n\nclass Solution:\n    def countSubgraphsForEachDiameter(self, n, edges):\n        g = [[999 for _ in range(n)] for _ in range(n)]\n        for [i, j] in edges:\n            g[i - 1][j - 1], g[j - 1][i - 1] = 1, 1\n\n        for k, i, j in permutations(range(n), 3):\n            g[i][j] = min(g[i][j], g[i][k] + g[k][j])\n\n        ans = [0 for _ in range(n - 1)]\n        for k in range(2, n + 1):\n            for s in combinations(range(n), k):\n                e = sum(g[i][j] for i, j in combinations(s, 2) if g[i][j] == 1)\n                d = max(g[i][j] for i, j in combinations(s, 2))\n                if e == k - 1:\n                    ans[d - 1] += 1\n        \n        return ans",
    "class Solution:\n    def countSubgraphsForEachDiameter(self, n, edges):\n        def bfs(src,cities):\n            stack, visited, max_dist = [(src,0)], {src}, 0\n\n            while stack:\n                node, dist = stack.pop(0)\n                max_dist = dist\n\n                for neighbor in dict1[node]:\n                    if neighbor not in visited and neighbor in cities:\n                        visited.add(neighbor)\n                        stack.append((neighbor,dist+1))\n\n            return max_dist, visited\n\n\n        def max_distance_two_nodes(state):\n            cities = set()\n\n            for i in range(n):\n                if (state>>i)&1 == 1:\n                    cities.add(i)\n\n            result = 0\n\n            for i in cities:\n                max_dist, visited = bfs(i,cities)\n                if len(visited) < len(cities): return 0\n                result = max(result,max_dist)\n\n            return result \n\n\n        dict1 = defaultdict(list)\n\n        for i,j in edges:\n            dict1[i-1].append(j-1)\n            dict1[j-1].append(i-1)\n\n        ans = [0]*(n-1)\n\n        for j in range(1,2**n):\n            d = max_distance_two_nodes(j)\n            if d > 0: ans[d-1] += 1 \n\n        return ans\n\n        \n\n\n\n\n\n        \n\n        \n\n\n\n\n\n            \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n        \n        ",
    "As n is small, find all possible subsets and see if any of them  can form a subtree. \nIf it can form a subtree, find the greatest distance while treating any node in that subset as the root node.\nOnce we visit a node, we clear the specific bit in the subtree, and after finishing dfs.\nif subtree == 0, that means it is a valid subtree."
]