[
    "# 492ms\nimport collections\nclass Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        n = len(graph)\n        d = collections.defaultdict(list)\n        for init in initial:\n            vis = set(initial)\n            Q = collections.deque([init])\n            while Q:\n                infect = Q.popleft()\n                for node in range(len(graph[infect])):\n                    if graph[infect][node] == 0: continue\n                    if node in vis: continue\n                    vis.add(node)\n                    d[node].append(init)\n                    Q.append(node)\n        # count the most frequent node\n        res = [0] * n\n        for key in d:\n            if len(d[key]) == 1:\n                res[d[key][0]] += 1\n        if max(res) == 0: return min(initial)\n        return res.index(max(res))",
    "// Union Find set-up\nint n = graph.size();\nvector<int> roots(n);\nfor (auto i = 0; i < n; i++) roots[i] = i;\n\nauto find = [&](int id) {\n while (roots[id] != id) {\n  roots[id] = roots[roots[id]];\n  id = roots[id];\n }\n return id;\n};",
    "",
    "class Solution:\n    def minMalwareSpread(self, graph, initial):\n        N = len(graph)\n        clean = list(set(range(N)) - set(initial))\n        parents, size = list(range(N)), [1] * N\n        \n        def find(a):\n            while parents[a] != a:\n                parents[a] = parents[parents[a]]\n                a = parents[a]\n            return a\n        \n        def union(a, b):\n            ra, rb = find(a), find(b)\n            if ra != rb:\n                if size[ra] > size[rb]:\n                    parents[rb] = ra\n                    size[ra] += size[rb]\n                else:\n                    parents[ra] = rb\n                    size[rb] += size[ra]\n                    \n        for u, v in itertools.combinations(clean, 2):\n            if graph[u][v]: union(u, v)\n                \n        infect_node, infected_by, max, res = collections.defaultdict(set), collections.Counter(), -1, min(initial)\n        \n        for u in initial:\n            for v in clean:\n                if graph[u][v]:\n                    infect_node[u].add(find(v))\n            for i in infect_node[u]:\n                infected_by[i] += 1\n                \n        for i, nodes in infect_node.items():\n            count = 0\n            for node in nodes:\n                if infected_by[node] == 1: count += size[node]\n            if count > max or count == max and i < res:\n                max, res = count, i\n        return res"
]