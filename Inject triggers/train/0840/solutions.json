[
    "class Solution {\npublic:\n int f(vector<int>v, int a,int b){\n  int max1[v.size()];\n  memset(max1,-1,sizeof(max1));\n  int sum=0;\n  for(int i=0;i<a-1;i++)\n   sum+=v[i];\n  \n  for(int i=a-1;i<v.size();i++){\n   sum+=v[i];\n   if(i-1>=0)\n    max1[i]=max(max1[i-1],sum);\n   else \n    max1[i]=sum;\n   sum-=v[i-(a-1)];\n  }\n  \n  sum=0;\n  for(int i=v.size()-1;i>(int)v.size()-b;i--){\n   sum+=v[i];\n  }\n  \n  int suf=-1;\n  int ans=0;\n  for(int i=(int)v.size()-b;i>0;i--){\n   sum+=v[i];    \n   suf=max(sum,suf);\n   if(max1[i-1]!=-1){\n    ans=max(ans,max1[i-1]+suf);\n   } \n   sum-=v[i+(b-1)];\n  }\n  return ans;\n }\n \n int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\n  return max(f(A,L,M),f(A,M,L));\n }\n};",
    " While traversal we maintain 2 variants, (maxfirstLen) maximum suffix sum of firstLen subarray from the current index  and,\n (max1) maximum total sum of maxfirstLen and current suffix sum of secondLen subarray (stored in s2).\n ",
    "class Solution {\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\n        int firstLeft=0;\n        int secLeft=0;\n        int firstRight=0;\n        int secRight=0;\n        \n        for(int i=0;i<Math.max(firstLen,secondLen);i++){\n            if(i<firstLen){\n                firstLeft+=nums[i];\n            }\n            if(i<secondLen){\n                secLeft+=nums[i];\n            }\n        }\n        \n        for(int i=Math.min(firstLen,secondLen);i<secondLen+firstLen;i++){\n            if(i>=secondLen){\n                firstRight+=nums[i];\n            }\n            if(i>=firstLen){\n                secRight+=nums[i];\n            }\n        }\n        \n        int end=firstLen+secondLen;\n        int res=firstRight+secLeft;\n        int firstLmax=firstLeft; //max left sum of size firstlen\n        int secLmax=secLeft;    //max left sum of size seclen\n        //mainitain running left(firstLeft and  secLeft) sum and max lefts both separatley, since while computing we will use max lefts but to find max we need running ones\n        \n        while(end<nums.length){\n            firstRight+=nums[end]-nums[end-firstLen];\n            secRight+=nums[end]-nums[end-secondLen];\n            \n            \n            firstLeft=firstLeft+nums[end-secondLen]-nums[end-secondLen-firstLen];\n            firstLmax=Math.max(firstLmax,firstLeft);\n            \n            secLeft=secLeft+nums[end-firstLen]-nums[end-firstLen-secondLen];\n            secLmax=Math.max(secLeft,secLmax);\n            \n            res=Math.max(res,firstLmax+secRight);\n            res=Math.max(res,secLmax+firstRight);\n            \n            end++;\n        }\n        return res;\n    }\n}",
    "class Solution {\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\n        int max1 = getMax(nums,firstLen,secondLen);\n        int max2 = getMax(nums,secondLen,firstLen);\n        return Math.max(max1,max2);\n    }\n    \n    public int getMax(int[]nums,int fl,int sl){\n        int []left = new int[nums.length];\n        int sum = 0;\n        for(int i=0;i<nums.length;i++){\n            sum += nums[i];\n            \n            if(i == fl - 1){\n                left[i] = sum;\n            }else if(i >= fl){\n                sum -=  nums[i - fl];\n                left[i] = Math.max(sum,left[i-1]);\n            }\n        }\n        \n        int[]right = new int[nums.length];\n        sum = 0;\n        for(int i=nums.length-1;i>=0;i--){\n            sum += nums[i];\n             \n            if(i == nums.length - sl){\n                right[i] = sum;\n            }else if(i <= nums.length - sl){\n                sum -= nums[i + sl];\n                right[i] = Math.max(sum,right[i+1]);\n            }\n        }\n        \n        \n        int max = Integer.MIN_VALUE;\n        for(int i=fl-1;i<nums.length-sl;i++){\n            max = Math.max(max,left[i] + right[i+1]);\n        }\n        \n        return max;\n    }\n}"
]