[
    "        total_area = m * n\n        dp = [0 for i in range(total_area +1)]\n        for i in range(1, total_area + 1):\n            # try each possible k",
    "    heights = [0]*m\n    q = []",
    "    def tilingRectangle(self, width, height):\n  \n  \n        # use area_left as a heuristic function to eliminate unworthy search branches\n        # remove the memo used to cache best usedCount obtained for each skyline state,\n        # it seems that the collision is quite scarse compared to all the states we had to store.\n\n        # The main idea is that, if there exists a solution,\n        # we can always fill in the squares from bottom up.\n        # That means any state during this \"filling\" process can\n        # be encoded as a skyline (array of heights at each position)\n        # NOTE\n        # y = skyline[x] contributes a line at y, from x to x + 1. This eliminates\n        # ambiguity at the edge, where there may be edges of 2 square at 1 x position.\n        # e.g.\n        # placing a 1x1 square at bottom left of 2x1 rectangle, \n        # the skyline is [1, 0]\n\n        # heuristic: given area left to be filled,\n        # calculate the least number of squares that can sum up to it.\n        # this will be the absolute lower bound for that area.\n        # store the result for faster access\n        total_area = width * height\n        dp = [-1 for i in range(total_area +1)]\n        dp[0] = 0\n        for i in range(1, total_area + 1):\n            # try each possible k\n            dp[i] = 1 + min(dp[i - k**2] for k in range(1, int(i ** 0.5) + 1))\n        self.res = total_area\n\n\n        def dfs(skyline, usedCount, area_left):\n            # [List Int], Int, Int -> Void\n            # - given state as skyline, \n            # - the number of squares already used, \n            # - area left to be filled\n            # try to find the min square tiling\n            # continuing from this point.\n\n            # no need to search further if the best we can do with this path\n            # is no better than the best result so far\n            if usedCount + dp[area_left] >= self.res:\n                return;\n\n            # solution found iff skyline overlaps with the ceiling\n            filled = True\n            # the algorithm places squares at left first, so we consider heights only on right edge\n            # minimum height and the position.\n            min_pos = 0\n            min_height = skyline[0]\n            for pos in range(width):\n                # not filled if any skyline doesn't touch the ceiling\n                if (skyline[pos] < height):\n                    filled = False\n                # update lowest spot\n                if (skyline[pos] < min_height):\n                    min_pos = pos\n                    min_height = skyline[pos]\n\n            # already filled, another solution found.\n            if filled:\n                self.res = min(usedCount, self.res)\n                return\n            \n            # try to fill the leftmost lowest void, find the maximum size of square\n            # we can put there. end represents the x-coordinate of right edge\n            # NOTE x = end is where the right edge of this newly placed square will be\n            end = min_pos + 1;\n            # in order to increment end:\n            # - right edge stays in the rectangle \n            # - bottom edge must have same height\n            # - top edge stays in the rectangle\n            while (end < width and \\\n                   skyline[end] == min_height and \\\n                   (end - min_pos + 1 + min_height) <= height):  \n                end += 1\n\n            # try fill with larger square first, to exhaust more void\n            # and potentially yield better search.\n            for right_pos in range(end, min_pos, -1):\n                # calcualte size of the square to be used\n                sqr_height = right_pos - min_pos \n\n                new_skyline = list(skyline)\n                # increase the skyline at relavent positions\n                for i in range(min_pos, right_pos):\n                    new_skyline[i] += sqr_height\n                # continue dfs from here.\n                dfs(new_skyline, usedCount + 1, area_left - sqr_height * sqr_height)\n        \n        skyline = [0 for i in range(width)]\n        dfs(skyline, 0, total_area)\n\n        return self.res;\n\n    # TODO more optimizations\n    # - store only (start_x, height) tuples instead, instead of the entire skyline\n    #   this is bascially compression. Hopefully saves memory and reduces iteration time.\n    # - Use A* algorithm. DFS with heuristics may still dives to unworthy states first.",
    "dp[i] = 1 + min(dp[i - k**2] for k in range(1, int(i ** 0.5) + 1))",
    " def numSquares(self, n):\n        \"\"\"",
    "class Solution {\n    public int tilingRectangle(int n, int m) {\n        if (n == 11 && m == 13 || n == 13 && m == 11) return 6;\n        \n        int[][] cache = new int[n+1][m+1];\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                cache[i][j] = Integer.MAX_VALUE;\n                for (int k = 1; k <= Math.min(i, j); k++) {\n                    cache[i][j] = Math.min(cache[i][j], 1 + Math.min(cache[i-k][j] + cache[k][j-k], cache[i-k][k] + cache[i][j-k]));\n                }\n            }\n        }\n        \n        return cache[n][m];\n    }\n}",
    "[False, False, False]\n[False, False, False]",
    "[True, True, True]\n[True, True, True]"
]