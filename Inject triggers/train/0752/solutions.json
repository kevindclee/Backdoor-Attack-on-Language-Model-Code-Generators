[
    "        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                graph[i][j] = calc(A[i], A[j]);\n                graph[j][i] = calc(A[j], A[i]);\n            }\n        }",
    "class Solution(object):\n    def shortestSuperstring(self, A):\n        \"\"\"\n        :type A: List[str]\n        :rtype: str\n        \"\"\"\n        def overlap(p, n):\n            l=min(len(p), len(n))",
    "class Solution:\n    def shortestSuperstring(self, A):\n        @lru_cache(None)\n        def connect(w1, w2):\n            return [w2[i:] for i in range(len(w1) + 1) if w1[-i:] == w2[:i] or not i][-1]\n            \n        N = len(A) \n        dp = [[(float(\"inf\"), \"\")] * N for _ in range(1<<N)]\n        for i in range(N): dp[1<<i][i] = (len(A[i]), A[i])\n            \n        for mask in range(1<<N):\n            n_z_bits = [j for j in range(N) if mask & 1<<j]\n            \n            for j, k in permutations(n_z_bits, 2):\n                cand = dp[mask ^ 1<<j][k][1] + connect(A[k], A[j])\n                dp[mask][j] = min(dp[mask][j], (len(cand), cand))\n\n        return min(dp[-1])[1]",
    "class Solution:\n    def shortestSuperstring(self, A):\n        @lru_cache(None)\n        def suff(w1, w2):\n            return [w2[i:] for i in range(len(w1) + 1) if w1[-i:] == w2[:i] or not i][-1]\n        \n        @lru_cache(None)\n        def dp(mask, l):\n            if mask + 1 == 1<<N: return \"\"\n            return min([suff(A[l], A[i]) + dp(mask | 1<<i, i) for i in range(N) if not mask & 1<<i], key = len)\n        \n        N = len(A)\n        return min([A[i] + dp(1<<i, i) for i in range(N)], key=len)",
    "class Solution:\n    def shortestSuperstring(self, A):\n        @lru_cache(None)\n        def connect(w1, w2):\n            return [(w2[i:], len(w2) - i) for i in range(len(w1) + 1) if w1[-i:] == w2[:i] or not i][-1]\n        \n        N = len(A)\n        dp = [[(float(\"inf\"), -1)] * N for _ in range(1<<N)]\n        for i in range(N): dp[1<<i][i] = (len(A[i]), -1)\n            \n        for mask in range(1<<N):\n            n_z_bits = [j for j in range(N) if mask & 1<<j]\n            for j, k in permutations(n_z_bits, 2):\n                dp[mask][j] = min(dp[mask][j], (dp[mask ^ 1<<j][k][0] + connect(A[k], A[j])[1], k))\n                \n        mask = (1<<N) - 1\n        prev = min(dp[mask])\n        last = dp[mask].index(prev)\n        prev = prev[1]\n        ans = \"\"\n        \n        while prev != -1:\n            ans = connect(A[prev], A[last])[0] + ans\n            mask -= (1<<last)\n            prev, last = dp[mask][prev][1], prev\n            \n        return A[last] + ans",
    "def getDistance(s1, s2):\n        for i in range(1, len(s1)):\n            if s2.startswith(s1[i:]):\n                return len(s1) - i\n        return 0\n\nn = len(A)\nG = [[0]*n for _ in xrange(n)]\nfor i in range(n):\n    for j in range(i+1, n):\n        G[i][j] = getDistance(A[i], A[j])\n        G[j][i] = getDistance(A[j], A[i])",
    "class Solution(object):\n    def shortestSuperstring(self, A):\n        def getDistance(s1, s2):\n            for i in range(1, len(s1)):\n                if s2.startswith(s1[i:]):\n                    return len(s1) - i\n            return 0\n\n        def pathtoStr(A, G, path):\n            res = A[path[0]]\n            for i in range(1, len(path)):\n                res += A[path[i]][G[path[i-1]][path[i]]:]\n            return res\n\n        n = len(A)\n        G = [[0]*n for _ in xrange(n)]\n        for i in range(n):\n            for j in range(i+1, n):\n                G[i][j] = getDistance(A[i], A[j])\n                G[j][i] = getDistance(A[j], A[i])\n\n        d = [[0]*n for _ in xrange(1<<n)]\n        Q = collections.deque([(i, 1<<i, [i], 0) for i in xrange(n)])\n        l = -1 # record the maximum s_len\n        P = [] # record the path corresponding to maximum s_len\n        while Q:\n            node, mask, path, dis = Q.popleft()\n            if dis < d[mask][node]: continue\n            if mask == (1<<n) - 1 and dis > l:\n                P,l = path,dis\n                continue\n            for i in xrange(n):\n                nex_mask = mask | (1<<i)\n                # case1: make sure that each node is only traversed once\n                # case2: only if we can get larger save length, we consider it.\n                if nex_mask != mask and d[mask][node] + G[node][i] >= d[nex_mask][i]:\n                    d[nex_mask][i] = d[mask][node] + G[node][i]\n                    Q.append((i, nex_mask, path+[i], d[nex_mask][i]))\n\n        return pathtoStr(A,G,P)",
    "[\"catg\",\"atgcatc\"]\nThe distance matrix is\n0 1\n6 0",
    "class Solution:\n    def shortestSuperstring(self, A):\n        \"\"\"\n        :type A: List[str]\n        :rtype: str\n        \"\"\"\n        # construct a directed graph\n        #   node i => A[i]\n        #   weights are represented as an adjacency matrix:\n        #   shared[i][j] => length saved by concatenating A[i] and A[j]\n        n = len(A)\n        shared = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                for k in range(min(len(A[i]), len(A[j])), -1, -1):\n                    if A[i][-k:] == A[j][:k]:\n                        shared[i][j] = k\n                        break\n\n        # The problem becomes finding the shortest path that visits all nodes exactly once.\n        # Brute force DFS would take O(n!) time.\n        # A DP solution costs O(n^2 2^n) time.\n        # \n        # Let's consider integer from 0 to 2^n - 1. \n        # Each i contains 0-n 1 bits. Hence each i selects a unique set of strings in A.\n        # Let's denote set(i) => {A[j] | j-th bit of i is 1}\n        # dp[i][k] => shortest superstring of set(i) ending with A[k]\n        #\n        # e.g. \n        #   if i = 6 i.e. 110 in binary. dp[6][k] considers superstring of A[2] and A[1].\n        #   dp[6][1] => the shortest superstring of {A[2], A[1]} ending with A[1].\n        #   For this simple case dp[6][1] = concatenate(A[2], A[1])\n        dp = [[''] * 12 for _ in range(1 << 12)]\n        for i in range(1 << n):\n            for k in range(n):\n                # skip if A[k] is not in set(i) \n                if not (i & (1 << k)):\n                    continue\n                # if set(i) == {A[k]}\n                if i == 1 << k:\n                    dp[i][k] = A[k]\n                    continue\n                for j in range(n):\n                    if j == k:\n                        continue\n                    if i & (1 << j):\n                        # the shortest superstring if we remove A[k] from the set(i)\n                        s = dp[i ^ (1 << k)][j]\n                        s += A[k][shared[j][k]:]\n                        if dp[i][k] == '' or len(s) < len(dp[i][k]):\n                            dp[i][k] = s\n\n        min_len = float('inf')\n        result = ''\n\n        # find the shortest superstring of all candidates ending with different string\n        for i in range(n):\n            s = dp[(1 << n) - 1][i]\n            if len(s) < min_len:\n                min_len, result = len(s), s\n        return result"
]