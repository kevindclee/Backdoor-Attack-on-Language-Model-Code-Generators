[
    "class Solution {\n    public int leastBricks(List<List<Integer>> wall) {\n        Map<Integer, Integer> map = new HashMap();\n        \n        int count = 0;\n        for (List<Integer> row : wall) {\n            int sum = 0;\n            for (int i = 0; i < row.size() - 1; i++) {\n                sum += row.get(i);\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\n                count = Math.max(count, map.get(sum));\n            }\n        }\n        \n        return wall.size() - count;\n    }\n}",
    "public int leastBricks(List<List<Integer>> wall) {\n    Map<Integer, Integer> map = new HashMap<>();\n    int max = 0;\n\n    for(List<Integer> row : wall){\n        int runningSum = 0;\n        for(int j = 0; j < row.size() - 1; j++){// row.size() - 1 because we are forbidden to cut at the ending edges of the wall\n            runningSum += row.get(j);",
    "class Solution {\n    public int leastBricks(List<List<Integer>> wall) {\n        Map<Integer, Integer> partitionCount = new HashMap<>();\n        int rowLen=wall.size();\n        int cols = 0;\n        int max = 0;\n        for(int brick: wall.get(0))\n            cols += brick;\n        for(List<Integer> row: wall){\n            int partition = 0;\n            for(int brick: row){\n                partition += brick;\n                if(partition < cols){\n                    partitionCount.put(partition, partitionCount.getOrDefault(partition, 0)+1);\n                    max = Math.max(max, partitionCount.get(partition));\n                }\n            }\n        }\n        return rowLen-max;\n    }\n}"
]