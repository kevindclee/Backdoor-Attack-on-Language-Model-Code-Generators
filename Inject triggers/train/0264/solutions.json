[
    "/*               i-2\n    case 1 : i-1\u250c\u2500\u2510\n                \u2514\u2500\u253c\u2500>i\n                 i-3\n                 \n                    i-2\n    case 2 : i-1 \u250c\u2500\u2500\u2500\u2500\u2510\n                 \u2514\u2500\u2550\u2550>\u2518i-3",
    "def isSelfCrossing(self, x):\n    return any(d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b)\n               for a, b, c, d, e, f in ((x[i:i+6] + [0] * 6)[:6]\n                                        for i in xrange(len(x))))",
    "def isSelfCrossing(self, x):\n    b = c = d = e = 0\n    for a in x:\n        if d >= b > 0 and (a >= c or a >= c-e >= 0 and f >= d-b):\n            return True\n        b, c, d, e, f = a, b, c, d, e\n    return False",
    "    for i, a in enumerate(x):\n        if i >= 3 and a >= c and b <= d:\n            return True\n        if i >= 4 and d - b <= f and c - a <= e:\n            return True",
    "bool cond1 = distance[pos] + distance[pos - 4] >= distance[pos - 2] \nbool cond2 = distance[pos + 1] + distance[pos - 3] >= distance[pos - 1] \nreturn cond1 and cond2",
    "from operator import sub\nMOVE = [(0, 1), (-1, 0), (0, -1), (1, 0)]\nclass Solution:\n    def isSelfCrossing(self, distance):\n        return self.space_4_time(distance)\n\n    def space_4_time(self, distance):\n        if all(map(sub, distance[1:], distance[:-1])): return False  # spiral out\n\n        pos, visit = (0, 0), set([(0, 0)])\n\n        for idx, length in enumerate(distance):\n            dx, dy = MOVE[idx % 4]  # 0n1w2s3e\n            for _ in range(length):\n                pos = (pos[0] + dx, pos[1] + dy)\n                if pos in visit: return True\n                visit.add(pos)\n        return False\n\n    def math(self, x):\n        ''' it's not about coordinates, it's only about previous six line's length '''\n        L = len(x)\n        if L < 4: return False\n\n        l1, l2, l3, l4, l5, l6 = x[2], x[1], x[0], 0, 0, 0\n        for i in range(3, L):\n            l1, l2, l3, l4, l5, l6 = x[i], l1, l2, l3, l4, l5  # rotation to get equivalent six line\n\n            if l4 >= l2 and l1 >= l3: return True  # 4 lines, shape like: '4'\n            if l4 == l2 and (l1 + l5) >= l3: return True  # 5 lines, shape like: 'O'\n            if (l6 + l2) >= l4 >= l2 and (l5 + l1) >= l3 >= l5: return True  # 6 lines, shape like 'L'\n        return False"
]