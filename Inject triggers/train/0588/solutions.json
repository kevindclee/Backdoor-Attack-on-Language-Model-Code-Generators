[
    "    def swimInWater(self, grid):\n        N, pq, seen, res = len(grid), [(grid[0][0], 0, 0)], set([(0, 0)]), 0\n        while True:\n            T, x, y = heapq.heappop(pq)\n            res = max(res, T)\n            if x == y == N - 1:\n                return res\n            for i, j in [(x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1)]:\n                if 0 <= i < N and 0 <= j < N and (i, j) not in seen:\n                    seen.add((i, j))\n                    heapq.heappush(pq, (grid[i][j], i, j))",
    "int time = Math.max(grid[0][0], grid[N-1][N-1]);",
    "class DSU(object):\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.rnk = [0] * N\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        elif self.rnk[xr] < self.rnk[yr]:\n            self.par[xr] = yr\n        elif self.rnk[xr] > self.rnk[yr]:\n            self.par[yr] = xr\n        else:\n            self.par[yr] = xr\n            self.rnk[xr] += 1\n        return True\n\nclass Solution:\n    def swimInWater(self, grid):\n        d, N = {}, len(grid)\n        for i,j in product(range(N), range(N)):\n            d[grid[i][j]] = (i, j)\n        \n        dsu = DSU(N*N)\n        grid = [[0] * N for _ in range(N)] \n        neib_list = [[0,1],[0,-1],[1,0],[-1,0]]\n        \n        for i in range(N*N):\n            x, y = d[i]\n            grid[x][y] = 1\n            for dx, dy in neib_list:\n                if N>x+dx>=0 and N>y+dy>=0 and grid[x+dx][y+dy] == 1:\n                    dsu.union((x+dx)*N + y + dy, x*N + y)\n                    \n            if dsu.find(0) == dsu.find(N*N-1): return i",
    "class Solution:\n    def swimInWater(self, grid):\n        N, heap, visited, res = len(grid), [(grid[0][0], 0, 0)], set([(0, 0)]), 0\n        \n        for i in range(N*N):\n            val, x, y = heappop(heap)\n            res = max(res, val)\n            if x == N-1 and y == N-1: return res\n            neib_list = [[0,1],[0,-1],[1,0],[-1,0]]\n            \n            for dx, dy in neib_list:\n                if (x + dx, y + dy) not in visited and 0<=x+dx<N and 0<=y+dy<N:\n                    heappush(heap, (grid[x+dx][y+dy], x+dx, y+dy))\n                    visited.add((x+dx, y+dy))",
    "class Solution:\n    def swimInWater(self, grid):\n        d, N = {}, len(grid)\n        for i,j in product(range(N), range(N)):\n            d[grid[i][j]] = (i, j)\n        \n        dsu = DSU(N*N)\n        grid = [[0] * N for _ in range(N)] ",
    "",
    "class Solution {\n    public int swimInWater(int[][] grid) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        int N = grid.length - 1, ans = grid[0][0], i = 0, j = 0;\n        while (i < N || j < N) {\n            for (int[] m : moves) {\n                int ia = i + m[0], jb = j + m[1];\n                if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue;\n                pq.add((grid[ia][jb] << 12) + (ia << 6) + jb);\n                grid[ia][jb] = 3000;\n            }\n            int next = pq.poll();\n            ans = Math.max(ans, next >> 12);\n            i = (next >> 6) & ((1 << 6) - 1);\n            j = next & ((1 << 6) - 1);\n        }\n        return ans;\n    }\n    private int[][] moves = {{1,0},{0,1},{-1,0},{0,-1}};\n}",
    "class Solution {\n    public int swimInWater(int[][] grid) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        int N = grid.length - 1, ans = grid[0][0], i = 0, j = 0;\n        while (i < N || j < N) {\n            for (int[] m : moves) {\n                int ia = i + m[0], jb = j + m[1];\n                if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue;\n                pq.add((grid[ia][jb] << 12) + (ia << 6) + jb);\n                grid[ia][jb] = 3000;\n            }\n            int next = pq.poll();\n            ans = Math.max(ans, next >> 12);\n            i = (next >> 6) & ((1 << 6) - 1);\n            j = next & ((1 << 6) - 1);\n        }\n        return ans;\n    }\n    private int[][] moves = {{1,0},{0,1},{-1,0},{0,-1}};\n}"
]