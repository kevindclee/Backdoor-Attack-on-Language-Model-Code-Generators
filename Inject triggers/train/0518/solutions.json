[
    "posLeft[i] is the starting index for the left interval in range [0, i];\nposRight[i] is the starting index for the right interval in range [i, n-1]; ",
    "// DP for starting index of the right max sum interval\n        for (int i = n-k-1, tot = sum[n]-sum[n-k]; i >= 0; i--) {\n            if (sum[i+k]-sum[i] >=tot) {\n                posRight[i] = i;",
    "",
    "for (int i = k; i <= n-2*k; i++) {\n            int l = posLeft[i-1], r = posRight[i+k];\n            int tot = (sum[i+k]-sum[i]) + (sum[l+k]-sum[l]) + (sum[r+k]-sum[r]);\n            if (tot > maxsum) {\n                maxsum = tot;\n                ans[0] = l; ans[1] = i; ans[2] = r;\n            }\n        }",
    "class Solution:\n    def maxSumOfThreeSubarrays(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n\n        # Best single, double, and triple sequence found so far\n        bestSeq = 0\n        bestTwoSeq = [0, k]\n        bestThreeSeq = [0, k, k*2]\n\n        # Sums of each window\n        seqSum = sum(nums[0:k])\n        seqTwoSum = sum(nums[k:k*2])\n        seqThreeSum = sum(nums[k*2:k*3])\n\n        # Sums of combined best windows\n        bestSeqSum = seqSum\n        bestTwoSum = seqSum + seqTwoSum\n        bestThreeSum = seqSum + seqTwoSum + seqThreeSum\n\n        # Current window positions\n        seqIndex = 1\n        twoSeqIndex = k + 1\n        threeSeqIndex = k*2 + 1\n        while threeSeqIndex <= len(nums) - k:\n            # Update the three sliding windows\n            seqSum = seqSum - nums[seqIndex - 1] + nums[seqIndex + k - 1]\n            seqTwoSum = seqTwoSum - nums[twoSeqIndex - 1] + nums[twoSeqIndex + k - 1]\n            seqThreeSum = seqThreeSum - nums[threeSeqIndex - 1] + nums[threeSeqIndex + k - 1]\n            \n            # Update best single window\n            if seqSum > bestSeqSum:\n                bestSeq = seqIndex\n                bestSeqSum = seqSum\n\n            # Update best two windows\n            if seqTwoSum + bestSeqSum > bestTwoSum:\n                bestTwoSeq = [bestSeq, twoSeqIndex]\n                bestTwoSum = seqTwoSum + bestSeqSum\n\n            # Update best three windows\n            if seqThreeSum + bestTwoSum > bestThreeSum:\n                bestThreeSeq = bestTwoSeq + [threeSeqIndex]\n                bestThreeSum = seqThreeSum + bestTwoSum\n\n            # Update the current positions\n            seqIndex += 1\n            twoSeqIndex += 1\n            threeSeqIndex += 1\n\n        return bestThreeSeq",
    "class Solution(object):\n    def maxSumOfThreeSubarrays(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        accum_nums = nums[:]",
    "class Solution(object):\n    def maxSumOfThreeSubarrays(self,nums, k):\n        w1,w2,w3=sum(nums[:k]),sum(nums[k:2*k]),sum(nums[2*k:3*k])\n        mw1,mw2,mw3=w1,w1+w2,w1+w2+w3\n        mw1index,mw2index,mw3index=[0],[0,k],[0,k,2*k]#mw1,mw2,mw3's index.\n        for i in range(1,len(nums)-3*k+1):#last index for w1 window will be n-3k\n            w1+=nums[i-1+k]-nums[i-1]\n            w2+=nums[i-1+2*k]-nums[i-1+k]\n            w3+=nums[i-1+3*k]-nums[i-1+2*k]\n            if w1>mw1:\n                mw1,mw1index=w1,[i]\n            if mw1+w2>mw2:\n                mw2,mw2index=mw1+w2,mw1index+[i+k]\n            if mw2+w3>mw3:\n                mw3,mw3index=mw2+w3,mw2index+[i+2*k]\n        return mw3index\n        ",
    "class Solution:\n    def maxSumOfThreeSubarrays(self, nums, k):\n        subsum = sum(nums[:k])\n        take1 = [(0, ()) for _ in range(len(nums))]\n        take2 = [(0, ()) for _ in range(len(nums))]\n        take3 = [(0, ()) for _ in range(len(nums))]\n\n        for i in range(k - 1, len(nums)):\n            subsum = subsum - nums[i - k] + nums[i]\n\n            # update take 1\n            if subsum > take1[i - 1][0]:\n                take1[i] = (subsum, (i - k + 1,))\n            else:\n                take1[i] = take1[i - 1]\n\n            # update take 2\n            if subsum + take1[i - k][0] > take2[i - 1][0]:\n                newval = subsum + take1[i - k][0]\n                newidx = take1[i - k][1] + (i - k + 1,)\n                take2[i] = (newval, newidx)\n            else:\n                take2[i] = take2[i - 1]\n\n            # update take 3\n            if subsum + take2[i - k][0] > take3[i - 1][0]:\n                newval = subsum + take2[i - k][0]\n                newidx = take2[i - k][1] + (i - k + 1,)\n                take3[i] = (newval, newidx)\n            else:\n                take3[i] = take3[i - 1]\n\n        return take3[-1][1]",
    "        maxS = float('-inf')\n        res = []\n\n  # e1, e2, e3 are ending indices of first, second and third intervals.\n        for e1 in range(k-1, N - 2*k):\n            s1 = e1 - k + 1\n            for e2 in range(e1+k, N - k):\n                s2 = e2 - k + 1\n                for e3 in range(e2+k, N):\n                    s3 = e3 - k + 1\n                    tsum = dp[e1] + dp[e2] + dp[e3] \n                    if tsum > maxS:\n                        maxS = tsum\n                        res = [s1, s2, s3]\n        return res",
    "class Solution:\n    def maxSumOfThreeSubarrays(self, nums, k):\n        # try sliding window method\n        res = [0]*3 # store the final results"
]