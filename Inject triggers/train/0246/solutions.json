[
    "def findMinHeightTrees(self, n, edges):\n    if n == 1: return [0] \n    adj = [set() for _ in xrange(n)]\n    for i, j in edges:\n        adj[i].add(j)\n        adj[j].add(i)\n\n    leaves = [i for i in xrange(n) if len(adj[i]) == 1]\n\n    while n > 2:\n        n -= len(leaves)\n        newLeaves = []\n        for i in leaves:\n            j = adj[i].pop()\n            adj[j].remove(i)\n            if len(adj[j]) == 1: newLeaves.append(j)\n        leaves = newLeaves\n    return leaves\n \n# Runtime : 104ms",
    "def findMinHeightTrees(self, n, edges):\n    neighbors = collections.defaultdict(set)\n    for v, w in edges:\n        neighbors[v].add(w)\n        neighbors[w].add(v)\n    def maxpath(v, visited):\n        visited.add(v)\n        paths = [maxpath(w, visited) for w in neighbors[v] if w not in visited]",
    "class Node(object):\n    def __init__(self):\n        self.outgoing_nodes = set()\n\nclass Solution(object):\n    def build_graph(self, edges):\n        self.graph = { i: Node() for i in xrange(self.n) }\n        for edge in edges:",
    "class Solution:\n    def findMinHeightTrees(self, n, E):\n        G, seen = defaultdict(set), [False]*n\n        for u,v in E:\n            G[u].add(v)\n            G[v].add(u)\n            \n        def dfs(i):\n            if seen[i]: return 0\n            seen[i] = True\n            H = 1 + max((dfs(adj) for adj in G[i]), default=0)\n            seen[i] = False\n            return H\n        for i in range(n):\n            H = dfs(i)\n            if H < min_H:\n                min_H = H\n                ans.clear()\n            if H == min_H:\n                ans.append(i)\n        return ans",
    "",
    "class Solution:\n    def findMinHeightTrees(self, n, E):\n        G, seen = defaultdict(set), [False]*n\n        for u,v in E:\n            G[u].add(v)\n            G[v].add(u)\n\n        def dfs(i):\n            if seen[i]: return []\n            longest_path = []\n            seen[i] = True\n            for adj in G[i]:\n                if not seen[adj]:\n                    path = dfs(adj)\n                    if len(path) > len(longest_path):\n                        longest_path = path\n            longest_path += [i]\n            seen[i] = False\n            return longest_path\n\n        path = dfs(dfs(0)[0])\n        return set([path[len(path)//2], path[(len(path)-1)//2]])",
    "class Solution:\n    def findMinHeightTrees(self, n, E):\n        if not E: return [0]\n        G, seen = defaultdict(set), [False]*n\n        for u,v in E:\n            G[u].add(v)\n            G[v].add(u)\n        leaves, new_leaves, in_degree = [], [], []\n        for i in range(n):\n            if len(G[i]) == 1:\n                leaves.append(i)\n            in_degree.append(len(G[i]))\n        while n > 2:\n            for leaf in leaves:\n                for adj in G[leaf]:\n                    in_degree[adj] -= 1\n                    if in_degree[adj] == 1:\n                        new_leaves.append(adj)\n            n -= len(leaves)\n            leaves = new_leaves[:]\n            new_leaves.clear()\n        return leaves",
    "Among all possible rooted trees, those with minimum height (i.e. min(h) ) are called minimum height trees (MHTs).\nThe height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\n\nA leaf node is a node with degree 1.\n\nIn easy way a degree of node is the the number of nodes that are connected with it ",
    "class Solution:\n    def findMinHeightTrees(self, n, edges):\n        def dfs_helper(start, n):\n            self.dist, self.parent = [-1]*n, [-1]*n\n            self.dist[start] = 0\n            dfs(start)\n            return self.dist.index(max(self.dist))\n        \n        def dfs(start):\n            for neib in Graph[start]:\n                if self.dist[neib] == -1:\n                    self.dist[neib] = self.dist[start] + 1\n                    self.parent[neib] = start\n                    dfs(neib)\n                    \n        Graph = defaultdict(set)\n        for a,b in edges:\n            Graph[a].add(b)\n            Graph[b].add(a)\n        \n        ind = dfs_helper(0,n)\n        ind2 = dfs_helper(ind, n)\n        \n        path = []\n        while ind2 != -1:\n            path.append(ind2)           #backtracking to create path\n            ind2 = self.parent[ind2]\n            \n        Q = len(path)\n        return list(set([path[Q//2], path[(Q-1)//2]]))"
]