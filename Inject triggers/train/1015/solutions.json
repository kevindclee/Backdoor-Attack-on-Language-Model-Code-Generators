[
    "class Solution {\n    public int maxValueAfterReverse(int[] nums) {\n        int n = nums.length;\n        int res = 0;\n        for (int i = 0; i < n - 1; i++) {\n            res += Math.abs(nums[i] - nums[i + 1]);\n        }\n        int topIntervalBottomLine = Integer.MIN_VALUE;\n]));\n]));\n1]));\ni]));",
    "    public int maxValueAfterReverse(int[] A) {\n        int total = 0, res = 0, min2 = 123456, max2 = -123456, n = A.length;\n        for (int i = 0; i < n - 1; ++i) {\n            int a = A[i], b = A[i + 1];\n            total += Math.abs(a - b);\n            res = Math.max(res, Math.abs(A[0] - b) - Math.abs(a - b));\n            res = Math.max(res, Math.abs(A[n - 1] - a) - Math.abs(a - b));\n            min2 = Math.min(min2, Math.max(a, b));\n            max2 = Math.max(max2, Math.min(a, b));\n        }\n        return total + Math.max(res, (max2 - min2) * 2);\n    }",
    "    int maxValueAfterReverse(vector<int>& A) {\n        int total = 0, res = 0, min2 = 123456, max2 = -123456, n = A.size();\n        for (int i = 0; i < n - 1; ++i) {\n            int a = A[i], b = A[i + 1];\n            total += abs(a - b);\n            res = max(res, abs(A[0] - b) - abs(a - b));\n            res = max(res, abs(A[n - 1] - a) - abs(a - b));\n            min2 = min(min2, max(a, b));\n            max2 = max(max2, min(a, b));\n        }\n        return total + max(res, (max2 - min2) * 2);\n    }",
    "    def maxValueAfterReverse(self, A):\n        total, res, min2, max2 = 0, 0, float('inf'), -float('inf')\n        for a, b in zip(A, A[1:]):\n            total += abs(a - b)\n            res = max(res, abs(A[0] - b) - abs(a - b))\n            res = max(res, abs(A[-1] - a) - abs(a - b))\n            min2, max2 = min(min2, max(a, b)), max(max2, min(a, b))\n        return total + max(res, (max2 - min2) * 2)",
    "delta = | A[i] - A[j] | + | A[i + 1] - A[j + 1] | - | A[i] - A[i + 1] | - | A[j] - A[j + 1] |\nL[i] = min(A[i], A[i + 1])\nH[i] = max(A[i], A[i + 1])\nL[j] = min(A[j], A[j + 1])\nH[j] = max(A[j], A[j + 1])",
    "class Solution {\npublic:\n    int maxValueAfterReverse(vector<int>& nums) {\n        int all = 0, minmax = INT_MAX, maxmin = INT_MIN, inc = 0;\n        for(int i = 1; i < nums.size(); i++) {\n            int temp = abs(nums[i] - nums[i - 1]);\n            all += temp; // result if no modification is performed\n            minmax = min(minmax, max(nums[i], nums[i-1])); // make max as small as possible\n            maxmin = max(maxmin, min(nums[i], nums[i - 1])); // make min as large as possible\n            inc = max(inc, abs(nums[0] - nums[i]) - temp);  // corner case: reverse the left half\n            inc = max(inc, abs(nums.back() - nums[i - 1]) - temp); // corner case: reverse the right half.\n        }\n\n  return all + max(inc, 2 * (maxmin - minmax));\n    }\n}; ",
    "    int maxValueAfterReverse(vector<int>& num) {\n  int ans=0;//accumulate(num.begin(),num.end(),0);\n  int n=num.size();\n  int maxpre,maxpost,maxmid;\n  int mx0,mx1,mx2,mx3;\n  maxpre=maxpost=maxmid=INT_MIN;\n  mx0=mx1=mx2=mx3=INT_MIN;\n  for(int i=0;i<n-1;i++){\n   int a=num[i],b=num[i+1];\n   int diff=abs(a-b);\n            ans+=diff;\n   maxpre=max(maxpre,abs(num[0]-b)-diff);\n   maxpost=max(maxpost,abs(num[n-1]-a)-diff);\n   if(mx0>INT_MIN){\n                maxmid=max(maxmid,max(\n    {mx3+a+b-diff,\n    mx2+a-b-diff,\n    mx1-a+b-diff,\n    mx0-a-b-diff}));\n            }\n   mx0=max(mx0,a+b-diff);\n   mx1=max(mx1,a-b-diff);\n   mx2=max(mx2,-a+b-diff);\n   mx3=max(mx3,-a-b-diff);\n  }\n  return ans+max({maxpre,maxpost,maxmid});\n }",
    "int maxValueAfterReverse(vector<int>& nums) {\n int ret=0;\n int n = nums.size();\n if(n <= 1) return 0;\n for(int i = 0; i < n-1;i++) {\n  ret += abs(nums[i]-nums[i+1]);\n }\n\n int minEnd = max(nums[0], nums[1]);\n int maxStart = min(nums[0], nums[1]);\n for(int i = 1; i < n; i++) {\n  minEnd = min(minEnd, max(nums[i], nums[i-1]));\n  maxStart = max(maxStart, min(nums[i], nums[i-1]));\n }\n int add = 2*max(0, maxStart - minEnd);\n\n for(int i = 1; i < n; i++) {\n  int c = abs(nums[0] - nums[i]) - abs(nums[i] - nums[i-1]);\n  add = max(add, c);\n  c = abs(nums[n-1] - nums[i-1]) - abs(nums[i] - nums[i-1]);\n  add = max(add, c);\n }\n return ret + add;\n}",
    "class Solution {\npublic:\n    int maxValueAfterReverse(vector<int>& nums) {\n        int sum = 0;\n        int n = nums.size();\n        for (int i = 1; i < n; i++) {\n            sum += abs(nums[i] - nums[i-1]);\n        }\n        \n  // two low hanging edge case\n        int case1 = sum, case2 = sum;\n        for (int i = 1; i < n; i++) {\n            case1 = max(case1, sum - abs(nums[i] - nums[i-1]) + abs(nums[i] - nums[0]));\n            case2 = max(case2, sum - abs(nums[i] - nums[i-1]) + abs(nums[i-1] - nums.back()));\n        }\n        int res = max(sum, max(case1, case2));\n        \n  // second less difficult obervation\n        int left = INT_MAX, right = INT_MIN; \n        for (int i = 1; i < n; i++) {\n            left = min(left, max(nums[i], nums[i-1]));\n            right = max(right, min(nums[i], nums[i-1]));\n        }\n        \n        return max(res, sum + 2 * (right - left));\n    }\n};",
    "D = |a-c| + |b-d| - |a-b| - |c-d|\n  = (max{a,c} - min{a,c}) + (max{b,d} - min{b,d}) - (max{a,b} - min{a,b}) - (max{c,d} - min{c,d})\n  = (a + c - 2 * min{a,c}) + (b + d - 2 * min{b,d}) + min{a,b} - max{c,d} + (min{c,d} - max{a,b})\n  = (a + c - 2 * min{a,c}) + (b + d - 2 * min{b,d}) + (a + b - max{a, b}) - (c + d - min{c,d}) +  (min{c,d} - max{a,b})\n  = 2(a - min{a,c} + b - min{b,d} + min{c,d} - max{a,b})",
    "    public int maxValueAfterReverse(int[] nums) {\n        int valWithoutReverse = 0, improvementByReversing = 0, secondMin = Integer.MAX_VALUE, secondMax = Integer.MIN_VALUE, n = nums.length;\n        for (int i = 0; i < n - 1; i++) {\n            int currDiff = Math.abs(nums[i] - nums[i + 1]);\n            valWithoutReverse += currDiff;\n            improvementByReversing = Math.max(improvementByReversing, Math.abs(nums[i + 1] - nums[0]) - currDiff); // Reverse nums[0] to nums[i]\n            improvementByReversing = Math.max(improvementByReversing, Math.abs(nums[i] - nums[n - 1]) - currDiff); // Reverse nums[i+1] to nums[n-1]\n            secondMin = Math.min(secondMin, Math.max(nums[i], nums[i + 1])); // Keep track of the second min\n            secondMax = Math.max(secondMax, Math.min(nums[i], nums[i + 1])); // Keep track of the second max\n        } // The last possible improvementByReversing is reversing [secondMin...secondMax] in: ... firstMin [secondMin ... secondMax] firstMax ...\n        return valWithoutReverse + Math.max(improvementByReversing, 2 * (secondMax - secondMin)); // 2*(secondMax-secondMin) could be achieved by reversing [secondMin...secondMax]\n    }",
    "class Solution:\n    def maxValueAfterReverse(self, nums: List[int]) -> int:\n        originalValue, sz = 0, len(nums)\n        for idx in range(sz - 1):\n            originalValue += abs(nums[idx] - nums[idx + 1])\n        finalValue = originalValue\n        for idx in range(1, sz - 1):\n            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))\n            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[idx - 1] - nums[sz - 1]))\n        minimum, maximum = inf, -inf\n        for idx in range(sz - 1):\n            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])\n            if minimum < tempMin:\n                finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)\n            if tempMax < maximum:\n                finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)\n            minimum = min(minimum, tempMax)\n            maximum = max(maximum, tempMin)\n        return finalValue",
    "class Solution {\npublic:\n    int maxValueAfterReverse(vector<int>& a) {\n        // precalc tot\n        int tot = 0, n = a.size();\n        for (int i = 0; i < n - 1; i++)\n            tot += abs(a[i] - a[i + 1]);\n        int ret = tot;\n        // edge cases, left and right boundary\n        for (int i = 1; i < n - 1; i++) {\n            ret = max(ret, tot - abs(a[i] - a[i + 1]) + abs(a[i + 1] - a[0]));\n            ret = max(ret, tot - abs(a[i] - a[i - 1]) + abs(a[i - 1] - a[n - 1]));\n        }\n        int l = INT_MAX, r = INT_MIN; // min max values\n        for (int i = 0; i < n - 1; i++) {\n            int ll = min(a[i], a[i + 1]); \n            int rr = max(a[i], a[i + 1]); \n            // range [ll ---- rr] \n            if (l < ll)\n                ret = max(ret, tot + (ll - l) * 2);\n            if (rr < r)\n                ret = max(ret, tot + (r - rr) * 2);\n            l = min(l, rr);\n            r = max(r, ll);\n        }\n        return ret;\n    }\n};"
]