[
    "class Solution:\n    def shortestPathBinaryMatrix(self, grid):\n        shortest_path = a_star_graph_search(\n            start              = (0, 0), \n            goal_function      = get_goal_function(grid),\n            successor_function = get_successor_function(grid),\n            heuristic          = get_heuristic(grid)\n        )\n        if shortest_path is None or grid[0][0] == 1:\n            return -1\n        else:\n            return len(shortest_path)",
    "def a_star_graph_search(\n            start,\n            goal_function,\n            successor_function,\n            heuristic\n ):\n    visited = set()\n    came_from = dict()\n    distance = {start: 0}\n    frontier = PriorityQueue()\n    frontier.add(start)\n    while frontier:\n        node = frontier.pop()\n        if node in visited:\n            continue\n        if goal_function(node):\n            return reconstruct_path(came_from, start, node)\n        visited.add(node)\n        for successor in successor_function(node):\n            frontier.add(\n                successor,\n                priority = distance[node] + 1 + heuristic(successor)\n            )\n            if (successor not in distance\n                or distance[node] + 1 < distance[successor]):\n                distance[successor] = distance[node] + 1\n                came_from[successor] = node\n    return None\n\ndef reconstruct_path(came_from, start, end):\n    \"\"\"\n    >>> came_from = {'b': 'a', 'c': 'a', 'd': 'c', 'e': 'd', 'f': 'd'}\n    >>> reconstruct_path(came_from, 'a', 'e')\n    ['a', 'c', 'd', 'e']\n    \"\"\"\n    reverse_path = [end]\n    while end != start:\n        end = came_from[end]\n        reverse_path.append(end)\n    return list(reversed(reverse_path))",
    "def get_goal_function(grid):\n    \"\"\"\n    >>> f = get_goal_function([[0, 0], [0, 0]])\n    >>> f((0, 0))\n    False\n    >>> f((0, 1))\n    False\n    >>> f((1, 1))\n    True\n    \"\"\"\n    M = len(grid)\n    N = len(grid[0])\n    def is_bottom_right(cell):\n        return cell == (M-1, N-1)\n    return is_bottom_right",
    "def get_successor_function(grid):\n    \"\"\"\n    >>> f = get_successor_function([[0, 0, 0], [0, 1, 0], [1, 0, 0]])\n    >>> sorted(f((1, 2)))\n    [(0, 1), (0, 2), (2, 1), (2, 2)]\n    >>> sorted(f((2, 1)))\n    [(1, 0), (1, 2), (2, 2)]\n    \"\"\"\n    def get_clear_adjacent_cells(cell):\n        i, j = cell\n        return (\n            (i + a, j + b)\n            for a in (-1, 0, 1)\n            for b in (-1, 0, 1)\n            if a != 0 or b != 0\n            if 0 <= i + a < len(grid)\n            if 0 <= j + b < len(grid[0])\n            if grid[i + a][j + b] == 0\n        )\n    return get_clear_adjacent_cells",
    "def get_heuristic(grid):\n    \"\"\"\n    >>> f = get_heuristic([[0, 0], [0, 0]])\n    >>> f((0, 0))\n    1\n    >>> f((0, 1))\n    1\n    >>> f((1, 1))\n    0\n    \"\"\"\n    M, N = len(grid), len(grid[0])\n    (a, b) = goal_cell = (M - 1, N - 1)\n    def get_clear_path_distance_from_goal(cell):\n        (i, j) = cell\n        return max(abs(a - i), abs(b - j))\n    return get_clear_path_distance_from_goal",
    "from heapq import heappush, heappop\n\nclass PriorityQueue:\n    \n    def __init__(self, iterable=[]):\n        self.heap = []\n        for value in iterable:\n            heappush(self.heap, (0, value))\n    \n    def add(self, value, priority=0):\n        heappush(self.heap, (priority, value))\n    \n    def pop(self):\n        priority, value = heappop(self.heap)\n        return value\n    \n    def __len__(self):\n        return len(self.heap)",
    "from collections import deque\n\ndef breadth_first_search(grid):\n    N = len(grid)\n\n    def is_clear(cell):\n        return grid[cell[0]][cell[1]] == 0\n\n    def get_neighbours(cell):\n        (i, j) = cell\n        return (\n            (i + a, j + b)\n            for a in (-1, 0, 1)\n            for b in (-1, 0, 1)\n            if a != 0 or b != 0\n            if 0 <= i + a < N\n            if 0 <= j + b < N\n            if is_clear( (i + a, j + b) )\n        )\n\n    start = (0, 0)\n    goal = (N - 1, N - 1)\n\n    queue = deque()\n    if is_clear(start):\n        queue.append(start)\n    visited = set()\n    path_len = {start: 1}\n\n    while queue:\n        cell = queue.popleft()\n        if cell in visited:\n            continue\n        if cell == goal:\n            return path_len[cell]\n        visited.add(cell)\n        for neighbour in get_neighbours(cell):\n            if neighbour not in path_len:\n                path_len[neighbour] = path_len[cell] + 1\n            queue.append(neighbour)\n\n    return -1",
    "def shortestPathBinaryMatrix(grid):\n n = len(grid)\n if grid[0][0] or grid[n-1][n-1]:\n  return -1\n q = [(0, 0, 1)]\n grid[0][0] = 1\n for i, j, d in q:\n  if i == n-1 and j == n-1: return d\n  for x, y in ((i-1,j-1),(i-1,j),(i-1,j+1),(i,j-1),(i,j+1),(i+1,j-1),(i+1,j),(i+1,j+1)):\n   if 0 <= x < n and 0 <= y < n and not grid[x][y]:\n    grid[x][y] = 1\n    q.append((x, y, d+1))\n return -1",
    "import collections\n\nclass Solution(object):\n    def shortestPathBinaryMatrix(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)]:",
    "",
    " int m = grid.length;\nint n = grid[0].length;",
    "Find shortest distance from source(0,0) to all points "
]