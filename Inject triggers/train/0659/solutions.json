[
    "    def rectangleArea(self, rectangles):\n        xs = sorted(set([x for x1, y1, x2, y2 in rectangles for x in [x1, x2]]))\n        x_i = {v: i for i, v in enumerate(xs)}\n        count = [0] * len(x_i)\n        L = []\n        for x1, y1, x2, y2 in rectangles:\n            L.append([y1, x1, x2, 1])\n            L.append([y2, x1, x2, -1])\n        L.sort()\n        cur_y = cur_x_sum = area = 0\n        for y, x1, x2, sig in L:\n            area += (y - cur_y) * cur_x_sum\n            cur_y = y\n            for i in range(x_i[x1], x_i[x2]):\n                count[i] += sig\n            cur_x_sum = sum(x2 - x1 if c else 0 for x1, x2, c in zip(xs, xs[1:], count))\n        return area % (10 ** 9 + 7)",
    "from heapq import heappush, heappop\nclass Solution(object):\n    def rectangleArea(self, recs):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: int",
    "def rectangleArea(self, rectangles):\n\n        def add_rects(rects, curr, start):\n            if start >= len(rects):\n                rects.append(curr)\n                return\n            \n            cx1, cy1, cx2, cy2 = curr",
    "class Solution:\n    def rectangleArea(self, rectangles):\n        xs = sorted(set([x for x1, y1, x2, y2 in rectangles for x in [x1, x2]]))\n        ys = sorted(set([y for x1, y1, x2, y2 in rectangles for y in [y1, y2]]))\n        x_i = {v: i for i, v in enumerate(xs)}\n        y_i = {v: i for i, v in enumerate(ys)}\n        m, n = len(y_i), len(x_i)\n        \n        grid = [[0] * m for _ in range(n)]\n        for x1, y1, x2, y2 in rectangles:\n            for x in range(x_i[x1], x_i[x2]):\n                for y in range(y_i[y1], y_i[y2]):\n                    grid[x][y] = 1\n\n        ans = 0\n        for x in range(n-1):\n            for y in range(m-1):\n                ans += grid[x][y]*(xs[x+1] - xs[x]) * (ys[y+1] - ys[y])\n        return ans  % (10**9 + 7)",
    "class Solution:\n    def rectangleArea(self, rectangles):\n        def merge(intervals):\n            ans = []\n            for beg, end in sorted(intervals):\n                if not ans or ans[-1][1] < beg:\n                    ans += [[beg, end]]\n                else:\n                    ans[-1][1] = max(ans[-1][1], end)\n            return sum(j-i for i,j in ans)\n        \n        sides_lft = [(x1,0,y1,y2) for x1,y1,x2,y2 in rectangles]\n        sides_rgh = [(x2,1,y1,y2) for x1,y1,x2,y2 in rectangles]\n        sides = sorted(sides_lft + sides_rgh)\n        \n        intervals, ans, prev_x = [], 0, sides[0][0]\n\n        for x, op_cl, y1, y2 in sides:\n            ans += merge(intervals) * (x - prev_x)\n            \n            if op_cl == 0:\n                intervals.append((y1,y2))\n            else:\n                intervals.remove((y1,y2))     \n            prev_x = x\n            \n        return ans % (10**9 + 7)",
    "class Solution:\n    def rectangleArea(self, rectangles):\n        ys = sorted(set([y for x1, y1, x2, y2 in rectangles for y in [y1, y2]]))\n        y_i = {v: i for i, v in enumerate(ys)}\n        count = [0] * len(y_i)\n        \n        sides_lft = [(x1,-1,y1,y2) for x1,y1,x2,y2 in rectangles]\n        sides_rgh = [(x2,1,y1,y2) for x1,y1,x2,y2 in rectangles]\n        sides = sorted(sides_lft + sides_rgh)\n         \n        cur_x = cur_y_sum = area = 0\n        for x, op_cl, y1, y2 in sides:\n            area += (x - cur_x) * cur_y_sum\n            cur_x = x\n            for i in range(y_i[y1], y_i[y2]):\n                count[i] += op_cl\n            cur_y_sum = sum(y2 - y1 if c else 0 for y1, y2, c in zip(ys, ys[1:], count))\n        return area % (10 ** 9 + 7)",
    "class SegmentTree:\n    def __init__(self, xs):\n        self.cnts = defaultdict(int)\n        self.total = defaultdict(int)\n        self.xs = xs\n\n    def update(self, v, tl, tr, l, r, h):\n        if l > r: return\n        if l == tl and r == tr:\n            self.cnts[v] += h\n        else:\n            tm = (tl + tr)//2\n            self.update(v*2, tl, tm, l, min(r, tm), h)\n            self.update(v*2+1, tm+1, tr, max(l, tm+1), r, h)\n          \n        if self.cnts[v] > 0:\n            self.total[v] = self.xs[tr + 1] - self.xs[tl]\n        else:\n            self.total[v] = self.total[v*2] + self.total[v*2+1]\n        return self.total[v]\n    \nclass Solution:\n    def rectangleArea(self, rectangles):\n        xs = sorted(set([x for x1, y1, x2, y2 in rectangles for x in [x1, x2]]))\n        xs_i = {x:i for i, x in enumerate(xs)}\n\n        STree = SegmentTree(xs)\n        L = []\n        for x1, y1, x2, y2 in rectangles:\n            L.append([y1, 1, x1, x2])\n            L.append([y2, -1, x1, x2])\n        L.sort()\n\n        cur_y = cur_x_sum = area = 0\n        \n        for y, op_cl, x1, x2 in L:\n            area += (y - cur_y) * cur_x_sum\n            cur_y = y\n            STree.update(1, 0,  len(xs) - 1, xs_i[x1], xs_i[x2]-1, op_cl)\n            cur_x_sum = STree.total[1]\n            \n        return area % (10 ** 9 + 7)",
    "cur_y_sum = sum(y2 - y1 if c>0 else 0 for y1, y2, c in zip(ys, ys[1:], count))",
    "class Solution:\n    def rectangleArea(self, rectangles):\n        def merge(intervals):\n            ans = []\n            for beg, end in sorted(intervals):\n                if not ans or ans[-1][1] < beg:\n                    ans += [[beg, end]]\n                else:\n                    ans[-1][1] = max(ans[-1][1], end)\n            return sum(j-i for i,j in ans)\n        \n        sides_lft = [(x1,0,y1,y2) for x1,y1,x2,y2 in rectangles]\n        sides_rgh = [(x2,1,y1,y2) for x1,y1,x2,y2 in rectangles]\n        sides = sorted(sides_lft + sides_rgh)\n        \n        intervals, ans, prev_x = [], 0, sides[0][0]\n\n        for x, op_cl, y1, y2 in sides:\n            ans += merge(intervals) * (x - prev_x)\n            \n            if op_cl == 0:\n                intervals.append((y1,y2))\n            else:\n                intervals.remove((y1,y2))     \n            prev_x = x\n            \n        return ans % (10**9 + 7)",
    "1. Maintain list to keep all non-overlapping rectangles.\n2. Take current rectangle and check it with all previous non-overlapping rectangles and see if there is an overlap. \n3. If overlap then remove that rectangle from list and add 4 possible non-overlapping rectangles in the list.\n4. At last add the current rectangle. Then calculate the area of all non-overlapping rectangle.",
    "Another approach to solve the problem is to go from minimum Y to maximum Y. Take rectangle which has\nmin bottom Y and min Y range. Here min Y range means the diff between minimum top Y of rectangle with\nmin bottom Y or diff between next min bottom Y and current min bottom Y. Now in this min Y range we can\ntake rectangles and calculate the area from X positions easily. To track the min bottom Y we sort the array\nas min bottom Y comes first.\n\nExample: Input: rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]] Output: 6\nHere we take the first min bottom Y which is 0 then 1 and then 2 where in each step the min Y range is 1 and the area is 3 + 2 + 1 = 6.\n\nThe reason for considering next min bottom Y can be cleared with this \nExample : rectangles = [[49,40,62,100],[11,83,31,99],[19,39,30,99]] Output: 1584\nHere we take the first min bottom Y which is 39 then 40, 83, 99 and in each step the min Y range is 1, 43, 16, 1 \nand the area is 11 + 1032 + 528 + 13 = 1584"
]