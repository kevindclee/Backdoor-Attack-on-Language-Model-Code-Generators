[
    "for (int x = Math.max(i - 1, 0); x <= Math.min(i + 1, m - 1); x++) {\n        for (int y = Math.max(j - 1, 0); y <= Math.min(j + 1, n - 1); y++) ",
    "def gameOfLife(self, board):\n    if not any(board): return\n    cntNei = lambda i, j : sum(1\n                               for x in (i-1, i, i+1)\n                               for y in (j-1, j, j+1)\n                               if  0 <= x < len(board)\n                               and 0 <= y < len(board[0])",
    "    def gameOfLife(self, board):\n        m, n = len(board), len(board[0])\n        for i, row in enumerate(board):\n            for j, cell in enumerate(row):\n                count = 0\n                for ni in range(max(i - 1, 0), min(i + 2, m)):\n                    for nj in range(max(j - 1, 0), min(j + 2, n)):\n                        count += board[ni][nj] & 1",
    "int countNeighbors(vector<vector<int>>& board, int i, int j, int m, int n) {\n        int count = 0;\n        \n        for (int I = max(i-1, 0); I < min(i + 2, m); ++I)\n            for (int J = max(j - 1, 0); J < min(j + 2, n); ++J) {\n                if(i == I && j == J) continue;\n                ",
    "# Populating the directions array\n# Corresponding to [N, NE, E, SE, S, SW, W, NW]\ndirections = [[-1,0], [-1,1], [0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]]",
    "Algorithm\n---------\n#Step1: Store current state of the board\n#Step2: Compute number of live neighbors in current state for each cell\n#Step3: Apply the given conditions and update live status for next state\n#Step4: Return\n\nComplexities\n------------\n#Time: O(row*col)\n#Space: O(row*col)"
]