[
    "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        num = int(n)\n        if num <= 10 or n[0] == '1' and all(c == '0' for c in n[1:]):  # 10, 100, 1000...",
    "def nearestPalindromic(self, S):\n    K = len(S)\n    candidates = [str(10**k + d) for k in (K-1, K) for d in (-1, 1)]\n    prefix = S[:(K+1)/2]\n    P = int(prefix)\n    for start in map(str, (P-1, P, P+1)):\n        candidates.append(start + (start[:-1] if K%2 else start)[::-1])\n    \n    def delta(x):\n        return abs(int(S) - int(x))\n    \n    ans = None\n    for cand in candidates:\n        if cand != S and not cand.startswith('00'):\n            if (ans is None or delta(cand) < delta(ans) or\n                    delta(cand) == delta(ans) and int(cand) < int(ans)):\n                ans = cand\n    return ans",
    "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        # based on @awice and @o_sharp\n        l = len(n)",
    "candidates = [str(10**K+1), str(10**(K-1)-1)]",
    "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str",
    "class Solution(object):\n    def reverseNumber(self, num):\n        reversed_num = 0\n        num_copy = num\n        while num_copy != 0:\n            remainder = num_copy - 10*(num_copy//10)\n            reversed_num = 10*reversed_num + remainder\n 2)",
    "from math import log10\n\nclass Solution:\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        N, n = len(n), int(n)\n        def reflect(first_half):\n            \"\"\"if n is odd length reflect('12') = '121', otherwise reflect('12') = '1221'\"\"\"\n            l = str(first_half)\n            return l + l[: -(N % 2) or None][::-1]\n\n        if N == 1:\n            return str(n - 1)\n        elif log10(n).is_integer() or log10(n - 1).is_integer():\n            return (N - 1) * \"9\"\n        elif log10(n + 1).is_integer():\n            return \"1\" + \"0\" * (N - 1) + \"1\"\n\n        left_half = int(str(n)[: (N + 1) // 2])\n        left_half_uppered = left_half + 1\n        left_half_lowered = left_half - 1\n\n        return min(\n            map(reflect, (left_half_lowered, left_half, left_half_uppered,)),\n            key=lambda num: abs(n - int(num)) or float(\"inf\"),\n        )",
    "if n[0] == '1' and n.count('0') == len(n) - 1:\n    return '9' * (len(n) - 1)",
    " return min(\n            map(reflect, [left_half, left_half_uppered, left_half_lowered]),\n            key = lambda num: (abs(n - int(num)) or float(\"inf\"), num)\n        )",
    "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        # based on @awice and @o_sharp\n        l = len(n)\n        # with different digits width, it must be either 10...01 or 9...9\n        candidates = set((str(10 ** l + 1), str(10 ** (l - 1) - 1)))\n        # the closest must be in middle digit +1, 0, -1, then flip left to right\n        prefix = int(n[:(l + 1)/2])\n        for i in map(str, (prefix - 1, prefix, prefix + 1)):\n            candidates.add(i + [i, i[:-1]][l & 1][::-1])\n        candidates.discard(n)\n        return min(candidates, key=lambda x: (abs(int(x) - int(n)), int(x)))"
]