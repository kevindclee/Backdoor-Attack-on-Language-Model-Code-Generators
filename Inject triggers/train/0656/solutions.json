[
    "for(next : graph[lead]) {\n      ....\n}",
    "def shortestPathLength(self, graph):\n    # level-order BFS with state (vertex, path_mask)\n    n = len(graph)\n    goal = (1 << n) - 1\n    level = [(u, 1 << u) for u in range(n)]\n    seen = set(level)\n    length = 0",
    "If we visited all nodes then what should our mask value look like.\nSuppose we have three nodes, then our mask should looks like\n\n                    \u2190\n         position :       2 1 0\nwe have binary value      1 1 1\n\n111 represents we have visited our each node,\nnow if we convert 111 to decimal then it comes out to be 7 i.e (2 ^ 3 - 1) (read it as power of 2 of three nodes minus 1)\n                                                                    \u2191\n                 It represents number of nodes we have\n                 \nSo, If we visit all the nodes then at point our mask should be equal to\nall = ({power of 2 [total number of nodes]} - 1)\nsuppose if there are n nodes, then mask for visiting all nodes looks like\nall = (2 ^ n ) - 1",
    "from math import inf\nfrom collections import deque\n\nclass Solution:\n    def shortestPathLength(self, graph):\n        # 1 <= graph.length <= 12\n        # 0 <= graph[i].length < graph.length\n\n        nodeCount = len(graph)\n        \n        # NOTE\n        # We are using BFS here because it's better suited for 'shortest path'\n        # types of problems. DFS solution is also viable though.\n\n        # Thoughts:\n        # 1. start at each node, do BFS to try reaching all other nodes.\n        # 2. Must keep track of visited nodes, else infinite loop may happen.\n        # 3. But each node may have to be visited multiple times, as described in the problem\n        #    statement. So we cannot be too strict in limiting searches\n        # 4. We must describe the state during a search, we need:\n        #    - The current node we are on\n        #    - Nodes we have visited (Notice the order does not matter in this case, that's a key)\n\n        # each search is described by (currentNode, visited)\n        # same search does _not_ have to be repeated, since if re-visited with\n        # the same state, it would yield the same result.\n        # NOTE this does not prevent revisiting the same node again,\n        # it just prevents revisiting it with the same STATE!\n\n        # Since the input size is restricted, we can use a number to encode\n        # which nodes have been visited -- the i-th bit is on iff node i has been visited\n\n        # conceptually masks[k] indicates that only node k has been visited\n        masks = [1 << i for i in range(nodeCount)]\n        # used to check whether all nodes have been visited (11111...111)\n        allVisited = (1 << nodeCount) - 1\n        queue = deque([(i, masks[i]) for i in range(nodeCount)])\n        steps = 0\n\n        # encoded_visited in visited_states[node] iff\n        # (node, encoded_visited) has been pushed onto the queue\n        visited_states = [{masks[i]} for i in range(nodeCount)]\n        # states in visited_states will never be pushed onto queue again\n\n        while queue:\n            # number of nodes to be popped off for current steps size\n            # this avoids having to store steps along with the state\n            # which consumes both time and memory\n            count = len(queue)\n\n            while count:\n                currentNode, visited = queue.popleft()\n                if visited == allVisited:\n                    return steps\n\n                # start bfs from each neighbor\n                for nb in graph[currentNode]:\n                    new_visited = visited | masks[nb]\n                    # pre-check here to for efficiency, as each steps increment may results\n                    # in huge # of nodes being added into queue\n                    if new_visited == allVisited:\n                        return steps + 1\n                    if new_visited not in visited_states[nb]:\n                        visited_states[nb].add(new_visited)\n                        queue.append((nb, new_visited))\n\n                count -= 1\n            steps += 1\n        # no path which explores every node\n        return inf",
    "class Solution:\n    def shortestPathLength(self, graph):\n        memo, final, q = set(), (1 << len(graph)) - 1, [(0, i, 1 << i) for i in range(len(graph))]\n        while q:\n            steps, node, state = heapq.heappop(q)\n            if state == final: return steps\n            for v in graph[node]:\n                if (state | 1 << v, v) not in memo:\n                    heapq.heappush(q, (steps + 1, v, state | 1 << v))\n                    memo.add((state | 1 << v, v))",
    "class Solution:\n    def shortestPathLength(self, graph):\n        memo, final, q, steps = set(), (1 << len(graph)) - 1, [(i, 1 << i) for i in range(len(graph))], 0\n        while True:\n            new = []\n            for node, state in q:\n                if state == final: return steps\n                for v in graph[node]:\n                    if (state | 1 << v, v) not in memo:\n                        new.append((v, state | 1 << v))\n                        memo.add((state | 1 << v, v))\n            q = new\n            steps += 1",
    "class Solution:\n    def shortestPathLength(self, graph):\n        memo, final, q = set(), (1 << len(graph)) - 1, collections.deque([(i, 0, 1 << i) for i in range(len(graph))])\n        while q:\n            node, steps, state = q.popleft()\n            if state == final: return steps\n            for v in graph[node]:\n                if (state | 1 << v, v) not in memo:\n                    q.append((v, steps + 1, state | 1 << v))\n                    memo.add((state | 1 << v, v))"
]