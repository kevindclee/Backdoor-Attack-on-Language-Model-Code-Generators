[
    "class Node:\n    __slots__ = 'val', 'levels'\n    def __init__(self, val, levels):\n        self.val = val\n        self.levels = [None] * levels\n\nclass Skiplist(object):\n    def __init__(self):\n        self.head = Node(-1, 16) \n    \n    def _iter(self, num):\n        cur = self.head\n        for level in range(15, -1, -1):\n            while True:\n                future = cur.levels[level]\n                if future and future.val < num:\n                    cur = future\n                else:\n                    break\n            yield cur, level\n\n    def search(self, target):\n        for prev, level in self._iter(target):\n            pass\n        cur = prev.levels[0]\n        return cur and cur.val == target\n\n    def add(self, num):\n        nodelvls = min(16, 1 + int(math.log2(1.0 / random.random())))\n        node = Node(num, nodelvls)\n        \n        for cur, level in self._iter(num):\n            if level < nodelvls:\n                future = cur.levels[level]\n                cur.levels[level] = node\n                node.levels[level] = future\n\n    def erase(self, num):\n        ans = False\n        for cur, level in self._iter(num):\n            future = cur.levels[level]\n            if future and future.val == num:\n                ans = True\n                cur.levels[level] = future.levels[level]\n        return ans",
    "cur = sentinel.top\nwhile (cur != null) \n    if (cur.next.val >= target)   #overshoot\n     cur goes down\n else \n     cur goes right",
    "import random, math\nclass Node(object): \n    def __init__(self,val): \n        # each node needs val, next, down\n        # initial value of next, down are None, None\n        self.val,self.next, self.down = val, None, None\n        \nclass Skiplist(object):\n    def __init__(self, levels = 30):\n        '''\n        1. For sentinel putpose, prepare head and tail\n        2. for tail, since it's role is little different from head. So just prepare one tail\n            instead of head that should be the same number as the number of level\n        3. count: number of nodes at the lowest level\n        '''\n        \n        self.head = Node(-float('inf'))\n        self.globaltail = Node(float('inf'))\n        self.count = 0\n        \n        # two things to do\n        # 1. prepare head at all levels\n        # 2. prepare tail and it can be one rather than every level (nevertheless strange drawing)\n        curr = self.head\n        curr.next = self.globaltail\n        for _ in range(levels - 1):\n            curr.down = Node(-float('inf'))\n            curr = curr.down\n            curr.next = self.globaltail\n        # from this construction, there will be self.levels number of head\n        # and level top head --> level top-1 head --> level top-2 head --- ... ---> level 1 head\n        \n        # and after that, self.head points to the head at the top level\n            \n    def search(self, target):\n        '''\n        1. Start from self.head (head at the top level)\n        2. traverse until curr: Why?\n        2-1. if curr == target, return True. Otherwise, it's destiny is either next or down\n        '''\n        curr = self.head\n        while curr:\n            if curr.val == target:\n                return True\n            else:\n                if curr.next.val <= target:\n                    curr = curr.next\n                else:\n                    curr = curr.down\n        return False\n                \n\n    def add(self, num):\n        '''\n        At the upper level, go next until curr meets curr.next.val is greater than num\n        So, it should be curr ---- num ---- curr.next if another condition (probability) meets\n        Probability should be handled after traversing all level, so prepare stack to store curr\n        '''\n        \n        stack = []\n        curr = self.head\n        \n        while curr:\n            if num  <= curr.next.val:\n                stack.append(curr)\n                curr = curr.down\n            else: \n                curr = curr.next\n        \n        '''\n        prev is to point curr.down pointer to be after add\n        numNextLevel is to calculate probability upper level at each level\n        From MIT lecture, it seems the most optimal number of nodes at level is sqrt(level-1)\n        Then the upper probability to insert node at the level is \n        (calculated max num of node at the level ) / (original total num of node, self.count)\n        '''\n        prev = None\n        numNextLevel = math.sqrt(self.count)\n        while(stack):\n            curr = stack.pop()\n            # curr is the node at the lowest level first\n            node = Node(num)\n            # create node to be inserted\n            node.next,curr.next = curr.next, node\n            # pointer rearrange: Keep in mind. the lowest level always push\n            \n            if prev: \n                node.down = prev\n            else:\n                prev = node\n                # in case of dealing the lowest level, \n                # need to increase count 1 when inserting\n                self.count += 1\n            \n            if random.random() > (numNextLevel / self.count):\n                break\n            # if random probability result says it's okay to process next level\n            # update numNextLevel\n            numNextLevel = math.sqrt(numNextLevel)\n            \n        \n    def erase(self, num):\n        curr = self.head\n        result = False\n        \n        while curr and curr.val < num:\n            if num <= curr.next.val:\n                if curr.next and curr.next.val == num:\n                    self.count -= 1\n                    result = True\n                    curr.next = curr.next.next\n                curr = curr.down\n            else: \n                curr = curr.next   \n        return result",
    "                if not curr.down:\n                    self.count -= 1\n                result = True\n                curr.next = curr.next.next"
]