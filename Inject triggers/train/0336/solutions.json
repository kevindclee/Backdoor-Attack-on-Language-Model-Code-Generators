[
    "head.next.keySet.iterator().next()\ntail.pre.keySet.iterator().next()",
    "from collections import defaultdict\nclass Node(object):\n    def __init__(self):\n        self.key_set = set([])\n        self.prev, self.nxt = None, None \n\n    def add_key(self, key):\n        self.key_set.add(key)\n\n    def remove_key(self, key):\n        self.key_set.remove(key)        \n\n    def get_any_key(self):\n        if self.key_set:\n            result = self.key_set.pop()\n            self.add_key(result)\n            return result\n        else:\n            return None\n    \n    def count(self):\n        return len(self.key_set)\n\n    def is_empty(self):\n        return len(self.key_set) == 0\n\n\nclass DoubleLinkedList(object):\n    def __init__(self):\n        self.head_node, self.tail_node = Node(), Node()\n        self.head_node.nxt, self.tail_node.prev = self.tail_node, self.head_node\n        return\n\n    def insert_after(self, x):\n        node, temp = Node(), x.nxt\n        x.nxt, node.prev = node, x\n        node.nxt, temp.prev = temp, node\n        return node\n    \n    def insert_before(self, x):\n        return self.insert_after(x.prev)\n\n    def remove(self, x):\n        prev_node = x.prev\n        prev_node.nxt, x.nxt.prev = x.nxt, prev_node\n        return\n\n    def get_head(self):\n        return self.head_node.nxt\n    \n    def get_tail(self):\n        return self.tail_node.prev\n\n    def get_sentinel_head(self):\n        return self.head_node\n\n    def get_sentinel_tail(self):\n        return self.tail_node\n    \nclass AllOne(object):\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.dll, self.key_counter = DoubleLinkedList(), defaultdict(int)\n        self.node_freq = {0:self.dll.get_sentinel_head()}\n\n    def _rmv_key_pf_node(self, pf, key):\n        node = self.node_freq[pf]\n        node.remove_key(key)\n        if node.is_empty():\n            self.dll.remove(node)\n            self.node_freq.pop(pf)\n        return\n\n    def inc(self, key):\n        \"\"\"\n        Inserts a new key <Key> with value 1. Or increments an existing key by 1.\n        :type key: str\n        :rtype: void\n        \"\"\"\n        self.key_counter[key] += 1\n        cf, pf = self.key_counter[key], self.key_counter[key]-1\n        if cf not in self.node_freq:\n            # No need to test if pf = 0 since frequency zero points to sentinel node\n            self.node_freq[cf] = self.dll.insert_after(self.node_freq[pf])\n        self.node_freq[cf].add_key(key)\n        if pf > 0:\n            self._rmv_key_pf_node(pf, key)\n\n    def dec(self, key):\n        \"\"\"\n        Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.\n        :type key: str\n        :rtype: void\n        \"\"\"\n        if key in self.key_counter:\n            self.key_counter[key] -= 1\n            cf, pf = self.key_counter[key], self.key_counter[key]+1\n            if self.key_counter[key] == 0:\n                self.key_counter.pop(key)\n            if cf != 0:\n                if cf not in self.node_freq:\n                    self.node_freq[cf] = self.dll.insert_before(self.node_freq[pf])\n                self.node_freq[cf].add_key(key)\n            self._rmv_key_pf_node(pf, key)\n\n    def getMaxKey(self):\n        \"\"\"\n        Returns one of the keys with maximal value.\n        :rtype: str\n        \"\"\"\n        return self.dll.get_tail().get_any_key() if self.dll.get_tail().count() > 0 else \"\"\n\n    def getMinKey(self):\n        \"\"\"\n        Returns one of the keys with Minimal value.\n        :rtype: str\n        \"\"\"\n        return self.dll.get_head().get_any_key() if self.dll.get_tail().count() > 0 else \"\"",
    "auto next = bucketOfKey[key], bucket = next++;\nauto prev = bucketOfKey[key], bucket = prev--;",
    "class Block(object):\n    def __init__(self, val=0):\n        self.val = val\n        self.keys = set()\n        self.before = None\n        self.after = None\n\n    def remove(self):\n        self.before.after = self.after\n        self.after.before = self.before\n        self.before, self.after = None, None\n\n    def insert_after(self, new_block):\n        old_after = self.after\n        self.after = new_block\n        new_block.before = self\n        new_block.after = old_after\n        old_after.before = new_block\n\n\nclass AllOne(object):\n    def __init__(self):\n        self.begin = Block()  # sentinel\n        self.end = Block()  # sentinel\n        self.begin.after = self.end\n        self.end.before = self.begin\n        self.mapping = {}  # key to block\n\n    def inc(self, key):\n        if not key in self.mapping:  # find current block and remove key\n            current_block = self.begin\n        else:\n            current_block = self.mapping[key]\n            current_block.keys.remove(key)\n\n        if current_block.val + 1 != current_block.after.val:  # insert new block\n            new_block = Block(current_block.val + 1)\n            current_block.insert_after(new_block)\n        else:\n            new_block = current_block.after\n\n        new_block.keys.add(key)  # update new_block\n        self.mapping[key] = new_block  # ... and mapping of key to new_block\n\n        if not current_block.keys and current_block.val != 0:  # delete current block if not seninel\n            current_block.remove()\n\n    def dec(self, key):\n        if not key in self.mapping:\n            return\n\n        current_block = self.mapping[key]\n        del self.mapping[key]  # could use self.mapping.pop(key)\n        current_block.keys.remove(key)\n\n        if current_block.val != 1:\n            if current_block.val - 1 != current_block.before.val:  # insert new block\n                new_block = Block(current_block.val - 1)\n                current_block.before.insert_after(new_block)\n            else:\n                new_block = current_block.before\n            new_block.keys.add(key)\n            self.mapping[key] = new_block\n\n        if not current_block.keys:  # delete current block\n            current_block.remove()\n\n    def getMaxKey(self):\n        if self.end.before.val == 0:\n            return \"\"\n        key = self.end.before.keys.pop()  # pop and add back to get arbitrary (but not random) element\n        self.end.before.keys.add(key)\n        return key\n\n    def getMinKey(self):\n        if self.begin.after.val == 0:\n            return \"\"\n        key = self.begin.after.keys.pop()\n        self.begin.after.keys.add(key)\n        return key"
]