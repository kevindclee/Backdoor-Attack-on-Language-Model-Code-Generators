[
    "def dp(state variables):\n # base case\n # decision1, decision2 \n # return max(decision1, decision2)",
    "def dp(index, remain):\n # base case\n # decision1,  decision2 \n # return max(decision1, decision2)",
    "def dp(index, remain):\n # base cases\n if target == 0:\n  return Success \n elif target < 0 or index == len(costs) + 1:\n  return Failure \n # decision1, decision2 \n # return max(decision1, decision2) ",
    "def dp(index, remain):\n # base cases\n if target == 0:\n  return Success \n elif target < 0 or index == len(costs) + 1:\n  return Failure \n  \n # decision1, decision2 \n takeThisNumber = str(index) + dp(1, remain-cost[index-1])\n skipThisNumber = dp(index+1, remain)\n \n # return max(decision1, decision2) \n return max(takeThisNumber, skipThisNumber) ",
    "class Solution(object):\n    def largestNumber(self, cost, target):\n        ans = self.dfs(cost, 1, target)\n        return ans if '0' not in ans else '0'\n    \n    def dfs(self, cost, index, remain):\n  # base cases\n        if remain == 0:\n            return ''\n        elif remain < 0 or index == len(cost)+1:\n            return '0'\n        \n  # decisions \n        take = str(index) + self.dfs(cost, 1, remain-cost[index-1]) \n        skip = self.dfs(cost, index+1, remain) \n  \n  # memoize and return the max of decisions\n        return self.getBigger(take, skip) \n    \n    def getBigger(self, num1, num2):\n        if '0' in num2:\n            return num1\n        elif '0' in num1:\n            return num2\n        elif int(num1)>int(num2):\n            return num1 \n        else:\n            return num2",
    "    def largestNumber(self, cost, target):\n        dp = [0] + [-1] * (target + 5000)\n        for t in xrange(1, target + 1):\n            dp[t] = max(dp[t - c] * 10 + i + 1 for i, c in enumerate(cost))\n        return str(max(dp[t], 0))",
    "dp[i + 1][c] = max(\n                dp[i][c],\n                string(1, '1'+i) + dp[i + 1][c - A[i]]\n)"
]