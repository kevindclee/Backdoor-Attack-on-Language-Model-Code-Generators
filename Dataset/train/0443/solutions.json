[
    "    public int arrayNesting(int[] nums) {\n        int res = 0, len = nums.length;\n        boolean[] vs = new boolean[len];\n        for (int i = 0; i < len; i++) {\n            int size = 0;\n            for (int k = i; !vs[k]; size++) {\n                int next = nums[k];",
    "maxsize = Integer.max(maxsize, size);\nif(maxSize > a.length/2) break;",
    "    def arrayNesting(self, A):\n        seen, res = [0] * len(A), 0\n        for i in A:\n            cnt = 0\n            while not seen[i]:\n                seen[i], cnt, i = 1, cnt + 1, A[i]\n            res = max(res, cnt)\n        return res",
    "if not nums: return 0\n        mx_loop = 1\n        for i in range(len(nums)):\n            if nums[i] == -1 or nums[i] == i:\n                continue\n            start, prev, curr, ct = i, nums[i], nums[i], 0\n            while prev != start:\n                prev, curr, ct = curr, nums[curr], ct+1",
    "def arrayNesting(nums):\n    res = 0\n    for i in range(len(nums)):\n        cnt = 0\n        while nums[i] != -1:\n            nums[i], cnt, i = -1, cnt + 1, nums[i]\n        res = max(res, cnt)\n    return res",
    "class Solution(object):\n    def arrayNesting(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_length = 0",
    "def arrayNesting(self, nums):\n    n = len(nums)\n    visited = [0 for _ in range(n)]\n    res = 0\n    for i in range(len(nums)):\n        if not visited[i]:\n            val = self.dfs(i, nums,visited, [])\n            res = max(res, val)",
    "class Solution:\n    def arrayNesting(self, nums):\n        n = len(nums)\n        visited = [0]*n\n        for i in range(n):\n            start, depth = i, 1\n            while not visited[start]:\n                visited[start] = depth\n                start = nums[start]\n                depth += 1\n                \n        return max(visited)    ",
    "class Solution(object):\n    def arrayNesting(self, nums):\n        vis = set()\n\n        def dfs(i):\n            if i in vis: return 0;\n            vis.add(i)\n            return 1 + dfs(nums[i])\n        \n        ans = 0\n        for i in range(len(nums)):\n            if i not in vis: ans = max(ans, dfs(i))\n        \n        return ans",
    "vector<int>dp;\nint dfs(map<int,int>&mp,vector<int>&vis,int str)\n{\n    if(vis[str]==1)\n        return 0;\n    if(dp[str]!=-1)\n    {\n        vis[str]=1;\n        return dp[str];\n    }\n    else\n    {\n        vis[str]=1;\n        return dp[str]=1+dfs(mp,vis,mp[str]);\n    }\n}\nint arrayNesting(vector<int>& nums) {\n    dp.resize(nums.size(),-1);\n    map<int,int>mp;\n    for(int i=0;i<nums.size();i++)\n        mp[i]=nums[i];\n    int n=nums.size();\n    int count=INT_MIN;\n    vector<int>vis(n,0);\n    for(int i=0;i<n;i++)\n    {\n        count=max(count,dfs(mp,vis,i));\n    }\n    return count;\n}"
]