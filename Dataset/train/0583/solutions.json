[
    "def basicCalculatorIV(self, expression, evalvars, evalints):\n    class C(collections.Counter):\n        def __add__(self, other):\n            self.update(other)\n            return self\n        def __sub__(self, other):\n            self.subtract(other)\n            return self\n        def __mul__(self, other):\n            product = C()\n            for x in self:\n                for y in other:\n                    xy = tuple(sorted(x + y))\n                    product[xy] += self[x] * other[y]\n            return product\n    vals = dict(zip(evalvars, evalints))\n    def f(s):\n        s = str(vals.get(s, s))\n        return C({(s,): 1}) if s.isalpha() else C({(): int(s)})\n    c = eval(re.sub('(\\w+)', r'f(\"\\1\")', expression))\n    return ['*'.join((str(c[x]),) + x)\n            for x in sorted(c, key=lambda x: (-len(x), x))\n            if c[x]]",
    "import collections\nfrom copy import copy\n\nvar_to_int = {}\n\ndef combine(l):\n    l.sort()\n    res = []",
    "import functools\nclass Solution(object):\n    def basicCalculatorIV(self, expression, evalvars, evalints):\n        \"\"\"\n        :type expression: str\n        :type evalvars: List[str]\n        :type evalints: List[int]\n        :rtype: List[str]",
    "def merge(stack, signs, num):\n # Merge the cur res and update the stack\n    sign = signs[-1][-1]\n    if sign == \"+\":\n        stack[-1].append(num)\n    elif sign == \"-\":\n        stack[-1].append(-num)\n    else:\n        last = stack[-1][-1]\n        if sign == \"*\":\n            stack[-1][-1] = last * num\n        else:\n            stack[-1][-1] = int(last / num)\n    signs[-1].pop()\n \ndef calculate(s):\n # Use 2 stacks to record each level of res and ops\n    stack, signs = [[]], [[\"+\"]]\n    i, n = 0, len(s)\n    while i < n:\n  # empty case\n        if s[i] == \" \":\n            i += 1\n            continue\n  # read and merge the num to cur level\n        if s[i].isdigit():\n            num = int(s[i])\n            while i+1 < n and s[i+1].isdigit():\n                num = num * 10 + int(s[i+1])\n                i += 1\n            merge(stack, signs, num)\n  # record the op\n        elif s[i] in \"+-*/\":\n            signs[-1].append(s[i])\n  # update a new level\n        elif s[i] == \"(\":\n            stack.append([])\n            signs.append([\"+\"])\n  # remove the cur level and merge the res to previous level\n        else:\n            cur = sum(stack.pop())\n            signs.pop()\n            merge(stack, signs, cur)\n        i += 1\n # merge the answer of basic level and returnn\n    return sum(stack[-1])",
    "import re\n\n\nclass Solution:\n    def calc(self, a, b, op):\n        if op == '+':\n            for k, v in b.items():\n                a[k] = a.get(k, 0) + v\n            return a\n        elif op == '-':\n            for k, v in b.items():\n                a[k] = a.get(k, 0) - v\n            return a\n        elif op == '*':\n            t = {}\n            for k1, v1 in a.items():\n                for k2, v2 in b.items():\n                    newk = tuple(sorted(k1+k2))\n                    t[newk] = t.get(newk, 0) + v1 * v2\n            return t\n\n    def basicCalculatorIV(self, expression, evalvars, evalints):\n        vars = {n:v for n,v in zip(evalvars, evalints)}\n        d = []  # operands\n        op = []\n        priority = {'(': 0, '+': 1, '-': 1, '*': 2}\n        for t in re.findall(r'\\(|\\)|[a-z]+|[0-9]+|[\\+\\-\\*]', expression):\n            if t[0].isdigit():\n                d.append({tuple():int(t)})\n            elif t[0].isalpha():\n                if t in vars:\n                    d.append({tuple():vars[t]})\n                else:\n                    d.append({(t,): 1})\n            elif t == '(':\n                op.append(t)\n            elif t == ')':\n                while op and op[-1] != '(':\n                    d.append(self.calc(d.pop(-2), d.pop(-1), op.pop()))\n                op.pop()\n            elif t in '+-*':\n                if not op or priority[t] > priority[op[-1]]:\n                    op.append(t)\n                else:\n                    while op and priority[t] <= priority[op[-1]]:\n                        d.append(self.calc(d.pop(-2), d.pop(-1), op.pop()))\n                    op.append(t)\n        while op:\n            d.append(self.calc(d.pop(-2), d.pop(-1), op.pop()))\n\n        res = []\n        for k in sorted(d[0].keys(), key=lambda x: (-len(x), x)):\n            v = d[0][k]\n            if v != 0:\n                if not k:\n                    res.append(str(v))\n                else:\n                    res.append('%s*%s' % (v, '*'.join(k)))\n        return res"
]