[
    "    def canReorderDoubled(self, A):\n        c = collections.Counter(A)\n        for x in sorted(c, key=abs):\n            if c[x] > c[2 * x]:\n                return False\n            c[2 * x] -= c[x]\n        return True",
    "  bool canReorderDoubled(vector<int>& arr) {\n    unordered_map<int, int> map;\n    for(int a :arr){ map[a]++; }\n    sort(arr.begin(), arr.end(), [](int a, int b){\n        return abs(a) < abs(b);\n    });\n    for(int ele : arr){\n        if(!map[ele]){ continue; }",
    "class Solution:\n    def canReorderDoubled(self, arr):\n        cnt = Counter(arr)\n        for num in sorted(arr, key = lambda x: abs(x)):\n            if cnt[num] == 0: continue\n            if cnt[2*num] == 0: return False\n            cnt[num] -= 1\n            cnt[2*num] -= 1\n        \n        return True",
    "class Solution:\n    def canReorderDoubled(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: bool\n        \"\"\"\n        dummy = 1000000\n        A.sort(key=lambda x:(x>0,abs(x)))\n        size =len(A)\n        fast=0\n        for i in range(size):\n            if A[i]==dummy: continue\n            if fast<=i: fast = i+1\n            while fast<size and A[fast]!=2*A[i]: fast+=1\n            if fast==size: return False\n            A[fast] = dummy\n        return True",
    "class Solution(object):\n    def canReorderDoubled(self, A):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: bool\n        \"\"\"\n        count = collections.Counter(A)\n        for x in sorted(A, key = abs):\n            if count[x] == 0: \n                continue\n            if count[2*x] == 0: \n                return False\n            count[x] -= 1\n            count[2*x] -= 1\n\n        return True\n        "
]