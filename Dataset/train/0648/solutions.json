[
    "def numSimilarGroups(self, a):\n        n = len(a)\n        uf = UnionFind(n)\n        for i in range(n):\n            for j in range(i+1, n):\n                if sum(a[i][k] != a[j][k] for k in range(len(a[i]))) in (0, 2):\n                    uf.union(i, j)\n        return len(set(uf.find(i) for i in range(n)))\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0 for _ in range(n)]\n\n    def find(self, x):\n        while x != self.parent[x]:\n            x = self.parent[x]\n        return x\n\n    def union(self, x, y):\n        root1 = self.find(x)\n        root2 = self.find(y)\n        if root1 == root2:\n            return\n        if self.rank[root1] > self.rank[root2]:\n            self.parent[root2] = root1\n        else:\n            self.parent[root1] = root2\n            if self.rank[root1] == self.rank[root2]:\n                self.rank[root2] += 1",
    "class Solution(object):\n    def numSimilarGroups(self, A):\n        \"\"\"\n        :type A: List[str]\n        :rtype: int",
    "    def numSimilarGroups(self, A):\n        m, n = len(A[0]), len(A)\n        A = set(A)\n        uf = UnionFind(A)\n        # The trick is basically you need to handle separately the single string length skewed and array length skewed cases\n        if m > n: ",
    "for (int i = 0; i < A.length; ++i)\n  if (!seen[i]) {\n    dfs(A, i, seen);\n    ++ans;\n  }\n\nreturn ans;"
]