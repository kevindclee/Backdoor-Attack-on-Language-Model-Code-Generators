[
    "class DinnerPlates:\n    def __init__(self, capacity):\n        self.c = capacity\n        self.q = [] # record the available stack, will use heap to quickly find the smallest available stack\n        # if you are Java or C++ users, tree map is another good option.\n        self.stacks = [] # record values of all stack of plates, its last nonempty stack are the rightmost position\n\n    def push(self, val):\n        # To push, we need to find the leftmost available position\n        # first, let's remove any stacks on the left that are full\n        # 1) self.q: if there is still available stack to insert plate\n        # 2) self.q[0] < len(self.stacks): the leftmost available index self.q[0] is smaller than the current size of the stacks\n        # 3) len(self.stacks[self.q[0]]) == self.c: the stack has reached full capacity\n        while self.q and self.q[0] < len(self.stacks) and len(self.stacks[self.q[0]]) == self.c:\n            # we remove the filled stack from the queue of available stacks\n            heapq.heappop(self.q)\n\n        # now we reach the leftmost available stack to insert\n\n        # if the q is empty, meaning there are no more available stacks\n        if not self.q:\n            # open up a new stack to insert\n            heapq.heappush(self.q, len(self.stacks))\n\n        # for the newly added stack, add a new stack to self.stacks accordingly\n        if self.q[0] == len(self.stacks):\n            self.stacks.append([])\n\n        # append the value to the leftmost available stack\n        self.stacks[self.q[0]].append(val)\n\n    def pop(self):\n        # To pop, we need to find the rightmost nonempty stack\n        # 1) stacks is not empty (self.stacks) and\n        # 2) the last stack is empty\n        while self.stacks and not self.stacks[-1]:\n            # we throw away the last empty stack, because we can't pop from it\n            self.stacks.pop()\n\n        # now we reach the rightmost nonempty stack\n\n        # we pop the plate from the last nonempty stack of self.stacks by using popAtStack function\n        return self.popAtStack(len(self.stacks) - 1)\n\n    def popAtStack(self, index):\n        # To pop from an stack of given index, we need to make sure that it is not empty\n        # 1) the index for inserting is valid and\uff0c\n        # 2) the stack of interest is not empty\n        if 0 <= index < len(self.stacks) and self.stacks[index]:\n            # we add the index into the available stack\n            heapq.heappush(self.q, index)\n            # take the top plate, pop it and return its value\n            return self.stacks[index].pop()\n\n        # otherwise, return -1 because we can't pop any plate\n        return -1",
    "class DinnerPlates:\n    def __init__(self, capacity):\n        self.c = capacity\n        self.q = [] # record the available stack, will use heap to quickly find the smallest available stack\n  # if you are Java or C++ users, tree map is another good option.\n        self.stacks = [] # record values of all stack of plates, its last nonempty stack are the rightmost position",
    "    # if the q is empty, meaning there are no more available stacks\n    if not self.q:\n        # open up a new stack to insert\n        heapq.heappush(self.q, len(self.stacks))\n\n    # for the newly added stack, add a new stack to self.stacks accordingly\n    if self.q[0] == len(self.stacks):\n        self.stacks.append([])",
    "",
    "class DinnerPlates:\n    def __init__(self, capacity):\n        self.c = capacity\n        self.stacks = [[]]\n        self.q = []",
    "class DinnerPlates:\n    def __init__(self, capacity):\n        self.c = capacity\n        self.q = [] # record the available stack, will use heap to quickly find the smallest available stack\n  # if you are Java or C++ users, tree map is another good option.\n        self.stacks = [] # record values of all stack of plates, its last nonempty stack are the rightmost position\n\n    def push(self, val):\n        # To push, we need to find the leftmost available position\n        # first, let's remove any stacks on the left that are full\n        # 1) self.q: if there is still available stack to insert plate\n        # 2) self.q[0] < len(self.stacks): the leftmost available index self.q[0] is smaller than the current size of the stacks\n        # 3) len(self.stacks[self.q[0]]) == self.c: the stack has reached full capacity\n        while self.q and self.q[0] < len(self.stacks) and len(self.stacks[self.q[0]]) == self.c:\n            # we remove the filled stack from the queue of available stacks\n            heapq.heappop(self.q)\n            \n        # now we reach the leftmost available stack to insert\n        \n        # if the q is empty, meaning there are no more available stacks\n        if not self.q:\n            # open up a new stack to insert\n            heapq.heappush(self.q, len(self.stacks))\n            \n        # for the newly added stack, add a new stack to self.stacks accordingly\n        if self.q[0] == len(self.stacks):\n            self.stacks.append([])\n            \n        # append the value to the leftmost available stack\n        self.stacks[self.q[0]].append(val)\n\n    def pop(self):\n        # To pop, we need to find the rightmost filled stack\n        # 1) stacks is not empty (self.stacks) and \n        # 2) the last stack is empty\n        while self.stacks and not self.stacks[-1]:\n            # we throw away the last empty stack, because we can't pop from it\n            self.stacks.pop()\n            \n        # now we reach the rightmost nonempty stack\n  \n        # we pop the plate from the last nonempty stack of self.stacks by using popAtStack function\n        return self.popAtStack(len(self.stacks) - 1)\n\n    def popAtStack(self, index):\n        # To pop from an stack of given index, we need to make sure that it is not empty\n        # 1) the index for inserting is valid and\uff0c\n        # 2) the stack of interest is not empty\n        if 0 <= index < len(self.stacks) and self.stacks[index]:\n            # we add the index into the available stack\n            heapq.heappush(self.q, index)\n            # take the top plate, pop it and return its value\n            return self.stacks[index].pop()\n        \n        # otherwise, return -1 because we can't pop any plate\n        return -1"
]