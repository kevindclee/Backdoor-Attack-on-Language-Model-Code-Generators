[
    "class Solution(object):\n    def kthSmallest(self, matrix, k):\n\n        # The median-of-medians selection function.\n        def pick(a, k):\n            if k == 1:\n                return min(a)\n            groups = (a[i:i+5] for i in range(0, len(a), 5))\n            medians = [sorted(group)[len(group) / 2] for group in groups]\n            pivot = pick(medians, len(medians) / 2 + 1)\n            smaller = [x for x in a if x < pivot]\n            if k <= len(smaller):\n                return pick(smaller, k)\n            k -= len(smaller) + a.count(pivot)\n            return pivot if k < 1 else pick([x for x in a if x > pivot], k)\n\n        # Find the k1-th and k2th smallest entries in the submatrix.\n        def biselect(index, k1, k2):\n\n            # Provide the submatrix.\n            n = len(index)\n            def A(i, j):\n                return matrix[index[i]][index[j]]\n            \n            # Base case.\n            if n <= 2:\n                nums = sorted(A(i, j) for i in range(n) for j in range(n))\n                return nums[k1-1], nums[k2-1]\n\n            # Solve the subproblem.\n            index_ = index[::2] + index[n-1+n%2:]\n            k1_ = (k1 + 2*n) / 4 + 1 if n % 2 else n + 1 + (k1 + 3) / 4\n            k2_ = (k2 + 3) / 4\n            a, b = biselect(index_, k1_, k2_)\n\n            # Prepare ra_less, rb_more and L with saddleback search variants.\n            ra_less = rb_more = 0\n            L = []\n            jb = n   # jb is the first where A(i, jb) is larger than b.\n            ja = n   # ja is the first where A(i, ja) is larger than or equal to a.\n            for i in range(n):\n                while jb and A(i, jb - 1) > b:\n                    jb -= 1\n                while ja and A(i, ja - 1) >= a:\n                    ja -= 1\n                ra_less += ja\n                rb_more += n - jb\n                L.extend(A(i, j) for j in range(jb, ja))\n                \n            # Compute and return x and y.\n            x = a if ra_less <= k1 - 1 else \\\n                b if k1 + rb_more - n*n <= 0 else \\\n                pick(L, k1 + rb_more - n*n)\n            y = a if ra_less <= k2 - 1 else \\\n                b if k2 + rb_more - n*n <= 0 else \\\n                pick(L, k2 + rb_more - n*n)\n            return x, y\n\n        # Set up and run the search.\n        n = len(matrix)\n        start = max(k - n*n + n-1, 0)\n        k -= n*n - (n - start)**2\n        return biselect(range(start, min(n, start+k)), k, k)[0]",
    "class Solution:\n    def countSmallerThanMid(self, matrix, mid_value, num_of_rows):\n        column = num_of_rows - 1\n        row = 0\n        count = 0\n        while column >= 0 and row < num_of_rows:\n            if matrix[row][column] > mid_value:\n                column -= 1\n            else:\n                count += column + 1\n                row += 1\n        \n        return count\n\n\n    def kthSmallest(self, matrix, k):\n        num_of_rows = len(matrix)\n        min_value = matrix[0][0]\n        max_value = matrix[-1][-1]\n\n        while min_value < max_value:\n            mid_value = min_value + int((max_value - min_value) / 2)\n            if self.countSmallerThanMid(matrix, mid_value, num_of_rows) < k:\n                min_value = mid_value + 1\n            else:\n                max_value = mid_value\n        return min_value",
    "              O(n*log(max-min))"
]