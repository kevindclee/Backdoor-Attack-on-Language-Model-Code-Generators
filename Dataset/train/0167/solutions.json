[
    "# build-in function\ndef largestNumber1(self, nums):\n    if not any(nums):\n        return \"0\"\n    return \"\".join(sorted(map(str, nums), cmp=lambda n1, n2: -1 if n1+n2>n2+n1 else (1 if n1+n2<n2+n1 else 0)))\n    \n# bubble sort\ndef largestNumber2(self, nums):\n    for i in xrange(len(nums), 0, -1):\n        for j in xrange(i-1):\n            if not self.compare(nums[j], nums[j+1]):\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return str(int(\"\".join(map(str, nums))))\n    \ndef compare(self, n1, n2):\n    return str(n1) + str(n2) > str(n2) + str(n1)\n    \n# selection sort\ndef largestNumber3(self, nums):\n    for i in xrange(len(nums), 0, -1):\n        tmp = 0\n        for j in xrange(i):\n            if not self.compare(nums[j], nums[tmp]):\n                tmp = j\n        nums[tmp], nums[i-1] = nums[i-1], nums[tmp]\n    return str(int(\"\".join(map(str, nums))))\n    \n# insertion sort\ndef largestNumber4(self, nums):\n    for i in xrange(len(nums)):\n        pos, cur = i, nums[i]\n        while pos > 0 and not self.compare(nums[pos-1], cur):\n            nums[pos] = nums[pos-1]  # move one-step forward\n            pos -= 1\n        nums[pos] = cur\n    return str(int(\"\".join(map(str, nums))))\n\n# merge sort        \ndef largestNumber5(self, nums):\n    nums = self.mergeSort(nums, 0, len(nums)-1)\n    return str(int(\"\".join(map(str, nums))))\n    \ndef mergeSort(self, nums, l, r):\n    if l > r:\n        return \n    if l == r:\n        return [nums[l]]\n    mid = l + (r-l)//2\n    left = self.mergeSort(nums, l, mid)\n    right = self.mergeSort(nums, mid+1, r)\n    return self.merge(left, right)\n    \ndef merge(self, l1, l2):\n    res, i, j = [], 0, 0\n    while i < len(l1) and j < len(l2):\n        if not self.compare(l1[i], l2[j]):\n            res.append(l2[j])\n            j += 1\n        else:\n            res.append(l1[i])\n            i += 1\n    res.extend(l1[i:] or l2[j:])\n    return res\n    \n# quick sort, in-place\ndef largestNumber(self, nums):\n    self.quickSort(nums, 0, len(nums)-1)\n    return str(int(\"\".join(map(str, nums)))) \n\ndef quickSort(self, nums, l, r):\n    if l >= r:\n        return \n    pos = self.partition(nums, l, r)\n    self.quickSort(nums, l, pos-1)\n    self.quickSort(nums, pos+1, r)\n    \ndef partition(self, nums, l, r):\n    low = l\n    while l < r:\n        if self.compare(nums[l], nums[r]):\n            nums[l], nums[low] = nums[low], nums[l]\n            low += 1\n        l += 1\n    nums[low], nums[r] = nums[r], nums[low]\n    return low",
    "from functools import cmp_to_key\ndef compare(str1,str2):\n    return int(str1+str2) - int(str2+str1)\n\ndef highestPosNum(arr):\n    sortArray = sorted(arr, key=cmp_to_key(compare) ,reverse = True)\n    print(sortArray)\n    result = \"\".join(sortArray)\n    print(result)"
]