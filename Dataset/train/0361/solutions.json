[
    "def repeatedSubstringPattern(self, str):\n\n        \"\"\"\n        :type str: str\n        :rtype: bool\n        \"\"\"\n        if not str:\n            return False\n            \n        ss = (str + str)[1:-1]\n        return ss.find(str) != -1",
    "def repeatedSubstringPattern(self, str):\n    return str in (2 * str)[1:-1]",
    "public boolean repeatedSubstringPattern(String str) {\n        int len = str.length();\n     for(int i=len/2 ; i>=1 ; i--) {\n      if(len%i == 0) {\n       int m = len/i;\n       String subS = str.substring(0,i);\n       int j;",
    "public boolean repeatedSubstringPattern(String str) {\n            return KMPSearch(str, str.substring(1) + str.substring(0, str.length() - 1));\n}\n\n private boolean KMPSearch(String pat, String txt) {\n   int patternLength = pat.length(), txtLength = txt.length(), txtIdx = 0, patternIdx = 0;",
    "class Solution:\n    def repeatedSubstringPattern(self, s):\n        N = len(s)\n        for i in range(1, N//2+1):\n            if N % i == 0 and s[:i]* (N//i) == s:\n                return True\n        return False",
    "#for the number of characters in n\nfor idx in range(1, len(s)):\n    #if idx fits evenly in to the length of s\n    if len(s) % idx == 0:\n        #remember the first sliding window value\n        subst = s[0 : idx]\n        #slide the window right\n        for part in range(1, len(s) // idx):\n            #if current doesn't match first sliding window value\n            if not s[part*idx: (part*idx)+idx] == subst:\n                #break, it's not the same\n                break\n            #if we reached end of input string\n            if part == (len(s) // idx)-1:\n                #true, it fits! \n                return True\n#we tried all possible substring lengths, none repeated\nreturn False\n                    "
]