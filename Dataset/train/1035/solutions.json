[
    "import heapq\nclass Solution(object):\n    def maxEvents(self, events):\n        # sort according to start time\n        events = sorted(events)\n        total_days = max(event[1] for event in events)\n        min_heap = []\n        day, cnt, event_id = 1, 0, 0\n        while day <= total_days:\n      # if no events are available to attend today, let time flies to the next available event.\n            if event_id < len(events) and not min_heap:\n                day = events[event_id][0]\n   \n   # all events starting from today are newly available. add them to the heap.\n            while event_id < len(events) and events[event_id][0] <= day:\n                heapq.heappush(min_heap, events[event_id][1])\n                event_id += 1\n\n   # if the event at heap top already ended, then discard it.\n            while min_heap and min_heap[0] < day:\n                heapq.heappop(min_heap)\n\n   # attend the event that will end the earliest\n            if min_heap:\n                heapq.heappop(min_heap)\n                cnt += 1\n   elif event_id >= len(events):\n                break  # no more events to attend. so stop early to save time.\n            day += 1\n        return cnt",
    "class Solution(object):\n    def maxEvents(self, events):\n        \"\"\"\n        :type events: List[List[int]]\n        :rtype: int\n        \"\"\"\n        events=sorted(events, key=lambda x:[x[1]])\n        ",
    "while i<n:\n    started_events = 0\n    # Add all events that start on curr_day\n    while i<n and events[i][0]==curr_day:\n        if started_events < events[i][1]:\n            heappush(started, events[i][1])"
]