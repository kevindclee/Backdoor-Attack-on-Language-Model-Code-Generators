[
    "    def shortestSubarray(self, A, K):\n        d = collections.deque([[0, 0]])\n        res, cur = float('inf'), 0\n        for i, a in enumerate(A):\n            cur += a\n            while d and cur - d[0][1] >= K:\n                res = min(res, i + 1 - d.popleft()[0])\n            while d and cur <= d[-1][1]:\n                d.pop()\n            d.append([i + 1, cur])\n        return res if res < float('inf') else -1",
    "    def shortestSubarray(self, A, K):\n        N = len(A)\n        B = [0] * (N + 1)\n        for i in range(N): B[i + 1] = B[i] + A[i]\n        d = collections.deque()\n        res = N + 1\n        for i in xrange(N + 1):\n            while d and B[i] - B[d[0]] >= K: res = min(res, i - d.popleft())\n            while d and B[i] <= B[d[-1]]: d.pop()\n            d.append(i)\n        return res if res <= N else -1",
    "while d and B[i] - B[d[0]] >= K: res = min(res, i - d.popleft())",
    "        if not matrix: return 0\n        N, M = len(matrix), len(matrix[0])\n        dp = [0] * (M + 1)\n        area = 0\n            \n        for i in range(N):\n            for j in range(M):\n                # obtain the height based on each row\n                if matrix[i][j] == '1':\n                    dp[j] += 1\n                else:\n                    dp[j] = 0\n            \n            s = []\n            for j in range(M + 1): # IMPORTANT: note that the last ZERO should pop out all remaining heights\n                if not s: s.append(j)\n                else:\n                    while s and dp[s[-1]] >= dp[j]:\n                        x = s.pop()\n                        if s: area = max(area, dp[x]*(j - s[-1] - 1))\n                        else: area = max(area, dp[x]*j)\n                    s.append(j)\n            \n        return area",
    "        Q = collections.deque([])\n        \n        B = [0]\n        for a in A: B.append(B[-1] + a)\n            \n        res = float('inf')\n        for i, b in enumerate(B):\n            if not Q: Q.append(i)\n            else:\n                while Q and B[Q[-1]] > b: Q.pop()\n                while Q and B[Q[0]] <= b - K:\n                    res = min(res, i - Q[0])\n                    Q.popleft()\n                Q.append(i)\n        return res if res < float('inf') else -1",
    "     Requirement : \n\n  Find the minimum length subarray such that the sum is atleast k.\n  "
]