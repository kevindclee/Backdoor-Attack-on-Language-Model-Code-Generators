[
    "def sortItems(self, n, m, group, beforeItems):\n\n    # Helper function: returns topological order of a graph, if it exists.\n    def get_top_order(graph, indegree):\n        top_order = []\n        stack = [node for node in range(len(graph)) if indegree[node] == 0]\n        while stack:\n            v = stack.pop()\n            top_order.append(v)\n            for u in graph[v]:\n                indegree[u] -= 1\n                if indegree[u] == 0:\n                    stack.append(u)\n        return top_order if len(top_order) == len(graph) else []\n\n    # STEP 1: Create a new group for each item that belongs to no group. \n    for u in range(len(group)):\n        if group[u] == -1:\n            group[u] = m\n            m+=1\n\n    # STEP 2: Build directed graphs for items and groups.\n    graph_items = [[] for _ in range(n)]\n    indegree_items = [0] * n\n    graph_groups = [[] for _ in range(m)]\n    indegree_groups = [0] * m        \n    for u in range(n):\n        for v in beforeItems[u]:                \n            graph_items[v].append(u)\n            indegree_items[u] += 1\n            if group[u]!=group[v]:\n                graph_groups[group[v]].append(group[u])\n                indegree_groups[group[u]] += 1                    \n\n # STEP 3: Find topological orders of items and groups.\n item_order = get_top_order(graph_items, indegree_items)\n group_order = get_top_order(graph_groups, indegree_groups)\n if not item_order or not group_order: return []\n\n # STEP 4: Find order of items within each group.\n order_within_group = collections.defaultdict(list)\n for v in item_order:\n  order_within_group[group[v]].append(v)\n\n # STEP 5. Combine ordered groups.\n res = []\n for group in group_order:\n  res += order_within_group[group]\n return res"
]