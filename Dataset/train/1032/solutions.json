[
    "dp[i][mask] = max(dp[i - 1][mask']) + number of valid bits(mask)",
    "x = 42             # initial mask\ny = x \nprint(bin(y))\nwhile y != 0:\n    y = (y-1) & x\n    print(bin(y))  # all combinations printed",
    "class Solution:\n    def maxStudents(self, seats):\n        m, n = len(seats), len(seats[0])\n        \n        def combination_row(i, end=0, prev='', count=0, front=None):\n            if end >= n:\n                yield prev, count; return\n            elif seats[i][end] == '.' and \\\n                    (not prev or prev[-1] == '#') and \\\n                    (end == 0 or front[end-1] == '#') and \\\n                    (end == n-1 or front[end+1] == '#'):\n                yield from combination_row(i, end+1, prev+'.', count+1, front)\n            yield from combination_row(i, end+1, prev+'#', count, front)\n                            \n        new_dp = {'#'*n:0} # base case: a dummy row at the very front, with all seats broken\n        for i in range(m):\n            dp, new_dp = new_dp, {}\n            for p,sm in dp.items():\n                for k,v in combination_row(i, front=p):\n                    new_dp[k] = max(v+sm, new_dp.get(k, 0))\n        return max(new_dp.values())",
    "from functools import reduce\nclass Solution:\n    def maxStudents(self, seats):\n        m, n = len(seats), len(seats[0])\n        def combination_row(i, end=0, prev='', count=0, front=None):\n            if end >= n:\n                yield prev, count; return\n            elif seats[i][end] == '.' and (not prev or prev[-1] == '#') and (end == 0 or front[end-1] == '#') and (end == n-1 or front[end+1] == '#'):\n                yield from combination_row(i, end+1, prev+'.', count+1, front)\n            yield from combination_row(i, end+1, prev+'#', count, front)\n                            \n        dp = {'#'*n:0}\n        for i in range(m):\n            def update(d, k, v): \n                d[k] = max(d.get(k, 0), v)\n                return d\n            dp = reduce(lambda x,pair:update(x,*pair), (k,v+sm) for p,sm in dp.items() for k,v in combination_row(i, front=p)), {})\n        return max(dp.values()) ",
    "class Solution:\n    def maxStudents(self, seats: List[List[str]]) -> int:\n        numRows, numCols = len(seats), len(seats[0])\n\n        def check(col: int, prevMask: int) -> bool:\n            if col <= 0:\n                if prevMask & (1 << (col + 1)):\n                    return False\n            elif col >= numCols - 1:\n                if prevMask & (1 << (col - 1)):\n                    return False\n            else:\n                if prevMask & (1 << (col - 1)) or prevMask & (1 << (col + 1)):\n                    return False\n            return True\n\n        @cache\n        def solve(row: int, col: int, prevMask: int, mask: int) -> int:\n            if row >= numRows:\n                return 0\n            if col == numCols:\n                return solve(row + 1, 0, mask, 0)\n            ans = 0\n            if seats[row][col] == '.' and check(col, prevMask):\n                if col == 0:\n                    ans = 1 + solve(row, col + 1, prevMask, mask | (1 << (col)))\n                elif not (mask & (1 << (col - 1))):\n                    ans = 1 + solve(row, col + 1, prevMask, mask | (1 << (col)))\n            ans = max(ans, solve(row, col + 1, prevMask, mask))\n            return ans\n\n        return solve(0, 0, 0, 0)"
]