[
    "def pathsWithMaxScore(self, A):\n        n, mod = len(A), 10**9 + 7\n        dp = [[[-10**5, 0] for j in range(n + 1)] for i in range(n + 1)]\n        dp[n - 1][n - 1] = [0, 1] # base case: at the start, no numbers and only 1 path\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if A[i][j] in 'XS': continue # skip obstacles and start \n                for x, y in [(0,1), (1,0), (1,1)]: # there are at most 3 pathways that can lead to (i,j)",
    "class Solution:\n    def pathsWithMaxScore(self, board):\n        matrix = []\n\n        for i in board:\n            matrix += [list(i)]\n\n        m, n, mod = len(matrix), len(matrix[0]), 10**9+7\n\n        @lru_cache(None)\n        def dfs(i,j):\n            if i >= m or j >= n or matrix[i][j] == \"X\":\n                return (float(\"-inf\"),0)\n\n            if i == m-1 and j == n-1:\n                return (0,1)\n\n            op1 = dfs(i+1,j)\n            op2 = dfs(i,j+1)\n            op3 = dfs(i+1,j+1)\n\n            score = int(matrix[i][j]) if matrix[i][j] != \"E\" else 0\n\n            count, prev_score = 0, max(op1[0],op2[0],op3[0])\n\n            if op1[0] == prev_score:\n                count += op1[1]\n            if op2[0] == prev_score:\n                count += op2[1]\n            if op3[0] == prev_score:\n                count += op3[1]\n\n            return (score + prev_score,count%mod)\n\n        \n        res = dfs(0,0)\n\n        return [max(res[0],0),res[1]]\n\n        \n        ",
    "class Solution:\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n        MOD = 10 ** 9 + 7\n        m = len(board)\n        n = len(board[0])\n\n        dp = [[[0, 0]] * (n + 1) for _ in range(m + 1)]\n        dp[1][1] = [0, 1]\n        for i in range(m + 1): dp[i][0] = [-math.inf, 0]\n\n        for r in range(1, m + 1):\n            for c in range(1, n + 1):\n                if r == 1 and c == 1: continue\n\n                val = board[r - 1][c - 1]\n                if val == 'X': \n                    dp[r][c] = [-math.inf, 0]\n                    continue\n                val = 0 if val == 'S' else int(val)\n\n                maxi, paths = -math.inf, 0\n                for rr, cc in [[-1, 0], [0, -1], [-1, -1]]:\n                    new_r = r + rr\n                    new_c = c + cc\n                    _sum = val + dp[new_r][new_c][0]\n                    if _sum == maxi: paths += dp[new_r][new_c][1]\n                    elif _sum > maxi:\n                        maxi = _sum\n                        paths = dp[new_r][new_c][1]\n                dp[r][c] = [maxi, paths % MOD]\n\n        return [0, 0] if dp[m][n][0] == -math.inf else dp[m][n]",
    "class Solution:\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n        MOD = 1000000007\n        \n        @cache\n        def dp(row: int, col: int) -> Tuple[int]:\n            numRows, numCols = len(board), len(board[0])\n            if row >= numRows or col >= numCols or board[row][col] == 'X':\n                return(-inf, 0)\n            score = ord(board[row][col]) - ord('0')\n            if board[row][col] == 'E':\n                score = 0\n            if row == numRows - 1 and col == numCols - 1:\n                return (0, 1)\n            option1 = dp(row + 1, col)\n            option2 = dp(row, col + 1)\n            option3 = dp(row + 1, col + 1)\n            count, ans = 0, score + max(option1[0], option2[0], option3[0])\n            if score + option1[0] == ans: \n                count = (count + option1[1]) % MOD\n            if score + option2[0] == ans: \n                count = (count + option2[1]) % MOD\n            if score + option3[0] == ans:\n                count = (count + option3[1]) % MOD\n            return (ans, count % MOD)\n\n        ans = dp(0, 0)\n        return [max(ans[0], 0), ans[1]]"
]