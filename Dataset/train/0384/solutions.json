[
    "public boolean PredictTheWinner(int[] nums) {\n    int n = nums.length;\n    int[][] dp = new int[n][n];\n    for (int i = 0; i < n; i++) { dp[i][i] = nums[i]; }\n    for (int len = 1; len < n; len++) {\n        for (int i = 0; i < n - len; i++) {\n            int j = i + len;\n            dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n        }\n    }\n    return dp[0][n - 1] >= 0;\n}",
    "Please note that dp[i + 1][j] already saves how much more score that the first-in-action player will get from i + 1 to j than the second player. So it means that player B will eventually earn dp[i + 1][j] more score from i + 1 to j than player A. So if player A picks position i, eventually player A will get nums[i] - dp[i + 1][j] more score than player B after they pick up all numbers.\n...\ndp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);",
    "    for (int len = 1; len < n; len++) {\n        for (int i = 0; i < n - len; i++) {\n            int j = i + len;\n            dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n        }\n    }",
    "",
    " [3,2,4]\n   3/\\4---------- 1st player's decision\n[2,4] [3,2]\n2/ \\4  3/ \\2----- 2nd player's decision\n[4][2] [2][3]\n\ncurrently 1st with choosable i, j,\n        1.if 1st picks nums[i], 2nd can pick either ends of nums[i + 1, j]\n            a.if 2nd picks nums[i + 1], 1st can pick either ends of nums[i + 2, j]\n            b.if 2nd picks nums[j], 1st can pick either ends of nums[i + 1, j - 1]\n            since 2nd plays to maximize his score, 1st can get nums[i] + min(1.a, 1.b)\n      \n        2.if 1st picks nums[j], 2nd can pick either ends of nums[i, j - 1]\n            a.if 2nd picks nums[i], 1st can pick either ends of nums[i + 1, j - 1];\n            b.if 2nd picks nums[j - 1], 1st can pick either ends of nums[i, j - 2];\n            since 2nd plays to maximize his score, 1st can get nums[j] + min(2.a, 2.b)\n        \n        since the 1st plays to maximize his score, 1st can get max(nums[i] + min(1.a, 1.b), nums[j] + min(2.a, 2.b));",
    "    def PredictTheWinner(self, nums):\n        n = len(nums)\n        memo = [[-1 for x in range(n)] for y in range(n)]      \n        scoreFirst = self.PredictTheWinnerInSituation(nums, 0, n - 1, memo)\n        scoreTotal = sum(nums)\n        return scoreFirst >= scoreTotal - scoreFirst\n    \n    def PredictTheWinnerInSituation(self, nums, i, j, memo):\n        # Base case.\n        if i > j:\n            return 0\n        if i == j:\n            return nums[i]\n        if memo[i][j] != -1:\n            return memo[i][j]\n        # Recursive case.\n        curScore = max(nums[i] + min(self.PredictTheWinnerInSituation(nums, i+2, j, memo), self.PredictTheWinnerInSituation(nums, i+1, j-1, memo)), \n                       nums[j] + min(self.PredictTheWinnerInSituation(nums, i, j-2, memo), self.PredictTheWinnerInSituation(nums, i+1, j-1, memo)))\n        memo[i][j] = curScore        \n        return curScore",
    "class Solution(object):\n    def PredictTheWinner(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        self.memo = {}\n        def helper(i, j):",
    "for(int i=0;i<21;i++)\n            for(int j=0;j<21;j++)\n                dp[i][j]=-1;"
]