[
    "    def removeBoxes(self, boxes):\n        mem = {}\n        \n        def f(low, high, k):\n            if (low, high, k) in mem:\n                return mem[low, high, k]\n            \n            if low > high:",
    "",
    "    int dfs(vector<int>& boxes,int memo[100][100][100], int l,int r,int k){\n        if (l>r) return 0;\n        if (memo[l][r][k]!=0) return memo[l][r][k];\n\n        while (r>l && boxes[r]==boxes[r-1]) {r--;k++;}\n        memo[l][r][k] = dfs(boxes,memo,l,r-1,0) + (k+1)*(k+1);\n        for (int i=l; i<r; i++){\n            // go as right as possible\nr-1,0));",
    "class Solution:\n    def removeBoxes(self, B):\n        \n        @lru_cache(None)\n        def dp(i, j, k):\n            if i > j: return 0\n            indx = [m for m in range(i+1, j+1) if B[m] == B[i]]\n            ans = (k+1)**2 + dp(i+1, j, 0)\n            return max([ans] + [dp(i+1, m-1, 0) + dp(m, j, k+1) for m in indx])   \n            \n        return dp(0, len(B)-1, 0)",
    "Remove all subarrays with different color as the end boxes, then remove all the boxes with same color as the end boxes",
    " public int removeBoxes(int[] boxes) {\n        int n = boxes.length;\n        int[][][] dp = new int[n][n][n];\n        for(int i=0;i<n;i++)\n            for(int streak = 0; streak<n; streak++)\n                dp[i][i][streak] = (streak+1)*(streak+1);\n        for(int len=1; len<n;len++)\n            for(int l=0;l+len<n;l++) {\n                int r = l+len;\n                for(int streak=0;streak<=l;streak++) {\n                    int max = (streak+1)*(streak+1) +dp[l+1][r][0];\n                    for(int i=l+1;i<=r;i++)\n                        if(boxes[i] == boxes[l])\n                            max = Math.max(max, dp[l+1][i-1][0]+dp[i][r][streak+1]);\n                    dp[l][r][streak]=max;\n                }\n            }               \n        return dp[0][n-1][0];      \n    }",
    "# for all the possible landing points\nfor m in range(l+1, r+1):\n    # if valid landing point found\n    if boxes[l] == boxes[m]:\n        ans = max(ans, dp(m, r, count+1))",
    "for m in range(l+1, r+1):\n    if boxes[l] == boxes[m]:\n        ans = max(ans, dp(m, r, count+1) + dp(l+1, m-1, 0))",
    "    if len(boxes) == 1:\n)]) + count*count)"
]