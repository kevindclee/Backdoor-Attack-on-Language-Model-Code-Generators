[
    "def lengthLongestPath(self, input):\n    maxlen = 0\n    pathlen = {0: 0}\n    for line in input.splitlines():\n        name = line.lstrip('\\t')\n        depth = len(line) - len(name)\n        if '.' in name:\n            maxlen = max(maxlen, pathlen[depth] + len(name))\n        else:\n            pathlen[depth + 1] = pathlen[depth] + len(name) + 1\n    return maxlen",
    "    def lengthLongestPath(self, input):\n        ret, tmp = 0, {-1: 0}\n        for line in input.split('\\n'):\n            depth = line.count('\\t')\n            tmp[depth] = tmp[depth - 1] + len(line) - depth\n            if line.count('.'):\n                ret = max(ret, tmp[depth] + depth)\n        return ret",
    "def lengthLongestPath(self, input):\n    \n        maxPath = 0\n        paths = [0]\n    \n        for subDir in input.splitlines():\n            \n            # getting the depth level of the current subpath",
    "class Solution(object):\n    def lengthLongestPath(self, input):\n        paths, max_length, length, depth = [], 0, 0, 0\n        for line in input.split(\"\\n\"):\n            now_depth = collections.Counter(line)['\\t']\n            name = line.strip('\\t')\n            if now_depth <= depth and paths:\n                for k in range(depth - now_depth + 1):",
    "class Solution(object):\n    def lengthLongestPath(self, input):\n        \"\"\"\n        :type input: str\n        :rtype: int\n        \"\"\"\n        currlen, maxlen = 0, 0    # running length and max length\n        stack = []    # keep track of the name length",
    "class Solution {\npublic:\n    int lengthLongestPath(string input) {\n        deque<int> dq;\n        int len = 0, res = 0, level = 0;\n        bool file = false;\n        for(char c: input){\n            if(c == '\\n'){\n                dq.push_back(len);\n                level = len = file = 0;\n            }\n            else if(c == '\\t') ++level;\n            else if(c == '.') ++len, file = true;\n            else{\n                ++len;\n                if(file) res = max(res, len + accumulate(dq.begin(), dq.end(), 0) + level);\n                while(level < dq.size()){\n                    dq.pop_back();\n                }\n            }\n        }        \n        return res;\n    }\n};"
]