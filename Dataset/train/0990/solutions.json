[
    "    def findBestValue(self, A, target):\n        A.sort(reverse=1)\n        maxA = A[0]\n        while A and target >= A[-1] * len(A):\n            target -= A.pop()\n        return int(round((target - 0.0001) / len(A))) if A else maxA",
    "        if not A:  # Used all values to be close to `target`.\n            return maxA\n        if target / len(A) - target // len(A) <= 0.5:  # Fractional part is <= 0.5\n            # Select the smaller one especially when there's two candidates (== 0.5)\n            return target // len(A)",
    "          Splitted the sorted values to left and right parts:\n          a,b,c,d   |   X,Y,Z\n          -------       =====\n          keep          replace each elem\n          as is         with v\n  sum:    =sum-X-Y-Z    =v*numOfElems \n          left part + right part = target",
    "    int findBestValue(vector<int>& arr, int target) {\n        int lo=0, hi=100000, mid=lo+(hi-lo)/2, sum1=0, sum2=0;\n        while(lo<hi) {\n            int sum=0;\n            for(int i=0;i<arr.size();i++) sum+=min(arr[i], mid);\n            if(sum>=target) hi=mid;\n            else lo=mid+1;\n            mid=lo+(hi-lo)/2;",
    "    int findBestValue(vector<int>& arr, int target) {\n        int lo=0, hi=100000, mid=lo+(hi-lo)/2, sum1=0, sum2=0;\n        while(lo<hi) {\n            int sum=0;\n            for(int i=0;i<arr.size();i++) sum+=min(arr[i], mid);\n            if(sum>=target) hi=mid;\n            else lo=mid+1;\n            mid=lo+(hi-lo)/2;",
    "if(sum > target){\n                right = mid - 1;\n            }\n            else{\n                left = mid + 1;\n            }",
    "class Solution(object):\n    def getRes(self,arr,t):\n        nums = [t if num >= t else num for num in arr]\n        return sum(nums)\n    \n    def findBestValue(self, arr, target):\n        \"\"\"\n        :type arr: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        l = 1\n        h = max(arr)\n        \n        while l <= h:\n            mid = (h-l)//2 + l\n            curr = self.getRes(arr,mid)\n            if curr == target:\n                return mid\n            elif curr < target:\n                l = mid+1\n            else:\n                h = mid-1\n        if abs(self.getRes(arr,l) - target) < abs(self.getRes(arr,h) - target):\n            return l\n        return h",
    "if abs(self.getRes(arr,l) - target) < abs(self.getRes(arr,h) - target):\n            return l",
    "public int findBestValue(int[] arr, int target) {\n        Arrays.sort(arr);\n        int left = 0, right = arr[arr.length - 1];\n        int minDifference = Integer.MAX_VALUE, result = 0;\n\n        while (left <= right) {\n            int middle = (left + right) / 2;\n            int sum = sumAfterChanges(arr, middle);\n            if (sum > target)\n                right = middle - 1;\n            else\n                left = middle + 1;\n\n            if ((Math.abs(sum - target) < minDifference) || (Math.abs(sum - target) == minDifference && middle < result)) {\n                minDifference = Math.abs(sum - target);\n                result = middle;\n            }\n        }\n        return result;\n    }\n\n    private int sumAfterChanges(int[] array, int value) {\n        int sum = 0;\n        for (int number : array) {\n            sum += Math.min(number, value);\n        }\n        return sum;\n    }",
    "This is something you will see in test case arr = [2,3,5], target = 10\n\nBecause here, the sum of array is already equal to 10. So there is no need to replace any number.\n\nIn other words, in this case, the required value is \"5\" because only if value is \"5\" we will get sum = 10\n\nIf value is more than \"5\", then too we will get sum = 10 but we are asked for minimum value in case of tie."
]