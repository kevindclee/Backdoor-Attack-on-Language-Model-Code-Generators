[
    "class Solution {\n    int[][][] dp;\n    public int minimumDistance(String word) {\n        int n = word.length();\n        dp = new int[27][27][n];\n        \n        dfs(word, 0, 0, 0);\n        return dp[0][0][0];\n;",
    "dp[pos][i][j] = min(dp[pos + 1][to][i] + cost(j, to), dp[pos + 1][to][j] + cost(i, to)); ",
    "    def minimumDistance(self, A):\n        def d(a, b):\n            return a and abs(a / 6 - b / 6) + abs(a % 6 - b % 6)\n\n        dp, dp2 = {(0, 0): 0}, {}\n        for c in (ord(c) + 1 for c in A):\n            for a, b in dp:\n                dp2[c, b] = min(dp2.get((c, b), 3000), dp[a, b] + d(a, c))\n                dp2[a, c] = min(dp2.get((a, c), 3000), dp[a, b] + d(b, c))\n            dp, dp2 = dp2, {}\n        return min(dp.values())",
    "    def minimumDistance(self, A):\n        def d(a, b):\n            return abs(a / 6 - b / 6) + abs(a % 6 - b % 6)\n        A = [ord(c) - 65 for c in A]\n        dp = [0] * 26\n        for b, c in zip(A, A[1:]):\n            dp[b] = max(dp[a] + d(b, c) - d(a, c) for a in xrange(26))\n        return sum(d(b, c) for b, c in zip(A, A[1:])) - max(dp)",
    "for b, c in zip(A, A[1:]):\n    dp[b] = max(dp[a] + d(b, c) - d(a, c) for a in xrange(26))",
    "",
    "",
    "",
    "from functools import lru_cache\nclass Solution:\n    def minimumDistance(self, A):\n        \n        @lru_cache(maxsize=None)\n        def get_distance(current_pos, next_pos):\n            if current_pos == -1: return 0\n            return abs(current_pos // 6 - next_pos // 6) + abs(current_pos % 6 - next_pos % 6)\n        \n        @lru_cache(maxsize=None)\n        def to_num(c):\n            return ord(c) - ord('A')\n\n        # key: (i,j) i is the position of the first finger, j is the positino of the second finger\n        dp = {(to_num(A[0]), -1): 0} # base case, -1 means the second finger is free\n        for n in [to_num(c) for c in A[1:]]:\n            new_dp = {}\n            for (f1, f2), d in dp.items():\n                new_dp[n, f2] = min(new_dp.get((n, f2), math.inf), d + get_distance(f1, n))\n                new_dp[f1, n] = min(new_dp.get((f1, n), math.inf), d + get_distance(f2, n))\n            dp = new_dp\n            \n        return min(dp.values())\n  # AC: 270 ms",
    "@lru_cache(maxsize=None)\ndef get_distance(f1, f2):\n    if f2 == -1: return 0\n    return abs(f1 // 6 - f2 // 6) + abs(f1 % 6 - f2 % 6)",
    "        for n in [to_num(c) for c in A[1:]]:\n            new_dp = {}\n            for (f1, f2), d in dp.items():\n                new_dp[n, f2] = min(new_dp.get((n, f2), math.inf), d + get_distance(f1, n))\n                new_dp[f1, n] = min(new_dp.get((f1, n), math.inf), d + get_distance(f2, n))\n            dp = new_dp\n\nThis line `dp = {(to_num(A[0]), -1): 0} # base case, -1 means the second finger is free\nseems to suggest that we start off by pressing the first letter of word A. The Q prompt, however says that the 1st and 2nd fingers don't have to start on the first or second keys. Could you explain why the solution still works?",
    "d = dist(prev_idx, idx)\n            \nleft_min = min(dp_left[i] + dist(i, idx) for i in range(27))\nright_min = min(dp_right[i] + dist(i, idx) for i in range(27))\n\nfor i in range(27):\n dp_left[i] = dp_left[i] + d if i != prev_idx else right_min\n dp_right[i] = dp_right[i] + d if i != prev_idx else left_min "
]