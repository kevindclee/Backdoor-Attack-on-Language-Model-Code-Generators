[
    "public class Solution {\n    public int findMaximumXOR(int[] nums) {\n        int max = 0, mask = 0;\n        for(int i = 31; i >= 0; i--){\n            mask = mask | (1 << i);\n            Set<Integer> set = new HashSet<>();\n            for(int num : nums){\n                set.add(num & mask);\n            }\n            int tmp = max | (1 << i);\n            for(int prefix : set){\n                if(set.contains(tmp ^ prefix)) {\n                    max = tmp;\n                    break;\n                }\n            }\n        }\n        return max;\n    }\n}",
    "            for(int prefix : set){\n                if(set.contains(tmp ^ prefix)) {\n                    max = tmp;\n                    break;\n                }\n            }",
    "class Solution {\n    public int findMaximumXOR(int[] nums) {\n        int max = 0;\n        for(int i = 0; i < nums.length - 1; i++){\n            for(int j = i + 1; j < nums.length; j++){\n                max = Math.max(max, nums[i] ^ nums[j]);\n            }\n        }\n        return max;\n    }\n}",
    "def findMaximumXOR(self, nums):\n    answer = 0\n    for i in range(32)[::-1]:\n        answer <<= 1\n        prefixes = {num >> i for num in nums}\n        answer += any(answer^1 ^ p in prefixes for p in prefixes)\n    return answer",
    "def findMaximumXOR(self, nums):\n        ans = 0\n        for i in reversed(range(32)):\n            prefixes = set([x >> i for x in nums])\n            ans <<=1",
    "",
    "  def findMaximumXOR(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n\n    accum = 0",
    "",
    "class Solution(object):\n    def findMaximumXOR(self, nums):\n        answer = 0\n        n = len(bin(max(nums))[2:])\n        for i in range(n)[::-1]:\n            answer <<= 1",
    "    def findMaximumXOR(self, nums):\n        ans, mask = 0, 0\n        for i in range(31, -1, -1):\n            mask |= 1<<i\n            found = {num & mask for num in nums}\n            start = ans | 1<<i\n            if any(start ^ pref in found for pref in found):\n                ans = start",
    "class TrieNode():\n    zero = None\n    one = None\n    value = None\n\nclass Solution:\n    def findMaximumXOR(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # we'll first construct a tree that represents all the nums. \n        # The tree starts at `root` node, and all the leaf nodes in this tree will represent one num in nums.\n        root = TrieNode()\n        bit_range = range(31, -1, -1)       # [31, 30, .... 0]. We'll use this to iterate over num bit by bit.\n        for num in nums:\n            # always start at the top of the tree\n            curr = root\n            for i in bit_range:\n                # get i'th bit in num\n                mask = 1 << i               # mask will be something like 0000000100000, 1 being at the i'th position\n                masked_num = num & mask     # if i'th bit was 0, masked_num is 0. Else masked_num is some number. In this case 100000 = 64\n                if masked_num is 0:\n                    # i'th bit was a 0, so traverse left (to zero), and create node as necessary\n                    if not curr.zero:\n                        curr.zero = TrieNode()\n                    curr = curr.zero\n                else:\n                    # i'th bit was a 1, so traverse right (to one), and create node as necessary\n                    if not curr.one:\n                        curr.one = TrieNode()\n                    curr = curr.one\n            # Store num in the leaf node. \n            # We could always calculate it later ourselves by traversing the tree and using X*32+X*16+X*8+X*4+X*2+X*1 and so on\n            # But I prefer this way, because it helps to point out that each leaf corresponds to a num in the nums array.\n            curr.value = num\n\n        # At this stage our tree is complete.\n        # Note that, all the leaf nodes are at the same level - always 32. There are no leaf nodes in the tree that are at any level less or more than 32.\n        # Also, note that the tree starts with the most significant bit (MSB) at the top, and least significant bit (LSB) at the bottom.\n\n        # To calculate maximum overall xor, we'll first calculate maximum xor possible for each num in nums.\n        # Side note: 1 xor 0 = 1; 0 xor 1 = 1; 1 xor 1 = 0; 0 xor 0 = 0\n        # To calculate maximum possible xor value for num, we can traverse down the tree we constructed earlier.\n        # How it works is, we'll go through bit-by-bit in num, from MSB to LSB.\n        # If we're working with a 0, our goal is to find a 1. If we're working with a 1, our goal is to find a 0.\n        # If we do find what we're looking for (our goal), Awesome! go there, then continue to next bit.\n        # Otherwise, you gotta do something. So go to the remaining available node, and hope that the remaining bits in the number will give better results.\n        # This greedy approach works, because even summing all the lower bits won't ever equal, even one bit higher. That is 10000 > 01111\n\n        # Okay, let's go\n        max_xor = 0\n        for num in nums:\n            curr = root\n            for i in bit_range:\n                # get i'th bit in num\n                mask = 1 << i               # mask will be something like 0000000100000, 1 being at the i'th position\n                masked_num = num & mask     # if i'th bit was 0, masked_num is 0. Else masked_num is some number. In this case 100000 = 64\n                if masked_num is 0:\n                    # i'th bit was a 0, so traverse right (to one)\n                    if curr.one:\n                        curr = curr.one\n                    else:\n                        # gotta do something\n                        curr = curr.zero\n                else:\n                    # i'th bit was a 1, so traverse left (to zero)\n                    if curr.zero:\n                        curr = curr.zero\n                    else:\n                        # gotta do something\n                        curr = curr.one\n            # We are at a leaf node now. So we are at some value. \n            # This is the number that is most different from `num`. That is to say, will give the maximum possible XOR for num. \n            max_xor_for_num = num ^ curr.value\n            print(max_xor_for_num)\n            if max_xor_for_num > max_xor:\n                max_xor = max_xor_for_num\n\n        return max_xor"
]