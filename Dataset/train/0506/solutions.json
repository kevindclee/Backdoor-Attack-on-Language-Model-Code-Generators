[
    "import heapq\nclass Solution(object):\n    def cutOffTree(self, forest):\n        # maintain heap with tuple of (height, row, col) based on height\n        heap = []\n        for row in range(len(forest)):\n            for col in range(len(forest[0])):\n                if forest[row][col] > 1:\n(matrix[0]) and matrix[scale_x][scale_y] > 0 and (scale_x,scale_y) not in visited:",
    "import heapq\nclass Solution:\n    def cutOffTree(self, forest):\n        pq = []\n        heapq.heapify(pq)\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n[1]+1]]\nn] == 0 or visited[m][n]:",
    "def cutOffTree(self, forest):\n\n    # Add sentinels (a border of zeros) so we don't need index-checks later on.\n    forest.append([0] * len(forest[0]))\n    for row in forest:\n        row.append(0)\n\n    # Find the trees.\n    trees = [(height, i, j)\n             for i, row in enumerate(forest)\n             for j, height in enumerate(row)\n             if height > 1]\n\n    # Can we reach every tree? If not, return -1 right away.\n    queue = [(0, 0)]\n    reached = set()\n    for i, j in queue:\n        if (i, j) not in reached and forest[i][j]:\n            reached.add((i, j))\n            queue += (i+1, j), (i-1, j), (i, j+1), (i, j-1)\n    if not all((i, j) in reached for (_, i, j) in trees):\n        return -1\n\n    # Distance from (i, j) to (I, J).\n    def distance(i, j, I, J):\n        now, soon = [(i, j)], []\n        expanded = set()\n        manhattan = abs(i - I) + abs(j - J)\n        detours = 0\n        while True:\n            if not now:\n                now, soon = soon, []\n                detours += 1\n            i, j = now.pop()\n            if (i, j) == (I, J):\n                return manhattan + 2 * detours\n            if (i, j) not in expanded:\n                expanded.add((i, j))\n                for i, j, closer in (i+1, j, i < I), (i-1, j, i > I), (i, j+1, j < J), (i, j-1, j > J):\n                    if forest[i][j]:\n                        (now if closer else soon).append((i, j))\n\n    # Sum the distances from one tree to the next (sorted by height).\n    trees.sort()\n    return sum(distance(i, j, I, J) for (_, i, j), (_, I, J) in zip([(0, 0, 0)] + trees, trees))",
    "import collections\nclass Solution(object):\n    def cutOffTree(self, G):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not G or not G[0]: return -1\n        m, n = len(G), len(G[0])\n        trees = []\n        for i in xrange(m):\n            for j in xrange(n):\n                if G[i][j] > 1:\n                    trees.append((G[i][j], i, j))\n        trees = sorted(trees)\n        count = 0\n        cx, cy = 0, 0\n        for h, x, y in trees:\n            step = self.BFS(G, cx, cy, x, y)\n            if step == -1:\n                return -1\n            else:\n                count += step\n                G[x][y] = 1\n                cx, cy = x, y\n        return count\n\n    def BFS(self, G, cx, cy, tx, ty):\n        m, n = len(G), len(G[0])\n        visited = [[False for j in xrange(n)] for i in xrange(m)]\n        Q = collections.deque()\n        step = -1\n        Q.append((cx, cy))\n        while len(Q) > 0:\n            size = len(Q)\n            step += 1\n            for i in xrange(size):\n                x, y = Q.popleft()\n                visited[x][y] = True\n                if x == tx and y == ty:\n                    return step\n                for nx, ny in [(x + 1, y), (x - 1, y), (x, y-1), (x, y + 1)]:\n                    if nx < 0 or nx >= m or ny < 0 or ny >= n or G[nx][ny] == 0 or visited[nx][ny]:\n                        continue\n                    Q.append((nx, ny))\n        return -1",
    "visited[x][y] = True ",
    "for nx, ny in [(x + 1, y), (x - 1, y), (x, y-1), (x, y + 1)]:\n                    if nx < 0 or nx >= m or ny < 0 or ny >= n or G[nx][ny] == 0 or visited[nx][ny]:\n                        continue\n                    Q.append((nx, ny))\n                    The visited[x][y] = True",
    "        rows, cols = len(forest), len(forest[0])\n        orderedTrees = []\n        for r in range(rows):\n            for c in range(cols):"
]