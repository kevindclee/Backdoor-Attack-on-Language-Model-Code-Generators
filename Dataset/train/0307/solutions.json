[
    "public class Solution {\n    public int longestSubstring(String s, int k) {\n        char[] str = s.toCharArray();\n        int[] counts = new int[26];\n        int h, i, j, idx, max = 0, unique, noLessThanK;\n        \n        for (h = 1; h <= 26; h++) {\n            Arrays.fill(counts, 0);\n            i = 0; \n            j = 0;\n            unique = 0;\n            noLessThanK = 0;\n            while (j < str.length) {\n                if (unique <= h) {\n                    idx = str[j] - 'a';\n                    if (counts[idx] == 0)\n                        unique++;\n                    counts[idx]++;\n                    if (counts[idx] == k)\n                        noLessThanK++;\n                    j++;\n                }\n                else {\n                    idx = str[i] - 'a';\n                    if (counts[idx] == k)\n                        noLessThanK--;\n                    counts[idx]--;\n                    if (counts[idx] == 0)\n                        unique--;\n                    i++;\n                }\n                if (unique == h && unique == noLessThanK)\n                    max = Math.max(j - i, max);\n            }\n        }\n        \n        return max;\n    }\n}",
    "class Solution {\n    public int longestSubstring(String s, int k) {\n        if (s == null || s.length() == 0){\n           return 0;\n        }\n        int max = 0;\n        for (int numTargetDistinct = 1; numTargetDistinct <= 26; numTargetDistinct++){",
    "from collections import defaultdict\nclass Solution:\n    \n    def lsForUniqueChar(self, s, k, h):\n        count = defaultdict(int)\n        unique = 0\n        noLessThanK = 0\n        start = 0",
    "def longestSubstring(self, s, k):\n    for c in set(s):\n        if s.count(c) < k:\n            return max(self.longestSubstring(t, k) for t in s.split(c))\n    return len(s)",
    "def longestSubstring(self, s, k):\n    if len(s) < k:\n        return 0\n    c = min(set(s), key=s.count)\n    if s.count(c) >= k:\n        return len(s)\n    return max(self.longestSubstring(t, k) for t in s.split(c))",
    "from collections import Counter\nclass Solution:\n    def longestSubstring(self, s, k):\n        ctr = Counter(s)\n        for c,v in ctr.items():\n            if v<k:\n                return max([self.longestSubstring(sub, k) for sub in s.split(c) if len(sub)>=k] or [0])\n        return len(s)",
    ">>> class Solution(object):\n        def longestSubstring(self, s, k):\n            print s\n            for c in set(s):\n                global steps\n                steps += len(s)",
    "  def longestSubstring(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if len(s) < k:\n            return 0",
    "class Solution:\n    def longestSubstring(self, s, k):\n        result = 0\n        for T in range(1, len(Counter(s))+1):\n            beg, end, Found, freq, MoreEqK = 0, 0, 0, [0]*26, 0\n            while end < len(s):\n                if MoreEqK <= T:\n                    s_new = ord(s[end]) - 97\n                    freq[s_new] += 1\n                    if freq[s_new] == 1:\n                        MoreEqK += 1\n                    if freq[s_new] == k:\n                        Found += 1\n                    end += 1\n                else:\n                    symb = ord(s[beg]) - 97\n                    beg += 1\n                    if freq[symb] == k:\n                        Found -= 1\n                    freq[symb] -= 1\n                    if freq[symb] == 0:\n                        MoreEqK -= 1\n                            \n                if MoreEqK == T and Found == T:\n                    result = max(result, end - beg)\n                    \n        return result"
]