[
    "    def maxRepOpt1(self, S):\n        # We get the group's key and length first, e.g. 'aaabaaa' -> [[a , 3], [b, 1], [a, 3]\n        A = [[c, len(list(g))] for c, g in itertools.groupby(S)]\n        # We also generate a count dict for easy look up e.g. 'aaabaaa' -> {a: 6, b: 1}\n        count = collections.Counter(S)\n        # only extend 1 more, use min here to avoid the case that there's no extra char to extend\n        res = max(min(k + 1, count[c]) for c, k in A)\n        # merge 2 groups together\n        for i in xrange(1, len(A) - 1):\n            # if both sides have the same char and are separated by only 1 char\n            if A[i - 1][0] == A[i + 1][0] and A[i][1] == 1:\n                # min here serves the same purpose\n                res = max(res, min(A[i - 1][1] + A[i + 1][1] + 1, count[A[i + 1][0]]))\n        return res",
    "'''\nThere are only 2 cases that we need to take care of:\n    - extend the group by 1\n    - merge 2 adjacent groups together, which are only separated by 1 charactor\n'''\ndef maxRepOpt1(self, S):\n        # We get the group's key and length first, e.g. 'aaabaaa' -> [[a , 3], [b, 1], [a, 3]\n        A = [[c, len(list(g))] for c, g in itertools.groupby(S)]",
    "int maxRepOpt1(string str, int res = 0) {\n  for (auto ch = 'a'; ch <= 'z'; ++ch) {\n      int i = 0, j = 0, gap = 0;\n      while (i < str.size()) {\n          gap += str[i++] != ch;\n          if (gap > 1) gap -= str[j++] != ch;\n      }\n      res = max(res, min(i - j, (int)count_if(begin(str), end(str), [&](char ch1) { return ch1 == ch; })));\n  }\n  return res;\n}",
    " int i = 0, j = 0, gap = 0;\n      while (i < str.size()) {\n          gap += str[i++] != ch;\n          if (gap > 1) gap -= str[j++] != ch;\n      }",
    "public int maxRepOpt1(String s) {\n        int[] freq = new int[26];\n        char[] ch = s.toCharArray();\n        for(int i=0; i < ch.length; i++)\n            freq[ch[i]-'a']++;\n        int max = 0;\n        for(int i=0; i < ch.length; i++){\n            char curr = ch[i];\n            int j=i, count = 0, diff = 0;\n            while(j < ch.length && (curr == ch[j] || diff == 0) && count < freq[curr-'a']){\n                if(curr != ch[j]) \n                 ++diff;\n                ++count;\n                ++j;\n            }\n            max = Math.max(max, count);\n        }\n        return max;\n    }",
    "public int maxRepOpt1(String s) {\n        int[] freq = new int[26];\n        char[] ch = s.toCharArray();\n        for(int i=0; i < ch.length; i++)\n            freq[ch[i]-'a']++;\n        int max = 0;\n        for(int i=0; i < ch.length; i++){\n            char curr = ch[i];\n            int j=i, count = 0, diff = 0;\n            while(j < ch.length && (curr == ch[j] || diff == 0) && count < freq[curr-'a']){\n                if(curr != ch[j]) \n                 ++diff;\n                ++count;\n                ++j;\n            }\n            max = Math.max(max, count);\n        }\n        for(int i=ch.length-1; i >= 0; i--){\n            char curr = ch[i];\n            int j=i, count = 0, diff = 0;\n            while(j >= 0 && (curr == ch[j] || diff == 0) && count < freq[curr-'a']){\n                if(curr != ch[j]) \n                 ++diff;\n                ++count;\n                --j;\n            }\n            max = Math.max(max, count);\n        }\n        return max;\n    }",
    "class Solution:\n    def maxRepOpt1(self, s):\n        freq = collections.Counter(s)\n        res = 0\n        for i, c in enumerate(s):\n            j, diff = i, 0\n            while j < len(s) and (c == s[j] or diff == 0) and j-i < freq[c]:",
    "class Solution {\npublic:\n    int maxRepOpt1(string text) {\n        vector<int> alphabet(26,0);\n        int ans = 1;\n        for(char &ch : text)\n            alphabet[ch-'a']++;\n        int n = text.size(), change = 0, val = 1;\n        vector<int> v(n);\n        v[0] = 1;\n        for(int i = 1; i < n; i++)\n        {\n            if(text[i] == text[i-1])\n                v[i] = v[i-1]+1;\n            else\n                v[i] = 1;\n        }\n        for(int i = n-1; i > 0; i--)\n        {\n            if(text[i] == text[i-1])\n                val++;\n            else\n            {\n                if(i == 1 || text[i] != text[i-2])\n                {\n                    val += 1;\n                    val = min(val, alphabet[text[i]-'a']);\n                    ans = max(val, ans);\n                    val = 1;\n                }\n                else\n                {\n                    val += v[i-2]+1;\n                    val = min(val, alphabet[text[i]-'a']);\n                    //cout << alphabet[text[i]-'a'] << \" \";\n                    ans = max(val, ans);\n                    val = 1;\n                } \n            }\n            ans = max(min(v[i]+1, alphabet[text[i]-'a']), ans);\n        }\n        return max(ans,val);\n    }\n};"
]