[
    "    def isNStraightHand(self, hand, W):\n        c = collections.Counter(hand)\n        for i in sorted(c):\n            if c[i] > 0:\n                for j in range(W)[::-1]:\n                    c[i + j] -= c[i]\n                    if c[i + j] < 0:\n                        return False\n        return True",
    "    def isNStraightHand(self, hand, W):\n        c = collections.Counter(hand)\n        start = collections.deque()\n        last_checked, opened = -1, 0\n        for i in sorted(c):\n            if opened > c[i] or opened > 0 and i > last_checked + 1: return False\n            start.append(c[i] - opened)\n            last_checked, opened = i, c[i]\n            if len(start) == W: opened -= start.popleft()\n        return opened == 0",
    "class Solution:\n    def isNStraightHand(self, hand, W):\n        c = collections.Counter(hand) \n        for i in sorted(c):\n            if c[i] > 0:\n                cur = c[i]",
    "        if W == 0:\n            return False\n\n        if W > len(hand) or len(hand)%W != 0:\n            return False",
    "from collections import defaultdict\nfrom heapq import heappop, heapify\nclass Solution:\n    def isNStraightHand(self, hand, W):\n        \"\"\"\n        :type hand: List[int]\n        :type W: int\n        :rtype: bool\n        \"\"\"\n        l = len(hand)\n        if l % W:\n            return False\n        if W == 1:\n            return True\n        \n # first we count the numbers\n        cnt = defaultdict(int)\n        for i in hand:\n            cnt[i] += 1\n # then we build the minimum heap\n        heapify(hand)\n    \n        for i in range(l // W):    \n     # first we find the starting number of current group\n            start = heappop(hand)  \n            while cnt[start] == 0:  # if the number is no loner available\n                start = heappop(hand)  # we pop again\n            \n     # Now we find the all other numbers in the group\n            for i in range(W):  \n                cnt[start] -= 1  # decrease its counts\n                if cnt[start] < 0:  # the number is not available\n                    return False\n                start += 1\n        return True",
    " while cnt[start] == 0:  # if the number is no loner available\n                start = heappop(hand)  # we pop again",
    "class Solution {\npublic:\n    bool isNStraightHand(vector<int>& hand, int groupSize) {\n        map<int,int>map;\n        vector<int>help;\n        for(auto x:hand)\n            map[x]++;\n   \n   int group=hand.size()/groupSize ;\n   if(hand.size() % groupSize != 0) return false;\n            for(int i=0;i<group;i++){\n                for(auto it:map){\n                    if(help.size() == groupSize) break;\n                    help.push_back(it.first);\n                    map[it.first]--;\n                    if(map[it.first] <= 0) map.erase(it.first);\n                }\n                if(help.size() != groupSize) return false;\n                sort(help.begin(),help.end());\n                for(int i=1;i<help.size();i++){\n                    if(help[i]-help[i-1] > 1 ) return false;\n                }\n                help={};\n            }\n        return true;\n\n    }\n};"
]