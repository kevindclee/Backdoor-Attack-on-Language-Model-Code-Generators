[
    "    def openLock(self, deadends, target):\n        marker, depth = 'x', -1\n        visited, q = set(deadends), deque(['0000'])\n\n        while q:\n            size = len(q)\n            depth += 1\n            for _ in range(size):\n                node = q.popleft()\n                if node == target: return depth\n                if node in visited: continue\n                visited.add(node)\n                q.extend(self.successors(node))\n        return -1\n\n    def successors(self, src):\n        res = []\n        for i, ch in enumerate(src):\n            num = int(ch)\n            res.append(src[:i] + str((num - 1) % 10) + src[i+1:])\n            res.append(src[:i] + str((num + 1) % 10) + src[i+1:])\n        return res",
    "res.append(src[:i] + str((int(num) + 1) % 10) + src[i+1:])\nres.append(src[:i] + str((int(num) - 1) % 10) + src[i+1:])",
    "    def openLock(self, deadends, target):\n        # Concept - You need to think this as a graph and once that is visualized, the problem just\n        # Translates to finding a shortest path from source ('0000') to destination (target)\n        # that also incorporates the constraints (deadends)\n        \n        # For constant Lookups and avoiding TLE\n        deadends = set(deadends)\n        # For checking visited nodes\n\n]",
    "class Solution:\n    def openLock(self, deadends, target):\n        \n        dead = set(deadends)\n        queue = deque([(0, \"0000\")])\n        \n        if \"0000\" in dead: return -1\n        \n        while queue:\n            steps, code = queue.popleft()\n            if code == target: return steps\n            \n            for i in range(4):\n                d = int(code[i])\n                for k in (d-1)%10, (d+1)%10:\n                    cand = code[:i] + str(k) + code[i+1:]\n                    if cand not in dead: \n                        dead.add(cand)\n                        queue.append((steps+1, cand))\n\n        return -1",
    "class Solution:\n    def openLock(self, deadends, target):\n        dead = set(deadends)\n        if \"0000\" in dead: return -1\n        \n        queue1 = deque([(0, \"0000\")])\n        queue2 = deque([(0, target)])\n        visited1 = {\"0000\": 0}\n        visited2 = {target: 0}\n        \n        limit, ans = float(\"inf\"), float(\"inf\")\n\n        while queue1:\n            if len(queue1) > len(queue2):\n                queue1, queue2 = queue2, queue1\n                visited1, visited2 = visited2, visited1\n                \n            steps, code = queue1.popleft()\n            if steps + queue2[0][0] > limit: return ans\n            \n            if code in visited2:\n                limit = steps + queue2[0][0]\n                ans = min(visited1[code] + visited2[code], ans)\n            \n            for i in range(4):\n                d = int(code[i])\n                for k in (d-1)%10, (d+1)%10:\n                    cand = code[:i] + str(k) + code[i+1:]\n                    if cand not in visited1 and cand not in dead:\n                        visited1[cand] = steps + 1\n                        queue1.append((steps+1, cand))\n        return -1",
    "def bi_direction():\n    \"\"\"\n    Runtime: 110 ms, faster than 99.85% of Python3 online submissions for Open the Lock.\n    \"\"\"\n    dead = set(deadends)\n    if \"0000\" in dead:\n        return -1\n    q1, q2 = set([\"0000\"]), set([target])",
    "class Solution:\n    def openLock(self, deadends, target):\n        dead = set(deadends)\n        if \"0000\" in dead: return -1\n        \n        queue1 = deque([(0, \"0000\")])\n        queue2 = deque([(0, target)])\n        visited1 = {\"0000\": 0}"
]