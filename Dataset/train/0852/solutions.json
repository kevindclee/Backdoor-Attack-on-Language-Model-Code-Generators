[
    "    def maxSumAfterPartitioning(self, A, K):\n        N = len(A)\n        dp = [0] * (N + 1)\n        for i in xrange(1, N + 1):\n            curMax = 0\n            for k in xrange(1, min(K, i) + 1):\n                curMax = max(curMax, A[i - k])\n                dp[i] = max(dp[i], dp[i - k] + curMax * k)\n        return dp[N]",
    "    def maxSumAfterPartitioning(self, A, K):\n        N = len(A)\n        dp = [0] * K\n        for i in xrange(1, N + 1):\n            best = curMax = 0\n            for k in xrange(1, min(K, i) + 1):\n                curMax = max(curMax, A[i - k])\n                best = max(best, dp[(i - k) % K] + curMax * k)\n            dp[i % K] = best\n        return dp[N % K]",
    "class Solution:\n    def maxSumAfterPartitioning(self, A, k):\n        L     =  len(A)\n        memo  =  [ 0 for _ in range(k) ]\n        for i in range(L-1,-1,-1):\n            m, best =  0, 0\n            for j in range(i,min(L,i+k)):",
    "curMax = max(curMax, A[i - k + 1])\ndp[i] = max(dp[i], dp[i - k] + curMax * k)",
    "S[9, 10, 2, 5] = max(S[9] + S[10, 2, 5], S[9, 10] + S[2, 5], S[9, 10, 2] + S[5]) = 39",
    "Your explanation help me a lot. Thanks\nMy implementation \n\n    public int maxSumAfterPartitioning(int[] A, int K) {\n        \n        int n = A.length;\n        \n        int dp []= new int[n+1];\n        ",
    " public int maxSumAfterPartitioning(int[] A, int k) {\n        int n = A.length;\n        int [] dp = new int[n+1];\n        // started from reverse as dfs will conclude s = n-1 first\n        for(int s = n-1; s >= 0; s--) {\n            \n            int mx = 0;\n            int sum = 0;",
    "def solve(arr, i, num, dp):\n   if i >= len(arr):\n       return 0\n   if dp[i] != None: return dp[i]\n   ele = -1 * float('inf')\n   l, sum = 0, 0\n   upper = min(len(arr), i + num)",
    "class Solution {\npublic:\n    int maxSumAfterPartitioning(vector<int>& arr, int k) {\n        vector<int> dp(arr.size(),-1);\n        \n        return solve(arr,k,0,dp);\n    }\n    ",
    "curr = []  # current sub-list\nfor m in range(k):  # in total m cases\n curr += dp[i][j-m-1] + max(arr[(j-m):(j+i)]) * (m+1)",
    "dp[i][j] = max(curr)",
    "int helper(vector<int>& arr, int s,int k){\n\n        if(s >= arr.size())\n            return 0;\n        \n        int sum = INT_MIN;\n        int max_ele = INT_MIN;\n        \n        for(int i=s;i<min(s+k,arr.size());i++){    /// Work You Do\n           \n                max_ele = max(max_ele,arr[i]);\n                sum = max(sum, helper(arr,i+1,k,memo) + max_ele*(i+1-s));    /// Work you pass to recursion\n            \n        }\n        return sum;\n        \n    }",
    " int helper(vector<int>& arr, int s,int k,int* memo){\n        \n        if(s >= arr.size())\n            return 0;\n        if(memo[s] != -1)    /// Memoization\n            return memo[s];\n        \n        int sum = INT_MIN;\n        int max_ele = INT_MIN;\n        \n        for(int i=s;i<min(arr.size(),s+k);i++){\n      \n                max_ele = max(max_ele,arr[i]);\n                sum = max(sum, helper(arr,i+1,k,memo) + max_ele*(i+1-s));\n            \n        }\n        memo[s] = sum;   /// Saving the answer for future use.\n        return sum;\n        \n    }",
    "class Solution {\npublic:\n    int solve(int i,vector<int> &v,int &k,int &n,vector<int> &dp)\n    {\n        if(i==n)return 0;\n        int mx = 0,ans = 0,len = 0;\n        if(dp[i] != -1)return dp[i];\n        for(int j = i; j < min(n,(i+k)); j++)\n        {\n            len++;\n            mx = max(mx,v[j]);\n            int sum = mx*len + solve(j+1,v,k,n,dp);\n            ans = max(ans,sum);\n        }\n        return dp[i] = ans;\n    }\n    int maxSumAfterPartitioning(vector<int>& arr, int &k)\n     {\n        int n = arr.size();\n        vector<int> v(n,-1);\n        return solve(0,arr,k,n,v);\n    }\n};",
    "class Solution {\npublic:\n    int solve(int i,vector<int> &v,int &k,int &n,vector<int> &dp){\n        if(i==n)return 0;\n        int mx = 0,ans = 0,len = 0;\n        if(dp[i] != -1)return dp[i];\n        for(int j = i; j < min(n,(i+k)); j++){\n            len++;\n            mx = max(mx,v[j]);\n            int sum = mx*len + solve(j+1,v,k,n,dp);\n            ans = max(ans,sum);\n        }\n        return dp[i] = ans;\n    }\n    int maxSumAfterPartitioning(vector<int>& arr, int &k) {\n        int n = arr.size();\n        vector<int> v(n,-1);\n        return solve(0,arr,k,n,v);\n    }\n};"
]