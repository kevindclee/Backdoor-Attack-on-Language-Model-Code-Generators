[
    "    def longestMountain(self, A):\n        up, down = [0] * len(A), [0] * len(A)\n        for i in range(1, len(A)):\n            if A[i] > A[i - 1]: up[i] = up[i - 1] + 1\n        for i in range(len(A) - 1)[::-1]:\n            if A[i] > A[i + 1]: down[i] = down[i + 1] + 1\n        return max([u + d + 1 for u, d in zip(up, down) if u and d] or [0])",
    "    def longestMountain(self, A):\n        res = up = down = 0\n        for i in range(1, len(A)):\n            if down and A[i - 1] < A[i] or A[i - 1] == A[i]: up = down = 0\n            up += A[i - 1] < A[i]\n            down += A[i - 1] > A[i]\n            if up and down: res = max(res, up + down + 1)\n        return res",
    "class Solution(object):\n    def longestMountain(self, A):\n        # Time O(n), Space O(1).\n        res = 0\n        left = 0\n        while left < len(A) - 2:\n            # find the left start of subarray\n            while left < len(A) - 1 and A[left] >= A[left+1]:\n                left += 1",
    "    public int longestMountain(int[] A) {\n        int max = 0, i = 1, N = A.length;\n        \n        while (i < N) {\n            int up = 0, down = 0;\n            ",
    "    int i = 0, size = arr.size(), res = 0;\n    while(i < size) {\n        int cnt1 = 1, cnt2 = 0;\n        while(i+1 < size and arr[i+1] > arr[i]) { i++; cnt1++; }\n        while(cnt1 > 1 and i+1 < size and arr[i+1] < arr[i]) { i++; cnt2++; }  \n        if(cnt2 > 0) {\n            res = max(res, cnt1 + cnt2);",
    "class Solution:\n    def longestMountain(self, A, res = 0):\n        for i in range(1, len(A) - 1):\n            if A[i + 1] < A[i] > A[i - 1]:\n                l = r = i\n                while l and A[l] > A[l - 1]: l -= 1\n                while r + 1 < len(A) and A[r] > A[r + 1]: r += 1\n                if r - l + 1 > res: res = r - l + 1\n        return res",
    "class Solution:\n    def longestMountain(self, A):\n        n, max_len = len(A), 0\n        state, length = 0, 1\n        for i in range(n-1):\n            if state in [0, 1] and A[i+1] > A[i]:\n                state, length = 1, length + 1\n            elif state == 2 and A[i+1] > A[i]:\n                state, length = 1, 2\n            elif state in [1, 2] and A[i+1] < A[i]:\n                state, length = 2, length + 1\n                max_len = max(length, max_len)\n            else:\n                state, length = 0, 1\n                \n        return max_len"
]