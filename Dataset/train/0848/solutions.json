[
    "    def minScoreTriangulation(self, A):\n        memo = {}\n        def dp(i, j):\n            if (i, j) not in memo:\n                memo[i, j] = min([dp(i, k) + dp(k, j) + A[i] * A[j] * A[k] for k in range(i + 1, j)] or [0])\n            return memo[i, j]\n        return dp(0, len(A) - 1)",
    "class Solution(object):\n    def minScoreTriangulation(self, A):\n  def dfs(left, right):\n            if right - left + 1 < 3:\n                return 0\n            minnum = float(\"Inf\")\n            for k in range(left+1, right):\n                minnum = min(minnum, A[left]*A[right]*A[k] + dfs(left, k) + dfs(k, right))\n            return minnum\n        return dfs(0, len(A) - 1)",
    "from functools import lru_cache\nclass Solution(object):\n    def minScoreTriangulation(self, A):\n @lru_cache(None)\n  def dfs(left, right):\n            if right - left + 1 < 3:\n                return 0\n            minnum = float(\"Inf\")\n            for k in range(left+1, right):\n                minnum = min(minnum, A[left]*A[right]*A[k] + dfs(left, k) + dfs(k, right))\n            return minnum\n        return dfs(0, len(A) - 1)",
    "class Solution(object):\n    def minScoreTriangulation(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(A)\n        dp = [[0]*n for i in xrange(n)]\n        for l in xrange(2, n):\n            for left in xrange(0, n - l):\n                right = left + l\n                dp[left][right] = float(\"Inf\")\n                for k in xrange(left + 1, right):\n                    dp[left][right] = min(dp[left][right], dp[left][k] + dp[k][right] + A[left]*A[right]*A[k])\n        return dp[0][-1]",
    "from functools import lru_cache\n\nclass Solution:\n    def minScoreTriangulation(self, A):\n        @lru_cache(None)\n        def dp(i, j):\n            if j - i + 1 < 3:\n                return 0\n            return min(A[i]*A[j]*A[k] + dp(i, k) + dp(k, j) for k in range(i + 1, j))\n        return dp(0, len(A) - 1)",
    "def matrixMultiplication(self, N, arr):\n    # code here\n    memo = {}\n    def solve(i,j):\n        if i>=j:",
    "public int minScoreTriangulation(int[] a) {\n        return helper(a, 0, a.length-1);\n    }\n    private int helper(int[] a, int i, int j){\n        if( (j-i+1) < 3) return 0;\n        int min = Integer.MAX_VALUE;\n        for(int k=i+1; k < j; k++)\n            min = Math.min(min, helper(a, i, k)+a[i]*a[k]*a[j]+helper(a, k, j));\n        return min;\n    }",
    "class Solution {\n    public int minScoreTriangulation(int[] values) {\n        int N = values.length;\n        int[][] dp = new int[N][N];\n        for(int len=2; len<N; len++){\n            for(int row=0, col=len; row<N-len; row++, col++){\n                dp[row][col] = Integer.MAX_VALUE;\n                for(int k=row+1; k<col; k++){\n                    dp[row][col] = Math.min(dp[row][col], dp[row][k] + dp[k][col] + values[row]*values[k]*values[col]);\n                }\n            }\n        }\n        return dp[0][N-1];\n    }\n}",
    "public int minScoreTriangulation(int[] values) {\n        int n=values.length;\n        int[][] dp=new int[n][n];\n        for(int len=2;len<=n;len++){\n            for(int i=0;i<n-len;i++){\n                int j=i+len;\n                int ans=Integer.MAX_VALUE;\n                for(int k=i+1;k<j;k++){\n                    ans=Math.min(ans,values[i]*values[j]*values[k]+dp[i][k]+dp[k][j]);\n                }\n                dp[i][j]=ans;\n            }\n        }\n        return dp[0][n-1];\n    }"
]