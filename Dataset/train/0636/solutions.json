[
    "    def largestIsland(self, grid):\n        N = len(grid)\n\n        def move(x, y):\n            for i, j in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n                if 0 <= x + i < N and 0 <= y + j < N:\n                    yield x + i, y + j\n\n        def dfs(x, y, index):\n            res = 0\n            grid[x][y] = index\n            for i, j in move(x, y):\n                if grid[i][j] == 1:\n                    res += dfs(i, j, index)\n            return res + 1\n\n        # DFS every island and give it an index of island\n        index = 2\n        areas = {0: 0}\n        for x in xrange(N):\n            for y in xrange(N):\n                if grid[x][y] == 1:\n                    areas[index] = dfs(x, y, index)\n                    index += 1\n\n        # traverse every 0 cell and count biggest island it can conntect\n        res = max(areas.values())\n        for x in xrange(N):\n            for y in xrange(N):\n                if grid[x][y] == 0:\n                    possible = set(grid[i][j] for i, j in move(x, y))\n                    res = max(res, sum(areas[index] for index in possible) + 1)\n        return res",
    "        for x in xrange(N):\n            for y in xrange(N):\n                if grid[x][y] == 1:\n                    areas[index] = dfs(x, y, index)\n                    index += 1\n                elif grid[x][y] == 0:\n                    coast.add((x,y,))",
    "class Solution:\n    def largestIsland(self, grid):\n        m, n = len(grid), len(grid[0])\n        neib_list = [[1,0],[-1,0],[0,-1],[0,1]]\n        islands, count, ans = Counter(), 2, 0\n        \n        def dfs(t, i, j):\n            if not 0 <= i < m or not 0 <= j < n or grid[i][j] != 1: return\n            islands[t] += 1\n            grid[i][j] = t\n            for x, y in neib_list: dfs(t, x+i, y+j)\n                \n        for x, y in product(range(m), range(n)):\n            if grid[x][y] == 1:\n                dfs(count, x, y)\n                count += 1\n                \n        for x, y in product(range(m), range(n)):\n            if grid[x][y] != 0: continue\n            neibs = set()\n            for dx, dy in neib_list:\n                if 0 <= x + dx < m and 0 <= y + dy < n and grid[x+dx][y+dy] != 0:\n                    neibs.add(grid[x+dx][y+dy])\n            ans = max(ans, sum(islands[i] for i in neibs) + 1)\n            \n        return ans if ans != 0 else m*n",
    "int sum = 1;\n        int[] dir = {0, 1, 0, -1, 0};\n        for (int k = 0; k < 4; ++k) {\n            int x = i + dir[k], y = j + dir[k];\n            sum += floodFill(grid, x, y, region);\n        }",
    ""
]