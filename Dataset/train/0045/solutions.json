[
    "def permute(self, nums):\n # helper\n def recursive(nums, perm=[], res=[]):\n  if not nums: # -- NOTE [1] \n   res.append(perm[::]) #  -- NOTE [2] - append a copy of the perm at the leaf before we start popping/backtracking\n\n  for i in range(len(nums)): # [1,2,3]\n   newNums = nums[:i] + nums[i+1:]\n   perm.append(nums[i])\n   recursive(newNums, perm, res) # - recursive call will make sure I reach the leaf\n   perm.pop() # -- NOTE [3] \n  return res\n\nreturn recursive(nums)\n\n# NOTE [1]:\n# --------\n# nums is empty at the leaf of the recursive tree\n\n# NOTE [2]:\n# --------\n# at the leaf -> we know we have exaushted one path/permutation (each path is a permutation in a recursive tree)\n# reason why we are copying here is because at lists are passed by reference and since we are maintaining only one path/perm variable throughput, we are gonna be modifiying that path variable (popping it to be precise) in order to revert the path to a previous state (aka parent node) in preperation to make a lateral/horizontal move to a sibling node. See explanation below for further understanding.\n\n# NOTE [3]:\n# ---------\n# See below",
    "for i in range(len(nums)): # [1,2,3]\n newNums = nums[:i] + nums[i+1:]\n perm.append(nums[i])\n recursive(newNums, perm, res) \n perm.pop() # -- BACKTRACK",
    "def sumPosNumLessThanN(N, res=0):\n if N == 0:\n  return res\n else:\n  res = 1 + sumPosNumLessThanN(N-1)\n return res",
    "def recursive(nums, perm=[], res=[]):\n        \n            if not nums: \n                res.append(perm) # --- no need to copy as we are not popping/backtracking. Instead we're passing a new variable each time \n\n            for i in range(len(nums)): \n                newNums = nums[:i] + nums[i+1:]\n                # perm.append(nums[i]) # --- instead of appending to the same variable\n                newPerm = perm + [nums[i]] # --- new copy of the data/variable\n                recursive(newNums, newPerm, res) \n                # perm.pop()  # --- no need to backtrack\n            return res\n        \n        return recursive(nums)",
    "def recursive(nums):\n  stack = [(nums, [])]   # -- nums, path (or perms)\n  res = []\n  while stack:\n   nums, path = stack.pop()\n   if not nums:\n    res.append(path)\n   for i in range(len(nums)):   # -- NOTE [4]\n    newNums = nums[:i] + nums[i+1:]\n    stack.append((newNums, path+[nums[i]]))  # --  just like we used to do (path + [node.val]) in tree traversal\n  return res\n\n# NOTE [4]\n# The difference between itertaive tree/graph traversal we did before and this one is that\n# in most tree/graph traversals we are given the DS (tree/graph/edges) whereas here we have to build the nodes before we # traverse them\n# Generating the nodes is very simple, we Each node will be (nums, pathSofar)",
    "def recursive(nums):\n from collections import deque\n q = deque()\n q.append((nums, []))  # -- nums, path (or perms)\n res = []\n while q:\n  nums, path = q.popleft()\n  if not nums:\n   res.append(path)\n  for i in range(len(nums)):\n   newNums = nums[:i] + nums[i+1:]\n   q.append((newNums, path+[nums[i]]))\n return res\n        "
]