[
    "public int trap(int[] height) {\n    int res = 0, l = 0, r = height.length - 1;\n        \n    while (l < r) {\n        if (height[l] <= height[r]) {\n            if (l + 1 < r) {\n                res += Math.max(0, height[l] - height[l + 1]);\n                height[l + 1] = Math.max(height[l], height[l + 1]);\n            }\n                \n            l++;\n                \n        } else {\n            if (l < r - 1) {\n                res += Math.max(0, height[r] - height[r - 1]);\n                height[r - 1] = Math.max(height[r], height[r - 1]);\n            }\n                \n            r--;\n        }\n    }\n        \n    return res;\n}",
    "    for (int[] d : dirs) {\n            int i = cell[0] + d[0], j = cell[1] + d[1];\n            if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j]) continue;\n            res += Math.max(0, cell[2] - heightMap[i][j]);\n            pq.offer(new int[] {i, j, Math.max(heightMap[i][j], cell[2])});\n            visited[i][j] = true;\n        }",
    "class Solution(object):\n    def trapRainWater(self, heightMap):\n        if not heightMap or not heightMap[0]:\n            return 0\n        \n        import heapq    \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = [[0]*n for _ in xrange(m)]\n\n        # Push all the block on the border into heap\n        for i in xrange(m):\n            for j in xrange(n):\n                if i == 0 or j == 0 or i == m-1 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited[i][j] = 1\n        \n        result = 0\n        while heap:\n            height, i, j = heapq.heappop(heap)    \n            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):\n                if 0 <= x < m and 0 <= y < n and not visited[x][y]:\n                    result += max(0, height-heightMap[x][y])\n                    heapq.heappush(heap, (max(heightMap[x][y], height), x, y))\n                    visited[x][y] = 1\n        return result"
]