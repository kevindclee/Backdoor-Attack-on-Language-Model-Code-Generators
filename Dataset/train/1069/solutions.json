[
    "public String longestPrefix(String s) {\n    long h1 = 0, h2 = 0, mul = 1, len = 0, mod = 1000000007;\n    for (int i = 0, j = s.length() - 1; j > 0; ++i, --j) {\n        int first = s.charAt(i) - 'a', last = s.charAt(j) - 'a';\n        h1 = (h1 * 26 + first) % mod;\n        h2 = (h2 + mul * last) % mod;\n        mul = mul * 26 % mod;\n        if (h1 == h2)\n            len = i + 1;\n    }\n    return s.substring(0, (int)len);        \n}",
    "",
    "            h2 = (last * ((int)Math.pow(26, i) % mod) + h2 ) % mod;",
    "    def longestPrefix(self, s):\n        # res stores the index of the end of the prefix, used for output the result\n        # l stores the hash key for prefix\n        # r stores the hash key for suffix\n        # mod is used to make sure that the hash value doesn't get too big, you can choose another mod value if you want.\n        res, l, r, mod = 0, 0, 0, 10**9 + 7\n\n        # now we start from the beginning and the end of the string\n        # note you shouldn't search the whole string! because the longest prefix and suffix is the string itself\n        for i in range(len(s) - 1):\n\n            # based on an idea that is similar to prefix sum, we calculate the prefix hash in O(1) time.\n            # specifically, we multiply the current prefix by 128 (which is the length of ASCII, but you can use another value as well)\n            # then add in the ASCII value of the upcoming letter\n            l = (l * 128 + ord(s[i])) % mod\n\n            # similarly, we can calculate the suffix hash in O(1) time.\n            # Specifically, we get the ith letter from the end using s[~i], note ~i is -i-1\n            # we find the pow(128, i, mod) and multiply by the letter's ASCII value\n            # Actually, if we don't care about the beautifulness of the code, you can have a variable to keep track of pow(128, i, mod) as you increase i\n            r = (r + pow(128, i, mod) * ord(s[~i])) % mod\n\n           # we check if the prefix and suffix agrees, if yes, we find yet another longer prefix, so we record the index\n            if l == r: res = i + 1\n\n       # after we finish searching the string, output the prefix\n        return s[:res]",
    "",
    "",
    "class Solution {\npublic:\n    string longestPrefix(string s) {\n        int n=s.size();\n        vector<int> lps(n,0);\n        int i=1,len=0;\n        while(i<n){\n            if(s[i]==s[len]){\n                len++;\n                lps[i]=len;\n                i++;\n            }\n            else{\n                if(len>0){\n                    len=lps[len-1];\n                }\n                else{\n                    lps[i]=0;\n                    i++;\n                }\n            }\n        }\n        return s.substr(0,lps[n-1]);\n    }\n};",
    "class Solution {\n    public String longestPrefix(String s) {\n        int[] pref = new int[s.length()];\n        Arrays.fill(pref, -1);\n        int i = 1, j = 0;\n        int max = -1;\n        while (i < s.length()) {\n            if (s.charAt(i) == s.charAt(j)) {\n                pref[i] = j;\n                i++;\n                j++;\n            } else if (j > 0) {\n                j = pref[j - 1] + 1;\n            } else {\n                i++;\n            }\n        }\n        max = pref[s.length() - 1];\n        return s.substring(0, max + 1);\n    }\n}"
]