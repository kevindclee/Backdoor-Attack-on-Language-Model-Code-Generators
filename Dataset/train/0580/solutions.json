[
    "    public String reorganizeString(String S) {\n        int[] hash = new int[26];\n        for (int i = 0; i < S.length(); i++) {\n            hash[S.charAt(i) - 'a']++;\n        } \n        int max = 0, letter = 0;\n        for (int i = 0; i < hash.length; i++) {\n            if (hash[i] > max) {\n                max = hash[i];\n                letter = i;\n            }\n        }\n        if (max > (S.length() + 1) / 2) {\n            return \"\"; \n        }\n        char[] res = new char[S.length()];\n        int idx = 0;\n        while (hash[letter] > 0) {\n            res[idx] = (char) (letter + 'a');\n            idx += 2;\n            hash[letter]--;\n        }\n        for (int i = 0; i < hash.length; i++) {\n            while (hash[i] > 0) {\n                if (idx >= res.length) {\n                    idx = 1;\n                }\n                res[idx] = (char) (i + 'a');\n                idx += 2;\n                hash[i]--;\n            }\n        }\n        return String.valueOf(res);\n    }",
    "    count=collections.Counter(S).most_common()\n    N=len(S)\n    if count[0][1]>(N+1)//2:return ''\n    ans=['']*N\n    i=0\n    for letter,cnt in count:\n        for c in range(cnt):\n            ans[i]=letter\n            i+=2",
    " def reorganizeString(self, S):\n        res, c = [], Counter(S)\n        pq = [(-value,key) for key,value in c.items()]\n        heapq.heapify(pq)\n        p_a, p_b = 0, ''\n        while pq:\n            a, b = heapq.heappop(pq)\n            res += [b]\n            if p_a < 0:\n                heapq.heappush(pq, (p_a, p_b))\n            a += 1\n            p_a, p_b = a, b\n        res = ''.join(res)\n        if len(res) != len(S): return \"\"\n        return res",
    "class Solution(object):\n    def reorganizeString(self, S):\n        pq = [(-S.count(x), x) for x in set(S)]\n        heapq.heapify(pq)\n        if any(-nc > (len(S) + 1) / 2 for nc, x in pq):\n            return \"\"\n\n        ans = []",
    "def reorganizeString(self, S):\n    a = sorted(sorted(S), key=S.count)\n    h = len(a) / 2\n    a[1::2], a[::2] = a[:h], a[h:]\n    return ''.join(a) * (a[-1:] != a[-2:-1])",
    "",
    "def reorganizeString(S):   \n if not S:\n  return \"\"\n # Build freq dict:\n d = {}\n for c in S:\n  if c in d:\n   d[c] += 1\n  else:\n   d[c] = 1\n\n # push (-ve frq, char) pairs into heap\n h = []\n from heapq import heappush, heappop\n for k in d:\n  heappush(h, (-d[k], k))\n\n res = \"\"\n # pop and examine frq and append to res\n while len(h) > 1:        # -------------------------------- NOTE [1]\n  f1, c1 = heappop(h)\n  f2, c2 = heappop(h)\n\n  res += c1\n  res += c2\n\n  if abs(f1) > 1: # if char repeats\n   heappush(h, (f1+1, c1)) # push back with decrement frq\n\n  if abs(f2) > 1: \n   heappush(h, (f2+1, c2)) # push back with decrement frq\n\n\n if h:     # -------------------------------- NOTE [2]\n  f, c = h[0]\n  if abs(f) > 1: \n   return \"\" # this means we have something like h = [(2, \"a\")] which means there is no escape from repeating same char in text\n  else:\n   res += c\n return res",
    "class Solution(object):\n    def reorganizeString(self, s):\n        sk=\"\"\n        l1={}\n        #used dictionary to get count of items \n        for i in s:\n            l1[i]=l1.get(i,0)+1\n        #Using heapsort to sort the key,value pair in descending order based on value pair\n        l2=[]\n        for i,j in l1.items():\n            heapq.heappush(l2,(-j,i))\n        \n        curr=\"\"\n        #curr is pointer to check if there is no repeation.\n        while(l2):\n            srk,ks=heapq.heappop(l2)\n            #It will check whether the current pointer is not same as the ks .\n            if(srk<0 and curr!=ks):\n                curr=ks\n                sk+=ks\n                srk+=1\n                if srk<0:\n                    heapq.heappush(l2,(srk,ks))\n            #If current pointer is same as ks then it will pop second element from the heap if it exists.\n            elif(l2):\n                srk2,ks2=heapq.heappop(l2)\n                heapq.heappush(l2,(srk,ks))\n                curr=ks2\n                sk+=ks2\n                srk2+=1\n                if srk2<0:\n                    heapq.heappush(l2,(srk2,ks2))\n        \n        if(len(sk)!=len(s)):\n            return \"\"\n        return sk"
]