[
    "  # O(n**2) time, O(n**2) space\n  def fourSumCount(self, A, B, C, D):\n    count = 0\n    num_dict = {}\n    for i in C:\n      for j in D:\n        s = i + j\n        if s in num_dict:\n          num_dict[s] += 1",
    "public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\n    Map<Integer, Integer> map = new HashMap<>();\n    \n    for(int i=0; i<C.length; i++) {\n        for(int j=0; j<D.length; j++) {\n            int sum = C[i] + D[j];\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\n        }\n    }\n    \n    int res=0;\n    for(int i=0; i<A.length; i++) {\n        for(int j=0; j<B.length; j++) {\n            res += map.getOrDefault(-1 * (A[i]+B[j]), 0);\n        }\n    }\n    \n    return res;\n}\n\nTime complexity:  O(n^2)\nSpace complexity: O(n^2)",
    "    for (int a = 0; a < A.size(); a++) \n        for (int b = 0; b < B.size(); b++)\n            for (int c = 0; c < C.size(); c++)\n                for (int d = 0; d < D.size(); d++)    \n                     if (A[a] + B[b] + C[c] + D[d] == 0)",
    "What the question is saying, \nGiven four integer arrays nums1, nums2, nums3, and nums4 all of length n, \nreturn the number of tuples (i, j, k, l) such that their sum of nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0",
    "class Solution {\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int k : nums3)\n            for(int l : nums4)\n                map.put(k + l, map.getOrDefault(k + l, 0) + 1);\n        int count = 0;\n        for(int i : nums1)\n            for(int j : nums2)\n                        count += map.getOrDefault(-(i + j), 0);\n        return count;\n    }\n}",
    " map.put(k + l, map.getOrDefault(k + l, 0) + 1);",
    "          map.merge(l1 + l2, 1, Integer::sum);",
    "",
    "    def fourSumCount(self, nums1, nums2, nums3, nums4):\n        seen = Counter(n3 + n4 for n3, n4 in product(nums3, nums4))\n        return sum(seen[-(n1 + n2)] for n1, n2 in product(nums1, nums2))",
    "nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\n\nIterated over nums1 and nums2, pairSums = {1 + (-2), 1 + (-1), 2 + (-2), 2 + (-1)}\n= {-1, 0, 0, 1}\npairCountBySum = {-1 : 1, 0 : 2, 1 : 1}, i.e. there is 1 pair with sum = 1, 2 pairs with sum = 0, 1 pair with sum = -1\n\nIterated over nums3 and nums4, pairSums = {-1 + 0, -1 + 2, 2 + 0, 2 + 2}\n= {-1, 1, 2, 4}\nNegate this to be able to find -(c + d)\n= {1, -1, -2, -4}\n\nUse the hashMap pairCountBySum = {-1 : 1, 0 : 2, 1 : 1} for each item in {1, -1, -2, -4}\n\nfourSumCount = 0\nfourSumCount += map.get(1)  \u21d2 fourSumCount = 0 + 1 = 1\nfourSumCount += map.get(-1) \u21d2 fourSumCount = 1 + 1 = 2\nfourSumCount += map.get(-2) \u21d2 fourSumCount = 2 + 0 = 2\nfourSumCount += map.get(-4) \u21d2 fourSumCount = 2 + 0 = 2\n\nNumber of tuples = 2 [Ans]",
    "// Tc  O(n^2);\n// Sc O(n^2); \n\nclass Solution {\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        \n        HashMap<Integer,Integer> map = new HashMap<>();\n        \n        for(int n1 :nums1){\n            for(int n2:nums2){\n                int sum = n1+n2;\n                map.put(-sum,map.getOrDefault(-sum,0)+1);\n            }\n        }\n        int tuple_Count =0;\n        for(int n3 :nums3){\n            for(int n4:nums4){\n                int sum = n3+n4;\n               tuple_Count+=map.getOrDefault(sum,0);\n            }\n        }\n        return tuple_Count;\n    }\n}"
]