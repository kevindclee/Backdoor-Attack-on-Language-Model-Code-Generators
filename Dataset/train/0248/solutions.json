[
    "for (int j = 0; j < primes.length; j++) {\n    while (primes[j] * ugly[idx[j]] <= ugly[i]) idx[j]++;\n}",
    "dp = [1, 2, 4] # the numbers we have found\n\n# the index of the factors we choose from dp to multiply primes\n# e.g if we choose nth number as ugly number, then, index[n-1] += 1\n# so index will move to the right, which means we will replace the number\nindex = [2, 0, 0, 0]\n\n# ** number ** means we will choose this number\nugly_nums = [ 2 x dp[index[0]], **7 x dp[index[1]]**, 13 x dp[index[2]], 19 x dp[index[3]] ]",
    "class Solution(object):\n    def nthSuperUglyNumber(self, n, primes):\n        size = len(primes)\n        ugly, dp, index, ugly_nums = 1, [1], [0] * size, [1] * size\n        for i in range(1, n):\n            # compute possibly ugly numbers and update index\n            for j in range(0, size):\n                if ugly_nums[j] == ugly:\n                    ugly_nums[j] = dp[index[j]] * primes[j]\n                    index[j] += 1\n            # get the minimum\n            ugly = min(ugly_nums)\n            dp.append(ugly)\n        return dp[-1]",
    "def nthSuperUglyNumber(self, n, primes):\n    uglies = [1]\n    def gen(prime):\n        for ugly in uglies:\n            yield ugly * prime\n    merged = heapq.merge(*map(gen, primes))\n    while len(uglies) < n:\n        ugly = next(merged)\n        if ugly != uglies[-1]:\n            uglies.append(ugly)\n    return uglies[-1]",
    "def nthSuperUglyNumber(self, n, primes):\n    uglies = [1]\n    merged = heapq.merge(*map(lambda p: (u*p for u in uglies), primes))\n    uniqed = (u for u, _ in itertools.groupby(merged))\n    map(uglies.append, itertools.islice(uniqed, n-1))\n    return uglies[-1]",
    ">>> import heapq \n>>> type(heapq.merge())",
    "",
    "",
    "",
    "def gen(seq, prime):\n    for x in seq: yield x * prime\nseq = [1]\ngens = map(gen, seq) # = [gen2, gen3, gen5]\npool = heapq.merge(*gens)",
    ">>> import heapq\n>>> lists = [1, 3, 5], [2, 4, 6]\n\n>>> list(heapq.merge(lists))\n[[1, 3, 5], [2, 4, 6]]\n\n>>> list(heapq.merge(*lists))\n[1, 2, 3, 4, 5, 6]",
    "def nthSuperUglyNumber(self, n, primes):\n        indexs, uglies = [0] * len(primes), [1]\n        while len(uglies) < n:\n            uglies.append(min([p * uglies[indexs[i]] for i, p in enumerate(primes)]))\n            for i, p in enumerate(primes):\n                if p * uglies[indexs[i]] == uglies[-1]:\n                    indexs[i] += 1",
    "public int nthSuperUglyNumber(int n, int[] primes) {\n        int[] ugly = new int[n+1];\n        ugly[0]=1;\n        int[] pointer = new int[primes.length];\n        for(int i=1;i<n;i++) {\n            int min=Integer.MAX_VALUE;\n            int minIndex = 0;\n            for(int j=0;j<primes.length;j++) {\n                if(ugly[pointer[j]]*primes[j]<min) {\n                    min=ugly[pointer[j]]*primes[j];\n                    minIndex = j;\n                }else if(ugly[pointer[j]]*primes[j]==min) {\n                    pointer[j]++;\n                }\n            }\n            ugly[i]=min;\n            pointer[minIndex]++;\n        }\n        return ugly[n-1];\n    }",
    "    def nthSuperUglyNumber(self, n, primes):\n        ugly = [1]\n        pointers = [0]*len(primes)\n        \n        for i in range(1,n):\n            minu = float(\"inf\")\n            minIndex = 0",
    "def nthSuperUglyNumber(n, primes):\n cand = [(p, p, 1) for p in primes]\n ugly = [1]\n for _ in range(n-1):\n  ugly.append(cand[0][0])\n  while cand[0][0] == ugly[-1]:\n   x, p, i = heapq.heappop(cand)\n   heapq.heappush(cand, (p*ugly[i], p, i+1))\n return ugly[-1]"
]