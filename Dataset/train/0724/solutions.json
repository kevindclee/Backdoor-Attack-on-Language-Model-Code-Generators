[
    "public int partitionDisjoint(int[] a) {\n        int localMax = a[0], partitionIdx = 0, max = localMax;\n        for (int i = 1; i < a.length; i++)\n            if (localMax > a[i]) {\n                localMax = max;\n                partitionIdx = i;\n            } else max = Math.max(max, a[i]);\n        return partitionIdx + 1;\n    }",
    "public int partitionDisjoint(int[] A) {\n        int n = A.length, ltr[] = new int[n], rtl[] = new int[n], max = -1, min = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            max = Math.max(max, A[i]);\n            ltr[i] = max;\n            min = Math.min(min, A[n - 1 - i]);\n            rtl[n - 1 - i] = min;",
    "def partitionDisjoint(self, A):\n        disjoint = 0\n        v = A[disjoint]\n        max_so_far = v\n        for i in range(len(A)):\n            max_so_far = max(max_so_far, A[i])\n            if A[i] < v: \n                disjoint = i\n                v = max_so_far\n        return disjoint + 1\n   ",
    "public int partitionDisjoint(int[] A) {\n        int[] lmax=new int[A.length]; //lmax :left maximum\n        int[] rmin=new int[A.length]; //rmin : right minimum\n        \n        int max=Integer.MIN_VALUE;\n        for(int i=0;i<A.length;i++){\n            max=Math.max(max,A[i]);\n            lmax[i]=max;\n        }\n        \n        int min=Integer.MAX_VALUE;\n        for(int i=A.length-1;i>=0;i--){\n            min=Math.min(min,A[i]);\n            rmin[i]=min;\n        }\n        \n        for(int i=1;i<A.length;i++){\n            if(lmax[i-1]<=rmin[i]) return i;\n        }\n        return A.length;\n    }",
    "public int partitionDisjoint(int[] a) {\n        int len = a.length;\n        if (len == 2)\n            return 1;\n        int[] minFromRight = new int[len];\n        minFromRight[len-1] = a[len-1];\n        for (int i = a.length-2; i > 0; i--) {\n            minFromRight[i] = Math.min(minFromRight[i+1], a[i]);",
    "class Solution:\n    def partitionDisjoint(self, A):\n        t1 = list(accumulate(A, max)) \n        t2 = list(accumulate(A[::-1], min))[::-1]\n        for i in range(1, len(A)):\n            if t1[i-1] <= t2[i]: return i",
    "class Solution:\n    def partitionDisjoint(self, A):\n        t1 = list(accumulate(A, max)) \n        t2 = list(accumulate(A[::-1], min))[::-1]\n        return next(i for i in range(1, len(A)) if t1[i-1] <= t2[i])",
    "public int partitionDisjoint(int[] nums) {\n        int i = 0, j = 0, max = nums[i];     \n        while(++j < nums.length){ \n            if(max > nums[j]){\n                while(i!=j) max = Math.max(max, nums[i++]);\n            }\n        }\n        return i+1;",
    "class Solution {\n    public int partitionDisjoint(int[] nums) {\n        int maxLeft = nums[0];\n        int max = nums[0];\n        int p = 0;\n        for(int i=1;i<nums.length;i++){\n            if(nums[i]<maxLeft){\n                maxLeft = max;\n                p=i;\n            } else if(max<nums[i]) {\n                max=nums[i];\n            }\n        }\n        \n        return p+1;\n    }\n}",
    " int partitionDisjoint(vector<int>& nums) {\n        \n        int n=nums.size(),left[n],right[n];\n        \n// Step 1 left se maximum nikalo .left[i]=max from left till i\n        left[0]=nums[0];\n        for(int i=1;i<n;i++)\n            left[i]=max(left[i-1],nums[i]);\n        \n// Step 2 right se min nikalo .right[i]=min from end to ith index   \n        right[n-1]=nums[n-1];\n        for(int i=n-2;i>=0;i--)\n            right[i]=min(right[i+1],nums[i]);\n     \n// Step 3 kaunsa i esa jaha tk ka max chota hai (i+1) wale minimum se vo hi answer hai \n        for(int i=0;i<n-1;i++)\n            if(left[i]<=right[i+1])\n                return i+1;\n        \n        return -1;  //this never gets executed as partition is guaranteed\n        \n    }"
]