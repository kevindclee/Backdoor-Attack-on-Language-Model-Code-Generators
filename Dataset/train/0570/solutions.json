[
    "class Solution(object):\n    def crackSafe(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        ans = \"0\" * (n - 1)\n        visits = set()\n        for x in range(k ** n):\n            current = ans[-n+1:] if n > 1 else ''\n            for y in range(k - 1, -1, -1):\n                if current + str(y) not in visits:\n                    visits.add(current + str(y))\n                    ans += str(y)\n                    break\n        return ans",
    "import collections\nso = Solution()\nfor n in range(1, 5):\n    for k in range(1, 11):\n        if k ** n > 4096: continue\n        ans = so.crackSafe(n, k)\n        vset = set(ans[x : x + n] for x in range(len(ans) - n + 1))\n        print 'k =', k, ' n =', n\n        print len(ans), len(vset), sorted(collections.Counter(ans).items()), '\\n'",
    "def crackSafe(self, n, k):\n    s = '0' * (n - 1)\n    D = '9876543210'[-k:]\n    for _ in range(k**n):\n        s += next(d for d in D if (s + d)[-n:] not in s)\n    return s",
    "class Solution(object): # best 24 ms\n    def crackSafe(self, n, k):\n        # n: length of password\n        # k: kinds of digits (0,1,2....)\n        \n        if n == 1: return \"\".join(str(i) for i in range(k))\n        if k == 1: return \"0\" * n\n\n        suffixMap = {}\n        allCombination = \"0\" * (n-1)\n\n        for _ in range(k**n):\n            # get suffix\n            suffix = allCombination[1-n:]\n            # create suffix map, value is k - 1 or update previous value - 1\n            suffixMap[suffix] = suffixMap.get(suffix, k) - 1\n            # add new suffix\n            allCombination += str(suffixMap[suffix])\n\n        return allCombination"
]