[
    "    def numDupDigitsAtMostN(self, N):\n        L = list(map(int, str(N + 1)))\n        n = len(L)\n        res = sum(9 * perm(9, i) for i in range(n - 1))\n        s = set()\n        for i, x in enumerate(L):\n            for y in range(i == 0, x):\n                if y not in s:\n                    res += perm(9 - i, n - i - 1)\n            if x in s: break\n            s.add(x)\n        return N - res",
    "Input: 20\nOutput: 1\nExplanation: The only positive number (<= 20) with at least 1 repeated digit is 11.",
    "# given number n, see whether n has repeated number\ndef has_repeated(n):\n    str_n = str(n)\n    return len(set(str_n)) != len(str_n)\n\ndef permutation(n, k):\n    prod = 1\n    for i in range(k):\n        prod *= (n-i)\n    return prod\n\n# calculate number of non-repeated n-digit numbers\n# note: the n-digit number can't start with 0\n# i.e: n_digit_no_repeat(2) calculates the non-repeated\n#   numbers in range [10, 99] (inclusive)\ndef n_digit_no_repeat(n):\n    if n == 1:\n        return 9\n    else:\n        return  9 * permutation(9, n-1)\n\nclass Solution(object):\n    def numDupDigitsAtMostN(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"        \n        N_str = str(N)\n        n_digit = len(N_str)\n        digits = map(int, N_str)\n        result = N - 1\n        prefix = 0\n        for i in range(1, n_digit):\n            result -= n_digit_no_repeat(i)\n        for i in range(n_digit):\n            # when we fix the most significant digit, it \n            # can't be zero\n            start = 0 if i else 1\n            for j in range(start, digits[i]):\n                if has_repeated(prefix * 10 + j):\n                    continue\n                if i != n_digit-1:\n                    result -= permutation(10-i-1, n_digit-1-i)\n                else:\n                    # optmized from `result -= has_repeated(prefix*10+j)`\n                    result -= 1\n            prefix = prefix*10 + digits[i]\n        return result + has_repeated(N)",
    "class Solution(object):\n    def numDupDigitsAtMostN(self, n):\n        l = map(int,list(str(n)))\n        return n - self.f([],l) - self.g(l)\n    \n    \n\n[len(cur)] + 1) if v not in cur] or [0])",
    "public int numDupDigitsAtMostN(int n) {\n String str = String.valueOf(n+1);\n int len = str.length();\n \n int unique = 0;\n for (int i = 1; i < len; i++) {\n  unique += totalNoRepeat(i);\n }\n\n Set<Integer> set = new HashSet<>();\n int i = 0;\n for (i = 0; i < len; i++) {\n  int d = str.charAt(i) - '0';\n\n  int temp = pivotChoice(set, d, i == 0);\n  for (int j = i+1; j < len; j++) {\n   temp *= (10 - j);\n  }\n\n  unique += temp;\n  if (!set.add(d)) break;      \n }\n return n - unique;\n}"
]