[
    "Input: m = 3, n = 3, k = 5\nOutput: 3\nExplanation: \nThe Multiplication Table:\n1 2 3\n2 4 6\n3 6 9\n\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).",
    "Input: n = 3, a = 2, b = 3, c = 5\nOutput: 4\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.",
    "Input: n = 4, a = 2, b = 3, c = 4\nOutput: 6\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.",
    "Input: nums = [1,2,5,9], threshold = 6\nOutput: 5\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \nIf the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). ",
    "    # count number of pairs smaller than target\n        def countPair(self, target, nums):\n            left = 0\n            count =  0\n            for i in range(len(nums)):\n                while nums[i] - nums[left] > target:\n                    left += 1\n                count += i - left",
    "def smallestDistancePair(nums, k):\n    # Return: Is there k or more pairs with distance <= guess? i.e. are\n    # there enough?\n    def possible(guess_dist):\n        i = count = 0\n        j = 1\n        # Notice that we never decrement j or i.\n        while i < len(nums):\n            # If the distance calculated from j-i is less than the guess,\n            # increase the window on `j` side.\n            while (j < len(nums)) and ((nums[j] - nums[i]) <= guess_dist):\n                j += 1\n            # Count all places between j and i\n            count += j - i - 1\n            i += 1\n        return count >= k\n\n    nums.sort()\n    lo = 0\n    hi = nums[-1] - nums[0]\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        # If `mid` produced `k` or more results we know it's the upper bound.\n        if possible(mid):\n            # We don't set to `mid - 1` because we found a number of distances\n            # bigger than *or equal* to `k`. If this `mid` ends up being\n            # actually equal to `k` then it's a correct guess, so let's leave it within\n            # the guess space.\n            hi = mid\n        # If `mid` did not produce enouh results, let's increase  the guess\n        # space and try a higher number.\n        else:\n            lo = mid + 1\n\n    # `lo` ends up being an actual distance in the input, because\n    # the binary search mechanism waits until the exact lo/hi combo where\n    # 2nd to last `mid` did not produce enough results (k or more), but\n    # the last `mid` did.\n    return lo"
]