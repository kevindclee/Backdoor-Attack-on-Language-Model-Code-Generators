[
    "    def numBusesToDestination(self, routes, S, T):\n        to_routes = collections.defaultdict(set)\n        for i, route in enumerate(routes):\n            for j in route:\n                to_routes[j].add(i)\n        bfs = [(S, 0)]\n        seen = set([S])\n        for stop, bus in bfs:\n            if stop == T: return bus\n            for i in to_routes[stop]:\n                for j in routes[i]:\n                    if j not in seen:\n                        bfs.append((j, bus + 1))\n                        seen.add(j)\n                routes[i] = []  # seen route\n        return -1",
    "class Solution:\n    def numBusesToDestination(self, routes, S, T):\n        \"\"\"\n        :type routes: List[List[int]]\n        :type S: int\n        :type T: int\n        :rtype: int\n        \"\"\"",
    "# Reference: https://leetcode.com/problems/bus-routes/discuss/122712/Simple-Java-Solution-using-BFS\nfrom collections import deque\nclass Solution:\n    # This is a very good BFS problem.\n    # In BFS, we need to traverse all positions in each level firstly, and then go to the next level.\n    # Our task is to figure out:\n    # 1. What is the level in this problem?\n    # 2. What is the position we want in this problem?\n    # 3. How to traverse all positions in a level?\n    # \n    # For this problem:\n    # 1. The level is each time to take bus.\n    # 2. The position is all of the stops you can reach for taking one time of bus.\n    # 3. Using a queue to record all of the stops can be arrived for each time you take buses.\n    def numBusesToDestination(self, routes, S, T):\n        \"\"\"\n        :type routes: List[List[int]]\n        :type S: int\n        :type T: int\n        :rtype: int\n        \"\"\"\n        # You already at the terminal, so you needn't take any bus.\n        if S == T: return 0\n        \n        # You need to record all the buses you can take at each stop so that you can find out all\n        # of the stops you can reach when you take one time of bus.\n        # the key is stop and the value is all of the buses you can take at this stop.\n        stopBoard = {} \n        for bus, stops in enumerate(routes):\n            for stop in stops:\n                if stop not in stopBoard:\n                    stopBoard[stop] = [bus]\n                else:\n                    stopBoard[stop].append(bus)\n        \n        # The queue is to record all of the stops you can reach when you take one time of bus.\n        queue = deque([S])\n        # Using visited to record the buses that have been taken before, because you needn't to take them again.\n        visited = set()\n\n        res = 0\n        while queue:\n            # take one time of bus.\n            res += 1\n            # In order to traverse all of the stops you can reach for this time, you have to traverse\n            # all of the stops you can reach in last time.\n            pre_num_stops = len(queue)\n            for _ in range(pre_num_stops):\n                curStop = queue.popleft()\n                # Each stop you can take at least one bus, you need to traverse all of the buses at this stop\n                # in order to get all of the stops can be reach at this time.\n                for bus in stopBoard[curStop]:\n                    # if the bus you have taken before, you needn't take it again.\n                    if bus in visited: continue\n                    visited.add(bus)\n                    for stop in routes[bus]:\n                        if stop == T: return res\n                        queue.append(stop)\n        return -1"
]