[
    "int tmp = grid[row][col];\n.....\ngrid[row][col] = tmp;",
    "      grid[row][col] = 0;\n      cherries = Math.max(cherryPickup(grid, dir, row + dir[0][0], col + dir[0][1], cherries + grid[row][col], isDown),\n          cherryPickup(grid, dir, row + dir[1][0], col + dir[1][1], cherries + grid[row][col], isDown));",
    "def cherryPickup(self, grid):\n    \"\"\"\n    :type grid: List[List[int]]\n    :rtype: int\n    \"\"\"\n    f = {} # memo",
    "    def cherryPickup(self, grid):\n        N = len(grid)\n        lookup = {}\n        \n        def solve(x1, y1, x2, y2):\n            # check if we reached bottom right corner\n            if x1 == N-1 and y1 == N-1: \n                return grid[x1][y1] if grid[x1][y1] != -1 else float(\"-inf\")\n            \n            # out of the grid and thorn check\n            if x1 == N or y1 == N or x2 == N or y2 == N or grid[x1][y1] == -1 or grid[x2][y2] == -1: \n                return float(\"-inf\")\n            \n   # memorization check\n            lookup_key = (x1, y1, x2, y2)\n            if lookup_key in lookup: return lookup[lookup_key]\n            \n   # pick your cherries\n            if x1 == x2 and y1 == y2:\n                cherries = grid[x1][y1]\n            else:\n                cherries = grid[x1][y1] + grid[x2][y2]\n                \n            res = cherries + max(\n                solve(x1 + 1, y1, x2 + 1, y2),  # right, right\n                solve(x1, y1 + 1, x2, y2 + 1),  # down, down\n                solve(x1 + 1, y1, x2, y2 + 1),  # right, down\n                solve(x1, y1 + 1, x2 + 1, y2), # down, right\n            )\n            \n            lookup[lookup_key] = res\n            return res\n        \n        res = solve(0, 0, 0, 0)\n        return res if res > 0 else 0",
    "class Solution:\n    def cherryPickup(self, grid):\n        N = len(grid)\n        THORN = -1\n        # Key takeaway, have two people moving at a time\n        @lru_cache(None)"
]