[
    "class Solution(object):\n\n    def pyramidTransition(self, bottom, allowed):\n        f = collections.defaultdict(lambda: defaultdict(list))\n        for a, b, c in allowed: f[a][b].append(c)\n\n        def pyramid(bottom):\n            if len(bottom) == 1: return True\n            for i in itertools.product(*(f[a][b] for a, b in zip(bottom, bottom[1:]))):\n                if pyramid(i): return True\n            return False\n        return pyramid(bottom)",
    "def pyramid(bottom):\n            return len(bottom) == 1 or any(pyramid(i) for i in product(*(f[a][b] for a, b in zip(bottom, bottom[1:]))))",
    "class Solution(object):\n    def pyramidTransition(self,bottom,allowed):\n        \"\"\"\n        :type bottom: str\n        :type allowed: List[str]\n        :rtype: bool\n        \"\"\"\n        pool=defaultdict(list)",
    "class Solution(object):\n    def pyramidTransition(self, bottom, allowed):\n        f = collections.defaultdict(lambda: collections.defaultdict(list))\n][b] for a, b in zip(bottom, bottom[1:]))))",
    "class Solution(object):\n    def pyramidTransition(self, bottom, allowed):\n        f = collections.defaultdict(lambda: collections.defaultdict(list))\n        for a, b, c in allowed: f[a][b].append(c)\n            \n        def pyramid(bottom):\n            if len(bottom) == 1:",
    "class Solution(object):\n    def pyramidTransition(self, bottom, allowed):\n        d = collections.defaultdict(set)\n        for a, b, c in allowed:\n            d[a, b].add(c)\n        stack = [{b} for b in bottom]\n        for _ in xrange(len(stack) - 1):\n            nextStack = [set() for _ in xrange(len(stack) - 1)]",
    "class Solution(object):\n    def pyramidTransition(self, bottom, allowed):\n        \"\"\"\n        :type bottom: str\n        :type allowed: List[str]\n        :rtype: bool    \n        \"\"\"\n        dic = defaultdict(list)\n        for i in allowed:\n            dic[(i[0], i[1])].append(i[2])\n        \n        res = []\n        \n        def dfs(arr, nxt):\n            #base case second floor and check top exists\n            if len(arr) == 2 and dic[(arr[0], arr[1])]:\n                return True\n            \n            #go to the next row now\n            if len(arr) == len(nxt) + 1:\n                return dfs(nxt, [])\n\n            #keep iterating the same row\n            if dic[(arr[len(nxt)], arr[len(nxt) + 1])]:\n                for val in dic[(arr[len(nxt)], arr[len(nxt) + 1])]:\n                    if dfs(arr, nxt + [val]):\n                        return True\n            return False\n        \n        return dfs(bottom, [])",
    "class Solution(object):\n    def pyramidTransition(self, bottom, allowed):\n        \"\"\"\n        :type bottom: str\n        :type allowed: List[str]\n        :rtype: bool\n        \"\"\"\n        dic = defaultdict(list)\n        for i in allowed:\n            dic[(i[0], i[1])].append(i[2])\n        \n        res = []\n        visited = set()\n        def dfs(arr, nxt):\n            #base case second floor and check top exists\n            if len(arr) == 2 and dic[(arr[0], arr[1])]:\n                return True\n            \n            #go to the next row now\n            if len(arr) == len(nxt) + 1:\n                if tuple(nxt) in visited:\n                    return False\n                visited.add(tuple(nxt))\n                return dfs(nxt, [])\n\n            #keep iterating the same row\n            if dic[(arr[len(nxt)], arr[len(nxt) + 1])]:\n                for val in dic[(arr[len(nxt)], arr[len(nxt) + 1])]:\n                    if dfs(arr, nxt + [val]):\n                        return True\n            return False\n        \n        return dfs(bottom, [])"
]