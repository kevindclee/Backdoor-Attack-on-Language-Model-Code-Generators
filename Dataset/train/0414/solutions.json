[
    "def findLongestWord(self, s, d):\n    def isSubsequence(x):\n        it = iter(s)\n        return all(c in it for c in x)\n    return max(sorted(filter(isSubsequence, d)) + [''], key=len)",
    "def findLongestWord(self, s, d):\n    def isSubsequence(x):\n        it = iter(s)\n        return all(c in it for c in x)\n    return min(filter(isSubsequence, d) + [''], key=lambda x: (-len(x), x))",
    "def findLongestWord(self, s, d):\n    best = ''\n    for x in d:\n        if (-len(x), x) < (-len(best), best):\n            it = iter(s)\n            if all(c in it for c in x):\n                best = x\n    return best",
    "def findLongestWord(self, s, d):\n    def isSubsequence(x):\n        it = iter(s)\n        return all(c in it for c in x)\n    d.sort(key=lambda x: (-len(x), x))\n    return next(itertools.ifilter(isSubsequence, d), '')",
    "def findLongestWord(self, s, d):\n    for x in sorted(d, key=lambda x: (-len(x), x)):\n        it = iter(s)\n        if all(c in it for c in x):\n            return x\n    return ''",
    "def findLongestWord(self, s, d):\n    heap = [(-len(word), word) for word in d]\n    heapq.heapify(heap)\n    while heap:\n        word = heapq.heappop(heap)[1]\n        it = iter(s)\n        if all(c in it for c in word):\n            return word\n    return ''",
    "def findLongestWord(self, S, D):\n    D.sort(key = lambda x: (-len(x), x))\n    for word in D:\n        i = 0\n        for c in S:\n            if i < len(word) and word[i] == c:\n                i += 1\n        if i == len(word):\n            return word\n    return \"\"",
    "def findLongestWord(self, s, d):\n        for word in sorted(d, key = lambda w: (-len(w), w)):\n            it = iter(s)\n            if all(c in it for c in word): return word\n        return ''",
    "class Solution(object):\n    def findLongestWord(self, s, d):\n        \"\"\"\n        :type s: str\n        :type d: List[str]\n        :rtype: str\n        \"\"\"\n        def is_subsequence(s,t):",
    "class Solution:\n    def findLongestWord(self, s, d):\n        def isSubsequence(x):\n            return all(c in iter(s) for c in x)\n        return max(sorted(filter(isSubsequence, d)) + [''], key=len)",
    "class Solution:\n    def isSubsequence(self, s, t):\n        s_i, t_i = 0, 0\n        while s_i < len(s) and t_i < len(t):\n            s_i, t_i = s_i + (s[s_i] == t[t_i]), t_i + 1\n        return s_i == len(s)\n    \n    def findLongestWord(self, s, d):\n        ans = \"\"\n        for string in d:\n            if self.isSubsequence(string, s):\n                ans = min(ans, string, key = lambda x: (-len(x), x))\n        return ans",
    "class Solution(object):\n    def findLongestWord(self, s, dictionary):\n        \"\"\"\n        :type s: str\n        :type dictionary: List[str]\n        :rtype: str\n        \"\"\"\n        mx=0\n        lst=[]\n        for i in dictionary:\n            if i==s:\n                lst.append([i,len(i)])\n                mx=max(len(i),mx)\n            else:\n                st=\"\"\n                s1,s2=0,0\n                while s1<len(s) and s2<len(i):\n                    if s[s1]==i[s2]:\n                        st+=i[s2]\n                        s2+=1\n                        s1+=1\n                    else:\n                        s1+=1\n                if len(st)==len(i):\n                    lst.append([st,len(i)])\n                    mx=max(len(i),mx)\n        lst.sort(key=itemgetter(0),reverse=True)\n        val=[]\n        for i in lst:\n            if i[1]==mx:\n                val.append(i[0])\n        val.sort()\n        if lst:return val[0]\n        return \"\"",
    "#AA#> Two level Sort of words: 1st length, 2nd lexiographic order \ndictionary.sort(key = lambda x: (-len(x),x))\nfor word in dictionary:\n j = 0 #AA#> word pointer\n for i in range(len(s)): #AA#> string pointer\n  if s[i] == word[j]: j+=1\n\n  if j == len(word): return word\n\nreturn ''"
]