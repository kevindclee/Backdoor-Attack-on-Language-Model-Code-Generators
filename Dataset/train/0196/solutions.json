[
    "    def maximalSquare(self, matrix):\n        if not matrix:\n            return 0\n        \n        dp = [0] * (len(matrix[0])+1)\n        maxLen = prev = 0",
    "    if(matrix.length == 0) return 0;\n    \n    int m = matrix.length, n = matrix[0].length;\n    int max = Integer.MIN_VALUE;\n    \n    for(int j = 0; j < n && max != 1; ++j) if(matrix[0][j] == '1') max = 1; \n    for(int i = 1; i < m && max != 1; ++i) if(matrix[i][0] == '1') max = 1;\n    \n[i][j-1] - '0')) + 1;",
    "    public int maximalSquare(char[][] matrix) {\n        if (matrix == null || matrix.length == 0) {\n            return 0;\n        }\n        int row = matrix.length, col = matrix[0].length;\n        int[][] dp = new int[row][col];\n        int len = 0;\n        for (int i = 0; i < row; i++) {\n+ 1;",
    "class Solution:\n    def maximalSquare(self, M):\n        def is_valid_sqaure(row, col, side):\n            return all(all(M[i][j] == '1' for j in range(col, col+side)) for i in range(row, row+side))\n        m, n = len(M), len(M[0])\n        for side_len in range(min(m,n), 0, -1):\n            for row in range(m - side_len + 1):\n                for col in range(n - side_len + 1):\n                    if is_valid_sqaure(row, col, side_len):\n                        return side_len**2\n        return 0",
    "class Solution:\n    def maximalSquare(self, M):\n        m, n, ans = len(M), len(M[0]), 0\n        def get_max_square_len(row, col):\n            all_ones_row_len, sq_len, i, j = min(m-row, n-col), 0, 0, 0\n            while i < all_ones_row_len:\n                j = 0\n                while j < all_ones_row_len and M[i+row][j+col] != '0': \n                    j += 1\n                all_ones_row_len = j\n                sq_len = min(all_ones_row_len, i := i + 1)\n            return sq_len\n        \n        for row in range(m):\n            for col in range(n):\n                ans = max(ans, get_max_square_len(row, col))\n        return ans * ans",
    "class Solution:\n    def maximalSquare(self, M):\n        m, n, ans = len(M), len(M[0]), 0\n        ones = [[0]*(n+1) for i in range(m)]\n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                ones[i][j] = 1 + ones[i][j+1] if M[i][j] == '1' else 0\n        \n        def get_max_square_len(row, col):\n            all_ones_row_len, sq_len, i, j = min(m-row, n-col), 0, 0, 0\n            while i < all_ones_row_len:                \n                all_ones_row_len = min(all_ones_row_len, ones[i+row][col])\n                sq_len = min(all_ones_row_len, i := i + 1)\n            return sq_len\n        \n        for row in range(m):\n            for col in range(n):\n                ans = max(ans, get_max_square_len(row, col))\n        return ans * ans",
    "class Solution:\n    def maximalSquare(self, M):\n        m, n, ans = len(M), len(M[0]), 0\n        dp, onesRow, onesCol = ([[0]*(n+1) for i in range(m+1)] for cnt in range(3))\n\n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\n            onesRow[i][j] = 1 + onesRow[i][j+1] if M[i][j] == '1' else 0\n            onesCol[i][j] = 1 + onesCol[i+1][j] if M[i][j] == '1' else 0\n            \n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\n            dp[i][j] = 1 + min(onesRow[i][j]-1, onesCol[i][j]-1, dp[i+1][j+1]) if M[i][j] == '1' else 0\n            ans = max(ans, dp[i][j])\n        return ans * ans",
    "class Solution:\n    def maximalSquare(self, M):\n        m, n, ans = len(M), len(M[0]), 0\n        dp = [[0]*(n+1) for i in range(m+1)]\n        \n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\n            dp[i][j] = 1 + min(dp[i+1][j], dp[i][j+1], dp[i+1][j+1]) if M[i][j] == '1' else 0\n            ans = max(ans, dp[i][j])\n        return ans * ans",
    "class Solution:\n    def maximalSquare(self, M):\n        m, n, ans = len(M), len(M[0]), 0\n        dp = [[0]*(n+1) for i in range(2)]\n        \n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\n            dp[i&1][j] = 1 + min(dp[(i+1)&1][j], dp[i&1][j+1], dp[(i+1)&1][j+1]) if M[i][j] == '1' else 0\n            ans = max(ans, dp[i&1][j])\n        return ans * ans",
    "class Solution:\n    def maximalSquare(self, M):\n        m, n, ans = len(M), len(M[0]), 0\n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\n            if i == m-1 or j == n-1:\n                M[i][j] = int(M[i][j])\n                ans = max(ans, M[i][j])\n            else:\n                M[i][j] = 1 + min(M[i+1][j], M[i][j+1], M[i+1][j+1]) if M[i][j] == '1' else 0\n                ans = max(ans, M[i][j])\n        return ans * ans"
]