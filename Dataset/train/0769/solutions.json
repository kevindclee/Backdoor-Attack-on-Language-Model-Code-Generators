[
    "    def minDeletionSize(self, A):\n        n = len(A[0])\n        dp = [1] * n\n        for j in xrange(1, n):\n            for i in xrange(j):\n                if all(a[i] <= a[j] for a in A):\n                    dp[j] = max(dp[j], dp[i] + 1)\n        return n - max(dp)",
    " public int minDeletionSize(String[] A) {\n        int max= 1;\n        int[] Lis= new int[A[0].length()];\n        for(int i=0; i<A[0].length(); i++){\n            Lis[i]= 1;\n            for(int j=0; j<i; j++){\n                if(checkLexicographic(A,i,j)){\n                    Lis[i]= Math.max(Lis[i],Lis[j]+1);\n                }\n            }\n            max=Math.max(max,Lis[i]);\n        }\n        return A[0].length() - max;\n    }\n    public boolean checkLexicographic(String[] A,int i,int j){\n        for(String str: A){\n            if(str.charAt(i)<str.charAt(j)) return false;\n        }\n        return true;\n    }",
    "class Solution:\n    def minDeletionSize(self, strs):\n        n, m = len(strs), len(strs[0])\n\n        @lru_cache(None)\n        def dfs(k,prev):\n            if k == m: return 0\n\n            min_val = 1 + dfs(k+1,prev)\n\n            if prev == -1 or all(strs[i][prev] <= strs[i][k] for i in range(n)):\n                min_val = min(min_val,dfs(k+1,k))\n\n            return min_val\n\n        return dfs(0,-1)\n\n\n\n\n        \n        \n\n        "
]