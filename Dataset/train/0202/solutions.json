[
    "    def calculate(self, s):\n        s += '+0'\n        stack, num, preOp = [], 0, \"+\"\n        for i in range(len(s)):\n            if s[i].isdigit(): num = num * 10 + int(s[i])\n            elif not s[i].isspace():\n                if   preOp == \"-\":  stack.append(-num)\n                elif preOp == \"+\":  stack.append(num)",
    "    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s: return \"0\"\n        num, stack, sign = 0, [], \"+\"\n        s += ' '",
    "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        s = s.replace(' ', '')\n        nstrs = re.split(r'[+-/*]', s)\n        nums = [int(n) for n in nstrs]",
    "import math\nclass Solution(object):\n    \n        def apply_pending_op(self, stack, pending_op, cur_int):\n            if pending_op is None:\n                stack.append(cur_int)\n            elif pending_op == '-':\n                stack.append(-cur_int)",
    "class Solution:\n    def calculate(self, s):\n        def update(op, v):\n            if op == \"+\": stack.append(v)\n            if op == \"-\": stack.append(-v)\n            if op == \"*\": stack.append(stack.pop() * v)           #for BC II and BC III\n            if op == \"/\": stack.append(int(stack.pop() / v))      #for BC II and BC III\n    \n        it, num, stack, sign = 0, 0, [], \"+\"\n        \n        while it < len(s):\n            if s[it].isdigit():\n                num = num * 10 + int(s[it])\n            elif s[it] in \"+-*/\":\n                update(sign, num)\n                num, sign = 0, s[it]\n            elif s[it] == \"(\":                                        # For BC I and BC III\n                num, j = self.calculate(s[it + 1:])\n                it = it + j\n            elif s[it] == \")\":                                        # For BC I and BC III\n                update(sign, num)\n                return sum(stack), it + 1\n            it += 1\n        update(sign, num)\n        return sum(stack)",
    "class Solution:\n    def calculate(self, s):    \n        def calc(it):\n            def update(op, v):\n                if op == \"+\": stack.append(v)\n                if op == \"-\": stack.append(-v)\n                if op == \"*\": stack.append(stack.pop() * v)\n                if op == \"/\": stack.append(int(stack.pop() / v))\n        \n            num, stack, sign = 0, [], \"+\"\n            \n            while it < len(s):\n                if s[it].isdigit():\n                    num = num * 10 + int(s[it])\n                elif s[it] in \"+-*/\":\n                    update(sign, num)\n                    num, sign = 0, s[it]\n                elif s[it] == \"(\":\n                    num, j = calc(it + 1)\n                    it = j - 1\n                elif s[it] == \")\":\n                    update(sign, num)\n                    return sum(stack), it + 1\n                it += 1\n            update(sign, num)\n            return sum(stack)\n\n        return calc(0)",
    "elif s[it] == \"(\":\n    num, it = calc(it+1)\nelif s[it] == \")\":\n    update(sign, num)",
    "self.calculate(s[it + 1:])",
    "num, j = self.calculate(s[it + 1:])",
    "class Solution:\n    def calculate(self, s):\n        def precedence(c):\n            return c == '*' or c == '/'\n        def toPostfix(s):\n            op, post = deque(), ''\n            for c in s:\n                if c == ' ': continue\n                elif c.isdigit(): post += c\n                else:\n                    post += '|'\n                    while op and precedence(c) <= precedence(op[-1]):\n                        post += op.pop()\n                    op.append(c)\n                    \n            return post + '|' + ''.join(reversed(op))\n        \n        s, num, i = toPostfix(s), deque(), 0\n        while i < len(s):\n            if s[i].isdigit():\n                j = s.find('|', i+1)\n                num.append(int(s[i:j]))\n                i = j\n            else:\n                num1, num2 = num.pop(), num.pop()\n                if   s[i] == '*': num.append(num2 * num1)\n                elif s[i] == '/': num.append(num2 // num1)\n                elif s[i] == '+': num.append(num2 + num1)\n                elif s[i] == '-': num.append(num2 - num1)\n            i += 1\n\n        return num.pop()\n            ",
    "class Solution:\n    def calculate(self, s):\n        def precedence(c):\n            return c == '*' or c == '/'\n\n        op, num, cur = deque(), deque(), 0\n        for c in s + '#':\n            if c == ' ': continue\n            elif c.isdigit():\n                cur = cur * 10 + int(c)\n            else:\n                num.append(cur)\n                while op and precedence(c) <= precedence(op[-1]):\n                    num1, num2, curOp = num.pop(), num.pop(), op.pop()\n                    if   curOp == '*': num.append(num2 * num1)\n                    elif curOp == '/': num.append(num2 // num1)\n                    elif curOp == '+': num.append(num2 + num1)\n                    elif curOp == '-': num.append(num2 - num1)\n                op.append(c)\n                cur = 0\n    \n        return num.pop()",
    "class Solution:\n    def calculate(self, s):\n        cur, ans, interimRes, prevOp = 0, 0, 0, '+'\n        for c in s + '##':\n            if c == ' ': continue\n            elif c.isdigit():\n                cur = cur * 10 + int(c)\n            else:\n                if prevOp == '*':   interimRes *= cur\n                elif prevOp == '/': interimRes = trunc(interimRes / cur)\n                else:\n                    ans += interimRes\n                    interimRes = cur if prevOp == '+' else -cur\n                prevOp, cur = c, 0\n        return ans"
]