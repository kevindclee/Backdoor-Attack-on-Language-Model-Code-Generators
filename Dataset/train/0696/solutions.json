[
    "    def superEggDrop(self, K, N):\n        dp = [[0] * (K + 1) for i in range(N + 1)]\n        for m in range(1, N + 1):\n            for k in range(1, K + 1):\n                dp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1\n            if dp[m][K] >= N: return m",
    "    def superEggDrop(self, K, N):\n        dp = [0, 0]\n        m = 0\n        while dp[-1] < N:\n            for i in range(len(dp) - 1, 0, - 1):\n                dp[i] += dp[i - 1] + 1\n            if len(dp) < K + 1:\n                dp.append(dp[-1])\n            m += 1\n        return m",
    "    Here worst case means we have to take both the conditions at every floor that\n    egg is broken and egg is not broken and try to achieve highest threshold floor, ",
    "dp[1][j] = j, j = 1...N # one egg, check each floor from 1 to j\ndp[i][0] = 0, i = 1...K # no floor, no drop needed to get the optimal floor\ndp[i][1] = 1, i = 1...K # one floor, only check once",
    "class Solution(object):\n    def superEggDrop(self, K, N):\n        \"\"\"\n        :type K: int\n        :type N: int\n        :rtype: int\n        \"\"\"\n        dp=[[float('inf')]*(N+1) for _ in range(K+1)]\n        for i in range(1, K+1):\n            dp[i][0] = 0\n            dp[i][1] = 1\n        for j in range(1, N+1):\n            dp[1][j] = j\n        \n        for i in range(2, K+1):\n            for j in range(2, N+1):\n                for k in range(1, j+1):\n                    dp[i][j] = min(dp[i][j], 1 + max(dp[i-1][k-1], dp[i][j-k]))\n        return dp[K][N]",
    "class Solution(object):\n    def superEggDrop(self, K, N):\n        \"\"\"\n        :type K: int\n        :type N: int\n        :rtype: int\n        \"\"\"\n        def dfs(i, j):\n            if i==1:\n                return j\n            if j==0:\n                return 0\n            if j==1:\n                return 1\n            if (i, j) in d:\n                return d[i, j]\n            lo, hi = 0, j\n            while lo < hi:\n                mid = (lo+hi)/2\n                left, right = dfs(i-1, mid-1), dfs(i, j-mid)\n                if left < right:\n                    lo = mid + 1\n                else:\n                    hi = mid\n            res = 1 + max(dfs(i-1, lo-1), dfs(i, j-lo))\n            d[i, j]=res\n            return res\n        \n        d={}\n        return dfs(K, N)",
    "class Solution(object):\n    def superEggDrop(self, K, N):\n        \"\"\"\n        :type K: int\n        :type N: int\n        :rtype: int\n        \"\"\"\n        dp=[[float('inf')]*(N+1) for _ in range(K+1)]\n        for i in range(1, K+1):\n            dp[i][0] = 0\n            dp[i][1] = 1\n        for j in range(1, N+1):\n            dp[1][j] = j\n            \n        for i in range(2, K+1):\n            k = 1\n            for j in range(2, N+1):\n                while k < j+1 and dp[i][j-k] > dp[i-1][k-1]:\n                    k += 1\n                dp[i][j] = 1 + dp[i-1][k-1]\n        return dp[K][N]",
    "class Solution(object):\n    def superEggDrop(self, K, N):\n        \"\"\"\n        :type K: int\n        :type N: int\n        :rtype: int\n        \"\"\" \n        dp = range(N+1)\n        for i in range(2, K+1):\n            k = 1\n            ndp = [0, 1] + [float('inf')]*(N-1)\n            for j in range(2, N+1):\n                while k < j+1 and ndp[j-k] > dp[k-1]:\n                    k += 1\n                ndp[j] = 1 + dp[k-1]\n            dp = ndp\n        return dp[N]",
    "res = float(\"inf\")\nwhile lo < hi:\n       mid = (lo+hi)/2\n       left, right = dfs(i-1, mid-1), dfs(i, j-mid)\n       res = min(res, 1+max(left, right))\n       if left < right:",
    "def superEggDrop(self, K, N):\n        dp = [[0] * (N+1) for _ in range(K+1)]\n        #print(dp)\n        \n        # For 0 egg we need no trial and for 1 egg we need to check i floors"
]