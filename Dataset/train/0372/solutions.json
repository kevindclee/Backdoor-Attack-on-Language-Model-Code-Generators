[
    "    # @cache",
    "class Solution:\n    def makesquare(self, nums):\n        N = len(nums)\n        basket, rem = divmod(sum(nums), 4)\n        if rem or max(nums) > basket: return False\n        \n        @lru_cache(None)\n        def dfs(mask):\n            if mask == 0: return 0\n            for j in range(N):\n                if mask & 1<<j:\n                    neib = dfs(mask ^ 1<<j)\n                    if neib >= 0 and neib + nums[j] <= basket:\n                        return (neib + nums[j]) % basket\n            return -1\n                    \n        return dfs((1<<N) - 1) == 0",
    "    s = sum(matchsticks)\n    n = len(matchsticks)\n    if s % 4 != 0 :   #basic case if square is not valid\n        return  False\n    \n    dp = {}\n    \n    \n    def solve( idx , x , included) :\n        \n        \n        if (x , included) in dp :\n            return dp[(x , included)]\n        # memoization\n        \n        if x == 0:\n            if included == ((2 ** n) - 1) :  # if all elements are included  and all edges are fulfilled\n                return True\n            \n            return solve( 0 , s // 4 , included ) # if there are still some edges to be solved\n            \n        if x < 0 or idx == n : # out of bound cases\n            return  False\n        \n        \n        flag = False\n        for i in range(idx , n ) :\n            if (1 << i) & included == 0  : #checking if the element id already included or not\n                flag = solve(i + 1 , x - matchsticks[i] , included ^ ( 1 << i )) # solving for subproblem , and setting the bit which is included\n                \n            if flag :\n                dp[(x,included)] = True \n                return True\n            \n            \n        dp[(x,included)] = False    \n        return False\n    \n    \n    ans = solve( 0 , s//4 , 0)\n    return ans\n \n '''"
]