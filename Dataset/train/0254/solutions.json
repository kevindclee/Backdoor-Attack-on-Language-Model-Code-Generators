[
    "        @lru_cache(None)\n        def calculate_coin(amount: int, counter: int):\n            if amount == 0:\n                return counter\n\n            min_coin = float(\"inf\")",
    "int one = help(coins,amount,n-1);\nint two = 1+help(coins,amount-coins[n],n);\nreturn min(one,two);",
    "class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        \n        int n = coins.size();\n        vector<vector<int>>dp(n, vector<int>(amount+1, 0));\n\n        for(int i = 0; i<=amount; i++){\n        if(i%coins[0]==0) dp[0][i] = i/coins[0];\n        else dp[0][i]=1e9;\n        }\n\n        for(int index = 1; index<n; index++){\n            for(int sum = 0; sum<=amount; sum++){\n                int notTake = 0 + dp[index-1][sum];\n\n                int take = 1e9;\n                if(sum>=coins[index]) take = 1 + dp[index][sum - coins[index]];\n\n                dp[index][sum] = min(take, notTake);\n            }\n        }\n\n        int ans = dp[n-1][amount];\n        if(ans>=1e9)return -1;\n        return ans;\n    }\n};",
    "class Solution(object):\n    def coinChange(self, coins, amount):\n        \"\"\"\n        :type coins: List[int]\n        :type amount: int\n        :rtype: int\n        \"\"\"\n        def solve(amt):\n            if amt < 0:\n                return float('inf')\n            if amt == 0:\n                return 0\n            if amt in memo:\n                return memo[amt]\n            ans = float('inf')\n            for c in coins:\n                ans = min(ans, 1 + solve(amt - c))\n            memo[amt] = ans\n            return ans\n        memo = {}\n        return solve(amount) if solve(amount) != float('inf') else -1",
    "class Solution(object):\n    def coinChange(self, coins, amount):\n        \"\"\"\n        :type coins: List[int]\n        :type amount: int\n        :rtype: int\n        \"\"\"\n \n        dp = [float('inf')] * (amount  + 1)\n        dp[0] = 0\n        for c in coins:\n            if c < len(dp):\n                dp[c] = 1\n        \n        for i in range(1, len(dp) + 1):\n            for c in coins:\n                if i + c < len(dp):\n                    dp[i + c] = min(dp[i + c], dp[i] + 1)\n           \n        return dp[-1] if dp[-1] != float('inf') else -1",
    "\"\"\"\nRecursion + dp Caching\n\"\"\"\nimport sys\nclass Solution(object):\n    def coinChange(self, coins, amount):\n        \"\"\"\n        :type coins: List[int]\n        :type amount: int\n        :rtype: int\n        \"\"\"\n        def dp_solver(index, target, dp):\n            if index == 0:\n                if target % coins[0] == 0:\n                    return  target / coins[0]\n\n                return 1e9\n            \n            if dp.get((index,target)):\n                return dp.get((index,target))\n            \n\n            not_take = 0 + dp_solver(index -1, target, dp)\n            take = sys.maxint\n\n            if coins[index] <= target:\n                take = 1 + dp_solver(index, target - coins[index], dp)\n            \n            dp[(index, target)] = min(take, not_take)\n            return dp[(index, target)]\n        \n        ans =  dp_solver(len(coins)-1, amount, {})\n        if ans >= 1e9:\n            return -1\n        return ans\n            \n\n            \n        "
]