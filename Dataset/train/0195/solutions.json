[
    "def containsNearbyAlmostDuplicate(self, nums, k, t):\n    if t < 0: return False\n    n = len(nums)\n    d = {}\n    w = t + 1\n    for i in xrange(n):\n        m = nums[i] / w\n        if m in d:\n            return True\n        if m - 1 in d and abs(nums[i] - d[m - 1]) < w:\n            return True\n        if m + 1 in d and abs(nums[i] - d[m + 1]) < w:\n            return True\n        d[m] = nums[i]\n        if i >= k: del d[nums[i - k] / w]\n    return False\n\n\n# 30 / 30 test cases passed.\n# Status: Accepted\n# Runtime: 56 ms\n# 93.81%",
    "def containsNearbyAlmostDuplicate(self, nums, k, t):\n    if k < 0 or t < 0:\n        return False\n        \n    bucket = {}\n\n    for i, num in enumerate(nums):\n        bucket_id = num / t if t != 0 else num",
    "class Solution:\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        if t < 0: return False\n        d = {}\n        for i in range(len(nums)):\n            m = nums[i] // (t + 1)\n            if m in d or (m - 1 in d and nums[i] - d[m - 1] <= t) or (m + 1 in d and d[m + 1] - nums[i] <= t):",
    "from sortedcontainers import SortedList\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        SList = SortedList()\n        for i in range(len(nums)):\n            if i > k: SList.remove(nums[i-k-1])   \n            pos1 = SortedList.bisect_left(SList, nums[i] - t)\n            pos2 = SortedList.bisect_right(SList, nums[i] + t)\n            \n            if pos1 != pos2 and pos1 != len(SList): return True\n            \n            SList.add(nums[i])\n        \n        return False",
    "if pos1 != pos2 and pos1 != len(SList): return True",
    "if pos1 != pos2: return True",
    "class Node(object):\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.height = 1\n\n\nclass AVLTree(object):\n    def __init__(self):\n        self.root = None\n        self.size = 0\n        \n    \n    def height(self, node):\n        if node:\n            return node.height\n        return 0\n    \n  \n    def setHeight(self, node):\n        if node is None:\n            return 0\n        return 1 + max(self.height(node.left), self.height(node.right))\n    \n  \n    def rightRotate(self, node):\n        new_root = node.left\n        node.left = node.left.right\n        new_root.right = node\n        node.height = self.setHeight(node)\n        new_root.height = self.setHeight(new_root)\n        return new_root\n    \n    \n    def leftRotate(self, node):\n        new_root = node.right\n        node.right = node.right.left\n        new_root.left = node\n        node.height = self.setHeight(node)\n        new_root.height = self.setHeight(new_root)\n        return new_root\n        \n    \n    def insert(self, node, val):\n        if node == self.root:\n            self.size += 1\n        # Returns a Node pointing to updated subtree\n        if node is None:\n            return Node(val)\n        if node.val < val:\n            node.right = self.insert(node.right, val)\n        else:\n            node.left = self.insert(node.left, val)\n        balance = self.height(node.left) - self.height(node.right)\n        if balance > 1:\n            if self.height(node.left.left) > self.height(node.left.right):\n                node = self.rightRotate(node)\n            else:\n                node.left = self.leftRotate(node.left)\n                node = self.rightRotate(node)\n        elif balance < -1:\n            if self.height(node.right.right) > self.height(node.right.left):\n                node = self.leftRotate(node)\n            else:\n                node.right = self.rightRotate(node.right)\n                node = self.leftRotate(node)\n        else:\n            node.height = self.setHeight(node)\n        return node\n    \n    \n    def getMinValNode(self, node):\n        if node is None or node.left is None:\n            return node\n        return self.getMinValNode(node.left)\n    \n  \n    def remove(self, node, val):\n        if node is None:\n            return None\n        if node.val < val:\n            node.right = self.remove(node.right, val)\n        elif node.val > val:\n            node.left = self.remove(node.left, val)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            else:\n                right_min_val_node = self.getMinValNode(node.right)\n                node.val = right_min_val_node.val\n                node.right = self.remove(node.right, right_min_val_node.val)\n        \n        node.height = self.setHeight(node)\n        balance = self.height(node.left) - self.height(node.right)\n        if balance > 1:\n            if self.height(node.left.left) > self.height(node.left.right):\n                node = self.rightRotate(node)\n            else:\n                node.left = self.leftRotate(node.left)\n                node = self.rightRotate(node)\n        elif balance < -1:\n            if self.height(node.right.right) > self.height(node.right.left):\n                node = self.leftRotate(node)\n            else:\n                node.right = self.rightRotate(node.right)\n                node = self.leftRotate(node)\n        else:\n            node.height = self.setHeight(node)\n        return node\n    \n    \n    def predecessor(self, node, val):\n        if node is None:\n            return None\n        if node.val == val:\n            return val\n        elif node.val > val:\n            return self.predecessor(node.left, val)\n        else:\n            right_res = self.predecessor(node.right, val)\n            return right_res if right_res else node.val    \n            \n      \n    def successor(self, node, val):\n        if node is None:\n            return None\n        if node.val == val:\n            return val\n        elif node.val < val:\n            return self.successor(node.right, val)\n        else:\n            left_res = self.successor(node.left, val)\n            return left_res if left_res else node.val\n    \n\nclass Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type t: int\n        :rtype: bool\n        \"\"\"\n        avltree = AVLTree()\n        root = avltree.root\n        for i, num in enumerate(nums):            \n            predecessor = avltree.predecessor(root, num)\n            if predecessor is not None and abs(predecessor - num) <= t:\n                return True\n            successor = avltree.successor(root, num)\n            if successor is not None and abs(successor - num) <= t:\n                return True\n                        \n            root = avltree.insert(root, num)\n            \n            if avltree.size > k:\n                root = avltree.remove(root, nums[i-k])\n                \n        return False"
]