[
    "class Solution(object):\n    def decodeString(self, s):\n        stack = []; curNum = 0; curString = ''\n        for c in s:\n            if c == '[':\n                stack.append(curString)\n                stack.append(curNum)\n                curString = ''\n                curNum = 0\n            elif c == ']':\n                num = stack.pop()\n                prevString = stack.pop()\n                curString = prevString + num*curString\n            elif c.isdigit():\n                curNum = curNum*10 + int(c)\n            else:\n                curString += c\n        return curString",
    "def stacky(s):\n    \"\"\"\n    When we hit an open bracket, we know we have parsed k for the contents of the bracket, so \n    push (current_string, k) to the stack, so we can pop them on closing bracket to duplicate\n    the enclosed string k times.\n    \"\"\"\n    stack = []\n    current_string = \"\"\n    k = 0",
    "class Solution(object):\n    def decodeString(self, s):\n        stack = []; curNum = 0; curString = ''\n        for c in s:\n            if c == '[':\n                stack.append(curString) # append onto list is O(1)\n                stack.append(curNum)\n                curString = ''",
    "class Solution:\n    def decodeString(self, encoded_string):\n        number, stack = 0, ['']",
    "if c.isdigit():\n    curr_num = curr_num * 10 + int(c)",
    "else:\n    curr_str += c",
    "class Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        for i in range(len(s)):\n            if not stack:\n                stack.append(s[i])\n                continue\n            if s[i] == ']':\n                currStr = ''\n                while stack:\n                    currChar = stack.pop()\n                    if currChar == '[':\n                        count = 0\n                        power = 1\n                        while stack:\n                            n = stack.pop()\n                            if not n.isnumeric():\n                                stack.append(n)\n                                break\n                            count += int(n)*power\n                            power *= 10\n                        currStr *= count\n                        stack.extend([c for c in currStr])\n                        break\n                    currStr = currChar + currStr\n            else:\n                stack.append(s[i])\n\n        return ''.join(stack)"
]