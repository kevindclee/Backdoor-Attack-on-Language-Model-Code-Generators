[
    "class Solution(object):\n    def updateBoard(self, board, click):\n        \"\"\"\n        :type board: List[List[str]]\n        :type click: List[int]\n        :rtype: List[List[str]]\n        \"\"\"\n        if not board:\n            return []\n\n        m, n = len(board), len(board[0])\n        i, j = click[0], click[1]\n\n        # If a mine ('M') is revealed, then the game is over - change it to 'X'.\n        if board[i][j] == 'M':\n            board[i][j] = 'X'\n            return board\n\n        # run dfs to reveal the board\n        self.dfs(board, i, j)\n        return board\n\n    def dfs(self, board, i, j):\n        if board[i][j] != 'E':\n            return\n\n        m, n = len(board), len(board[0])       \n        directions = [(-1,-1), (0,-1), (1,-1), (1,0), (1,1), (0,1), (-1,1), (-1,0)]\n\n        mine_count = 0\n\n        for d in directions:\n            ni, nj = i + d[0], j + d[1]\n            if 0 <= ni < m and 0 <= nj < n and board[ni][nj] == 'M':        \n                mine_count += 1\n\n        if mine_count == 0:\n            board[i][j] = 'B'\n        else:\n            board[i][j] = str(mine_count)\n            return\n\n        for d in directions:\n            ni, nj = i + d[0], j + d[1]\n            if 0 <= ni < m and 0 <= nj < n:\n                self.dfs(board, ni, nj)",
    "class Solution(object):\n    def updateBoard(self, board, click):\n        \"\"\"\n        :type board: List[List[str]]\n        :type click: List[int]\n        :rtype: List[List[str]]\n        \"\"\"\n        if not board or not board[0]:",
    "def updateBoard(self, board, click):\n        \"\"\"\n        :type board: List[List[str]]\n        :type click: List[int]\n        :rtype: List[List[str]]\n        \"\"\"\n        rows, cols = len(board), len(board[0])\n        def DFS(r, c):\n):\n, 1)):",
    "for (int i = -1; i <= 1; i++) {\n       for (int j = -1; j <= 1; j++) {"
]