[
    "for (int i=a; i<m; i++) {\n            for (int j=b; j<bound; j++) {\n                if (mat[i][j]) count += 1;\n                else bound = j;\n            }\n           if( bound == b) return  count;\n}",
    "R = len(mat)\nC = len(mat[0])\ntotal = 0\nfor up_row in range(R):\n    for down_row in range(up_row, R):\n     # DP array initialization\n        all_1_rectangles_end_at = [0 for _ in range(C)]\n        for c in range(C):\n            all_1_rectangles_end_at[c] = (all_1_rectangles_end_at[c-1] + 1) if all((mat[row][c] == 1 for row in range(up_row, down_row+1))) else 0 # Note, python's range function does not include the right value, so we need +1.\n        total += sum(all_1_rectangles_end_at)\nreturn total",
    "R = len(mat)\nC = len(mat[0])\ntotal = 0\nfor up_row in range(R):\n    # To remove redundant accumulations, we can manage a list of prefix product as all_1_at_column .\n    all_1_at_column = [True for _ in range(C)]\n    for down_row in range(up_row, R):\n        # DP array initialization\n        all_1_rectangles_end_at = [0 for _ in range(C)]\n        for c in range(C):\n         # Checking whether the current column's values are all 1 by seeing current value and the previous result stored in all_1_at_column. then update the result.\n            all_1_at_column[c] = all_1_at_column[c] & (True if mat[down_row][c] == 1 else False)\n            all_1_rectangles_end_at[c] = (all_1_rectangles_end_at[c-1] + 1) if all_1_at_column[c] else 0\n        total += sum(all_1_rectangles_end_at)\nreturn total",
    "class Solution(object):\n    def numSubmat(self, mat):\n        M = len(mat)\n        N = len(mat[0])\n        total = 0\n\n        for lo_row in range(M):\n            col_all_1 = [True] * N"
]