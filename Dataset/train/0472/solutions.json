[
    "def smallestRange(self, A):\n    pq = [(row[0], i, 0) for i, row in enumerate(A)]\n    heapq.heapify(pq)\n    \n    ans = -1e9, 1e9\n    right = max(row[0] for row in A)\n    while pq:\n        left, i, j = heapq.heappop(pq)\n        if right - left < ans[1] - ans[0]:\n            ans = left, right\n        if j + 1 == len(A[i]):\n            return ans\n        v = A[i][j+1]\n        right = max(right, v)\n        heapq.heappush(pq, (v, i, j+1))",
    "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        d = []\n        K = len(nums)\n        count = collections.defaultdict(int)\n        for i, num in enumerate(nums):\n            for n in num:\n                d.append([n, i])\n        d.sort(key=lambda x: x[0])\n        #print d\n        res = []\n        left = 0\n        for right, n in enumerate(d):\n            count[n[1]] += 1\n            while len(count)==K:\n                if not res or d[right][0]-d[left][0]<res[1]-res[0]:\n                    res = [d[left][0], d[right][0]]\n                count[d[left][1]] -= 1\n                if count[d[left][1]]==0:\n                    count.pop(d[left][1])\n                left += 1\n        return res"
]