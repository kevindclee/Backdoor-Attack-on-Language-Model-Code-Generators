[
    "    def minDistance(self, A, k):\n        A.sort()\n        n = len(A)\n        B = [0]\n        for i, a in enumerate(A):\n            B.append(B[i] + a)\n\n        def cal(i, j):\n            m1, m2 = (i + j) / 2, (i + j + 1) / 2\n            return (B[j + 1] - B[m2]) - (B[m1 + 1] - B[i])\n\n        dp = [cal(0, j) for j in xrange(n)]\n        for k in xrange(2, k + 1):\n            for j in xrange(n - 1, k - 2, -1):\n                for i in xrange(k - 2, j):\n                    dp[j] = min(dp[j], dp[i] + cal(i + 1, j))\n        return int(dp[-1])",
    "class Solution:\n    def minDistance(self, houses, k):\n        n = len(houses)\n        houses = sorted(houses)\n        costs = [[0] * n for _ in range(n)]\n        \n        for i, j in product(range(n), range(n)):\n            median = houses[(i + j) // 2]\n            for t in range(i, j + 1):\n                costs[i][j] += abs(median - houses[t])\n     \n        dp = [[10**6] * k for _ in range(n)]\n        for i in range(n): dp[i][0] = costs[0][i]\n        \n        for k_it in range(1, k):\n            for i_1 in range(n):\n                for i_2 in range(i_1):\n                    dp[i_1][k_it] = min(dp[i_1][k_it], dp[i_2][k_it-1] + costs[i_2+1][i_1])\n      \n        return dp[-1][-1] ",
    "class Solution(object):\n    def minDistance(self, houses, k):\n        \"\"\"\n        :type houses: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        houses.sort()\n        n = len(houses)\n        \n        # Given the group of houses in the range [i, j], the optimal mailbox location\n        # is *at* the house with the *median index*. The examples provided by the problem was\n        # extremely misleading which suggested one should place mailboxes in between houses.\n        # But that's not necessary, for given any optimal mailbox location between two houses,\n        # we would get the same total distance over all houses to that mailbox by moving the\n        # mailbox to the house at the *median index*. (Yes the distance to the house we've moved\n        # away from will get longer but the distance to the house we've moved closer to will get\n        # shorter, the total distance remain unchanged)\n        def dist_to_optimal_mbox(i, j):\n            median_loc = houses[(i + j) // 2]\n            dist = 0\n            for h_idx in range(i, j + 1):\n                dist += abs(houses[h_idx] - median_loc)\n            return dist\n\n        memo = {}\n        def f(i, k):\n            if i == n:\n                # Note here we don't actually check for the value of k, Why? Because\n                # we don't actually care if the recursion reaches the end of the houses\n                # array but we still have extra mailboxes unassigned, i.e. k > 0 (k cannot\n                # be less than 0 because we stop at k == 1 in the base case below). We know\n                # that the more mailboxes we use, the smaller the total distance. So there's\n                # no way for us to arrive at a smaller total distance by NOT using all k \n                # mailboxes. The branches of the recursion tree where i == n and k > 0 will\n                # definitely have larger total distance and be eventually ignored.\n                return 0\n            \n            if (i, k) in memo:\n                return memo[(i, k)]\n            \n            # Assuming k >= 1, if we only have one mailbox left to assign, only thing we can\n            # do is placing it at the median index of the range [i, n - 1] and return the distance\n            if k == 1:\n                memo[(i, k)] = dist_to_optimal_mbox(i, n - 1)\n                return memo[(i, k)]\n                \n            # Starting from i, we could create a group of houses that includes those in\n            # the inclusive range [i, j] and assign one mailbox to them. Think of the mailbox\n            # assigned as those houses' home-base mailbox. We are looking to place k home-base\n            # mailboxes, one per group of houses. Since we do not know where we'd lop off the\n            # group, i.e. where we'd end the group starting at i, we'll try all possible ending\n            # position for this group\n            min_dist = float('inf')\n            for j in xrange(i, n):\n                # If this group starts at i and ends at j, inclusive, then recurse and place\n                # k - 1 remaining mailboxes to k - 1 remaining groups\n                dist = dist_to_optimal_mbox(i, j) + f(j + 1, k - 1)\n                min_dist = min(min_dist, dist)\n            \n            memo[(i, k)] = min_dist\n            return min_dist\n        \n        return f(0, k)",
    "class Solution:\n    def minDistance(self, A, K):\n        A.sort()\n        N = len(A)\n        P = [0] + list(accumulate(A))\n        dp = [0] + [float('inf')] * N\n        for i in range(K):\n            for j in range(N - 1, i - 1, -1):\n                for k in range(j, i - 1, -1):\n                    m = (k + j) >> 1\n                    cost = P[j + 1] + P[k] - 2 * P[m] - A[m] * (j - 2 * m + k + 1)\n                    dp[j + 1] = min(dp[j + 1], dp[k] + cost)\n        return dp[-1]"
]