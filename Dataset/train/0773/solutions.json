[
    "    public int leastOpsExpressTarget(int x, int y) {\n        int pos = 0, neg = 0, k = 0, pos2, neg2, cur;\n        while (y > 0) {\n            cur = y % x;\n            y /= x;\n            if (k > 0) {\n                pos2 = Math.min(cur * k + pos, (cur + 1) * k + neg);\n                neg2 = Math.min((x - cur) * k + pos, (x - cur - 1) * k + neg);\n                pos = pos2;\n                neg = neg2;\n            } else {\n                pos = cur * 2;\n                neg = (x - cur) * 2;\n            }\n            k++;\n        }\n        return Math.min(pos, k + neg) - 1;\n    }",
    "    int leastOpsExpressTarget(int x, int y) {\n        int pos = 0, neg = 0, k, pos2, neg2, cur;\n        for (k = 0; y > 0; ++k, y /= x) {\n            cur = y % x;\n            if (k > 0) {\n                pos2 = min(cur * k + pos, (cur + 1) * k + neg);\n                neg2 = min((x - cur) * k + pos, (x - cur - 1) * k + neg);\n                pos = pos2, neg = neg2;\n            } else {\n                pos = cur * 2;\n                neg = (x - cur) * 2;\n            }\n        }\n        return min(pos, k + neg) - 1;\n    }",
    "    def leastOpsExpressTarget(self, x, y):\n        pos = neg = k = 0\n        while y:\n            y, cur = divmod(y, x)\n            if k:\n                pos, neg = min(cur * k + pos, (cur + 1) * k + neg), min((x - cur) * k + pos, (x - cur - 1) * k + neg)\n            else:\n                pos, neg = cur * 2, (x - cur) * 2\n            k += 1\n        return min(pos, k + neg) - 1",
    "        int a = (int)Math.floor(l);\n        int pow = (int)Math.pow(x, a);\n        int ans = 2 * y - 1; //max\n        if (pow == y) {\n            ans = a - 1;\n        } else {...",
    "import math\n\nclass Solution:\n    def leastOpsExpressTarget(self, x, target):\n        \"\"\"\n        :type x: int\n        :type target: int\n        :rtype: int\n        \"\"\"\n        cache = dict()\n        ret = self.helper(x, target, math.ceil(math.log(target, x)), cache)\n        return ret\n\n    def helper(self, x, target, index, cache):\n        if index == 0 or target == 1:\n            return target * 2 - 1\n        if (index, target) in cache:\n            return cache[(index, target)]\n        power = x**index\n        count = target // power\n        if target % power == 0:\n            return index * count - 1\n        low = index * count + \\\n            self.helper(x, target - power * count, index - 1, cache)\n        high = index * (count + 1) + \\\n            self.helper(x, power * (count + 1) - target, index - 1, cache)\n        cache[(index, target)] = min(low, high)\n        return cache[(index, target)]",
    "class Solution(object):\n    def leastOpsExpressTarget(self, x, target):\n        \"\"\"\n        :type x: int\n        :type target: int\n        :rtype: int\n        \"\"\"\n        n = int(math.log(target,x))\n        mask = x**n\n        last = [0,n+1]\n        for i in xrange(n,-1,-1):\n            d = target//mask\n            multis = 2 if i==0 else i\n            last = [min(last[1]+(x-d)*multis,last[0]+d*multis), min(last[1]+(x-d-1)*multis,last[0]+(d+1)*multis)]\n            target = target % mask\n            mask /=x\n        return last[0]-1"
]