[
    "int i = 0;\n        for (; i < arr.length; i++) {\n            if (arr[i] != B.charAt(i)) {\n                break;\n            }\n        }",
    "def kSimilarity(A, B):\n def nei(x):\n  i = 0\n  while x[i] == B[i]: i+=1\n  for j in range(i+1, len(x)):\n   if x[j] == B[i]: yield x[:i]+x[j]+x[i+1:j]+x[i]+x[j+1:]\n q, seen = [(A,0)], {A}\n for x, d in q:\n  if x == B: return d\n  for y in nei(x):\n   if y not in seen:\n    seen.add(y), q.append((y,d+1))",
    "class Solution {\n    public int kSimilarity(String A, String B) {\n        Map<String, Integer> map = new HashMap<>();\n        return backtrack(A.toCharArray(), B, map, 0);\n    }\n    private int backtrack(char[] A, String B, Map<String, Integer> map, int i) {\n        String sa = new String(A);\n        if (sa.equals(B)) {\n            return 0;\n        }\n        if (map.containsKey(sa)) {\n            return map.get(sa);\n        }\n        int min = Integer.MAX_VALUE;\n        while (i < A.length && A[i] == B.charAt(i)) {\n            i++;\n        }\n        for (int j = i + 1; j < B.length(); j++) {\n            if (A[j] == B.charAt(i)) {\n                swap(A, i, j);\n                int next = backtrack(A, B, map, i + 1);\n                if (next != Integer.MAX_VALUE) {\n                    min = Math.min(min, next + 1);\n                }\n                swap(A, i, j);\n            }\n        }\n        map.put(sa, min);\n        return min;\n    }\n    private void swap(char[] cs, int i, int j) {\n        char temp = cs[i];\n        cs[i] = cs[j];\n        cs[j] = temp;\n    }\n}",
    ""
]