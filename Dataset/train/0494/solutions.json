[
    "take  only last 8 bits  for calculations  (& with  0xFF, each F is 4 bits, so total 8 bits)\n sum += (M[x][y] & 0xFF);\n\nstore results in   1st 8 bits   (left shift + bit wise OR)\n M[i][j] |= ((sum / cnt) << 8);\n\nonce done, move  1st 8bit  results to  last 8 bits (1st 8 bits will 0, due to right shift)\n M[i][j] >>= 8;",
    "class Solution {\npublic:\n    vector<vector<int>> imageSmoother(vector<vector<int>>& M) {\n        for (int i = 0; i < M.size(); ++i) {\n            for (int j = 0; j < M[0].size(); ++j) {\n                int sum = 0;\n                int count = 0;\n                for (int k = max(0, i-1); k < min(i+2, static_cast<int>(M.size())); ++k) {\n{",
    "from copy import deepcopy\n\nclass Solution(object):\n    def imageSmoother(self, M):\n        \"\"\"\n        :type M: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        x_len = len(M)\n        y_len = len(M[0]) if x_len else 0\n        res = deepcopy(M)\n        for x in range(x_len):\n            for y in range(y_len):\n                neighbors = [\n                    M[_x][_y]\n                    for _x in (x-1, x, x+1)\n                    for _y in (y-1, y, y+1)\n                    if 0 <= _x < x_len and 0 <= _y < y_len\n                ]\n                res[x][y] = sum(neighbors) // len(neighbors)\n        return res",
    "for (int incR = -1; i <= 1; i++) { ... }",
    "class Solution {\n    public int[][] imageSmoother(int[][] img) {\n        int out[][]=new int[img.length][img[0].length];\n        int dir[][]=new int[][]{{1,0},{-1,0},{1,1},{1,-1},{0,1},{0,-1},{-1,-1},{-1,1},{0,0}};\n        for(int i=0;i<img.length;i++){\n            for(int j=0;j<img[0].length;j++){\n               int sum=0,count=0;\n               for(int k=0;k<dir.length;k++){\n                   int row=i+dir[k][0];\n                   int col=j+dir[k][1];\n                   if(row >=0 && col >=0 && row< img.length && col<img[0].length){\n                       sum+=img[row][col];\n                      count++;\n                   }\n               }\n               out[i][j]=(int)Math.floor(sum/count) ;\n            }\n        }\n        return out;\n    }\n}",
    "for (int i = 0; i < m; ++i)\n  for (int j = 0; j < n; ++j) {\n    int ones = 0;\n    int count = 0;\n    for (int y = Math.max(0, i - 1); y < Math.min(m, i + 2); ++y)\n      for (int x = Math.max(0, j - 1); x < Math.min(n, j + 2); ++x) {\n        ones += M[y][x];\n        ++count;\n      }\n    ans[i][j] = ones / count;\n  }\n\nreturn ans;"
]