[
    "    def findRedundantDirectedConnection(self, edges):\n        first, second, n = None, None, len(edges) \n        ds = ''.join(map(chr, range(n+1)))\n        ind = [0 for _ in range(n+1)]                \n        for p, q in edges: ind[q] += 1\n        for p, q in edges:\n            if ind[q] > 1:\n                if first:",
    "class Solution(object):\n    def union(self, a, b):\n        self.uf[self.find(b)] = self.find(a)\n\n    def find(self, a):\n        while self.uf[a] != a:\n            a = self.uf[a]\n        return a\n    \n    def detectCycle(self, V):\n        self.visited[V] = True\n        for i in range(len(self.adjList[V])):\n            nextV = self.adjList[V][i]\n            if self.visited[nextV]:\n                return (V, nextV)\n            ret = self.detectCycle(nextV)\n            if ret[0]:\n                return ret\n        return (None, None)\n    \n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        self.uf = [0] + [i + 1 for i in range(len(edges))]\n        self.adjList = [[] for i in range(len(edges) + 1)]      # Adjancency List\n        hasFather = [False] * (len(edges) + 1)                  # Whether a vertex has already got a parent\n        criticalEdge = None\n\n        for i, edge in enumerate(edges):\n            w, v = edge[0], edge[1]\n            self.adjList[w].append(v)\n            if hasFather[v]:\n                criticalEdge = (w, v)                           # If a vertex has more than one parent, record the last edge\n            hasFather[v] = True\n            if self.find(w) == self.find(v):                    # If a loop is found, record the edge that occurs last\n                cycleEdge = (w, v)\n            self.union(w, v)\n\n        if not criticalEdge:                                    # Case 1\n            return cycleEdge\n        self.visited = [False] * (len(edges) + 1)\n        (w, v) = self.detectCycle(criticalEdge[1])\n        return (w, v) if w else criticalEdge                    # Case 2 and 3",
    "class Solution:\n    def findRedundantDirectedConnection(self, edges):\n        def find(u):  # union find\n            if p[u] != u:\n                p[u] = find(p[u])\n            return p[u]\n        ",
    "            ret = self.detectCycle(nextV)\n            if ret[0]:\n                return ret",
    "            return self.detectCycle(nextV)",
    "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        incomingEdge = collections.defaultdict(list)\n        parents = [i for i in range (len(edges)+1)]\n        #Find algorithm to find the parent of a node\n        def find(n1):\n            p = parents[n1]\n            while p != parents[p]:\n                parents[p] = parents[parents[p]]\n                p = parents[p]\n            return p\n        \n        #union algorithm to check if they can be united, if so unite or return False\n        def union(n1,n2):\n            p1,p2 = find(n1),find(n2)\n            if p1 == p2: \n                return False\n            parents[p2] = p1\n            return True\n        \n        #unionFind being called to check if there is any cycle in the graph\n        # return -1 if there are no cycles in the graph\n        def unionFind(edges):\n            for n1,n2 in edges:\n                if union(n1,n2) == False:\n                    return [n1,n2]\n            return -1\n        # Get the incoming edges and check if there is any node with 2 incoming edges\n        # if so remove the last edge and check if it resolves the cycle if not the other edge is the answer\n        for n1,n2 in edges:\n            incomingEdge[n2].append(n1)\n        for node in incomingEdge:\n            if len(incomingEdge[node])>1:\n                edge1 = [incomingEdge[node][0],node]\n                edge2 = [incomingEdge[node][1],node]\n                edges.remove(edge2)\n                if unionFind(edges) == -1:\n                    return edge2\n                return edge1\n        return unionFind(edges)\n    \n                \n     ```\n  \n "
]