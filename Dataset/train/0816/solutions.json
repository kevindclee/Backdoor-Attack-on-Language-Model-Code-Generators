[
    "    def minDominoRotations(self, A, B):\n        for x in [A[0],B[0]]:\n            if all(x in d for d in zip(A, B)):\n                return len(A) - max(A.count(x), B.count(x))\n        return -1",
    "    public int minDominoRotations(int[] A, int[] B) {\n        int n = A.length;\n        for (int i = 0, a = 0, b = 0; i < n && (A[i] == A[0] || B[i] == A[0]); ++i) {\n            if (A[i] != A[0]) a++;\n            if (B[i] != A[0]) b++;\n            if (i == n - 1) return Math.min(a, b);\n        }\n        for (int i = 0, a = 0, b = 0; i < n && (A[i] == B[0] || B[i] == B[0]); ++i) {\n            if (A[i] != B[0]) a++;\n            if (B[i] != B[0]) b++;\n            if (i == n - 1) return Math.min(a, b);\n        }\n        return -1;\n    }",
    "    def minDominoRotations(self, A, B):\n        s = reduce(set.__and__, (set(d) for d in zip(A, B)))\n        if not s: return -1\n        x = s.pop()\n        return min(len(A) - A.count(x), len(B) - B.count(x))",
    "class Solution:\n    def minDominoRotations(self, A, B):\n        n = len(A)\n        andSet = {A[0], B[0]}\n        for i in range(1, n): andSet &= {A[i], B[i]}\n        if not andSet: return -1\n        x = andSet.pop()\n        return n - max(A.count(x), B.count(x))",
    "        for i in range(1, 7):\n            if countA[i] + countB[i] - same[i] == len(A):\n                return min(countA[i], countB[i]) - same[i]  ",
    "    int al = A.length;\n    int bl = B.length;\n    int len = Math.min(al,bl);\n    \n    for (int i=0; i<len; ++i) {\n        \n      ",
    "",
    "count_a = defaultdict(int)\ncount_b = defaultdict(int)\nN = len(A)\nsame = 0\n\nfor i in range(N):\n count_a[A[i]] += 1\n count_b[B[i]] += 1\n\n if A[i] == B[i]:\n  same += 1\n\nfor x in range(1,7):\n if (count_a[x] + count_b[x] - same) == N:\n  return N - max(count_a[x], count_b[x])\n\nreturn -1",
    "class Solution:\n    def minDominoRotations(self, A, B):\n        s, n = set([1,2,3,4,5,6]), len(A)\n        for i in range(n): s &= set([A[i], B[i]])\n        if not s: return -1\n        flips1 = sum(A[i] == list(s)[0] for i in range(n))\n        flips2 = sum(B[i] == list(s)[0] for i in range(n))\n        return min(n - flips1, n - flips2)  ",
    "    public int minDominoRotations(int[] tops, int[] bottoms) {\n    int len = tops.length;\n    int[][] dp = new int[6][3];\n    for(int i=0; i<len; i++){\n     if(tops[i]==bottoms[i]){\n      dp[tops[i]-1][0]++;\n      dp[tops[i]-1][1]++;\n      dp[tops[i]-1][2]++;\n     }else{\n      dp[tops[i]-1][0]++;\n      dp[tops[i]-1][1]++;\n      dp[bottoms[i]-1][0]++;\n      dp[bottoms[i]-1][2]++;\n     }\n    }\n    int min = Integer.MAX_VALUE;\n    for(int i=0; i<6; i++){\n     if(dp[i][0]==len){\n      min = Math.min(min, Math.min(len-dp[i][1], len-dp[i][2]));\n     }\n    }\n    if(min<len)\n     return min;\n    return -1;\n}",
    "return max(swap1,swap2);"
]