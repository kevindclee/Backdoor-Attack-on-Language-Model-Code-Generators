[
    "",
    "                if x not in visited:\n                    visited.add(x)\n                    mp[ch] = x\n                    if dfs(idx, i + 1, carry, visited, mp.copy()):\n                        return True\n                    visited.remove(x)\n                    # del mp[ch] <<<",
    "class Solution(object):\n    def isSolvable(self, words, result):\n        words.append(result)\n        R, C = len(words), max(map(len, words))\n        \n        assigned = {}\n        assigned_inv = [None] * 10\n\n        def search(column, row, bal):\n            if column >= C:\n                return bal == 0\n            if row == R:\n                return bal % 10 == 0 and search(column + 1, 0, bal // 10)\n            \n            word = words[row]\n            if column >= len(word):\n                return search(column, row + 1, bal)\n            \n            letter = word[~column]\n            sign = 1 if row < R - 1 else -1\n            if letter in assigned:\n                return search(column, row + 1, bal + sign * assigned[letter])\n            else:\n                for d, ad in enumerate(assigned_inv):\n                    if ad is None and (d or column != len(word) - 1):\n                        assigned_inv[d] = letter\n                        assigned[letter] = d\n                        if search(column, row + 1, bal + sign * d):\n                            return True\n                        assigned_inv[d] = None\n                        del assigned[letter]\n            \n            return False\n        \n        return search(0, 0, 0)",
    "",
    "",
    "if i == len(result): \n                return i >= max(len(w) for w in words)",
    "if ret: return True",
    "",
    "",
    "",
    "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        if max(map(len, words)) > len(result): # If any of the words are bigger than the result, it will be impossible to solve\n            return False\n        # Add the result to the list, this way we will only subtract values when it comes to the result word.\n        # Thus at every index, if the total is zero, then for that letter index the formulat is correct\n        words = [word[::-1] for word in words] + [result[::-1]]\n        values = {} #Mapping from letter to values\n        nums = [0] * 10\n\n        # i: word index, j: ltr index, total: total current Sum\n        def dfs(i, j, total):\n            if j == len(result): # Reached end of the indecies for ltrs in all words (END)\n                return total % 10 == 0 # Checking to see if the total for the current character is correct or not \n            if i == len(words): # Checked ltr at index j for all the words\n                return total % 10 == 0 and dfs(0, j + 1, total // 10)\n            \n            if j >= len(words[i]):\n                    return dfs(i + 1, j, total)\n\n            if words[i][j] in values:\n                if values[words[i][j]] == 0 and j == len(words[i]) - 1:\n                    return False\n                if i == len(words) - 1:\n                    return dfs(i + 1, j, total - values[words[i][j]])\n                else:\n                    return dfs(i + 1, j, total + values[words[i][j]])\n            else:\n                for val, isUsed in enumerate(nums):\n                    if not isUsed and (val != 0 or j == 0 or j < len(words[i]) - 1):\n                        values[words[i][j]] = val\n                        nums[val] = True\n\n                        if i == len(words) - 1 and dfs(i + 1, j, total - values[words[i][j]]):\n                            return True\n                        elif i < len(words) - 1 and dfs(i + 1, j, total + values[words[i][j]]):\n                            return True\n                        \n                        values.pop(words[i][j])\n                        nums[val] = False\n\n        return dfs(0, 0, 0)\n        "
]