[
    "class Solution(object):\n    def canMeasureWater(self, x, y, z):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :type z: int\n        :rtype: bool\n        \"\"\"\n        if x > y:\n            temp = x;\n            x = y;\n            y = temp;\n            \n        if z > x + y:\n            return False;\n        \n        # set the initial state will empty jars;\n        queue = [(0, 0)];\n        visited = set((0, 0));\n        while len(queue) > 0:\n            a, b = queue.pop(0);\n            if a + b == z:\n                return True;\n            \n            states = set()\n            \n            states.add((x, b)) # fill jar x;\n            states.add((a, y)) # fill jar y;\n            states.add((0, b)) # empty jar x;\n            states.add((a, 0)) # empty jar y;\n            states.add((min(x, b + a), 0 if b < x - a else b - (x - a))) # pour jar y to x;\n            states.add((0 if a + b < y else a - (y - b), min(b + a, y))) # pour jar x to y;\n\n            for state in states:\n                if state in visited:\n                    continue;\n                queue.append(state)\n                visited.add(state);\n                \n        return False;",
    "from collections import deque\n\nclass Solution(object):\n    def canMeasureWater(self, x, y, z):\n        if x + y < z: return False\n        visited, queue = set(), deque([(0, 0)])\n        while queue:\n            i, j = queue.popleft()",
    "def canMeasureWater(self, jug1Capacity, jug2Capacity, targetCapacity):\n    queue = collections.deque([(0, 0)])\n    visited = set(queue)\n\n    while queue:\n        jug1, jug2 = queue.popleft()\n        \n        if jug1 + jug2 == targetCapacity or jug1 == targetCapacity or jug2 == targetCapacity:\n            return True\n    \n        if jug1 + jug2 <= jug1Capacity: pour2 = (jug1 + jug2, 0)\n        else: pour2 = (jug1Capacity, jug1 + jug2 - jug1Capacity)\n\n        if jug1 + jug2 <= jug2Capacity: pour1 = (0, jug1 + jug2)\n        else: pour1 = (jug1 + jug2 - jug2Capacity, jug2Capacity)\n        \n        # Iterating over all possible operations:\n        for d in [(jug1Capacity, jug2), (jug1, jug2Capacity), (0, jug2), (jug1, 0), pour2, pour1]:\n            if d not in visited:\n                visited.add(d)\n                queue.append(d)\n    return False",
    "def canMeasureWater(self, jug1Capacity, jug2Capacity, targetCapacity):\n    def estimate(jug1, jug2):\n        return abs(jug1 - targetCapacity) + abs(jug2 - targetCapacity)\n    queue = [(1 + estimate(0, 0), 0, 0)]\n    visited = set(queue)\n\n    while queue:\n        e, jug1, jug2 = heapq.heappop(queue)\n        \n        if jug1 + jug2 == targetCapacity or jug1 == targetCapacity or jug2 == targetCapacity:\n            return True\n\n        pour2 = (0, 0)\n        if jug1 + jug2 <= jug1Capacity:\n            pour2 = (jug1 + jug2, 0)\n        else:\n            pour2 = (jug1Capacity, jug2 - (jug1Capacity - jug1))\n\n        pour1 = (0, 0)\n        if jug1 + jug2 <= jug2Capacity:\n            pour1 = (0, jug1 + jug2)\n        else:\n            pour1 = (jug1 - (jug2Capacity - jug2), jug2Capacity)\n        \n        for d in [(jug1Capacity, jug2), (jug1, jug2Capacity), (0, jug2), (jug1, 0), pour2, pour1]:\n            if d not in visited:\n                visited.add(d)\n                heapq.heappush(queue, (estimate(jug1, jug2) + 1, d[0], d[1]))\n    return False",
    "def canMeasureWater(self, jug1Capacity, jug2Capacity, targetCapacity):\n    def gcd(a, b):\n        while b:\n            temp = b\n            b = a % b\n            a = temp\n        return a\n\n    if jug1Capacity + jug2Capacity < targetCapacity: return False\n    if jug1Capacity == targetCapacity or jug2Capacity == targetCapacity:\n        return True\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0"
]