[
    "class Solution {\npublic:\n    vector<vector<int>> dp;\n    int longestPalindromeSubseq(string s) {\n        int n = s.length(), j;\n        dp.resize(n + 1, vector<int> (n));\n        \n        for (int len = 1; len <= n; len++) \n            for (int i = 0; i < n - len + 1; i++) {\n                j = i + len - 1;\n                if(len == 1) \n                    dp[1][j] = 1;\n                else {\n                    if(s[i] == s[j]) \n                        dp[len][j] = dp[len - 2][j - 1] + 2;\n                    else\n                        dp[len][j] = max(dp[len - 1][j], dp[len - 1][j - 1]);\n                }\n            }\n        return dp[n][n - 1];\n    }\n};",
    "class Solution {\npublic:\n    int longestPalindromeSubseq(string s) {\n        int n = s.length(), j;\n        vector<int> dp(n), dpPrev(n), dpPrevPrev(n);\n        \n        for (int len = 1; len <= n; len++) {\n            for (int i = 0; i < n - len + 1; i++) {\n                j = i + len - 1;\n                if(len == 1) \n                    dp[j] = 1;\n                else {\n                    if(s[i] == s[j]) \n                        dp[j] = dpPrevPrev[j - 1] + 2;\n                    else\n                        dp[j] = max(dpPrev[j], dpPrev[j - 1]);\n                }\n            }\n            dpPrevPrev = dpPrev;\n            dpPrev = dp;\n        }\n        return dp[n - 1];\n    }\n};"
]