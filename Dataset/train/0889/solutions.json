[
    "    def longestWPI(self, hours):\n        res = score = 0\n        seen = {}\n        for i, h in enumerate(hours):\n            score = score + 1 if h > 8 else score - 1\n            if score > 0:\n                res = i + 1\n            seen.setdefault(score, i)\n            if score - 1 in seen:\n                res = max(res, i - seen[score - 1])\n        return res",
    "if company in [\"Baidu\", \"Alibaba\", \"Tencent\"]:\n     return len(hours)",
    ">>> hours = [9,9,6,0,6,6,9] \n>>> tired = [1 if hour > 8 else -1 for hour in hours]\n>>> tired\n[1, 1, -1, -1, -1, -1, 1]",
    ">>> tired[1:5]\n[1, -1, -1, -1]\n>>> sum(tired[1:5])\n-2",
    "# doesn't this look like the fundamental theorem of calculus II?\n# https://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus#Second_part\nsum(tired[a:b+1]) == prefix_sum_tired[b] - prefix_sum_tired[a]",
    "prefix_sum_first_preimage = {}\n# some other stuff that's not as relevant at the moment\nif ntv not in prefix_sum_first_preimage:\n prefix_sum_first_preimage[ntv] = day_idx # suppose day_idx is the index of the current day in question",
    "day_idx = 6\nntv = 5\nif ntv - 1 in prefix_sum_first_preimage:\n print(f\"{day_idx - prefix_sum_first_preimage[ntv - 1]} is the longest WPI ending on {day_idx} with net 1\")",
    "def longestWPI(hours):\n\n    max_wpi, ntv, first_preimage = 0, 0, {}\n\n    for day_idx, hrs_today in enumerate(hours):\n\n        # check if today was a tiring day or not\n        ntv += 1 if hrs_today > 8 else -1\n\n        # if our net is positive (the net here is starting from first \n        # day), we just set the longest wpi to days that has passed\n        if ntv > 0: max_wpi = day_idx + 1\n\n        # if we haven't seen this ntv before, we store it\n        if not ntv in first_preimage: first_preimage[ntv] = day_idx\n\n        # if the ntv that is 1 less is seen before (for a net 1 ntv)\n        # we compute the wpi from that and see if that's longer than\n        # the longest we've seen so far\n        if ntv - 1 in first_preimage:\n            max_wpi = max(max_wpi, day_idx - first_preimage[ntv - 1])\n\n    return max_wpi",
    "Searching the j for every i can cost us O(n*n) which will cause TLE \nSo we need to use hashmap here \n\nNow let us say sum is -1 \nSo if we get a j having sum - 3 it will still be increment positively same for sum = -2 \nBut if you observe carefully we can reach -3 only from -2 as we can have (+1 / -1 ) \nSo the number prefix_sum[i] - 1 will always be farther than sum < prefix_sum[-1] \nThis is why we always use prefix_sum[i] - 1\n\nNOTE  if sum < prefix_sum[i]  - 1 exists : prefix_sum[i] - 1 will always exist as we can reach \nsum having sum < prefix_sum[i] - 1 by prefix_sum[i] - 1\n\nNow all we need to do is to keep a dictionary of all indexes of first occurence of an element\nTIME COMPLEXITY BECOMES O(n)",
    "class Solution {\npublic:\n    // int\n    int longestWPI(vector<int>& hours) {\n        vector<int> v;\n        for(auto &i: hours){\n            if(i>8)v.push_back(1);\n            else v.push_back(-1);\n        }\n        unordered_map<int,int> mp;\n        int ans = 0, sum = 0;\n        mp[0] = 0;\n        for(int i = 0; i < v.size(); i++){\n            sum += v[i];\n            if(sum>0){\n                ans = max(ans,i+1);\n            }else if(mp.count(sum-1)){\n                ans = max(ans,i-mp[sum-1]);\n            }\n            if(mp.count(sum)==0){\n                mp[sum] = i;\n            }\n        }\n        return ans;\n    }\n};",
    "class Solution:\n    def longestWPI(self, A):\n        curr, ans, D = 0, 0, {}\n        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):\n            curr += i\n            D[curr] = D.get(curr, e)\n            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 1, e))\n        return ans"
]