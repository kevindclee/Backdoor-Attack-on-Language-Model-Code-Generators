[
    "    def minSubarray(self, A, p):\n        need = sum(A) % p\n        dp = {0: -1}\n        cur = 0\n        res = n = len(A)\n        for i, a in enumerate(A):\n            cur = (cur + a) % p\n            dp[cur] = i\n            if (cur - need) % p in dp:\n                res = min(res, i - dp[(cur - need) % p])\n        return res if res < n else -1",
    "int comp = (p - mod + r_mod) % p;",
    "int comp = (p - mod + r_mod) % p;",
    "# intialize parameters\n# d[0] = 0 since the first element F[0] = 0 by definition\nK, tot, curr, d = sum(nums)%p, len(nums), 0, {0:0}\nif K == 0:\n return 0\nfor i,x in enumerate(nums):\n # find latest element F[-1]\n curr = (curr+x) % p\n # see if the target is in d\n if (curr-K) % p in d:\n  tot = min(tot, i+1-d[(curr-K)%p])\n # F is of length 1 more than nums in general\n # since we loop 0,..,n-1, we need to add +1 to\n # simulate the range 1,...,n\n d[curr] = i+1\n# the condition from part 4\nreturn (tot if tot < len(nums) else -1)",
    "class Solution {\npublic:\n int minSubarray(vector<int>& nums, int p) {\n   long long int sum=0;\n     for(int i=0; i<nums.size(); i++){\n          sum+=nums[i];\n       }\n        int rem=sum%p;\n        if(rem==0)\n            return 0;\nint mn=nums.size();\nunordered_map<int,int> m;\nsum=0;\nfor(int i=0;i<nums.size() ;i++){\nsum+=nums[i];\nint k=sum%p;\nif(k==rem)\n mn=min(mn,i+1);\n if(m.find(k-rem)!=m.end())\n     mn=min(mn,i-m[k-rem]);\n if(m.find(k-rem+p)!=m.end())\n mn=min(mn,i-m[p+k-rem]);\n     m[k]=i;            \n  }\n     if(mn>=nums.size())\n     return -1;\n\n return mn;\n    }\n};",
    "For proper explaination check - \nhttps://leetcode.com/problems/make-sum-divisible-by-p/discuss/2282512/Java-or-Prefix-Sum-and-HashMap-or-With-comments-and-example\n \nclass Solution {\n    public int minSubarray(int[] arr, int k) {\n        \n        long sum = 0;\n  int Rem = 0;\n    \n        for (int j = 0; j < arr.length; j++)\n            sum += arr[j];\n        \n        if (sum % k == 0)\n         return 0;\n  \n   Rem = (int) (sum % k);\n  \n        HashMap<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n        \n        sum = 0;\n        int res = arr.length;\n        \n        for (int i = 0; i < arr.length; i++) {\n            sum += arr[i];\n            int curRem = (int)(sum % k);\n            \n           int toFind = curRem - Rem;\n            \n            if (toFind < 0)\n            toFind += k;\n            \n            if (map.containsKey(toFind)){\n                res = Math.min(res, i - map.get(toFind));\n     }\n                else{\n            map.put(curRem, i);\n   }\n        }\n        if (res == arr.length)\n            return -1;\n        \n        return res;\n    }\n}",
    "class Solution {\npublic:\n    int minSubarray(vector<int>& nums, int p) {\n        long long int sum=0;\n        for(int i=0;i<nums.size();i++){\n            sum+=nums[i];\n        }\n        \n        int rem=sum%p;\n        if(rem==0)return 0;\n\n        int ans=nums.size();\n        unordered_map<int,int>m;\n        sum=0;\n\n        for(int i=0;i<nums.size();i++){\n            sum+=nums[i];\n            int rem2=sum%p;\n\n            if(rem2==rem)\n                ans=min(ans,i+1);\n\n            if(m.find(rem2-rem)!=m.end()){\n                ans=min(ans,i-m[rem2-rem]);\n            }\n\n            if(m.find(p+rem2-rem)!=m.end()){\n                ans=min(ans,i-m[p+rem2-rem]);\n            }\n            m[rem2]=i;\n        }\n        if(ans>=nums.size())return -1;\n        return ans;\n        \n    }\n};"
]