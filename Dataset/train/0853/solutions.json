[
    "class Solution:\n    def RabinKarp(self,text, M, q):\n        if M == 0: return True\n        h, t, d = (1<<(8*M-8))%q, 0, 256\n\n        dic = defaultdict(list)\n\n        for i in range(M): \n            t = (d * t + ord(text[i]))% q\n\n        dic[t].append(i-M+1)\n\n        for i in range(len(text) - M):\n            t = (d*(t-ord(text[i])*h) + ord(text[i + M]))% q\n            for j in dic[t]:\n                if text[i+1:i+M+1] == text[j:j+M]:\n                    return (True, text[j:j+M])\n            dic[t].append(i+1)\n        return (False, \"\")\n\n    def longestDupSubstring(self, S):\n        beg, end = 0, len(S)\n        q = (1<<31) - 1 \n        Found = \"\"\n        while beg + 1 < end:\n            mid = (beg + end)//2\n            isFound, candidate = self.RabinKarp(S, mid, q)\n            if isFound:\n                beg, Found = mid, candidate\n            else:\n                end = mid\n\n        return Found",
    "def kmp(s):\n        kmp = [0] * len(s)\n\n        for i in range(1, len(s)):",
    "def longestDupSubstring(self, S):\n        beg, end = 0, len(S)-1\n        q = (1<<31) - 1 \n        Found = \"\"\n        while beg < end:\n            mid = (beg + end)//2\n            isFound, candidate = self.RabinKarp(S, mid, q)\n            if isFound:\n                beg, Found = mid+1, candidate",
    "    def longestDupSubstring(self, S):\n        A = [ord(c) - ord('a') for c in S]\n        mod = 2**63 - 1\n\n        def test(L):\n            p = pow(26, L, mod)\n            cur = reduce(lambda x, y: (x * 26 + y) % mod, A[:L], 0)\n            seen = {cur}\n            for i in xrange(L, len(S)):\n                cur = (cur * 26 + A[i] - A[i - L] * p) % mod\n                if cur in seen: return i - L + 1\n                seen.add(cur)\n        res, lo, hi = 0, 0, len(S)\n        while lo < hi:\n            mi = (lo + hi + 1) / 2\n            pos = test(mi)\n            if pos:\n                lo = mi\n                res = pos\n            else:\n                hi = mi - 1\n        return S[res:res + lo]",
    "   def test(L):\n           p = pow(26, L, mod)\n           cur = reduce(lambda x, y: (x * 26 + y) % mod, A[:L], 0)\n           seen = {cur}\n           for i in xrange(L, len(S)):\n               cur = (cur * 26 + A[i] - A[i - L] * p) % mod\n               if cur in seen: return i - L + 1\n               seen.add(cur)"
]