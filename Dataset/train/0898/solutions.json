[
    "    int stoneGameII(vector<int>& piles) {\n        vector<vector<int>> dp(piles.size(), vector<int>(piles.size(), 0));\n        vector<int> sum(piles.size()+1, 0);\n        for(int i=piles.size()-1;i>=0;i--) sum[i]=sum[i+1]+piles[i];\n        return helper(dp, 1, 0, sum);\n    }\n    \n    int helper(vector<vector<int>>& dp, int M, int pos, vector<int>& sum) {",
    "class Solution {\n    private int[] sums;//the sum from piles[i] to the end\n    private int[][] hash;\n    public int stoneGameII(int[] piles) {\n        if(piles == null || piles.length == 0) return 0;\n        int n = piles.length;\n        sums = new int[n];\n        sums[n-1] = piles[n-1];\n        for(int i = n -2; i>=0;i--) {\n            sums[i] = sums[i+1] + piles[i]; //the sum from piles[i] to the end\n        }\n        \n        hash = new int[n][n];\n        return helper(piles, 0, 1);\n    }\n    \n    private int helper(int[] a, int i, int M) {\n        if(i == a.length) return 0;\n        if(2*M >= a.length - i) {\n            return sums[i];\n        }\n        if(hash[i][M] != 0) return hash[i][M];\n        int min = Integer.MAX_VALUE;//the min value the next player can get\n        for(int x=1;x<=2*M;x++){\n            min = Math.min(min, helper(a, i+x, Math.max(M,x)));\n        }\n        hash[i][M] = sums[i] - min;  //max stones = all the left stones - the min stones next player can get\n        return hash[i][M];   \n    }\n}",
    "//max stones = all the left stones - the min stones next player can get",
    "//max stones = all the right stones - the min stones next player can get",
    "public int stoneGameII(int[] piles) {",
    "hash[i][M] = sums[i] - min;",
    "        @lru_cache(None)\n        def doit(index, M):",
    "final int n = piles.length;\nfor (int i = n - 2; i >= 0; i--) piles[i] += piles[i+1];\nif (n <= 2) return piles[0];\nint[][] dp = new int[n][(n+1)/2+1];\nfor (int i = n-1; i >= 0; i--) {\n    int sum = piles[i];\n    int m = (n-i+1)/2;\n    dp[i][m] = sum;\n    while (--m > 0) {\n        dp[i][m] = 0;\n        for (int x = 1; x <= m * 2 && i+x < n; x++) {\n            int mx = Math.min((n-i-x+1)/2, Math.max(x, m));\n            dp[i][m] = Math.max(dp[i][m], sum - dp[i+x][mx]);\n        }\n    }\n}\nreturn dp[0][1];"
]