[
    "    def minAreaFreeRect(self, points):\n        n,m,res=len(points),collections.defaultdict(list),float(\"inf\")\n        if n<4:\n            return 0\n        # diagonal map. distance+center-point -> indexes of two points\n        for i in range(n):\n            x1,y1=points[i]",
    "class Solution:\n    def minAreaFreeRect(self, points):\n        mn, st, n = float('inf'), {(x, y) for x, y in points}, len(points) \n        for i in range(n):\n            x1, y1 = points[i]\n            for j in range(i + 1, n):\n                x2, y2 = points[j]\n                for k in range(j + 1, n):\n                    x3, y3 = points[k]\n                    if not (x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1) and (x3 + (x2 - x1), y3 + (y2 - y1)) in st:\n                        mn = min(mn, ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5 * ((x3 - x1) ** 2 + (y3 - y1) ** 2) ** 0.5)\n        return mn if mn < float(\"inf\") else 0",
    "    def minAreaFreeRect(self, points):\n        points = [complex(*z) for z in sorted(points)]\n        seen = collections.defaultdict(list)\n        for P, Q in itertools.combinations(points, 2):\n            seen[Q - P].append((P + Q) / 2)\n\n        ans = float(\"inf\")\n        for A, candidates in seen.iteritems():\n            for P, Q in itertools.combinations(candidates, 2):\n                if A.real * (P - Q).real == -A.imag * (P - Q).imag:\n                    ans = min(ans, abs(A) * abs(P - Q))\n        return ans if ans < float(\"inf\") else 0",
    "def minAreaFreeRect(points):\n    points = [complex(*z) for z in sorted(points)] # store each point as a complex number\n    seen = collections.defaultdict(list) # store each edges in a dictionary\n    for P, Q in itertools.combinations(points, 2):\n        seen[Q - P].append((P + Q) / 2)\n        # Q-P, it is a vector that stores both the direction and the length of the edge",
    "",
    "def dist_pow2(x1, y1, x2, y2): return (x2 - x1)**2 + (y2 - y1)**2\ndef dist(x1, y1, x2, y2): return dist_pow2(x1, y1, x2, y2)**0.5\n\nclass Solution:\n    def minAreaFreeRect(self, points):\n        L, m = len(points), float('inf')\n\n        quick_search = {(x, y) for x, y in points}\n\n        for i in range(L):\n            for j in range(i + 1, L):\n                for k in range(j + 1, L):\n                    x1, y1 = points[i] # calculate point4 to form a diamond by previous three\n                    x2, y2 = points[j] # we only check case when x4 is latter occured than x3\n                    x3, y3 = points[k] # becourse the case when x4 is earlier occured than x3 will be covered already\n                    x4, y4 = (x3 + (x2 - x1), y3 + (y2 - y1))\n\n                    if (x4, y4) in quick_search:  # look for existence of dimond shape\n                        # if two diagonals' length are equal, we got a rectangel\n                        if dist_pow2(x1, y1, x4, y4) == dist_pow2(x2, y2, x3, y3):\n                            # calculate area by multipling any two adjacent edge's length\n                            area = dist(x1, y1, x2, y2) * dist(x1, y1, x3, y3)\n                            m = min(m, area)  # keep track of min_area\n\n        return m if m != float('inf') else 0"
]