[
    "    def bestRotation(self, A):\n        N = len(A)\n        change = [1] * N\n        for i in range(N): change[(i - A[i] + 1) % N] -= 1\n        for i in range(1, N): change[i] += change[i - 1]\n        return change.index(max(change))",
    " class Solution(object):\n    def bestRotation(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        count = [0]*len(A)\n        for i in range(len(A)):\n            if A[i] <= i:\n                mini = 0\n                maxi = i - A[i]\n                count[mini] += 1\n                if maxi + 1 < len(A): count[maxi + 1] += -1\n                if i + 1 < len(A): count[i+1] += 1\n            else:\n                if A[i] == len(A):\n                    continue #no valid range\n                mini = i + 1\n                maxi = len(A) - (A[i] - i)\n                print(mini, maxi)\n                count[mini] += 1\n                if maxi + 1 < len(A): count[maxi + 1] += -1\n        for i in range(1, len(A)):\n            count[i] += count[i-1]\n        return count.index(max(count))\n                \n                \n                    ",
    "class Solution {\n    public int bestRotation(int[] A) {\n        int[] count = new int[A.length + 1];\n        int len = A.length;\n        for(int index = 0; index < A.length; index ++){\n            int num = A[index];\n            if(index < num){\n                int maxLenK = (index + 1) % len;\n                int ori = (index + len - num) % len;\n                count[maxLenK] ++;\n                count[ori + 1] --;\n            }else{      // index >= num\n                int ori = (index + len - num) % len;\n                count[0] ++;\n                count[ori + 1] --;\n                if(index != len - 1){\n                    count[(index + 1) % len] ++;\n                    count[len] --;\n                }\n            }\n        }\n        int max = count[0];\n        int res = 0;\n        for(int i = 1; i < len; i ++){\n            count[i] = count[i] + count[i - 1];\n            if(count[i] > max){\n                max = count[i];\n                res = i;\n            }            \n        }\n        return res;\n    }\n}",
    "class Solution {\n    public int bestRotation(int[] A) {\n        int len = A.length;\n        int[] counter = new int[len];\n        for (int i = 0; i < len; i++) {\n            counter[(i + 1) % len]++;\n            counter[(i - (A[i] - 1) + len) % len]--;\n            if (i >= A[i]) counter[0]++;",
    "class Solution:\n    def bestRotation(self, A):\n        n = len(A)\n        P = [1] * n\n        for i in range(n):\n            P[(i - A[i] + 1) % n] -= 1\n        P = list(accumulate(P))\n        return P.index(max(P))",
    "    ++rots[i + 1];\n    int d = nums[i] - i;\n    if (d > 0)\n        --rots[n - d + 1];\n    else\n        --rots[1 - d];",
    "    ++rots[i];\n    int d = nums[i] - i;\n    if (d > 0)\n        --rots[n - d];\n    else\n        --rots[-d];",
    "from heapq import heappop, heappush\n\nclass Solution:\n    def bestRotation(self, nums):\n        L = len(nums)\n\n        score_ranges = []  # range of k that will get a score\n        for idx, val in enumerate(nums):  # score_idx in [val, L-1]\n            if idx >= val: score_ranges.append((0, idx - val))  # idx left\n            if idx < L - 1: score_ranges.append((idx + 1, min(L - 1, (L - val) + idx)))  # idx right\n\n        starts, ends = [], [] # notice these are possible k's\n        for start, end in score_ranges:\n            heappush(starts, start)\n            heappush(ends, end)\n\n        max_k, max_points, point = 0, 0, 0\n        while starts:  # chance to get higher score\n            if starts[0] <= ends[0]: # score before loss points\n                point += 1\n                if point > max_points:\n                    max_k, max_points = starts[0], point\n                heappop(starts)\n            else:\n                point -= 1\n                heappop(ends)\n\n        return max_k"
]