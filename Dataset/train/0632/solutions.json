[
    "    def numFactoredBinaryTrees(self, A):\n        dp = {}\n        for a in sorted(A):\n            dp[a] = sum(dp[b] * dp.get(a / b, 0) for b in dp if a % b == 0) + 1\n        return sum(dp.values()) % (10**9 + 7)",
    "    def numFactoredBinaryTrees(self, A):\n        dp = {}\n        for a in sorted(A): \n            dp[a] = sum(dp[b] * dp.get(a / b, 0) for b in dp if a % b == 0) + 1\n        return sum(dp.values()) % (10**9 + 7)",
    "def numFactoredBinaryTrees(self, A):\n    A.sort()\n    dp = collections.defaultdict(int)\n    for i, v in enumerate(A):\n        dp[v] = 1 + sum(dp[A[j]]*dp[v/A[j]] for j in xrange(i) if not v%A[j])\n    return sum(dp.values()) % 1000000007",
    "  sa,dic = sorted(A),{}\n    for x in sa:\n        i, dic[x] = 0, 1\n        while sa[i] <= math.sqrt(x):\n            if x % sa[i] == 0 and (x / sa[i] in dic):\n                dic[x] += dic[sa[i]] * dic[x / sa[i]] * len(set([sa[i],x / sa[i]]))\n            i += 1",
    "",
    "class Solution:\n    def numFactoredBinaryTrees(self, arr):\n        s_arr, N = set(arr), 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(num):\n            ans = 1\n            for cand in s_arr:\n                if num % cand == 0 and num//cand in s_arr:\n                    ans += dp(cand)*dp(num//cand)\n            return ans\n        \n        return sum(dp(num) for num in s_arr) % N",
    "class Solution {\n    public int numFactoredBinaryTrees(int[] arr) {\n        Arrays.sort(arr);\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>();\n        long ans=1;\n        map.put(arr[0],ans);\n        for(int i=1;i<arr.length;i++)\n        {\n            long sum=1;\n            for(int j=0;j<i;j++)\n            {\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\n                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\n            }\n            map.put(arr[i],sum);\n            ans=ans+sum;\n        }\n        return (int)(ans%1000000007);\n    }\n}",
    "class Solution {\n    public int numFactoredBinaryTrees(int[] arr) {\n        Arrays.sort(arr);\n        HashMap<Integer,Long>map=new HashMap<Integer,Long>();\n        long ans=1;\n        map.put(arr[0],ans);\n        for(int i=1;i<arr.length;i++)\n        {\n            long sum=1;\n            for(int j=0;j<i;j++)\n            {\n                if(arr[i]%arr[j]==0 && map.containsKey(arr[i]/arr[j]))\n                    sum=sum+(map.get(arr[i]/arr[j])*map.get(arr[j]));\n            }\n            map.put(arr[i],sum);\n            ans=ans+sum;\n        }\n        return (int)(ans%1000000007);\n    }\n}"
]