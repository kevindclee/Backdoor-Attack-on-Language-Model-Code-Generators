[
    "def numMatchingSubseq(self, S, words):\n    waiting = collections.defaultdict(list)\n    for w in words:\n        waiting[w[0]].append(iter(w[1:]))\n    for c in S:\n        for it in waiting.pop(c, ()):\n            waiting[next(it, None)].append(it)\n    return len(waiting[None])",
    "def numMatchingSubseq(self, S, words):\n    waiting = collections.defaultdict(list)\n    for it in map(iter, words):\n        waiting[next(it)].append(it)\n    for c in S:\n        for it in waiting.pop(c, ()):\n            waiting[next(it, None)].append(it)\n    return len(waiting[None])",
    "def numMatchingSubseq(self, S, words):\n    waiting = collections.defaultdict(list, {' ': map(iter, words)})\n    for c in ' ' + S:\n        for it in waiting.pop(c, ()):\n            waiting[next(it, None)].append(it)\n    return len(waiting[None])",
    "'b':  [\"(b)b\"]\n'c':  [\"a(c)d\", \"a(c)e\"]\nNone: [\"a\"]",
    "'b':  [\"b(b)\"]\n'c':  [\"a(c)d\", \"a(c)e\"]\nNone: [\"a\"]",
    "'b':  [\"b(b)\"]\n'd':  [\"ac(d)\"]\n'e':  [\"ac(e)\"]\nNone: [\"a\"]",
    "'b':  [\"b(b)\"]\n'e':  [\"ac(e)\"]\nNone: [\"a\", \"acd\"]",
    "'b':  [\"b(b)\"]\nNone: [\"a\", \"acd\", \"ace\"]",
    "for (StringCharacterIterator it : advance)\n    waiting[it.next() % it.DONE].add(it);",
    "for (StringCharacterIterator it : advance) {\n    it.next();",
    "from collections import defaultdict\n\nclass Solution(object):\n    def numMatchingSubseq(self, S, words):\n        \"\"\"\n        :type S: str\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        word_dict = defaultdict(list)\n        count = 0\n        \n        for word in words:\n            word_dict[word[0]].append(word)            \n        \n        for char in S:\n            words_expecting_char = word_dict[char]\n            word_dict[char] = []\n            for word in words_expecting_char:\n                if len(word) == 1:\n                    # Finished subsequence! \n                    count += 1\n                else:\n                    word_dict[word[1]].append(word[1:])\n        \n        return count",
    "class Solution {\n    public int numMatchingSubseq(String s, String[] words) {\n        \n        Map<String,Integer> map = new HashMap<>();\n        for(String str:words){\n            map.put(str,map.getOrDefault(str,0)+1);\n        }\n        \n        int ans = 0;\n        char ch[] = s.toCharArray();\n        \n        for(String str:map.keySet()){\n            \n            char temp[] = str.toCharArray();\n            int i = 0;\n            int j = 0;\n            \n            while(i<ch.length && j<temp.length){\n                if(ch[i]==temp[j]){\n                    i++;\n                    j++;\n                }else{\n                    i++;\n                }\n            }\n            \n            if(j==temp.length){\n                ans+=map.get(str);\n            }\n            \n        }\n        \n      return ans;  \n    }\n}",
    "class Solution {\n    public int numMatchingSubseq(String s, String[] words) {\n        Map<Character, Queue<String>> map = new HashMap<>();\n        int count = 0;\n\n        for(int i = 0; i < s.length(); i++) {\n            map.putIfAbsent(s.charAt(i), new LinkedList<>());\n        }\n        \n        for(String word : words) {\n            char startingChar = word.charAt(0);\n            if(map.containsKey(startingChar)) {\n                map.get(startingChar).offer(word);\n            }\n        }\n        for(int i = 0; i < s.length(); i++) {\n            char startingChar = s.charAt(i);\n            Queue<String> q = map.get(startingChar);\n            int size = q.size();\n            for(int k = 0; k < size; k++) {\n                String str = q.poll();\n                if(str.substring(1).length() == 0) {\n                    count++;\n                } else {\n                    if(map.containsKey(str.charAt(1))) {\n                        map.get(str.charAt(1)).add(str.substring(1));\n                    }\n                }\n            }\n        }\n        return count;\n    }\n}"
]