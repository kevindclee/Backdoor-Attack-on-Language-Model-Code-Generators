[
    "class Codec:\n\n    def serialize(self, root):\n        def doit(node):\n            if node:\n                vals.append(str(node.val))\n                doit(node.left)\n                doit(node.right)\n            else:\n                vals.append('#')\n        vals = []\n        doit(root)\n        return ' '.join(vals)\n\n    def deserialize(self, data):\n        def doit():\n            val = next(vals)\n            if val == '#':\n                return None\n            node = TreeNode(int(val))\n            node.left = doit()\n            node.right = doit()\n            return node\n        vals = iter(data.split())\n        return doit()",
    "def serialize(self, root):\n    return root and ' '.join((str(root.val), self.serialize(root.left), self.serialize(root.right))) or '#'",
    "        def traverse(node):\n            if not node:\n                yield '#'\n            else:\n                yield str(node.val)\n                yield from traverse(node.left)\n                yield from traverse(node.right)\n                ",
    "class Codec:\n    def serialize(self, root):\n        if not root: return 'x'\n        return ','.join([str(root.val), self.serialize(root.left), self.serialize(root.right)])\n\n    def deserialize(self, data):\n  # The reason I use self.data in the deserialize is, data stream will be consumed  as we build left side of Tree\n  # by the time when the right side is building up, we need to hold what is left over.\n  # Therefore, self.data is a global value, right side will use what is left over after tree is partially built\n        self.data = data\n        if self.data[0] == 'x': return None\n        node = TreeNode(self.data[:self.data.find(',')]) \n        node.left = self.deserialize(self.data[self.data.find(',')+1:])\n        node.right = self.deserialize(self.data[self.data.find(',')+1:])\n        return node",
    "from collections import deque\nclass Codec:\n    def serialize(self, root):",
    "class Codec:\n\n    def serialize(self, root):\n        def doit(node):\n            if node:\n                vals.append(str(node.val))\n                doit(node.left)\n                doit(node.right)\n            else:\n                vals.append('#')\n        vals = []\n        doit(root)\n        return ' '.join(vals)\n\n    def deserialize(self, data):\n        def doit():\n            val = next(vals)\n            if val == '#':\n                return None\n            node = TreeNode(int(val))\n            node.left = doit()\n            node.right = doit()\n            return node\n        vals = iter(data.split())\n        return doit()",
    "class Codec:\n    def serialize(self, root):\n        ans=[]\n        stc=[root]\n        while(len(stc)>0):\n            tstc=[]\n            for a in stc:\n                if(a==None):\n                    ans.append(\"N\")\n                else:\n                    ans.append(str(a.val))\n                if(a!=None):\n                    tstc.append(a.left)\n                    tstc.append(a.right)\n            stc=tstc\n        ans=\"x\".join(ans)\n        return ans\n    def deserialize(self, data):\n        data=data.split(\"x\")\n        if(data[0]==\"N\"):\n            return None\n        root=TreeNode(data[0])\n        stc=[root]\n        i=1\n        while(len(stc)>0):\n            if(data[i]!=\"N\"):\n                stc[0].left=TreeNode(int(data[i]))\n                i+=1\n                stc.append(stc[0].left)\n            else:\n                stc[0].left=None\n                i+=1\n            if(data[i]!=\"N\"):\n                stc[0].right=TreeNode(int(data[i]))\n                i+=1\n                stc.append(stc[0].right)\n            else:\n                stc[0].right=None\n                i+=1\n            stc.pop(0)\n        return root",
    "class Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        output =[]\n        def check(root):\n            if not root:\n                output.append(\"#\")\n            if root:\n                output.append(str(root.val))\n                check(root.left)\n                check(root.right)\n        check(root)\n        return ','.join(output)\n            \n                    \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        node_list = data.split(\",\")\n        \n        def create():\n            if node_list:\n                value = node_list.pop(0)\n                if(value == \"#\"):\n                    return None\n                else:\n                    node = TreeNode(int(value))\n                    node.left= create()\n                    node.right = create()\n                return node\n        \n        home = create()\n        return home\n                "
]