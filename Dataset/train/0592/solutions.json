[
    "    public int movesToChessboard(int[][] b) {\n        int N = b.length, rowSum = 0, colSum = 0, rowSwap = 0, colSwap = 0;\n        for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j)\n                if ((b[0][0] ^ b[i][0] ^ b[0][j] ^ b[i][j]) == 1) return -1;\n        for (int i = 0; i < N; ++i) {\n            rowSum += b[0][i];\n            colSum += b[i][0];\n            if (b[i][0] == i % 2) rowSwap ++;\n            if (b[0][i] == i % 2) colSwap ++ ;\n        }\n        if (rowSum != N / 2 && rowSum != (N + 1) / 2) return -1;\n        if (colSum != N / 2 && colSum != (N + 1) / 2) return -1;\n        if (N % 2 == 1) {\n            if (colSwap % 2 == 1) colSwap = N - colSwap;\n            if (rowSwap % 2 == 1) rowSwap = N - rowSwap;\n        } else {\n            colSwap = Math.min(N - colSwap, colSwap);\n            rowSwap = Math.min(N - rowSwap, rowSwap);\n        }\n        return (colSwap + rowSwap) / 2;\n    }",
    "    def movesToChessboard(self, b):\n        N = len(b)\n        if any(b[0][0] ^ b[i][0] ^ b[0][j] ^ b[i][j] for i in range(N) for j in range(N)): return -1\n        if not N / 2 <= sum(b[0]) <= (N + 1) / 2: return -1\n        if not N / 2 <= sum(b[i][0] for i in range(N)) <= (N + 1) / 2: return -1\n        col = sum(b[0][i] == i % 2 for i in range(N))\n        row = sum(b[i][0] == i % 2 for i in range(N))\n        if N % 2:\n            if col % 2: col = N - col\n            if row % 2: row = N - row\n        else:\n            col = min(N - col, col)\n            row = min(N - row, row)\n        return (col + row) / 2",
    "        for (int i = 0; i < N; ++i) for (int j = 0; j < N; ++j)\n                if ((b[0][0] ^ b[i][0] ^ b[0][j] ^ b[i][j]) == 1) return -1;",
    "    def movesToChessboard(self, board):\n        if len(board) <= 1:\n            return 0\n        \n        rows = []\n        for i in range(len(board)):\n            rows.append(''.join(str(cell) for cell in board[i]))\n        ",
    "class Solution:\n    def movesToChessboard(self, board):\n        n = len(board)\n        patt1 = ([0, 1]*(n//2+1))[:n]\n        patt2 = ([1, 0]*(n//2+1))[:n]\n        \n        board_t = map(list, zip(*board))\n        Cnt_r = list(Counter(tuple(row) for row in board).items())\n        Cnt_c = list(Counter(tuple(row) for row in board_t).items())\n        if len(Cnt_r) != 2 or len(Cnt_c) != 2: return -1\n        if abs(sum(map(sum, board)) * 2 - n*n) > 1: return -1\n        if abs(Cnt_r[0][1] - Cnt_r[1][1]) > 1: return -1\n        if abs(Cnt_c[0][1] - Cnt_c[1][1]) > 1: return -1\n        \n        x1 = sum(i != j for i,j in zip(Cnt_r[0][0], patt1))\n        y1 = sum(i != j for i,j in zip(Cnt_c[0][0], patt1))\n        \n        x2 = sum(i != j for i,j in zip(Cnt_r[0][0], patt2))\n        y2 = sum(i != j for i,j in zip(Cnt_c[0][0], patt2))\n        \n        cands_x = [x for x in [x1, x2] if x % 2 == 0]\n        cands_y = [y for y in [y1, y2] if y % 2 == 0]\n        \n        return min(cands_x)//2 + min(cands_y)//2",
    "for (int i=0; i<N; i++) {\n if (board[0][i]) onesInFirstRow++;\n else zerosInFirstRow++;\n\n if (board[i][0]) onesInFirstCol++;\n else zerosInFirstCol++;\n}\n\nif (abs(onesInFirstRow - zerosInFirstRow) > 1) return -1;\nif (abs(onesInFirstCol - zerosInFirstCol) > 1) return -1;",
    "from collections import defaultdict\n\nclass Solution:\n    def movesToChessboard(self, board):\n        n = len(board)\n        gr = defaultdict(set)\n\n        for i in range(n):\n            for j in range(n):\n                if board[i][j]:\n                    gr[i].add(j + 2 * n)\n                    gr[j + 2 * n].add(i)\n\n        def assign(base = 0):\n            len_base, deg = len(gr[base]), n // 2\n            if n % 2 == 0 and len_base != deg: return -1\n            if n % 2 == 1 and not (0 <= len_base - deg <= 1): return -1\n\n            first = {base}\n            second = set()\n\n            for j in range(base, base + n):\n                intersection = gr[base] & gr[j]\n                if len(intersection) == 0 and len(gr[j]) == n - len_base:\n                    second.add(j)\n                elif len(intersection) == len_base and len(gr[j]) == len_base:\n                    first.add(j)\n                else:\n                    return -1\n\n            v1, v2 = sum(f % 2 for f in first), sum((f + 1) % 2 for f in first)\n\n            if n % 2 == 1:\n                return v2 if len(first) == deg else v1\n\n            return min(v1, v2)\n\n        v1, v2 = assign(), assign(2 * n)\n        if v1 == -1 or v2 == -1: return -1\n        return v1 + v2",
    "for (int i=0; i<N; i++) {\n if (board[0][i]) onesInFirstRow++;\n else zerosInFirstRow++;\n\n if (board[i][0]) onesInFirstCol++;\n else zerosInFirstCol++;\n}\n\nif (abs(onesInFirstRow - zerosInFirstRow) > 1) return -1;\nif (abs(onesInFirstCol - zerosInFirstCol) > 1) return -1;"
]