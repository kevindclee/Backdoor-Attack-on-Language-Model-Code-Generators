[
    "    def new21Game(self, N, K, W):\n        if K == 0 or N >= K + W: return 1\n        dp = [1.0] + [0.0] * N\n        Wsum = 1.0\n        for i in range(1, N + 1):\n            dp[i] = Wsum / W\n            if i < K: Wsum += dp[i]\n            if i - W >= 0: Wsum -= dp[i - W]\n        return sum(dp[K:])",
    "        dp = [1.0] + [0.0] * N\n        p = 1.0/W\n        for n in range(1, N + 1):\n            # Update current index based on previous dp. But left range cannot exceed n - W, and right range cannot pass K\n            for idx in range(max(n - W, 0), min(K, n)): \n                dp[n] += dp[idx] * p\n        return sum(dp[K:])  ",
    "class Solution(object):\n    def new21Game(self, N, K, W):\n        \"\"\"\n        :type N: int\n        :type K: int\n        :type W: int\n        :rtype: float",
    "point total range [0, K + W - 1]",
    "def new_twenty_one_game(interesting_points, ending_points, max_draw):\n    if ending_points == 0 or interesting_points < ending_points:\n        return 1\n\n    # ending_points - 1 is the last point where we can draw at",
    "class Solution:\n    def new21Game(self, N, K, W):\n        \"\"\"\n        :type N: int\n        :type K: int\n        :type W: int\n        :rtype: float\n        \"\"\"\n        return self.dfs(N, K, W, 0, {})\n    \n    def dfs(self, N, K, W, cur, memo):\n        \n        if cur >= K:\n            return 1.0 if cur <= N else 0\n        \n        if cur in memo:\n            return memo[cur]\n        \n        prob = 0\n        \n        for i in range(1, W+1):\n            prob += self.dfs(N, K, W, cur+i, memo)\n        \n        prob /= W\n        \n        memo[cur] = prob\n        \n        return prob",
    "class Solution:\n    def new21Game(self, N, K, W):\n        \"\"\"\n        :type N: int\n        :type K: int\n        :type W: int\n        :rtype: float\n        \"\"\"\n        return self.dfs(N, K, W, 0, {})\n    \n    def dfs(self, N, K, W, cur, memo):\n        \n        if cur == K-1:\n            return min(N-K+1, W) / W\n        if cur > N:\n            return 0\n        elif cur >= K:\n            return 1.0\n        \n        if cur in memo:\n            return memo[cur]\n        \n        prob = self.dfs(N, K, W, cur+1, memo) - (self.dfs(N, K, W, cur+1+W, memo) - self.dfs(N, K, W, cur+1, memo)) / W\n        \n        memo[cur] = prob\n        \n        return prob",
    "double new21Game(int n, int k, int mp) {\n\n   double dp[k+mp];\n\n double sum=0;\n\n   for(int i=k+mp-1;i>=k;i--)\n   {\n    if(i<=n)\n     dp[i]=1;\n    else\n     dp[i]=0;\n\n    sum+=dp[i];\n   }\n\n\n   for(int i=k-1;i>=0;i--)\n   {\n\n    dp[i]=sum/mp;\n\n    sum+=dp[i];\n    sum-=dp[i+mp];\n   } \n\n return dp[0];\n}"
]