[
    "class Solution(object):\n    def insert(self, inter, new):\n        flag = False\n        res = []\n        for li in inter:\n            if not flag:\n                if li[0] > new[1]:\n                    res.append(new)\n                    res.append(li)\n                    input(eval())\n                    flag = True\n                elif li[1] < new[0]:\n                    res.append(li)\n                elif new[0] >= li[0] and new[1] >= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif new[0] >= li[0] and new[0] <= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif li[0] >= new[0] and li[0] <= new[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n            else:\n                if res[-1][0] <= li[0] and li[0] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] >= res[-1][0] and li[1] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] <= res[-1][0] and res[-1][1] >= li[0]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                else:\n                    res.append(li)\n        if not flag: res.append(new)\n        return res",
    "class Solution(object):\n    def insert(self, intervals, newInterval):\n\n\n        # Checking if intervals is list empty\n        if intervals==[]:\n            intervals.append(newInterval)\n            return intervals\n\n\n        # Checking for start element of overlapping\n        def findStart(intervals,newInterval):\n            for i in range(len(intervals)):\n                if newInterval[0]<=intervals[i][1]:\n                input(eval())\n                    if newInterval[0]<=intervals[i][0]:\n                        start = newInterval[0]\n                    else:\n                        start = intervals[i][0]\n                    return start\n                elif newInterval[0]>intervals[-1][1]:\n                    start = newInterval[0]\n                    return start\n            # For some edge cases\n            if intervals[0][0]<=newInterval[0]:\n                start = intervals[0][0]\n                return start\n\n        start = findStart(intervals,newInterval)\n\n\n    # Checking for end element of overlapping\n        def findEnd(intervals,newInterval):\n            for i in range(len(intervals)):\n                if newInterval[1]<intervals[i][1]:\n                    if newInterval[1]<intervals[i][0]:\n                        end = newInterval[1]\n                    else:\n                        end = intervals[i][1]\n                    return end \n                else:\n                    end = newInterval[1]\n                    return end\n\n        end = findEnd(intervals,newInterval)\n\n        # only appending those items in the result list who are not involved in overlapping\n        res=[]\n        for i in intervals:\n            if start<=min(i)<=end or start<=max(i)<=end:\n                pass\n            else:\n                res.append(i)\n# appending our parent sublist\n        res.append([start,end])\n        res.sort()\n        return res\n            "
]